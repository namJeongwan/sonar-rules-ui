[
  {
    "id": "S4434",
    "key": "java:S4434",
    "name": "Allowing deserialization of LDAP objects is security-sensitive",
    "type": "security-hotspot",
    "severity": "major",
    "tags": [
      "cwe"
    ],
    "why": "<p>JNDI supports the deserialization of objects from LDAP directories, which can lead to remote code execution.</p>\n<p>This rule raises an issue when an LDAP search query is executed with <code>SearchControls</code> configured to allow deserialization.</p>\n",
    "howToFix": "<h2>Recommended Secure Coding Practices</h2>\n<p>It is recommended to disable deserialization of LDAP objects.</p>\n<h2>Compliant Solution</h2>\n<pre>\nDirContext ctx = new InitialDirContext();\n// ...\nctx.search(query, filter,\n        new SearchControls(scope, countLimit, timeLimit, attributes,\n            false, // Compliant\n            deref));\n</pre>\n<h2>See</h2>\n<ul>\n  <li> OWASP - <a href=\"https://owasp.org/Top10/A08_2021-Software_and_Data_Integrity_Failures/\">Top 10 2021 Category A8 - Software and Data Integrity\n  Failures</a> </li>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/502\">CWE-502 - Deserialization of Untrusted Data</a> </li>\n  <li> OWASP - <a href=\"https://owasp.org/www-project-top-ten/2017/A8_2017-Insecure_Deserialization\">Top 10 2017 Category A8 - Insecure\n  Deserialization</a> </li>\n  <li> <a href=\"https://www.blackhat.com/docs/us-16/materials/us-16-Munoz-A-Journey-From-JNDI-LDAP-Manipulation-To-RCE-wp.pdf\">BlackHat\n  presentation</a> </li>\n  <li> Derived from FindSecBugs rule <a href=\"https://find-sec-bugs.github.io/bugs.htm#LDAP_ENTRY_POISONING\">LDAP_ENTRY_POISONING</a> </li>\n</ul>",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "LDAP 객체의 역직렬화를 허용하는 것은 보안에 민감합니다",
    "why_ko": "<p>JNDI는 LDAP 디렉토리에서 객체의 역직렬화를 지원하며, 이는 원격 코드 실행으로 이어질 수 있습니다.</p>\n<p>이 규칙은 역직렬화를 허용하도록 구성된 <code>SearchControls</code>로 LDAP 검색 쿼리가 실행될 때 문제를 제기합니다.</p>\n",
    "howToFix_ko": "<h2>권장되는 보안 코딩 관행</h2>\n<p>LDAP 객체의 역직렬화를 비활성화하는 것이 권장됩니다.</p>\n<h2>규칙을 준수하는 해결책</h2>\n<pre>\nDirContext ctx = new InitialDirContext();\n// ...\nctx.search(query, filter,\n        new SearchControls(scope, countLimit, timeLimit, attributes,\n            false, // 규칙 준수\n            deref));\n</pre>\n<h2>참고</h2>\n<ul>\n  <li> OWASP - <a href=\"https://owasp.org/Top10/A08_2021-Software_and_Data_Integrity_Failures/\">Top 10 2021 카테고리 A8 - 소프트웨어 및 데이터 무결성 실패</a> </li>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/502\">CWE-502 - 신뢰할 수 없는 데이터의 역직렬화</a> </li>\n  <li> OWASP - <a href=\"https://owasp.org/www-project-top-ten/2017/A8_2017-Insecure_Deserialization\">Top 10 2017 카테고리 A8 - 안전하지 않은 역직렬화</a> </li>\n  <li> <a href=\"https://www.blackhat.com/docs/us-16/materials/us-16-Munoz-A-Journey-From-JNDI-LDAP-Manipulation-To-RCE-wp.pdf\">BlackHat 발표</a> </li>\n  <li> FindSecBugs 규칙에서 파생됨 <a href=\"https://find-sec-bugs.github.io/bugs.htm#LDAP_ENTRY_POISONING\">LDAP_ENTRY_POISONING</a> </li>\n</ul>",
    "moreInfo_ko": ""
  },
  {
    "id": "S2333",
    "key": "java:S2333",
    "name": "Redundant modifiers should not be used",
    "type": "code-smell",
    "severity": "minor",
    "tags": [
      "finding",
      "clumsy"
    ],
    "why": "<p>The methods declared in an <code>interface</code> are <code>public</code> and <code>abstract</code> by default. Any variables are automatically\n<code>public static final</code>. Finally, <code>class</code> and <code>interface</code> are automatically <code>public static</code>. There is no\nneed to explicitly declare them so.</p>\n<p>Since annotations are implicitly interfaces, the same holds true for them as well.</p>\n<p>Similarly, the <code>final</code> modifier is redundant on any method of a <code>final</code> class, <code>private</code> is redundant on the\nconstructor of an <code>Enum</code>, and <code>static</code> is redundant for <code>interface</code> nested into a <code>class</code> or\n<code>enum</code>.</p>\n<h3>Noncompliant code example</h3>\n<pre>\npublic interface Vehicle {\n\n  public void go(int speed, Direction direction);  // Noncompliant\n</pre>\n<h3>Compliant solution</h3>\n<pre>\npublic interface Vehicle {\n\n  void go(int speed, Direction direction);\n</pre>",
    "howToFix": "",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "중복된 수정자를 사용하면 안 됩니다",
    "why_ko": "<p><code>interface</code>에 선언된 메서드는 기본적으로 <code>public</code>이고 <code>abstract</code>입니다. 모든 변수는 자동으로 <code>public static final</code>입니다. 마지막으로 <code>class</code>와 <code>interface</code>는 자동으로 <code>public static</code>입니다. 명시적으로 선언할 필요가 없습니다.</p>\n<p>어노테이션은 암시적으로 인터페이스이므로 동일하게 적용됩니다.</p>\n<p>마찬가지로 <code>final</code> 수정자는 <code>final</code> 클래스의 모든 메서드에서 중복이고, <code>private</code>은 <code>Enum</code>의 생성자에서 중복이며, <code>static</code>은 <code>class</code>나 <code>enum</code> 안에 중첩된 <code>interface</code>에서 중복입니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\npublic interface Vehicle {\n\n  public void go(int speed, Direction direction);  // 규칙 위반\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre>\npublic interface Vehicle {\n\n  void go(int speed, Direction direction);\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": ""
  },
  {
    "id": "S6665",
    "key": "java:S6665",
    "name": "Redundant nullability annotations should be removed",
    "type": "code-smell",
    "severity": "major",
    "tags": [
      "jspecify",
      "nullability"
    ],
    "why": "<p>Nullability annotations in Java are used to indicate whether a variable or parameter can be assigned a null value or not. These annotations help to prevent Null Pointer Exceptions and improve the reliability of code.</p>\n<p>Redundant nullability annotations can clutter the code and make it harder to read and understand. When a nullability annotation is already implied by the context or by other annotations, explicitly adding it again only adds noise and makes the code less clear.</p>\n<p>Removing them improves code readability, maintainability, reduces the risk of inconsistencies, and ensures that the remaining annotations carry meaningful information.</p>\n<h3>Noncompliant code example</h3>\nJSpecify code example:\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\n@NullMarked\nclass MyClass {\n  public void method(@NonNull Object o) { // Noncompliant: @NonNull is redundant here\n    // ...\n  }\n}\n</pre>\n<h3>Compliant solution</h3>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\n@NullMarked\nclass MyClass {\n  public void method(Object o) {\n    // ...\n  }\n}\n</pre>",
    "howToFix": "",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "중복된 null 가능성 주석은 제거해야 합니다",
    "why_ko": "<p>Java의 Nullability 주석은 변수나 매개변수에 null 값을 할당할 수 있는지 여부를 나타내는 데 사용됩니다. 이러한 주석은 Null Pointer Exception을 방지하고 코드의 신뢰성을 향상시키는 데 도움이 됩니다.</p>\n<p>중복된 nullability 주석은 코드를 복잡하게 만들고 읽고 이해하기 어렵게 만들 수 있습니다. nullability 주석이 이미 컨텍스트나 다른 주석에 의해 암시되는 경우 명시적으로 다시 추가하면 노이즈만 추가하고 코드를 덜 명확하게 만듭니다.</p>\n<p>이를 제거하면 코드 가독성, 유지 관리성이 향상되고, 불일치 위험이 줄어들며, 나머지 주석이 의미 있는 정보를 전달하도록 보장합니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\nJSpecify 코드 예시:\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\n@NullMarked\nclass MyClass {\n  public void method(@NonNull Object o) { // 규칙 위반: @NonNull은 여기서 중복됩니다\n    // ...\n  }\n}\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\n@NullMarked\nclass MyClass {\n  public void method(Object o) {\n    // ...\n  }\n}\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": ""
  },
  {
    "id": "S2276",
    "key": "java:S2276",
    "name": "\"wait(...)\" should be used instead of \"Thread.sleep(...)\" when a lock is held",
    "type": "bug",
    "severity": "blocker",
    "tags": [
      "performance",
      "multi-threading",
      "cert"
    ],
    "why": "<p>In a multithreaded environment, a thread may need to wait for a particular condition to become true. One way of pausing execution in Java is\n<code>Thread.sleep(…​)</code>.</p>\n<p>If a thread that holds a lock calls <code>Thread.sleep(…​)</code>, no other thread can acquire said lock. This can lead to performance and\nscalability issues, in the worst case leading to deadlocks.</p>",
    "howToFix": "<p>Call <code>wait(…​)</code> on the monitor object instead of using <code>Thread.sleep(…​)</code>. While <code>wait(…​)</code> is executed, the lock\nis temporarily released and hence other threads can run in the meantime.</p>\n\n<h4>Noncompliant code example</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\npublic void doSomething(){\n  synchronized(monitor) {\n    while(notReady()){\n      Thread.sleep(200); // Noncompliant, any other thread synchronizing on monitor is blocked from running while the first thread sleeps.\n    }\n    process();\n  }\n  ...\n}\n</pre>\n<h4>Compliant solution</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\npublic void doSomething(){\n  synchronized(monitor) {\n    while(notReady()){\n      monitor.wait(200); // Compliant, the current monitor is released.\n    }\n    process();\n  }\n  ...\n}\n</pre>",
    "moreInfo": "<ul>\n  <li> <a href=\"https://wiki.sei.cmu.edu/confluence/x/YTdGBQ\">CERT, LCK09-J.</a> - Do not perform operations that can block while holding a lock </li>\n</ul>",
    "status": "READY",
    "name_ko": "락을 보유한 상태에서는 \"Thread.sleep(...)\" 대신 \"wait(...)\"를 사용해야 합니다",
    "why_ko": "<p>멀티스레드 환경에서 스레드는 특정 조건이 참이 될 때까지 기다려야 할 수 있습니다. Java에서 실행을 일시 중지하는 한 가지 방법은 <code>Thread.sleep(…​)</code>입니다.</p>\n<p>락을 보유한 스레드가 <code>Thread.sleep(…​)</code>을 호출하면 다른 스레드는 해당 락을 획득할 수 없습니다. 이는 성능 및 확장성 문제를 유발할 수 있으며 최악의 경우 데드락으로 이어질 수 있습니다.</p>",
    "howToFix_ko": "<p><code>Thread.sleep(…​)</code> 대신 모니터 객체에서 <code>wait(…​)</code>를 호출하세요. <code>wait(…​)</code>가 실행되는 동안 락은 일시적으로 해제되므로 다른 스레드가 그 동안 실행될 수 있습니다.</p>\n\n<h4>규칙을 준수하지 않는 코드 예시</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\npublic void doSomething(){\n  synchronized(monitor) {\n    while(notReady()){\n      Thread.sleep(200); // 규칙 위반, 첫 번째 스레드가 sleep하는 동안 monitor에서 동기화하는 다른 스레드는 실행이 차단됨\n    }\n    process();\n  }\n  ...\n}\n</pre>\n<h4>규칙을 준수하는 해결책</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\npublic void doSomething(){\n  synchronized(monitor) {\n    while(notReady()){\n      monitor.wait(200); // 규칙 준수, 현재 모니터가 해제됨\n    }\n    process();\n  }\n  ...\n}\n</pre>",
    "moreInfo_ko": "<ul>\n  <li> <a href=\"https://wiki.sei.cmu.edu/confluence/x/YTdGBQ\">CERT, LCK09-J.</a> - 락을 보유한 상태에서 차단될 수 있는 작업을 수행하지 마세요 </li>\n</ul>"
  },
  {
    "id": "S1118",
    "key": "java:S1118",
    "name": "Utility classes should not have public constructors",
    "type": "code-smell",
    "severity": "major",
    "tags": [
      "design"
    ],
    "why": "<p>Whenever there are portions of code that are duplicated and do not depend on the state of their container class, they can be centralized inside a\n\"utility class\". A utility class is a class that only has static members, hence it should not be instantiated.</p>\n<h3>Exceptions</h3>\n<p>When a class contains <code>public static void main(String[] args)</code> method it is not considered as a utility class and will be ignored by\nthis rule.</p>",
    "howToFix": "<p>To prevent the class from being instantiated, you should define a non-public constructor. This will prevent the compiler from implicitly generating\na public parameterless constructor.</p>\n\n<h4>Noncompliant code example</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\nclass StringUtils { // Noncompliant\n\n  public static String concatenate(String s1, String s2) {\n    return s1 + s2;\n  }\n\n}\n</pre>\n<h4>Compliant solution</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\nclass StringUtils { // Compliant\n\n  private StringUtils() {\n    throw new IllegalStateException(\"Utility class\");\n  }\n\n  public static String concatenate(String s1, String s2) {\n    return s1 + s2;\n  }\n\n}\n</pre>",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "유틸리티 클래스는 public 생성자를 가지면 안 됩니다",
    "why_ko": "<p>중복된 코드 부분이 있고 해당 컨테이너 클래스의 상태에 의존하지 않는 경우, \"유틸리티 클래스\" 내부에 중앙 집중화할 수 있습니다. 유틸리티 클래스는 static 멤버만 가지는 클래스이므로 인스턴스화되어서는 안 됩니다.</p>\n<h3>예외 사항</h3>\n<p>클래스에 <code>public static void main(String[] args)</code> 메서드가 포함되어 있으면 유틸리티 클래스로 간주되지 않으며 이 규칙에서 무시됩니다.</p>",
    "howToFix_ko": "<p>클래스가 인스턴스화되는 것을 방지하려면 비공개 생성자를 정의해야 합니다. 이렇게 하면 컴파일러가 암시적으로 public 매개변수 없는 생성자를 생성하는 것을 방지합니다.</p>\n\n<h4>규칙을 준수하지 않는 코드 예시</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\nclass StringUtils { // 규칙 위반\n\n  public static String concatenate(String s1, String s2) {\n    return s1 + s2;\n  }\n\n}\n</pre>\n<h4>규칙을 준수하는 해결책</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\nclass StringUtils { // 규칙 준수\n\n  private StringUtils() {\n    throw new IllegalStateException(\"Utility class\");\n  }\n\n  public static String concatenate(String s1, String s2) {\n    return s1 + s2;\n  }\n\n}\n</pre>",
    "moreInfo_ko": ""
  },
  {
    "id": "S2221",
    "key": "java:S2221",
    "name": "\"Exception\" should not be caught when not required by called methods",
    "type": "code-smell",
    "severity": "minor",
    "tags": [
      "error-handling",
      "cwe"
    ],
    "why": "<p>Catching <code>Exception</code> seems like an efficient way to handle multiple possible exceptions. Unfortunately, it traps all exception types,\nboth checked and runtime exceptions, thereby casting too broad a net. Indeed, was it really the intention of developers to also catch runtime\nexceptions? To prevent any misunderstanding, if both checked and runtime exceptions are really expected to be caught, they should be explicitly listed\nin the <code>catch</code> clause.</p>\n<p>This rule raises an issue if <code>Exception</code> is caught when it is not explicitly thrown by a method in the <code>try</code> block.</p>\n<h3>Noncompliant code example</h3>\n<pre>\ntry {\n  // do something that might throw an UnsupportedDataTypeException or UnsupportedEncodingException\n} catch (Exception e) { // Noncompliant\n  // log exception ...\n}\n</pre>\n<h3>Compliant solution</h3>\n<pre>\ntry {\n  // do something\n} catch (UnsupportedEncodingException|UnsupportedDataTypeException|RuntimeException e) {\n  // log exception ...\n}\n</pre>\n<p>or if runtime exceptions should not be caught:</p>\n<pre>\ntry {\n  // do something\n} catch (UnsupportedEncodingException|UnsupportedDataTypeException e) {\n  // log exception ...\n}\n</pre>",
    "howToFix": "",
    "moreInfo": "<ul>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/396\">CWE-396 - Declaration of Catch for Generic Exception</a> </li>\n</ul>",
    "status": "READY",
    "name_ko": "호출된 메서드에서 요구하지 않는 경우 \"Exception\"을 catch하면 안 됩니다",
    "why_ko": "<p><code>Exception</code>을 catch하는 것은 여러 가능한 예외를 처리하는 효율적인 방법처럼 보입니다. 불행히도, 이는 체크 예외와 런타임 예외 모두를 포함한 모든 예외 유형을 잡아내어 너무 넓은 그물을 던지는 것입니다. 실제로 개발자가 런타임 예외도 catch하려는 의도였을까요? 오해를 방지하기 위해 체크 예외와 런타임 예외 모두를 catch할 것으로 예상되는 경우 <code>catch</code> 절에 명시적으로 나열해야 합니다.</p>\n<p>이 규칙은 <code>try</code> 블록의 메서드에서 명시적으로 throw하지 않는 경우 <code>Exception</code>을 catch하면 이슈를 제기합니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\ntry {\n  // UnsupportedDataTypeException 또는 UnsupportedEncodingException을 발생시킬 수 있는 작업 수행\n} catch (Exception e) { // 규칙 위반\n  // 예외 로깅 ...\n}\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre>\ntry {\n  // 작업 수행\n} catch (UnsupportedEncodingException|UnsupportedDataTypeException|RuntimeException e) {\n  // 예외 로깅 ...\n}\n</pre>\n<p>또는 런타임 예외를 catch하지 않아야 하는 경우:</p>\n<pre>\ntry {\n  // 작업 수행\n} catch (UnsupportedEncodingException|UnsupportedDataTypeException e) {\n  // 예외 로깅 ...\n}\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": "<ul>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/396\">CWE-396 - 일반 예외에 대한 Catch 선언</a> </li>\n</ul>"
  },
  {
    "id": "S6262",
    "key": "java:S6262",
    "name": "AWS region should not be set with a hardcoded String",
    "type": "code-smell",
    "severity": "minor",
    "tags": [
      "aws"
    ],
    "why": "<p>When explicitly setting the region on an AWS Client, you should always prefer providing the value from the Enum <a\nhref=\"https://docs.aws.amazon.com/AWSJavaSDK/latest/javadoc/index.html?com/amazonaws/regions/Regions.html\">Regions</a> instead of a hardcoded String.\nThis will allow you to transparently support any change in the API and avoid mistakes.</p>\n<p>This rule reports an issue when a hardcoded string is used instead of an available enum value.</p>\n<h3>Noncompliant code example</h3>\n<pre>\nAmazonS3ClientBuilder.standard().withRegion(\"eu_west_1\").build();\n</pre>\n<h3>Compliant solution</h3>\n<pre>\nAmazonS3ClientBuilder.standard().withRegion(Regions.EU_WEST_1).build();\n</pre>",
    "howToFix": "",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "AWS region은 하드코딩된 String으로 설정하면 안 됩니다",
    "why_ko": "<p>AWS Client에서 명시적으로 region을 설정할 때는 하드코딩된 String 대신 <a href=\"https://docs.aws.amazon.com/AWSJavaSDK/latest/javadoc/index.html?com/amazonaws/regions/Regions.html\">Regions</a> Enum에서 값을 제공하는 것을 항상 선호해야 합니다. 이렇게 하면 API의 모든 변경 사항을 투명하게 지원하고 실수를 피할 수 있습니다.</p>\n<p>이 규칙은 사용 가능한 enum 값 대신 하드코딩된 문자열이 사용될 때 문제를 보고합니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\nAmazonS3ClientBuilder.standard().withRegion(\"eu_west_1\").build();\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre>\nAmazonS3ClientBuilder.standard().withRegion(Regions.EU_WEST_1).build();\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": ""
  },
  {
    "id": "S1698",
    "key": "java:S1698",
    "name": "\"==\" and \"!=\" should not be used when \"equals\" is overridden",
    "type": "code-smell",
    "severity": "minor",
    "tags": [
      "cwe",
      "cert",
      "suspicious"
    ],
    "why": "<p>It is equivalent to use the equality <code>==</code> operator and the <code>equals</code> method to compare two objects if the <code>equals</code>\nmethod inherited from <code>Object</code> has not been overridden. In this case both checks compare the object references.</p>\n<p>But as soon as <code>equals</code> is overridden, two objects not having the same reference but having the same value can be equal. This rule spots\nsuspicious uses of <code>==</code> and <code>!=</code> operators on objects whose <code>equals</code> methods are overridden.</p>\n<h3>Noncompliant code example</h3>\n<pre>\nString firstName = getFirstName(); // String overrides equals\nString lastName = getLastName();\n\nif (firstName == lastName) { ... }; // Non-compliant; false even if the strings have the same value\n</pre>\n<h3>Compliant solution</h3>\n<pre>\nString firstName = getFirstName();\nString lastName = getLastName();\n\nif (firstName != null &amp;&amp; firstName.equals(lastName)) { ... };\n</pre>\n<h3>Exceptions</h3>\n<p>Comparing two instances of the <code>Class</code> object will not raise an issue:</p>\n<pre>\nClass c;\nif(c == Integer.class) { // No issue raised\n}\n</pre>\n<p>Comparing <code>Enum</code> will not raise an issue:</p>\n<pre>\npublic enum Fruit {\n   APPLE, BANANA, GRAPE\n}\npublic boolean isFruitGrape(Fruit candidateFruit) {\n  return candidateFruit == Fruit.GRAPE; // it's recommended to activate S4551 to enforce comparison of Enums using ==\n}\n</pre>\n<p>Comparing with <code>final</code> reference will not raise an issue:</p>\n<pre>\nprivate static final Type DEFAULT = new Type();\n\nvoid foo(Type other) {\n  if (other == DEFAULT) { // Compliant\n  //...\n  }\n}\n</pre>\n<p>Comparing with <code>this</code> will not raise an issue:</p>\n<pre>\n  public boolean equals(Object other) {\n    if (this == other) {  // Compliant\n      return false;\n    }\n }\n</pre>\n<p>Comparing with <code>java.lang.String</code> and boxed types <code>java.lang.Integer</code>, …​ will not raise an issue.</p>",
    "howToFix": "",
    "moreInfo": "<ul>\n  <li> <a href='/coding_rules#rule_key=java%3AS4973'>S4973</a> - Strings and Boxed types should be compared using \"equals()\" </li>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/595\">CWE-595 - Comparison of Object References Instead of Object Contents</a> </li>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/597\">CWE-597 - Use of Wrong Operator in String Comparison</a> </li>\n  <li> <a href=\"https://wiki.sei.cmu.edu/confluence/x/UjdGBQ\">CERT, EXP03-J.</a> - Do not use the equality operators when comparing values of boxed\n  primitives </li>\n  <li> <a href=\"https://wiki.sei.cmu.edu/confluence/x/yDdGBQ\">CERT, EXP50-J.</a> - Do not confuse abstract object equality with reference equality\n  </li>\n</ul>",
    "status": "READY",
    "name_ko": "\"equals\"가 오버라이드된 경우 \"==\"와 \"!=\"를 사용하면 안 됩니다",
    "why_ko": "<p><code>Object</code>에서 상속받은 <code>equals</code> 메서드가 오버라이드되지 않은 경우, 두 객체를 비교할 때 동등 연산자 <code>==</code>와 <code>equals</code> 메서드를 사용하는 것은 동일합니다. 이 경우 두 검사 모두 객체 참조를 비교합니다.</p>\n<p>그러나 <code>equals</code>가 오버라이드되면, 동일한 참조를 갖지 않지만 동일한 값을 가진 두 객체가 동등할 수 있습니다. 이 규칙은 <code>equals</code> 메서드가 오버라이드된 객체에서 <code>==</code>와 <code>!=</code> 연산자의 의심스러운 사용을 감지합니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\nString firstName = getFirstName(); // String은 equals를 오버라이드함\nString lastName = getLastName();\n\nif (firstName == lastName) { ... }; // 규칙 위반; 문자열이 동일한 값을 가져도 false\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre>\nString firstName = getFirstName();\nString lastName = getLastName();\n\nif (firstName != null &amp;&amp; firstName.equals(lastName)) { ... };\n</pre>\n<h3>예외</h3>\n<p><code>Class</code> 객체의 두 인스턴스를 비교하는 경우 이슈가 발생하지 않습니다:</p>\n<pre>\nClass c;\nif(c == Integer.class) { // 이슈 발생 안 함\n}\n</pre>\n<p><code>Enum</code>을 비교하는 경우 이슈가 발생하지 않습니다:</p>\n<pre>\npublic enum Fruit {\n   APPLE, BANANA, GRAPE\n}\npublic boolean isFruitGrape(Fruit candidateFruit) {\n  return candidateFruit == Fruit.GRAPE; // ==를 사용한 Enum 비교를 강제하려면 S4551을 활성화하는 것이 권장됩니다\n}\n</pre>\n<p><code>final</code> 참조와 비교하는 경우 이슈가 발생하지 않습니다:</p>\n<pre>\nprivate static final Type DEFAULT = new Type();\n\nvoid foo(Type other) {\n  if (other == DEFAULT) { // 규칙 준수\n  //...\n  }\n}\n</pre>\n<p><code>this</code>와 비교하는 경우 이슈가 발생하지 않습니다:</p>\n<pre>\n  public boolean equals(Object other) {\n    if (this == other) {  // 규칙 준수\n      return false;\n    }\n }\n</pre>\n<p><code>java.lang.String</code> 및 박싱 타입 <code>java.lang.Integer</code> 등과 비교하는 경우 이슈가 발생하지 않습니다.</p>",
    "howToFix_ko": "",
    "moreInfo_ko": "<ul>\n  <li> <a href='/coding_rules#rule_key=java%3AS4973'>S4973</a> - 문자열과 박싱 타입은 \"equals()\"를 사용하여 비교해야 합니다 </li>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/595\">CWE-595 - 객체 내용 대신 객체 참조 비교</a> </li>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/597\">CWE-597 - 문자열 비교에서 잘못된 연산자 사용</a> </li>\n  <li> <a href=\"https://wiki.sei.cmu.edu/confluence/x/UjdGBQ\">CERT, EXP03-J.</a> - 박싱된 기본형 값을 비교할 때 동등 연산자를 사용하지 마세요 </li>\n  <li> <a href=\"https://wiki.sei.cmu.edu/confluence/x/yDdGBQ\">CERT, EXP50-J.</a> - 추상 객체 동등성과 참조 동등성을 혼동하지 마세요 </li>\n</ul>"
  },
  {
    "id": "S4926",
    "key": "java:S4926",
    "name": "\"serialVersionUID\" should not be declared blindly",
    "type": "code-smell",
    "severity": "minor",
    "tags": [
      "serialization",
      "pitfall"
    ],
    "why": "<p>Providing a <code>serialVersionUID</code> field on <code>Serializable</code> classes is strongly recommended by the <code>Serializable</code>\ndocumentation but blindly following that recommendation can be harmful.</p>\n<p><code>serialVersionUID</code> value is stored with the serialized data and this field is verified when deserializing the data to ensure that the\ncode reading the data is compatible with the serialized data. In case of failure, it means the serialized data and the code are not in sync and this\nfine because you know what's wrong.</p>\n<p>When the <code>serialVersionUID</code> is generated by an IDE or blindly hard-coded, there is a high probability that one will forget to update the\n<code>serialVersionUID</code> value when the <code>Serializable</code> class is later enriched with additional fields. As a consequence, old\nserialized data will incorrectly be considered compatible with the newer version of the code creating situations which are hard to debug.</p>\n<p>Therefore, defining <code>serialVersionUID</code> should be done with care. This rule raises an issue on each <code>serialVersionUID</code> field\ndeclared on classes implementing <code>Serializable</code> to be sure the presence and the value of the <code>serialVersionUID</code> field is\nchallenged and validated by the team.</p>\n<h3>Noncompliant code example</h3>\n<pre>\npublic class Foo implements Serializable {\n  private static final long serialVersionUID = 1;\n}\n\npublic class BarException extends RuntimeException {\n  private static final long serialVersionUID = 8582433437601788991L;\n}\n</pre>",
    "howToFix": "",
    "moreInfo": "<ul>\n  <li> Vojtech Ruzicka's Programming Blog: <a href=\"https://www.vojtechruzicka.com/explicitly-declare-serialversionuid/\">Should I explicitly declare\n  serialVersionUID?</a> </li>\n</ul>",
    "status": "READY",
    "name_ko": "serialVersionUID를 무분별하게 선언하면 안 됩니다",
    "why_ko": "<p><code>Serializable</code> 클래스에 <code>serialVersionUID</code> 필드를 제공하는 것은 <code>Serializable</code> 문서에서 강력히 권장하지만 이 권장 사항을 맹목적으로 따르면 해로울 수 있습니다.</p>\n<p><code>serialVersionUID</code> 값은 직렬화된 데이터와 함께 저장되며 이 필드는 데이터를 역직렬화할 때 데이터를 읽는 코드가 직렬화된 데이터와 호환되는지 확인하기 위해 검증됩니다. 실패하는 경우 직렬화된 데이터와 코드가 동기화되지 않은 것을 의미하며 문제가 무엇인지 알 수 있으므로 괜찮습니다.</p>\n<p><code>serialVersionUID</code>가 IDE에서 생성되거나 맹목적으로 하드코딩되면 <code>Serializable</code> 클래스가 나중에 추가 필드로 보강될 때 <code>serialVersionUID</code> 값을 업데이트하는 것을 잊을 확률이 높습니다. 결과적으로 오래된 직렬화된 데이터가 잘못 더 새로운 버전의 코드와 호환되는 것으로 간주되어 디버그하기 어려운 상황이 생성됩니다.</p>\n<p>따라서 <code>serialVersionUID</code>를 정의하는 것은 주의해서 수행해야 합니다. 이 규칙은 <code>Serializable</code>을 구현하는 클래스에 선언된 각 <code>serialVersionUID</code> 필드에 대해 문제를 제기하여 <code>serialVersionUID</code> 필드의 존재와 값이 팀에 의해 검토되고 검증되도록 합니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\npublic class Foo implements Serializable {\n  private static final long serialVersionUID = 1;\n}\n\npublic class BarException extends RuntimeException {\n  private static final long serialVersionUID = 8582433437601788991L;\n}\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": "<ul>\n  <li> Vojtech Ruzicka의 프로그래밍 블로그: <a href=\"https://www.vojtechruzicka.com/explicitly-declare-serialversionuid/\">serialVersionUID를 명시적으로 선언해야 할까요?</a> </li>\n</ul>"
  },
  {
    "id": "S6331",
    "key": "java:S6331",
    "name": "Regular expressions should not contain empty groups",
    "type": "code-smell",
    "severity": "major",
    "tags": [
      "regex"
    ],
    "why": "<p>There are several reasons to use a group in a regular expression:</p>\n<ul>\n  <li> to change the precedence (e.g. <code>do(g|or)</code> will match 'dog' and 'door') </li>\n  <li> to remember parenthesised part of the match in the case of capturing group </li>\n  <li> to improve readability </li>\n</ul>\n<p>In any case, having an empty group is most probably a mistake. Either it is a leftover after refactoring and should be removed, or the actual\nparentheses were intended and were not escaped.</p>\n<h3>Noncompliant code example</h3>\n<pre>\n\"foo()\"  // Noncompliant, will match only 'foo'\n</pre>\n<h3>Compliant solution</h3>\n<pre>\n\"foo\\\\(\\\\)\"  // Matches 'foo()'\n</pre>",
    "howToFix": "",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "정규 표현식에 빈 그룹이 포함되면 안 됩니다",
    "why_ko": "<p>정규 표현식에서 그룹을 사용하는 데는 여러 이유가 있습니다:</p>\n<ul>\n  <li> 우선순위를 변경하기 위해 (예: <code>do(g|or)</code>는 'dog'과 'door'를 매칭합니다) </li>\n  <li> 캡처링 그룹의 경우 매칭된 괄호 부분을 기억하기 위해 </li>\n  <li> 가독성을 향상시키기 위해 </li>\n</ul>\n<p>어떤 경우든 빈 그룹이 있다면 대부분 실수입니다. 리팩토링 후 남은 것이므로 제거해야 하거나, 실제 괄호가 의도된 것이지만 이스케이프되지 않은 것입니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\n\"foo()\"  // 규칙 위반, 'foo'만 매칭됨\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre>\n\"foo\\\\(\\\\)\"  // 'foo()' 매칭\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": ""
  },
  {
    "id": "S1948",
    "key": "java:S1948",
    "name": "Fields in a \"Serializable\" class should either be transient or serializable",
    "type": "code-smell",
    "severity": "critical",
    "tags": [
      "cwe",
      "serialization"
    ],
    "why": "<p>By contract, non-static fields in a <code>Serializable</code> class must themselves be either <code>Serializable</code> or <code>transient</code>.\nEven if the class is never explicitly serialized or deserialized, it is not safe to assume that this cannot happen. For instance, under load, most\nJ2EE application frameworks flush objects to disk.</p>\n<p>An object that implements <code>Serializable</code> but contains non-transient, non-serializable data members (and thus violates the contract)\ncould cause application crashes and open the door to attackers. In general, a <code>Serializable</code> class is expected to fulfil its contract and\nnot exhibit unexpected behaviour when an instance is serialized.</p>\n<p>This rule raises an issue on:</p>\n<ul>\n  <li> Non-<code>Serializable</code> fields. </li>\n  <li> When a field is assigned a non-<code>Serializable</code> type within the class. </li>\n  <li> Collection fields when they are not <code>private</code>. Values that are not serializable could be added to these collections externally. Due\n  to type erasure, it cannot be guaranteed that the collection will only contain serializable objects at runtime despite being declared as a\n  collection of serializable types. </li>\n</ul>",
    "howToFix": "<p>Consider the following scenario.</p>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\npublic class Address {\n    ...\n}\n\npublic class Person implements Serializable {\n  private static final long serialVersionUID = 1905122041950251207L;\n\n  private String name;\n  private Address address;  // Noncompliant, Address is not serializable\n}\n</pre>\n<p>How to fix this issue depends on the application's needs. If the field's value should be preserved during serialization and deserialization, you\nmay want to make the field's value serializable.</p>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\npublic class Address implements Serializable {\n  private static final long serialVersionUID = 2405172041950251807L;\n\n    ...\n}\n\npublic class Person implements Serializable {\n  private static final long serialVersionUID = 1905122041950251207L;\n\n  private String name;\n  private Address address; // Compliant, Address is serializable\n}\n</pre>\n<p>If the field's value does not need to be preserved during serialization and deserialization, mark it as <code>transient</code>. The field will be\nignored when the object is serialized. After deserialization, the field will be set to the default value corresponding to its type (e.g.,\n<code>null</code> for object references).</p>\n<pre>\npublic class Address {\n    ...\n}\n\npublic class Person implements Serializable {\n  private static final long serialVersionUID = 1905122041950251207L;\n\n  private String name;\n  private transient Address address; // Compliant, the field is transient\n}\n</pre>\n<p>The alternative to making all members serializable or <code>transient</code> is to implement special methods which take on the responsibility of\nproperly serializing and de-serializing the object <code>writeObject</code> and <code>readObject</code>. These methods can be used to properly\n(de-)serialize an object, even though it contains fields that are not transient or serializable. Hence, this rule does not raise issues on fields of\nclasses which implement these methods.</p>\n<pre>\npublic class Address {\n    ...\n}\n\npublic class Person implements Serializable {\n  private static final long serialVersionUID = 1905122041950251207L;\n\n  private String name;\n  private Address address; // Compliant, writeObject and readObject handle this field\n\n  private void writeObject(java.io.ObjectOutputStream out) throws IOException {\n    // Appropriate serialization logic here\n  }\n\n  private void readObject(java.io.ObjectInputStream in) throws IOException, ClassNotFoundException {\n    // Appropriate deserialization logic here\n  }\n}\n</pre>\n<p>Finally, static fields are out of scope for serialization, so making a field static prevents issues from being raised.</p>\n<pre>\npublic class Person implements Serializable {\n  private static final long serialVersionUID = 1905122041950251207L;\n\n  private String name;\n\n  private static Logger log = getLogger(); // Compliant, static fields are not serialized\n}\n</pre>",
    "moreInfo": "<ul>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/594\">CWE-594 - Saving Unserializable Objects to Disk</a> </li>\n  <li> <a href=\"https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/io/Serializable.html\">Interface Serializable - Java SE 11 API\n  Documentation</a> </li>\n  <li> <a href=\"https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/io/Serializable.html\">Interface Serializable - Java SE 17 API\n  Documentation</a> </li>\n</ul>",
    "status": "READY",
    "name_ko": "\"Serializable\" 클래스의 필드는 transient이거나 직렬화 가능해야 합니다",
    "why_ko": "<p>계약상 <code>Serializable</code> 클래스의 비정적 필드는 반드시 <code>Serializable</code>이거나 <code>transient</code>여야 합니다. 클래스가 명시적으로 직렬화되거나 역직렬화되지 않더라도, 이것이 일어나지 않을 것이라고 가정하는 것은 안전하지 않습니다. 예를 들어, 부하가 걸리면 대부분의 J2EE 애플리케이션 프레임워크는 객체를 디스크로 플러시합니다.</p>\n<p><code>Serializable</code>을 구현하지만 transient가 아니고 직렬화 불가능한 데이터 멤버를 포함하는 객체(따라서 계약을 위반하는)는 애플리케이션 충돌을 일으키고 공격자에게 문을 열어줄 수 있습니다. 일반적으로 <code>Serializable</code> 클래스는 계약을 이행하고 인스턴스가 직렬화될 때 예기치 않은 동작을 나타내지 않아야 합니다.</p>\n<p>이 규칙은 다음에서 문제를 제기합니다:</p>\n<ul>\n  <li> <code>Serializable</code>이 아닌 필드. </li>\n  <li> 클래스 내에서 <code>Serializable</code>이 아닌 타입이 필드에 할당될 때. </li>\n  <li> <code>private</code>이 아닌 컬렉션 필드. 직렬화 불가능한 값이 외부에서 이러한 컬렉션에 추가될 수 있습니다. 타입 소거로 인해 직렬화 가능한 타입의 컬렉션으로 선언되었음에도 불구하고 런타임에 컬렉션이 직렬화 가능한 객체만 포함할 것이라고 보장할 수 없습니다. </li>\n</ul>",
    "howToFix_ko": "<p>다음 시나리오를 고려하세요.</p>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\npublic class Address {\n    ...\n}\n\npublic class Person implements Serializable {\n  private static final long serialVersionUID = 1905122041950251207L;\n\n  private String name;\n  private Address address;  // 규칙 위반, Address는 직렬화 가능하지 않음\n}\n</pre>\n<p>이 문제를 해결하는 방법은 애플리케이션의 요구 사항에 따라 다릅니다. 직렬화 및 역직렬화 중에 필드의 값이 보존되어야 한다면 필드의 값을 직렬화 가능하게 만들 수 있습니다.</p>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\npublic class Address implements Serializable {\n  private static final long serialVersionUID = 2405172041950251807L;\n\n    ...\n}\n\npublic class Person implements Serializable {\n  private static final long serialVersionUID = 1905122041950251207L;\n\n  private String name;\n  private Address address; // 규칙 준수, Address는 직렬화 가능\n}\n</pre>\n<p>직렬화 및 역직렬화 중에 필드의 값을 보존할 필요가 없다면 <code>transient</code>로 표시하세요. 객체가 직렬화될 때 필드는 무시됩니다. 역직렬화 후 필드는 해당 타입에 해당하는 기본값으로 설정됩니다(예: 객체 참조의 경우 <code>null</code>).</p>\n<pre>\npublic class Address {\n    ...\n}\n\npublic class Person implements Serializable {\n  private static final long serialVersionUID = 1905122041950251207L;\n\n  private String name;\n  private transient Address address; // 규칙 준수, 필드가 transient임\n}\n</pre>\n<p>모든 멤버를 직렬화 가능하게 만들거나 <code>transient</code>로 만드는 것의 대안은 객체를 적절하게 직렬화하고 역직렬화하는 책임을 맡는 특수 메서드 <code>writeObject</code>와 <code>readObject</code>를 구현하는 것입니다. 이러한 메서드는 transient가 아니거나 직렬화 불가능한 필드를 포함하더라도 객체를 적절하게 (역)직렬화하는 데 사용할 수 있습니다. 따라서 이 규칙은 이러한 메서드를 구현하는 클래스의 필드에 대해 문제를 제기하지 않습니다.</p>\n<pre>\npublic class Address {\n    ...\n}\n\npublic class Person implements Serializable {\n  private static final long serialVersionUID = 1905122041950251207L;\n\n  private String name;\n  private Address address; // 규칙 준수, writeObject와 readObject가 이 필드를 처리함\n\n  private void writeObject(java.io.ObjectOutputStream out) throws IOException {\n    // 적절한 직렬화 로직\n  }\n\n  private void readObject(java.io.ObjectInputStream in) throws IOException, ClassNotFoundException {\n    // 적절한 역직렬화 로직\n  }\n}\n</pre>\n<p>마지막으로, static 필드는 직렬화 범위에서 벗어나므로 필드를 static으로 만들면 문제가 제기되지 않습니다.</p>\n<pre>\npublic class Person implements Serializable {\n  private static final long serialVersionUID = 1905122041950251207L;\n\n  private String name;\n\n  private static Logger log = getLogger(); // 규칙 준수, static 필드는 직렬화되지 않음\n}\n</pre>",
    "moreInfo_ko": "<ul>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/594\">CWE-594 - 직렬화 불가능한 객체를 디스크에 저장</a> </li>\n  <li> <a href=\"https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/io/Serializable.html\">Interface Serializable - Java SE 11 API 문서</a> </li>\n  <li> <a href=\"https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/io/Serializable.html\">Interface Serializable - Java SE 17 API 문서</a> </li>\n</ul>"
  },
  {
    "id": "S108",
    "key": "java:S108",
    "name": "Nested blocks of code should not be left empty",
    "type": "code-smell",
    "severity": "major",
    "tags": [
      "suspicious"
    ],
    "why": "<p>An empty code block is confusing. It will require some effort from maintainers to determine if it is intentional or indicates the implementation is\nincomplete.</p>\n<pre>\nfor (int i = 0; i &lt; 42; i++){}  // Noncompliant: is the block empty on purpose, or is code missing?\n</pre>\n<p>Removing or filling the empty code blocks takes away ambiguity and generally results in a more straightforward and less surprising code.</p>\n<h3>Exceptions</h3>\n<p>The rule ignores code blocks that contain comments unless they are <code>synchronized</code> blocks because these can affect program flow.</p>",
    "howToFix": "",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "중첩된 코드 블록은 비워두면 안 됩니다",
    "why_ko": "<p>빈 코드 블록은 혼란스럽습니다. 유지 관리자가 의도적인 것인지 구현이 불완전한 것인지 파악하는 데 노력이 필요합니다.</p>\n<pre>\nfor (int i = 0; i &lt; 42; i++){}  // 규칙 위반: 블록이 의도적으로 비어 있는 것인가요, 아니면 코드가 누락된 것인가요?\n</pre>\n<p>빈 코드 블록을 제거하거나 채우면 모호성이 사라지고 일반적으로 더 직관적이고 덜 놀라운 코드가 됩니다.</p>\n<h3>예외</h3>\n<p>규칙은 주석이 포함된 코드 블록을 무시하지만 <code>synchronized</code> 블록은 프로그램 흐름에 영향을 줄 수 있으므로 예외입니다.</p>",
    "howToFix_ko": "",
    "moreInfo_ko": ""
  },
  {
    "id": "S6809",
    "key": "java:S6809",
    "name": "Methods with Spring proxy should not be called via \"this\"",
    "type": "code-smell",
    "severity": "critical",
    "tags": [],
    "why": "<p>A method annotated with Spring's <code>@Async</code>, <code>@Cacheable</code> or <code>@Transactional</code> annotations will not work as expected\nif invoked directly from within its class.</p>\n<p>This is because Spring generates a proxy class with wrapper code to manage the method's asynchronicity (<code>@Async</code>), to cache methods\ninvocations (<code>@Cacheable</code>), or to handle the transaction (<code>@Transactional</code>). However, when called using <code>this</code>, the\nproxy instance is bypassed, and the method is invoked directly without the required wrapper code.</p>",
    "howToFix": "<p>Replace calls to <code>@Async</code>, <code>@Cacheable</code> or <code>@Transactional</code> methods via <code>this</code> with calls on an\ninstance that was injected by Spring (<code>@Autowired</code>, <code>@Resource</code> or <code>@Inject</code>). The injected instance is a proxy on\nwhich the methods can be invoked safely.</p>\n\n<h4>Noncompliant code example</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\n@Service\npublic class AsyncNotificationProcessor implements NotificationProcessor {\n\n  @Override\n  public void process(Notification notification) {\n    processAsync(notification); // Noncompliant, call bypasses proxy\n    retrieveNotification(notification.id); // Noncompliant, call bypasses proxy and will not be cached\n  }\n\n  @Async\n  public processAsync(Notification notification) {\n    // ...\n  }\n\n  @Cacheable\n  public Notification retrieveNotification(Long id) {\n    // ...\n  }\n\n}\n</pre>\n<h4>Compliant solution</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\n@Service\npublic class AsyncNotificationProcessor implements NotificationProcessor {\n\n  @Resource\n  private AsyncNotificationProcessor asyncNotificationProcessor;\n\n  @Override\n  public void process(Notification notification) {\n    asyncNotificationProcessor.processAsync(notification); // Compliant, call via injected proxy\n    asyncNotificationProcessor.retrieveNotification(notification.id); // Compliant, the call will be cached\n  }\n\n  @Async\n  public processAsync(Notification notification) {\n    // ...\n  }\n\n  @Cacheable\n  public Notification retrieveNotification(Long id) {\n    // ...\n  }\n}\n</pre>",
    "moreInfo": "<h3>Documentation</h3>\n<ul>\n  <li> <a href=\"https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/scheduling/annotation/Async.html\">Spring\n  Framework API - Annotation Interface Async</a> </li>\n  <li> <a href=\"https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/transaction/annotation/Transactional.html\">Spring\n  Framework API - Annotation Interface Transactional</a> </li>\n  <li> <a href=\"https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/cache/annotation/Cacheable.html\">Spring Framework\n  API - Annotation Interface Cacheable</a> </li>\n</ul>\n<h3>Articles &amp; blog posts</h3>\n<ul>\n  <li> <a href=\"https://www.baeldung.com/spring-async\">Baeldung - How To Do @Async in Spring</a> </li>\n  <li> <a href=\"https://stackoverflow.com/questions/22561775/spring-async-ignored\">Stack Overflow - Spring @Async ignored</a> </li>\n  <li> <a href=\"https://stackoverflow.com/questions/4396284/does-spring-transactional-attribute-work-on-a-private-method\">Stack Overflow - Does Spring\n  @Transactional attribute work on a private method?</a> </li>\n  <li> <a href=\"https://docs.spring.io/spring-framework/reference/integration/cache/annotations.html#cache-annotations-cacheable\">Spring docs, The\n  @Cacheable Annotation</a> </li>\n</ul>",
    "status": "READY",
    "name_ko": "Spring proxy가 적용된 메서드는 \"this\"를 통해 호출하면 안 됩니다",
    "why_ko": "<p>Spring의 <code>@Async</code>, <code>@Cacheable</code> 또는 <code>@Transactional</code> 어노테이션이 적용된 메서드는 해당 클래스 내에서 직접 호출되면 예상대로 작동하지 않습니다.</p>\n<p>이는 Spring이 메서드의 비동기성(<code>@Async</code>)을 관리하거나, 메서드 호출을 캐시하거나(<code>@Cacheable</code>), 트랜잭션을 처리하기 위해(<code>@Transactional</code>) 래퍼 코드가 있는 프록시 클래스를 생성하기 때문입니다. 그러나 <code>this</code>를 사용하여 호출하면 프록시 인스턴스가 우회되고 필요한 래퍼 코드 없이 메서드가 직접 호출됩니다.</p>",
    "howToFix_ko": "<p><code>this</code>를 통한 <code>@Async</code>, <code>@Cacheable</code> 또는 <code>@Transactional</code> 메서드 호출을 Spring에 의해 주입된 인스턴스(<code>@Autowired</code>, <code>@Resource</code> 또는 <code>@Inject</code>)에 대한 호출로 대체하세요. 주입된 인스턴스는 메서드를 안전하게 호출할 수 있는 프록시입니다.</p>\n\n<h4>규칙을 준수하지 않는 코드 예시</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\n@Service\npublic class AsyncNotificationProcessor implements NotificationProcessor {\n\n  @Override\n  public void process(Notification notification) {\n    processAsync(notification); // 규칙 위반, 호출이 프록시를 우회합니다\n    retrieveNotification(notification.id); // 규칙 위반, 호출이 프록시를 우회하고 캐시되지 않습니다\n  }\n\n  @Async\n  public processAsync(Notification notification) {\n    // ...\n  }\n\n  @Cacheable\n  public Notification retrieveNotification(Long id) {\n    // ...\n  }\n\n}\n</pre>\n<h4>규칙을 준수하는 해결책</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\n@Service\npublic class AsyncNotificationProcessor implements NotificationProcessor {\n\n  @Resource\n  private AsyncNotificationProcessor asyncNotificationProcessor;\n\n  @Override\n  public void process(Notification notification) {\n    asyncNotificationProcessor.processAsync(notification); // 규칙 준수, 주입된 프록시를 통한 호출\n    asyncNotificationProcessor.retrieveNotification(notification.id); // 규칙 준수, 호출이 캐시됩니다\n  }\n\n  @Async\n  public processAsync(Notification notification) {\n    // ...\n  }\n\n  @Cacheable\n  public Notification retrieveNotification(Long id) {\n    // ...\n  }\n}\n</pre>",
    "moreInfo_ko": "<h3>문서</h3>\n<ul>\n  <li> <a href=\"https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/scheduling/annotation/Async.html\">Spring Framework API - 어노테이션 인터페이스 Async</a> </li>\n  <li> <a href=\"https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/transaction/annotation/Transactional.html\">Spring Framework API - 어노테이션 인터페이스 Transactional</a> </li>\n  <li> <a href=\"https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/cache/annotation/Cacheable.html\">Spring Framework API - 어노테이션 인터페이스 Cacheable</a> </li>\n</ul>\n<h3>기사 및 블로그 게시물</h3>\n<ul>\n  <li> <a href=\"https://www.baeldung.com/spring-async\">Baeldung - Spring에서 @Async 사용하기</a> </li>\n  <li> <a href=\"https://stackoverflow.com/questions/22561775/spring-async-ignored\">Stack Overflow - Spring @Async가 무시됨</a> </li>\n  <li> <a href=\"https://stackoverflow.com/questions/4396284/does-spring-transactional-attribute-work-on-a-private-method\">Stack Overflow - Spring @Transactional 속성이 private 메서드에서 작동하나요?</a> </li>\n  <li> <a href=\"https://docs.spring.io/spring-framework/reference/integration/cache/annotations.html#cache-annotations-cacheable\">Spring 문서, @Cacheable 어노테이션</a> </li>\n</ul>"
  },
  {
    "id": "S5663",
    "key": "java:S5663",
    "name": "Simple string literal should be used for single line strings",
    "type": "code-smell",
    "severity": "minor",
    "tags": [
      "java14"
    ],
    "why": "<p>If a string fits on a single line, without concatenation and escaped newlines, you should probably continue to use a string literal.</p>\n<h3>Noncompliant code example</h3>\n<pre>\nString question = \"\"\"\n              What's the point, really?\"\"\";\n</pre>\n<h3>Compliant solution</h3>\n<pre>\nString question = \"What's the point, really?\";\n</pre>",
    "howToFix": "",
    "moreInfo": "<ul>\n  <li> <a href=\"https://openjdk.java.net/jeps/378\">JEP 378: Text Blocks</a> </li>\n  <li> <a href=\"https://openjdk.org/projects/amber/guides/text-blocks-guide\">Programmer's Guide To Text Blocks</a>, by Jim Laskey and Stuart Marks\n  </li>\n</ul>",
    "status": "READY",
    "name_ko": "한 줄 문자열에는 단순 문자열 리터럴을 사용해야 합니다",
    "why_ko": "<p>문자열이 연결이나 이스케이프된 줄바꿈 없이 한 줄에 맞으면 문자열 리터럴을 계속 사용해야 합니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\nString question = \"\"\"\n              What's the point, really?\"\"\";\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre>\nString question = \"What's the point, really?\";\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": "<ul>\n  <li> <a href=\"https://openjdk.java.net/jeps/378\">JEP 378: Text Blocks</a> </li>\n  <li> <a href=\"https://openjdk.org/projects/amber/guides/text-blocks-guide\">Programmer's Guide To Text Blocks</a>, Jim Laskey와 Stuart Marks 저 </li>\n</ul>"
  },
  {
    "id": "S2325",
    "key": "java:S2325",
    "name": "\"private\" and \"final\" methods that don't access instance data should be \"static\"",
    "type": "code-smell",
    "severity": "minor",
    "tags": [
      "pitfall"
    ],
    "why": "<p>Non-overridable methods (<code>private</code> or <code>final</code>) that don't access instance data can be <code>static</code> to prevent any\nmisunderstanding about the contract of the method.</p>\n<h3>Noncompliant code example</h3>\n<pre>\nclass Utilities {\n  private static String magicWord = \"magic\";\n\n  private String getMagicWord() { // Noncompliant\n    return magicWord;\n  }\n\n  private void setMagicWord(String value) { // Noncompliant\n    magicWord = value;\n  }\n\n}\n</pre>\n<h3>Compliant solution</h3>\n<pre>\nclass Utilities {\n  private static String magicWord = \"magic\";\n\n  private static String getMagicWord() {\n    return magicWord;\n  }\n\n  private static void setMagicWord(String value) {\n    magicWord = value;\n  }\n\n}\n</pre>\n<h3>Exceptions</h3>\n<p>When <code>java.io.Serializable</code> is implemented the following three methods are excluded by the rule:</p>\n<ul>\n  <li> <code>private void writeObject(java.io.ObjectOutputStream out) throws IOException;</code> </li>\n  <li> <code>private void readObject(java.io.ObjectInputStream in) throws IOException, ClassNotFoundException;</code> </li>\n  <li> <code>private void readObjectNoData() throws ObjectStreamException;</code> </li>\n</ul>",
    "howToFix": "",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "인스턴스 데이터에 접근하지 않는 \"private\" 및 \"final\" 메서드는 \"static\"이어야 합니다",
    "why_ko": "<p>인스턴스 데이터에 접근하지 않는 재정의 불가능한 메서드(<code>private</code> 또는 <code>final</code>)는 메서드의 계약에 대한 오해를 방지하기 위해 <code>static</code>일 수 있습니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\nclass Utilities {\n  private static String magicWord = \"magic\";\n\n  private String getMagicWord() { // 규칙 위반\n    return magicWord;\n  }\n\n  private void setMagicWord(String value) { // 규칙 위반\n    magicWord = value;\n  }\n\n}\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre>\nclass Utilities {\n  private static String magicWord = \"magic\";\n\n  private static String getMagicWord() {\n    return magicWord;\n  }\n\n  private static void setMagicWord(String value) {\n    magicWord = value;\n  }\n\n}\n</pre>\n<h3>예외</h3>\n<p><code>java.io.Serializable</code>이 구현된 경우 다음 세 가지 메서드는 규칙에서 제외됩니다:</p>\n<ul>\n  <li> <code>private void writeObject(java.io.ObjectOutputStream out) throws IOException;</code> </li>\n  <li> <code>private void readObject(java.io.ObjectInputStream in) throws IOException, ClassNotFoundException;</code> </li>\n  <li> <code>private void readObjectNoData() throws ObjectStreamException;</code> </li>\n</ul>",
    "howToFix_ko": "",
    "moreInfo_ko": ""
  },
  {
    "id": "S2260",
    "key": "java:S2260",
    "name": "Java parser failure",
    "type": "code-smell",
    "severity": "major",
    "tags": [
      "suspicious"
    ],
    "why": "<p>When the Java parser fails, it is possible to record the failure as a violation on the file. This way, not only it is possible to track the number\nof files that do not parse but also to easily find out why they do not parse.</p>",
    "howToFix": "",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "Java 파서 실패",
    "why_ko": "<p>Java 파서가 실패하면 파일에 대한 위반으로 실패를 기록할 수 있습니다. 이렇게 하면 파싱되지 않는 파일의 수를 추적할 수 있을 뿐만 아니라 왜 파싱되지 않는지도 쉽게 파악할 수 있습니다.</p>",
    "howToFix_ko": "",
    "moreInfo_ko": ""
  },
  {
    "id": "S2974",
    "key": "java:S2974",
    "name": "Classes without \"public\" constructors should be \"final\"",
    "type": "code-smell",
    "severity": "minor",
    "tags": [
      "design"
    ],
    "why": "<p>Classes with only <code>private</code> constructors should be marked <code>final</code> to prevent any mistaken extension attempts.</p>\n<h3>Noncompliant code example</h3>\n<pre>\npublic class PrivateConstructorClass {  // Noncompliant\n  private PrivateConstructorClass() {\n    // ...\n  }\n\n  public static int magic(){\n    return 42;\n  }\n}\n</pre>\n<h3>Compliant solution</h3>\n<pre>\npublic final class PrivateConstructorClass {  // Compliant\n  private PrivateConstructorClass() {\n    // ...\n  }\n\n  public static int magic(){\n    return 42;\n  }\n}\n</pre>",
    "howToFix": "",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "public 생성자가 없는 클래스는 final이어야 합니다",
    "why_ko": "<p><code>private</code> 생성자만 있는 클래스는 잘못된 확장 시도를 방지하기 위해 <code>final</code>로 표시해야 합니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\npublic class PrivateConstructorClass {  // 규칙 위반\n  private PrivateConstructorClass() {\n    // ...\n  }\n\n  public static int magic(){\n    return 42;\n  }\n}\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre>\npublic final class PrivateConstructorClass {  // 규칙 준수\n  private PrivateConstructorClass() {\n    // ...\n  }\n\n  public static int magic(){\n    return 42;\n  }\n}\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": ""
  },
  {
    "id": "S2077",
    "key": "java:S2077",
    "name": "Formatting SQL queries is security-sensitive",
    "type": "security-hotspot",
    "severity": "major",
    "tags": [
      "cwe",
      "spring",
      "bad-practice",
      "cert",
      "hibernate",
      "sql"
    ],
    "why": "<p>Formatted SQL queries can be difficult to maintain, debug and can increase the risk of SQL injection when concatenating untrusted values into the\nquery. However, this rule doesn't detect SQL injections (unlike rule <a href='/coding_rules#rule_key=javasecurity%3AS3649'>S3649</a>), the goal is only to highlight complex/formatted queries.</p>\n",
    "howToFix": "<h2>Recommended Secure Coding Practices</h2>\n<ul>\n  <li> Use <a href=\"https://cheatsheetseries.owasp.org/cheatsheets/Query_Parameterization_Cheat_Sheet.html\">parameterized queries, prepared\n  statements, or stored procedures</a> and bind variables to SQL query parameters. </li>\n  <li> Consider using ORM frameworks if there is a need to have an abstract layer to access data. </li>\n</ul>\n<h2>Compliant Solution</h2>\n<pre>\npublic User getUser(Connection con, String user) throws SQLException {\n\n  Statement stmt1 = null;\n  PreparedStatement pstmt = null;\n  String query = \"select FNAME, LNAME, SSN \" +\n                 \"from USERS where UNAME=?\"\n  try {\n    stmt1 = con.createStatement();\n    ResultSet rs1 = stmt1.executeQuery(\"GETDATE()\");\n\n    pstmt = con.prepareStatement(query);\n    pstmt.setString(1, user);  // Good; PreparedStatements escape their inputs.\n    ResultSet rs2 = pstmt.executeQuery();\n\n    //...\n  }\n}\n\npublic User getUserHibernate(org.hibernate.Session session, String data) {\n\n  org.hibernate.Query query =  session.createQuery(\"FROM students where fname = ?\");\n  query = query.setParameter(0,data);  // Good; Parameter binding escapes all input\n\n  org.hibernate.Query query2 =  session.createQuery(\"FROM students where fname = \" + data); // Sensitive\n  // ...\n</pre>\n<h2>See</h2>\n<ul>\n  <li> OWASP - <a href=\"https://owasp.org/Top10/A03_2021-Injection/\">Top 10 2021 Category A3 - Injection</a> </li>\n  <li> OWASP - <a href=\"https://owasp.org/www-project-top-ten/2017/A1_2017-Injection\">Top 10 2017 Category A1 - Injection</a> </li>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/89\">CWE-89 - Improper Neutralization of Special Elements used in an SQL Command</a> </li>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/564\">CWE-564 - SQL Injection: Hibernate</a> </li>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/20\">CWE-20 - Improper Input Validation</a> </li>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/943\">CWE-943 - Improper Neutralization of Special Elements in Data Query Logic</a> </li>\n  <li> <a href=\"https://wiki.sei.cmu.edu/confluence/x/ITdGBQ\">CERT, IDS00-J.</a> - Prevent SQL injection </li>\n  <li> Derived from FindSecBugs rules <a href=\"https://h3xstream.github.io/find-sec-bugs/bugs.htm#SQL_INJECTION_JPA\">Potential SQL/JPQL Injection\n  (JPA)</a>, <a href=\"https://h3xstream.github.io/find-sec-bugs/bugs.htm#SQL_INJECTION_JDO\">Potential SQL/JDOQL Injection (JDO)</a>, <a\n  href=\"https://h3xstream.github.io/find-sec-bugs/bugs.htm#SQL_INJECTION_HIBERNATE\">Potential SQL/HQL Injection (Hibernate)</a> </li>\n</ul>",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "SQL 쿼리 포맷팅은 보안에 민감합니다",
    "why_ko": "<p>포맷된 SQL 쿼리는 유지 관리, 디버그가 어려울 수 있으며 신뢰할 수 없는 값을 쿼리에 연결할 때 SQL 인젝션의 위험을 높일 수 있습니다. 그러나 이 규칙은 SQL 인젝션을 감지하지 않습니다(규칙 <a href='/coding_rules#rule_key=javasecurity%3AS3649'>S3649</a>와는 다르게). 목표는 복잡한/포맷된 쿼리를 강조하는 것뿐입니다.</p>\n",
    "howToFix_ko": "<h2>권장 보안 코딩 방법</h2>\n<ul>\n  <li> <a href=\"https://cheatsheetseries.owasp.org/cheatsheets/Query_Parameterization_Cheat_Sheet.html\">파라미터화된 쿼리, prepared statements 또는 저장 프로시저</a>를 사용하고 변수를 SQL 쿼리 파라미터에 바인딩하세요. </li>\n  <li> 데이터에 액세스하기 위한 추상 계층이 필요한 경우 ORM 프레임워크 사용을 고려하세요. </li>\n</ul>\n<h2>규칙을 준수하는 해결책</h2>\n<pre>\npublic User getUser(Connection con, String user) throws SQLException {\n\n  Statement stmt1 = null;\n  PreparedStatement pstmt = null;\n  String query = \"select FNAME, LNAME, SSN \" +\n                 \"from USERS where UNAME=?\"\n  try {\n    stmt1 = con.createStatement();\n    ResultSet rs1 = stmt1.executeQuery(\"GETDATE()\");\n\n    pstmt = con.prepareStatement(query);\n    pstmt.setString(1, user);  // 좋음; PreparedStatements는 입력을 이스케이프합니다.\n    ResultSet rs2 = pstmt.executeQuery();\n\n    //...\n  }\n}\n\npublic User getUserHibernate(org.hibernate.Session session, String data) {\n\n  org.hibernate.Query query =  session.createQuery(\"FROM students where fname = ?\");\n  query = query.setParameter(0,data);  // 좋음; 파라미터 바인딩은 모든 입력을 이스케이프합니다\n\n  org.hibernate.Query query2 =  session.createQuery(\"FROM students where fname = \" + data); // 민감함\n  // ...\n</pre>\n<h2>참고</h2>\n<ul>\n  <li> OWASP - <a href=\"https://owasp.org/Top10/A03_2021-Injection/\">Top 10 2021 Category A3 - Injection</a> </li>\n  <li> OWASP - <a href=\"https://owasp.org/www-project-top-ten/2017/A1_2017-Injection\">Top 10 2017 Category A1 - Injection</a> </li>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/89\">CWE-89 - Improper Neutralization of Special Elements used in an SQL Command</a> </li>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/564\">CWE-564 - SQL Injection: Hibernate</a> </li>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/20\">CWE-20 - Improper Input Validation</a> </li>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/943\">CWE-943 - Improper Neutralization of Special Elements in Data Query Logic</a> </li>\n  <li> <a href=\"https://wiki.sei.cmu.edu/confluence/x/ITdGBQ\">CERT, IDS00-J.</a> - Prevent SQL injection </li>\n  <li> FindSecBugs 규칙에서 파생됨 <a href=\"https://h3xstream.github.io/find-sec-bugs/bugs.htm#SQL_INJECTION_JPA\">Potential SQL/JPQL Injection (JPA)</a>, <a href=\"https://h3xstream.github.io/find-sec-bugs/bugs.htm#SQL_INJECTION_JDO\">Potential SQL/JDOQL Injection (JDO)</a>, <a href=\"https://h3xstream.github.io/find-sec-bugs/bugs.htm#SQL_INJECTION_HIBERNATE\">Potential SQL/HQL Injection (Hibernate)</a> </li>\n</ul>",
    "moreInfo_ko": ""
  },
  {
    "id": "S124",
    "key": "java:S124",
    "name": "Track comments matching a regular expression",
    "type": "code-smell",
    "severity": "major",
    "tags": [],
    "why": "<p>This rule template can be used to create rules which will be triggered when the full content of a comment matches a given regular expression. Note\nthat the regular expression should be expressed using the dotall format (where the <code>.</code> character matches any character).</p>\n<p>For example, one can create a rule with the regular expression <code>.*REVIEW.*</code> to match all comment containing \"REVIEW\".</p>\n<p>Note that, in order to match REVIEW regardless of the case, the <code>(?i)</code> modifier should be prepended to the expression, as in\n<code>(?i).*REVIEW.*</code>.</p>",
    "howToFix": "",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "정규 표현식과 일치하는 주석을 추적해야 합니다",
    "why_ko": "<p>이 규칙 템플릿은 주석의 전체 내용이 주어진 정규 표현식과 일치할 때 트리거되는 규칙을 만드는 데 사용할 수 있습니다. 정규 표현식은 dotall 형식(<code>.</code> 문자가 모든 문자와 일치하는 형식)으로 표현해야 합니다.</p>\n<p>예를 들어 \"REVIEW\"를 포함하는 모든 주석과 일치하도록 정규 표현식 <code>.*REVIEW.*</code>로 규칙을 만들 수 있습니다.</p>\n<p>대소문자에 관계없이 REVIEW를 일치시키려면 <code>(?i).*REVIEW.*</code>와 같이 표현식 앞에 <code>(?i)</code> 수정자를 추가해야 합니다.</p>",
    "howToFix_ko": "",
    "moreInfo_ko": ""
  },
  {
    "id": "S3959",
    "key": "java:S3959",
    "name": "Consumed Stream pipelines should not be reused",
    "type": "bug",
    "severity": "major",
    "tags": [
      "symbolic-execution",
      "java8"
    ],
    "why": "<p>Stream operations are divided into intermediate and terminal operations, and are combined to form stream pipelines. After the terminal operation is\nperformed, the stream pipeline is considered consumed, and cannot be used again. Such a reuse will yield unexpected results.</p>\n<h3>Noncompliant code example</h3>\n<pre>\nStream&lt;Widget&gt; pipeline = widgets.stream().filter(b -&gt; b.getColor() == RED);\nint sum1 = pipeline.sum();\nint sum2 = pipeline.mapToInt(b -&gt; b.getWeight()).sum(); // Noncompliant\n</pre>",
    "howToFix": "",
    "moreInfo": "<p><a href=\"https://docs.oracle.com/javase/8/docs/api/java/util/stream/package-summary.html#StreamOps\">Stream Operations</a></p>",
    "status": "READY",
    "name_ko": "소비된 Stream 파이프라인을 재사용하면 안 됩니다",
    "why_ko": "<p>스트림 연산은 중간 연산과 종단 연산으로 나뉘며, 결합하여 스트림 파이프라인을 형성합니다. 종단 연산이 수행된 후 스트림 파이프라인은 소비된 것으로 간주되며 다시 사용할 수 없습니다. 이러한 재사용은 예상치 못한 결과를 초래합니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\nStream&lt;Widget&gt; pipeline = widgets.stream().filter(b -&gt; b.getColor() == RED);\nint sum1 = pipeline.sum();\nint sum2 = pipeline.mapToInt(b -&gt; b.getWeight()).sum(); // 규칙 위반\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": "<p><a href=\"https://docs.oracle.com/javase/8/docs/api/java/util/stream/package-summary.html#StreamOps\">Stream 연산</a></p>"
  },
  {
    "id": "S4635",
    "key": "java:S4635",
    "name": "String offset-based methods should be preferred for finding substrings from offsets",
    "type": "code-smell",
    "severity": "critical",
    "tags": [
      "performance"
    ],
    "why": "<p>Looking for a given substring starting from a specified offset can be achieved by such code: <code>str.substring(beginIndex).indexOf(char1)</code>.\nThis works well, but it creates a new <code>String</code> for each call to the <code>substring</code> method. When this is done in a loop, a lot of\n<code>Strings</code> are created for nothing, which can lead to performance problems if <code>str</code> is large.</p>\n<p>To avoid performance problems, <code>String.substring(beginIndex)</code> should not be chained with the following methods:</p>\n<ul>\n  <li> <code>indexOf(int ch)</code> </li>\n  <li> <code>indexOf(String str)</code> </li>\n  <li> <code>lastIndexOf(int ch)</code> </li>\n  <li> <code>lastIndexOf(String str)</code> </li>\n  <li> <code>startsWith(String prefix)</code> </li>\n</ul>\n<p>For each of these methods, another method with an additional parameter is available to specify an offset.</p>\n<p>Using these methods will avoid the creation of additional <code>String</code> instances. For indexOf methods, adjust the returned value by\nsubtracting the substring index parameter to obtain the same result.</p>\n<h3>Noncompliant code example</h3>\n<pre>\nstr.substring(beginIndex).indexOf(char1); // Noncompliant; a new String is going to be created by \"substring\"\n</pre>\n<h3>Compliant solution</h3>\n<pre>\nstr.indexOf(char1, beginIndex) - beginIndex; // index for char1 not found is (-1-beginIndex)\n</pre>",
    "howToFix": "",
    "moreInfo": "<h3>Benchmarks</h3>\n<table>\n  <colgroup>\n    <col style=\"width: 20%;\">\n    <col style=\"width: 20%;\">\n    <col style=\"width: 20%;\">\n    <col style=\"width: 20%;\">\n    <col style=\"width: 20%;\">\n  </colgroup>\n  <thead>\n    <tr>\n      <th>Method</th>\n      <th>stringSize</th>\n      <th>Runtime</th>\n      <th>Average time</th>\n      <th>Error margin</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td><p>indexOfOnly</p></td>\n      <td><p>10</p></td>\n      <td><p>Temurin 21</p></td>\n      <td><p>1.55 ns/op</p></td>\n      <td><p>±0.12 ns/op</p></td>\n    </tr>\n    <tr>\n      <td><p>indexOfOnly</p></td>\n      <td><p>100</p></td>\n      <td><p>Temurin 21</p></td>\n      <td><p>1.78 ns/op</p></td>\n      <td><p>±0.05 ns/op</p></td>\n    </tr>\n    <tr>\n      <td><p>indexOfOnly</p></td>\n      <td><p>1000</p></td>\n      <td><p>Temurin 21</p></td>\n      <td><p>1.82 ns/op</p></td>\n      <td><p>±0.18 ns/op</p></td>\n    </tr>\n    <tr>\n      <td><p>indexOfOnly</p></td>\n      <td><p>10000</p></td>\n      <td><p>Temurin 21</p></td>\n      <td><p>1.77 ns/op</p></td>\n      <td><p>±0.08 ns/op</p></td>\n    </tr>\n    <tr>\n      <td><p>substringThenIndexOf</p></td>\n      <td><p>10</p></td>\n      <td><p>Temurin 21</p></td>\n      <td><p>4.85 ns/op</p></td>\n      <td><p>±0.41 ns/op</p></td>\n    </tr>\n    <tr>\n      <td><p>substringThenIndexOf</p></td>\n      <td><p>100</p></td>\n      <td><p>Temurin 21</p></td>\n      <td><p>6.22 ns/op</p></td>\n      <td><p>±0.40 ns/op</p></td>\n    </tr>\n    <tr>\n      <td><p>substringThenIndexOf</p></td>\n      <td><p>1000</p></td>\n      <td><p>Temurin 21</p></td>\n      <td><p>14.22 ns/op</p></td>\n      <td><p>±1.66 ns/op</p></td>\n    </tr>\n    <tr>\n      <td><p>substringThenIndexOf</p></td>\n      <td><p>10000</p></td>\n      <td><p>Temurin 21</p></td>\n      <td><p>275.00 ns/op</p></td>\n      <td><p>±20.49 ns/op</p></td>\n    </tr>\n  </tbody>\n</table>\n<p><strong>Benchmarking code</strong></p>\n<p>The results were generated by running the following snippet with <a href=\"https://github.com/openjdk/jmh\">JMH</a>.</p>\n<pre>\n@BenchmarkMode({Mode.AverageTime})\n@OutputTimeUnit(TimeUnit.NANOSECONDS)\n@State(Scope.Benchmark)\npublic class S4635 {\n  @Param({\"10\", \"100\", \"1000\", \"10000\"})\n  int stringSize;\n\n  String input;\n\n  @Setup\n  public void setup() {\n    StringBuilder builder = new StringBuilder();\n    for (int i = 0; i &lt; stringSize; i++) {\n      builder.append('a');\n    }\n    input = builder.toString();\n  }\n\n  @Benchmark\n  public int substringThenIndexOf() {\n    return stringSize / 2 + input.substring(stringSize / 2).indexOf('a');\n  }\n\n  @Benchmark\n  public int indexOfOnly() {\n    return input.indexOf('a', stringSize / 2);\n  }\n}\n</pre>",
    "status": "READY",
    "name_ko": "오프셋에서 부분 문자열을 찾을 때는 오프셋 기반 String 메서드를 사용해야 합니다",
    "why_ko": "<p>지정된 오프셋에서 시작하여 주어진 부분 문자열을 찾는 것은 <code>str.substring(beginIndex).indexOf(char1)</code>과 같은 코드로 수행할 수 있습니다. 이 코드는 잘 작동하지만 <code>substring</code> 메서드를 호출할 때마다 새로운 <code>String</code>을 생성합니다. 루프에서 이 작업을 수행하면 아무 이유 없이 많은 <code>String</code>이 생성되어 <code>str</code>이 큰 경우 성능 문제가 발생할 수 있습니다.</p>\n<p>성능 문제를 피하려면 <code>String.substring(beginIndex)</code>를 다음 메서드와 연결하면 안 됩니다:</p>\n<ul>\n  <li> <code>indexOf(int ch)</code> </li>\n  <li> <code>indexOf(String str)</code> </li>\n  <li> <code>lastIndexOf(int ch)</code> </li>\n  <li> <code>lastIndexOf(String str)</code> </li>\n  <li> <code>startsWith(String prefix)</code> </li>\n</ul>\n<p>이러한 각 메서드에 대해 오프셋을 지정하기 위한 추가 매개변수가 있는 다른 메서드를 사용할 수 있습니다.</p>\n<p>이러한 메서드를 사용하면 추가 <code>String</code> 인스턴스 생성을 피할 수 있습니다. indexOf 메서드의 경우 동일한 결과를 얻으려면 반환된 값에서 substring 인덱스 매개변수를 빼서 조정하세요.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\nstr.substring(beginIndex).indexOf(char1); // 규칙 위반; \"substring\"에 의해 새 String이 생성됨\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre>\nstr.indexOf(char1, beginIndex) - beginIndex; // char1을 찾지 못한 경우 인덱스는 (-1-beginIndex)\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": "<h3>벤치마크</h3>\n<table>\n  <colgroup>\n    <col style=\"width: 20%;\">\n    <col style=\"width: 20%;\">\n    <col style=\"width: 20%;\">\n    <col style=\"width: 20%;\">\n    <col style=\"width: 20%;\">\n  </colgroup>\n  <thead>\n    <tr>\n      <th>메서드</th>\n      <th>문자열 크기</th>\n      <th>런타임</th>\n      <th>평균 시간</th>\n      <th>오차 범위</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td><p>indexOfOnly</p></td>\n      <td><p>10</p></td>\n      <td><p>Temurin 21</p></td>\n      <td><p>1.55 ns/op</p></td>\n      <td><p>±0.12 ns/op</p></td>\n    </tr>\n    <tr>\n      <td><p>indexOfOnly</p></td>\n      <td><p>100</p></td>\n      <td><p>Temurin 21</p></td>\n      <td><p>1.78 ns/op</p></td>\n      <td><p>±0.05 ns/op</p></td>\n    </tr>\n    <tr>\n      <td><p>indexOfOnly</p></td>\n      <td><p>1000</p></td>\n      <td><p>Temurin 21</p></td>\n      <td><p>1.82 ns/op</p></td>\n      <td><p>±0.18 ns/op</p></td>\n    </tr>\n    <tr>\n      <td><p>indexOfOnly</p></td>\n      <td><p>10000</p></td>\n      <td><p>Temurin 21</p></td>\n      <td><p>1.77 ns/op</p></td>\n      <td><p>±0.08 ns/op</p></td>\n    </tr>\n    <tr>\n      <td><p>substringThenIndexOf</p></td>\n      <td><p>10</p></td>\n      <td><p>Temurin 21</p></td>\n      <td><p>4.85 ns/op</p></td>\n      <td><p>±0.41 ns/op</p></td>\n    </tr>\n    <tr>\n      <td><p>substringThenIndexOf</p></td>\n      <td><p>100</p></td>\n      <td><p>Temurin 21</p></td>\n      <td><p>6.22 ns/op</p></td>\n      <td><p>±0.40 ns/op</p></td>\n    </tr>\n    <tr>\n      <td><p>substringThenIndexOf</p></td>\n      <td><p>1000</p></td>\n      <td><p>Temurin 21</p></td>\n      <td><p>14.22 ns/op</p></td>\n      <td><p>±1.66 ns/op</p></td>\n    </tr>\n    <tr>\n      <td><p>substringThenIndexOf</p></td>\n      <td><p>10000</p></td>\n      <td><p>Temurin 21</p></td>\n      <td><p>275.00 ns/op</p></td>\n      <td><p>±20.49 ns/op</p></td>\n    </tr>\n  </tbody>\n</table>\n<p><strong>벤치마크 코드</strong></p>\n<p>결과는 <a href=\"https://github.com/openjdk/jmh\">JMH</a>로 다음 코드 조각을 실행하여 생성되었습니다.</p>\n<pre>\n@BenchmarkMode({Mode.AverageTime})\n@OutputTimeUnit(TimeUnit.NANOSECONDS)\n@State(Scope.Benchmark)\npublic class S4635 {\n  @Param({\"10\", \"100\", \"1000\", \"10000\"})\n  int stringSize;\n\n  String input;\n\n  @Setup\n  public void setup() {\n    StringBuilder builder = new StringBuilder();\n    for (int i = 0; i &lt; stringSize; i++) {\n      builder.append('a');\n    }\n    input = builder.toString();\n  }\n\n  @Benchmark\n  public int substringThenIndexOf() {\n    return stringSize / 2 + input.substring(stringSize / 2).indexOf('a');\n  }\n\n  @Benchmark\n  public int indexOfOnly() {\n    return input.indexOf('a', stringSize / 2);\n  }\n}\n</pre>"
  },
  {
    "id": "S1067",
    "key": "java:S1067",
    "name": "Expressions should not be too complex",
    "type": "code-smell",
    "severity": "critical",
    "tags": [
      "brain-overload"
    ],
    "why": "<p>The complexity of an expression is defined by the number of <code>&amp;&amp;</code>, <code>||</code> and <code>condition ? ifTrue : ifFalse</code>\noperators it contains.</p>\n<p>A single expression's complexity should not become too high to keep the code readable.</p>\n<h3>Noncompliant code example</h3>\n<p>With the default threshold value of 3:</p>\n<pre>\nif (((condition1 &amp;&amp; condition2) || (condition3 &amp;&amp; condition4)) &amp;&amp; condition5) { ... }\n</pre>\n<h3>Compliant solution</h3>\n<pre>\nif ( (myFirstCondition() || mySecondCondition()) &amp;&amp; myLastCondition()) { ... }\n</pre>\n<h3>Exceptions</h3>\n<p>No issue is reported inside <code>equals</code> methods, because it is common to compare all the fields of a class for equality inside this kind of\nmethod.</p>",
    "howToFix": "",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "표현식은 너무 복잡하면 안 됩니다",
    "why_ko": "<p>표현식의 복잡도는 포함된 <code>&amp;&amp;</code>, <code>||</code>, <code>condition ? ifTrue : ifFalse</code> 연산자의 수로 정의됩니다.</p>\n<p>코드의 가독성을 유지하기 위해 단일 표현식의 복잡도가 너무 높아져서는 안 됩니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<p>기본 임계값 3을 사용할 경우:</p>\n<pre>\nif (((condition1 &amp;&amp; condition2) || (condition3 &amp;&amp; condition4)) &amp;&amp; condition5) { ... }\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre>\nif ( (myFirstCondition() || mySecondCondition()) &amp;&amp; myLastCondition()) { ... }\n</pre>\n<h3>예외 사항</h3>\n<p><code>equals</code> 메서드 내부에서는 이슈가 보고되지 않습니다. 이러한 종류의 메서드에서는 클래스의 모든 필드를 동등성 비교하는 것이 일반적이기 때문입니다.</p>",
    "howToFix_ko": "",
    "moreInfo_ko": ""
  },
  {
    "id": "S1821",
    "key": "java:S1821",
    "name": "\"switch\" statements and expressions should not be nested",
    "type": "code-smell",
    "severity": "critical",
    "tags": [
      "pitfall"
    ],
    "why": "<p>Nested <code>switch</code> structures are difficult to understand because you can easily confuse the cases of an inner <code>switch</code> as\nbelonging to an outer statement or expression. Therefore nested <code>switch</code> statements and expressions should be avoided.</p>\n<p>Specifically, you should structure your code to avoid the need for nested <code>switch</code> statements or expressions, but if you cannot, then\nconsider moving the inner <code>switch</code> to another method.</p>\n<h3>Noncompliant code example</h3>\n<pre>\nvoid foo(int n, int m) {\n  switch (n) {\n    case 0:\n      switch (m) {  // Noncompliant; nested switch\n        // ...\n      }\n    case 1:\n      // ...\n    default:\n      // ...\n  }\n}\n</pre>\n<h3>Compliant solution</h3>\n<pre>\nvoid foo(int n, int m) {\n  switch (n) {\n    case 0:\n      bar(m);\n    case 1:\n      // ...\n    default:\n      // ...\n  }\n}\n\nvoid bar(int m){\n  switch(m) {\n    // ...\n  }\n}\n</pre>",
    "howToFix": "",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "\"switch\" 문과 표현식은 중첩되면 안 됩니다",
    "why_ko": "<p>중첩된 <code>switch</code> 구조는 내부 <code>switch</code>의 case를 외부 문이나 표현식에 속하는 것으로 쉽게 혼동할 수 있기 때문에 이해하기 어렵습니다. 따라서 중첩된 <code>switch</code> 문과 표현식은 피해야 합니다.</p>\n<p>구체적으로, 중첩된 <code>switch</code> 문이나 표현식이 필요하지 않도록 코드를 구조화해야 하지만, 그렇게 할 수 없다면 내부 <code>switch</code>를 다른 메서드로 이동하는 것을 고려하세요.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\nvoid foo(int n, int m) {\n  switch (n) {\n    case 0:\n      switch (m) {  // 규칙 위반; 중첩된 switch\n        // ...\n      }\n    case 1:\n      // ...\n    default:\n      // ...\n  }\n}\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre>\nvoid foo(int n, int m) {\n  switch (n) {\n    case 0:\n      bar(m);\n    case 1:\n      // ...\n    default:\n      // ...\n  }\n}\n\nvoid bar(int m){\n  switch(m) {\n    // ...\n  }\n}\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": ""
  },
  {
    "id": "S3631",
    "key": "java:S3631",
    "name": "\"Arrays.stream\" should be used for primitive arrays",
    "type": "code-smell",
    "severity": "major",
    "tags": [
      "performance"
    ],
    "why": "<p>For arrays of objects, <code>Arrays.asList(T ... a).stream()</code> and <code>Arrays.stream(array)</code> are basically equivalent in terms of\nperformance. However, for arrays of primitives, using <code>Arrays.asList</code> will force the construction of a list of boxed types, and then use\n<em>that</em> list as a stream. On the other hand, <code>Arrays.stream</code> uses the appropriate primitive stream type (<code>IntStream</code>,\n<code>LongStream</code>, <code>DoubleStream</code>) when applicable, with much better performance.</p>\n<h3>Noncompliant code example</h3>\n<pre>\nArrays.asList(\"a1\", \"a2\", \"b1\", \"c2\", \"c1\").stream()\n    .filter(...)\n    .forEach(...);\n\nArrays.asList(1, 2, 3, 4).stream() // Noncompliant\n    .filter(...)\n    .forEach(...);\n</pre>\n<h3>Compliant solution</h3>\n<pre>\nArrays.asList(\"a1\", \"a2\", \"b1\", \"c2\", \"c1\").stream()\n    .filter(...)\n    .forEach(...);\n\nint[] intArray = new int[]{1, 2, 3, 4};\nArrays.stream(intArray)\n    .filter(...)\n    .forEach(...);\n</pre>",
    "howToFix": "",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "primitive 배열에는 Arrays.stream을 사용해야 합니다",
    "why_ko": "<p>객체 배열의 경우 <code>Arrays.asList(T ... a).stream()</code>과 <code>Arrays.stream(array)</code>는 성능 면에서 기본적으로 동등합니다. 그러나 primitive 배열의 경우 <code>Arrays.asList</code>를 사용하면 박싱된 타입의 리스트를 강제로 구성한 다음 <em>그</em> 리스트를 스트림으로 사용합니다. 반면에 <code>Arrays.stream</code>은 해당되는 경우 적절한 primitive 스트림 타입(<code>IntStream</code>, <code>LongStream</code>, <code>DoubleStream</code>)을 사용하여 훨씬 더 나은 성능을 제공합니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\nArrays.asList(\"a1\", \"a2\", \"b1\", \"c2\", \"c1\").stream()\n    .filter(...)\n    .forEach(...);\n\nArrays.asList(1, 2, 3, 4).stream() // 규칙 위반\n    .filter(...)\n    .forEach(...);\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre>\nArrays.asList(\"a1\", \"a2\", \"b1\", \"c2\", \"c1\").stream()\n    .filter(...)\n    .forEach(...);\n\nint[] intArray = new int[]{1, 2, 3, 4};\nArrays.stream(intArray)\n    .filter(...)\n    .forEach(...);\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": ""
  },
  {
    "id": "S1319",
    "key": "java:S1319",
    "name": "Declarations should use Java collection interfaces such as \"List\" rather than specific implementation classes such as \"LinkedList\"",
    "type": "code-smell",
    "severity": "minor",
    "tags": [
      "bad-practice"
    ],
    "why": "<p>The Java Collections API offers a well-structured hierarchy of interfaces designed to hide collection implementation details. For the various\ncollection data structures like lists, sets, and maps, specific interfaces (<code>java.util.List</code>, <code>java.util.Set</code>,\n<code>java.util.Map</code>) cover the essential features.</p>\n<p>When passing collections as method parameters, return values, or when exposing fields, it is generally recommended to use these interfaces instead\nof the implementing classes. The implementing classes, such as <code>java.util.LinkedList</code>, <code>java.util.ArrayList</code>, and\n<code>java.util.HasMap</code>, should only be used for collection instantiation. They provide finer control over the performance characteristics of\nthose structures, and developers choose them depending on their use case.</p>\n<p>For example, if fast random element access is essential, <code>java.util.ArrayList</code> should be instantiated. If inserting elements at a random\nposition into a list is crucial, a <code>java.util.LinkedList</code> should be preferred. However, this is an implementation detail your API should\nnot expose.</p>\n\n<h4>Noncompliant code example</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\npublic class Employees {\n  public final HashSet&lt;Employee&gt; employees   // Noncompliant, field type should be \"Set\"\n    = new HashSet&lt;Employee&gt;();\n\n  public HashSet&lt;Employee&gt; getEmployees() {  // Noncompliant, return type should be \"Set\"\n    return employees;\n  }\n}\n</pre>\n<h4>Compliant solution</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\npublic class Employees {\n  public final Set&lt;Employee&gt; employees       // Compliant\n    = new HashSet&lt;Employee&gt;();\n\n  public Set&lt;Employee&gt; getEmployees() {      // Compliant\n    return employees;\n  }\n}\n</pre>",
    "howToFix": "",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "선언에는 \"LinkedList\" 같은 구체 클래스 대신 \"List\" 같은 Java 컬렉션 인터페이스를 사용해야 합니다",
    "why_ko": "<p>Java Collections API는 컬렉션 구현 세부 사항을 숨기도록 설계된 잘 구조화된 인터페이스 계층을 제공합니다. 리스트, 집합, 맵과 같은 다양한 컬렉션 데이터 구조에 대해 특정 인터페이스(<code>java.util.List</code>, <code>java.util.Set</code>, <code>java.util.Map</code>)가 필수 기능을 제공합니다.</p>\n<p>컬렉션을 메서드 파라미터, 반환 값으로 전달하거나 필드를 노출할 때 구현 클래스 대신 이러한 인터페이스를 사용하는 것이 일반적으로 권장됩니다. <code>java.util.LinkedList</code>, <code>java.util.ArrayList</code>, <code>java.util.HashMap</code>과 같은 구현 클래스는 컬렉션 인스턴스화에만 사용해야 합니다. 이러한 클래스는 해당 구조의 성능 특성에 대한 더 세밀한 제어를 제공하며 개발자는 사용 사례에 따라 선택합니다.</p>\n<p>예를 들어, 빠른 랜덤 요소 접근이 필수적인 경우 <code>java.util.ArrayList</code>를 인스턴스화해야 합니다. 리스트의 임의 위치에 요소를 삽입하는 것이 중요한 경우 <code>java.util.LinkedList</code>가 선호되어야 합니다. 그러나 이것은 API가 노출하지 않아야 하는 구현 세부 사항입니다.</p>\n\n<h4>규칙을 준수하지 않는 코드 예시</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\npublic class Employees {\n  public final HashSet&lt;Employee&gt; employees   // 규칙 위반, 필드 타입은 \"Set\"이어야 합니다\n    = new HashSet&lt;Employee&gt;();\n\n  public HashSet&lt;Employee&gt; getEmployees() {  // 규칙 위반, 반환 타입은 \"Set\"이어야 합니다\n    return employees;\n  }\n}\n</pre>\n<h4>규칙을 준수하는 해결책</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\npublic class Employees {\n  public final Set&lt;Employee&gt; employees       // 규칙 준수\n    = new HashSet&lt;Employee&gt;();\n\n  public Set&lt;Employee&gt; getEmployees() {      // 규칙 준수\n    return employees;\n  }\n}\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": ""
  },
  {
    "id": "S6126",
    "key": "java:S6126",
    "name": "String multiline concatenation should be replaced with Text Blocks",
    "type": "code-smell",
    "severity": "major",
    "tags": [
      "java15"
    ],
    "why": "<p>In Java 15 Text Blocks are now official and can be used. The most common pattern for multiline strings in Java &lt; 15 was to write String\nconcatenation. Now it's possible to do it in a more natural way using Text Blocks.</p>\n<h3>Noncompliant code example</h3>\n<pre>\nString textBlock =\n               \"&lt;html&gt;\\n\" +\n               \"    &lt;body&gt;\\n\" +\n               \"        &lt;tag&gt;\\n\" +\n               \"        &lt;/tag&gt;\\n\" +\n               \"    &lt;/body&gt;\\n\" +\n               \"&lt;/html&gt;\";\n</pre>\n<h3>Compliant solution</h3>\n<pre>\nString textBlock = \"\"\"\n        &lt;html&gt;\n            &lt;body&gt;\n                &lt;tag&gt;\n                &lt;/tag&gt;\n            &lt;/body&gt;\n        &lt;/html&gt;\"\"\";\n</pre>",
    "howToFix": "",
    "moreInfo": "<ul>\n  <li> <a href=\"https://openjdk.java.net/jeps/378\">JEP 378: Text Blocks</a> </li>\n  <li> <a href=\"https://openjdk.org/projects/amber/guides/text-blocks-guide\">Programmer's Guide To Text Blocks</a>, by Jim Laskey and Stuart Marks\n  </li>\n</ul>",
    "status": "READY",
    "name_ko": "String 여러 줄 연결은 Text Block으로 대체해야 합니다",
    "why_ko": "<p>Java 15에서 Text Block이 공식화되어 사용할 수 있습니다. Java 15 이전의 여러 줄 문자열에 대한 가장 일반적인 패턴은 String 연결을 작성하는 것이었습니다. 이제 Text Block을 사용하여 더 자연스러운 방식으로 작성할 수 있습니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\nString textBlock =\n               \"&lt;html&gt;\\n\" +\n               \"    &lt;body&gt;\\n\" +\n               \"        &lt;tag&gt;\\n\" +\n               \"        &lt;/tag&gt;\\n\" +\n               \"    &lt;/body&gt;\\n\" +\n               \"&lt;/html&gt;\";\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre>\nString textBlock = \"\"\"\n        &lt;html&gt;\n            &lt;body&gt;\n                &lt;tag&gt;\n                &lt;/tag&gt;\n            &lt;/body&gt;\n        &lt;/html&gt;\"\"\";\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": "<ul>\n  <li> <a href=\"https://openjdk.java.net/jeps/378\">JEP 378: Text Blocks</a> </li>\n  <li> <a href=\"https://openjdk.org/projects/amber/guides/text-blocks-guide\">Programmer's Guide To Text Blocks</a>, Jim Laskey, Stuart Marks 작성\n  </li>\n</ul>"
  },
  {
    "id": "S2165",
    "key": "java:S2165",
    "name": "\"finalize\" should not set fields to \"null\"",
    "type": "code-smell",
    "severity": "minor",
    "tags": [],
    "why": "<p>In the Java object lifecycle, the <code>finalize</code> method for an instance is called after the garbage collector has determined that the\ninstance can be removed from the object heap. Therefore, it is unnecessary to implement a finalizer to set instance fields explicitly to\n<code>null</code> to tell the garbage collector that the instance no longer needs them.</p>\n<p>In the worst case, implementing <code>finalize</code> is even counterproductive because it might accidentally create new references from other\n(living) objects on the heap to the collectible instance, thus, reviving it.</p>\n<p><strong>Important note about finalizers:</strong></p>\n<p>There are no guarantees when the Java Runtime will call the <code>finalize</code> method or whether it will be called at all.</p>\n<p>Using finalizers is, therefore, a bad practice. They should never be used to free resources, such as closing streams, freeing locks, or freeing\nnative system resources. Consider other freeing mechanisms instead, such as an explicit <code>close</code>, <code>unlock</code>, or <code>free</code>\nmethod in your class.</p>",
    "howToFix": "<p>Remove assignments from your finalizer that assign <code>null</code> to fields of the instance the finalizer is called on. When this leaves you\nwith an empty finalizer body, remove the finalizer.</p>\n\n<h4>Noncompliant code example</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\npublic class Foo {\n  private String name;\n\n  @Override\n  void finalize() {\n    name = null;  // Noncompliant, instance will be removed anyway\n  }\n}\n</pre>\n<h4>Compliant solution</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\npublic class Foo { // Compliant\n  private String name;\n}\n</pre>",
    "moreInfo": "<h3>Documentation</h3>\n<ul>\n  <li> <a href=\"https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html#finalize--\">Java SE 8 API Specification - Object.finalize</a> </li>\n</ul>\n<h3>Articles &amp; blog posts</h3>\n<ul>\n  <li> <a href=\"https://howtodoinjava.com/java/basics/why-not-to-use-finalize-method-in-java\">Java finalize() – Why We Should Not Use It? - Lokesh\n  Gupta</a> </li>\n  <li> <a href=\"https://www.baeldung.com/java-finalize\">A Guide to the finalize Method in Java - Baeldung</a> </li>\n</ul>",
    "status": "DEPRECATED",
    "name_ko": "\"finalize\"에서 필드를 \"null\"로 설정하면 안 됩니다",
    "why_ko": "<p>Java 객체 수명 주기에서 인스턴스의 <code>finalize</code> 메서드는 가비지 컬렉터가 해당 인스턴스를 객체 힙에서 제거할 수 있다고 판단한 후에 호출됩니다. 따라서 인스턴스 필드를 명시적으로 <code>null</code>로 설정하여 가비지 컬렉터에게 인스턴스가 더 이상 해당 필드가 필요하지 않다고 알리기 위해 finalize를 구현하는 것은 불필요합니다.</p>\n<p>최악의 경우, <code>finalize</code>를 구현하는 것은 오히려 역효과를 낼 수 있습니다. 힙에 있는 다른 (살아있는) 객체에서 수집 가능한 인스턴스로 새로운 참조를 우연히 생성하여 해당 인스턴스를 부활시킬 수 있기 때문입니다.</p>\n<p><strong>finalizer에 대한 중요 참고 사항:</strong></p>\n<p>Java 런타임이 <code>finalize</code> 메서드를 언제 호출할지, 또는 호출할지 여부에 대한 보장이 없습니다.</p>\n<p>따라서 finalizer를 사용하는 것은 나쁜 관행입니다. 스트림 닫기, 락 해제 또는 네이티브 시스템 리소스 해제와 같은 리소스 해제에 사용해서는 안 됩니다. 대신 클래스에서 명시적인 <code>close</code>, <code>unlock</code> 또는 <code>free</code> 메서드와 같은 다른 해제 메커니즘을 고려하세요.</p>",
    "howToFix_ko": "<p>finalizer가 호출되는 인스턴스의 필드에 <code>null</code>을 할당하는 할당문을 finalizer에서 제거하세요. 이로 인해 finalizer 본문이 비게 되면 finalizer를 제거하세요.</p>\n\n<h4>규칙을 준수하지 않는 코드 예시</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\npublic class Foo {\n  private String name;\n\n  @Override\n  void finalize() {\n    name = null;  // 규칙 위반, 인스턴스는 어차피 제거됨\n  }\n}\n</pre>\n<h4>규칙을 준수하는 해결책</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\npublic class Foo { // 규칙 준수\n  private String name;\n}\n</pre>",
    "moreInfo_ko": "<h3>문서</h3>\n<ul>\n  <li> <a href=\"https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html#finalize--\">Java SE 8 API Specification - Object.finalize</a> </li>\n</ul>\n<h3>관련 문서 및 블로그 게시물</h3>\n<ul>\n  <li> <a href=\"https://howtodoinjava.com/java/basics/why-not-to-use-finalize-method-in-java\">Java finalize() – Why We Should Not Use It? - Lokesh Gupta</a> </li>\n  <li> <a href=\"https://www.baeldung.com/java-finalize\">A Guide to the finalize Method in Java - Baeldung</a> </li>\n</ul>"
  },
  {
    "id": "S5970",
    "key": "java:S5970",
    "name": "Spring's ModelAndViewAssert assertions should be used instead of other assertions",
    "type": "code-smell",
    "severity": "major",
    "tags": [
      "spring",
      "tests"
    ],
    "why": "<p>The Spring framework comes with dedicated classes to help writing better and simpler unit tests. In particular, when testing applications built on\ntop of Spring MVC, it is recommended to use Spring's <code>ModelAndViewAssert</code> assertions class, instead of manually testing MVC's\nproperties.</p>\n<p>&nbsp;</p>\n<p>This rule raises an issue when&nbsp;Spring's <code>ModelAndViewAssert</code> assertions should be used instead of manual testing.</p>\n<h3>Noncompliant code example</h3>\n<pre>\nModelAndView mav = getMyModelAndView();\n\nAssert.assertEquals(\"register\", mav.getViewName());\nAssert.assertTrue((Boolean) mav.getModelMap().get(\"myAttribute\"));\nAssert.assertFalse((Boolean) mav.getModelMap().get(\"myAttribute\"));\nAssert.assertEquals(myObject, mav.getModelMap().get(\"myAttribute\"));\n</pre>\n<h3>Compliant solution</h3>\n<pre>\nModelAndView mav = getMyModelAndView();\n\nModelAndViewAssert.assertViewName(mav, \"register\");\nModelAndViewAssert.assertModelAttributeValue(mav, \"myAttribute\", Boolean.TRUE);\nModelAndViewAssert.assertModelAttributeValue(mav, \"myAttribute\", Boolean.FALSE);\nModelAndViewAssert.assertModelAttributeValue(mav, \"myAttribute\", myObject);\n</pre>",
    "howToFix": "",
    "moreInfo": "<ul>\n  <li> <a href=\"https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/testing.html#unit-testing-spring-mvc\">Unit Testing\n  Spring MVC</a> </li>\n  <li> <a\n  href=\"https://docs.spring.io/spring-framework/docs/5.2.8.RELEASE/javadoc-api/org/springframework/test/web/ModelAndViewAssert.html\">ModelAndViewAssert Javadoc</a> </li>\n</ul>",
    "status": "READY",
    "name_ko": "다른 검증 대신 Spring의 ModelAndViewAssert 검증을 사용해야 합니다",
    "why_ko": "<p>Spring 프레임워크는 더 나은 더 간단한 단위 테스트 작성을 돕기 위한 전용 클래스를 제공합니다. 특히 Spring MVC 위에 구축된 애플리케이션을 테스트할 때 MVC의 속성을 수동으로 테스트하는 대신 Spring의 <code>ModelAndViewAssert</code> 검증 클래스를 사용하는 것이 좋습니다.</p>\n<p>&nbsp;</p>\n<p>이 규칙은 수동 테스트 대신 Spring의 <code>ModelAndViewAssert</code> 검증을 사용해야 할 때 문제를 제기합니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\nModelAndView mav = getMyModelAndView();\n\nAssert.assertEquals(\"register\", mav.getViewName());\nAssert.assertTrue((Boolean) mav.getModelMap().get(\"myAttribute\"));\nAssert.assertFalse((Boolean) mav.getModelMap().get(\"myAttribute\"));\nAssert.assertEquals(myObject, mav.getModelMap().get(\"myAttribute\"));\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre>\nModelAndView mav = getMyModelAndView();\n\nModelAndViewAssert.assertViewName(mav, \"register\");\nModelAndViewAssert.assertModelAttributeValue(mav, \"myAttribute\", Boolean.TRUE);\nModelAndViewAssert.assertModelAttributeValue(mav, \"myAttribute\", Boolean.FALSE);\nModelAndViewAssert.assertModelAttributeValue(mav, \"myAttribute\", myObject);\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": "<ul>\n  <li> <a href=\"https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/testing.html#unit-testing-spring-mvc\">Spring MVC 단위 테스트</a> </li>\n  <li> <a href=\"https://docs.spring.io/spring-framework/docs/5.2.8.RELEASE/javadoc-api/org/springframework/test/web/ModelAndViewAssert.html\">ModelAndViewAssert Javadoc</a> </li>\n</ul>"
  },
  {
    "id": "S2309",
    "key": "java:S2309",
    "name": "Files should not be empty",
    "type": "code-smell",
    "severity": "minor",
    "tags": [
      "unused"
    ],
    "why": "<p>Files with no lines of code clutter a project and should be removed.</p>\n<h3>Noncompliant code example</h3>\n<pre>\n//package org.foo;\n//\n//public class Bar {}\n</pre>",
    "howToFix": "",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "파일이 비어있으면 안 됩니다",
    "why_ko": "<p>코드 줄이 없는 파일은 프로젝트를 어지럽히므로 제거해야 합니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\n//package org.foo;\n//\n//public class Bar {}\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": ""
  },
  {
    "id": "S1175",
    "key": "java:S1175",
    "name": "The signature of \"finalize()\" should match that of \"Object.finalize()\"",
    "type": "bug",
    "severity": "critical",
    "tags": [
      "pitfall"
    ],
    "why": "<p><code>Object.finalize()</code> is called by the Garbage Collector at some point after the object becomes unreferenced.</p>\n<p>In general, overloading <code>Object.finalize()</code> is a bad idea because:</p>\n<ul>\n  <li> The overload may not be called by the Garbage Collector. </li>\n  <li> Users are not expected to call <code>Object.finalize()</code> and will get confused. </li>\n</ul>\n<p>But beyond that it's a terrible idea to name a method \"finalize\" if it doesn't actually override <code>Object.finalize()</code>.</p>\n<h3>Noncompliant code example</h3>\n<pre>\npublic int finalize(int someParameter) {        // Noncompliant\n  /* ... */\n}\n</pre>\n<h3>Compliant solution</h3>\n<pre>\npublic int someBetterName(int someParameter) {  // Compliant\n  /* ... */\n}\n</pre>",
    "howToFix": "",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "\"finalize()\"의 시그니처는 \"Object.finalize()\"와 일치해야 합니다",
    "why_ko": "<p><code>Object.finalize()</code>는 객체가 참조되지 않게 된 후 어느 시점에 가비지 컬렉터에 의해 호출됩니다.</p>\n<p>일반적으로 <code>Object.finalize()</code>를 오버로딩하는 것은 좋지 않은 아이디어입니다:</p>\n<ul>\n  <li> 오버로드된 메서드는 가비지 컬렉터에 의해 호출되지 않을 수 있습니다. </li>\n  <li> 사용자는 <code>Object.finalize()</code>를 호출할 것으로 예상하지 않으며 혼란스러워할 것입니다. </li>\n</ul>\n<p>그 외에도 실제로 <code>Object.finalize()</code>를 오버라이드하지 않으면서 메서드 이름을 \"finalize\"로 지정하는 것은 매우 나쁜 아이디어입니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\npublic int finalize(int someParameter) {        // 규칙 위반\n  /* ... */\n}\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre>\npublic int someBetterName(int someParameter) {  // 규칙 준수\n  /* ... */\n}\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": ""
  },
  {
    "id": "S3518",
    "key": "java:S3518",
    "name": "Zero should not be a possible denominator",
    "type": "bug",
    "severity": "critical",
    "tags": [
      "cwe",
      "symbolic-execution",
      "denial-of-service",
      "cert"
    ],
    "why": "<p>A division (<code>/</code>) or remainder operation (<code>%</code>) by zero indicates a bug or logical error. This is because in Java, a division\nor remainder operation where the denominator is zero and not a floating point value always results in an <code>ArithmeticException</code> being\nthrown.</p>\n<p>When working with <code>double</code> or <code>float</code> values, no exception will be thrown, but the operation will result in special floating\npoint values representing either positive infinity, negative infinity, or <code>NaN</code>. Unless these special values are explicitly handled by a\nprogram, zero denominators should be avoided in floating point operations, too. Otherwise, the application might produce unexpected results.</p>\n<h3>What is the potential impact?</h3>\n<p>Issues of this type interrupt the normal execution of a program, causing it to crash or putting it into an inconsistent state. Therefore, this\nissue might impact the availability and reliability of your application, or even result in data loss.</p>\n<p>If the computation of the denominator is tied to user input data, this issue can potentially even be exploited by attackers to disrupt your\napplication.</p>\n<h3>Noncompliant code example</h3>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\nvoid test_divide() {\n  int z = 0;\n  if (unknown()) {\n    // ..\n    z = 3;\n  } else {\n    // ..\n  }\n  z = 1 / z; // Noncompliant, possible division by zero\n}\n</pre>\n<h3>Compliant solution</h3>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\nvoid test_divide() {\n  int z = 0;\n  if (unknown()) {\n    // ..\n    z = 3;\n  } else {\n    // ..\n    z = 1;\n  }\n  z = 1 / z;\n}\n</pre>",
    "howToFix": "",
    "moreInfo": "<h3>Documentation</h3>\n<ul>\n  <li> <a href=\"https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/ArithmeticException.html\">ArithmeticException</a> </li>\n  <li> <a href=\"https://docs.oracle.com/javase/specs/jls/se17/html/jls-15.html#jls-15.17.2\">The Division Operator in the JLS</a> </li>\n  <li> <a href=\"https://docs.oracle.com/javase/specs/jls/se17/html/jls-15.html#jls-15.17.3\">The Remainder Operator in the JLS</a> </li>\n</ul>\n<h3>Standards</h3>\n<ul>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/369\">CWE-369 - Divide by zero</a> </li>\n  <li> <a href=\"https://wiki.sei.cmu.edu/confluence/x/CTZGBQ\">CERT, NUM02-J.</a> - Ensure that division and remainder operations do not result in\n  divide-by-zero errors </li>\n  <li> STIG Viewer - <a href=\"https://stigviewer.com/stig/application_security_and_development/2023-06-08/finding/V-222612\">Application Security and\n  Development: V-222612</a> - The application must not be vulnerable to overflow attacks. </li>\n</ul>",
    "status": "READY",
    "name_ko": "0이 분모가 될 수 있으면 안 됩니다",
    "why_ko": "<p>0으로 나누기(<code>/</code>) 또는 나머지 연산(<code>%</code>)은 버그 또는 논리적 오류를 나타냅니다. Java에서 분모가 0이고 부동 소수점 값이 아닌 나누기 또는 나머지 연산은 항상 <code>ArithmeticException</code>을 발생시키기 때문입니다.</p>\n<p><code>double</code> 또는 <code>float</code> 값으로 작업할 때는 예외가 발생하지 않지만, 연산 결과는 양의 무한대, 음의 무한대 또는 <code>NaN</code>을 나타내는 특수 부동 소수점 값이 됩니다. 프로그램에서 이러한 특수 값을 명시적으로 처리하지 않는 한, 부동 소수점 연산에서도 0 분모를 피해야 합니다. 그렇지 않으면 애플리케이션이 예상치 못한 결과를 생성할 수 있습니다.</p>\n<h3>잠재적 영향은 무엇인가요?</h3>\n<p>이 유형의 문제는 프로그램의 정상적인 실행을 중단시켜 충돌을 일으키거나 일관되지 않은 상태로 만듭니다. 따라서 이 문제는 애플리케이션의 가용성과 신뢰성에 영향을 미치거나 데이터 손실을 초래할 수 있습니다.</p>\n<p>분모 계산이 사용자 입력 데이터와 연결된 경우, 이 문제는 공격자가 애플리케이션을 방해하는 데 악용될 수도 있습니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\nvoid test_divide() {\n  int z = 0;\n  if (unknown()) {\n    // ..\n    z = 3;\n  } else {\n    // ..\n  }\n  z = 1 / z; // 규칙 위반, 0으로 나누기 가능\n}\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\nvoid test_divide() {\n  int z = 0;\n  if (unknown()) {\n    // ..\n    z = 3;\n  } else {\n    // ..\n    z = 1;\n  }\n  z = 1 / z;\n}\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": "<h3>문서</h3>\n<ul>\n  <li> <a href=\"https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/ArithmeticException.html\">ArithmeticException</a> </li>\n  <li> <a href=\"https://docs.oracle.com/javase/specs/jls/se17/html/jls-15.html#jls-15.17.2\">JLS의 나누기 연산자</a> </li>\n  <li> <a href=\"https://docs.oracle.com/javase/specs/jls/se17/html/jls-15.html#jls-15.17.3\">JLS의 나머지 연산자</a> </li>\n</ul>\n<h3>표준</h3>\n<ul>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/369\">CWE-369 - 0으로 나누기</a> </li>\n  <li> <a href=\"https://wiki.sei.cmu.edu/confluence/x/CTZGBQ\">CERT, NUM02-J.</a> - 나누기 및 나머지 연산이 0으로 나누기 오류를 발생시키지 않도록 보장하세요 </li>\n  <li> STIG Viewer - <a href=\"https://stigviewer.com/stig/application_security_and_development/2023-06-08/finding/V-222612\">Application Security and Development: V-222612</a> - 애플리케이션은 오버플로 공격에 취약하지 않아야 합니다. </li>\n</ul>"
  },
  {
    "id": "S5659",
    "key": "java:S5659",
    "name": "JWT should be signed and verified with strong cipher algorithms",
    "type": "vulnerability",
    "severity": "critical",
    "tags": [
      "cwe",
      "privacy"
    ],
    "why": "<p>JSON Web Tokens (JWTs), a popular method of securely transmitting information between parties as a JSON object, can become a significant security\nrisk when they are not properly signed with a robust cipher algorithm, left unsigned altogether, or if the signature is not verified. This\nvulnerability class allows malicious actors to craft fraudulent tokens, effectively impersonating user identities. In essence, the integrity of a JWT\nhinges on the strength and presence of its signature.</p>\n<h3>What is the potential impact?</h3>\n<p>When a JSON Web Token is not appropriately signed with a strong cipher algorithm or if the signature is not verified, it becomes a significant\nthreat to data security and the privacy of user identities.</p>\n<h4>Impersonation of users</h4>\n<p>JWTs are commonly used to represent user authorization claims. They contain information about the user's identity, user roles, and access rights.\nWhen these tokens are not securely signed, it allows an attacker to forge them. In essence, a weak or missing signature gives an attacker the power to\ncraft a token that could impersonate any user. For instance, they could create a token for an administrator account, gaining access to high-level\npermissions and sensitive data.</p>\n<h4>Unauthorized data access</h4>\n<p>When a JWT is not securely signed, it can be tampered with by an attacker, and the integrity of the data it carries cannot be trusted. An attacker\ncan manipulate the content of the token and grant themselves permissions they should not have, leading to unauthorized data access.</p>",
    "howToFix": "<p>The following code contains examples of JWT encoding and decoding without a strong cipher algorithm.</p>\n<h4>Noncompliant code example</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\nimport com.auth0.jwt.JWT;\n\npublic void encode() {\n    JWT.create()\n        .withSubject(SUBJECT)\n        .sign(Algorithm.none()); // Noncompliant\n}\n</pre>\n<pre data-diff-id=\"2\" data-diff-type=\"noncompliant\">\nimport com.auth0.jwt.JWT;\n\npublic void decode() {\n    JWTVerifier verifier = JWT.require(Algorithm.none()) // Noncompliant\n        .withSubject(LOGIN)\n        .build();\n}\n</pre>\n<h4>Compliant solution</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\nimport com.auth0.jwt.JWT;\n\npublic void encode() {\n    JWT.create()\n        .withSubject(SUBJECT)\n        .sign(Algorithm.HMAC256(SECRET_KEY));\n}\n</pre>\n<pre data-diff-id=\"2\" data-diff-type=\"compliant\">\nimport com.auth0.jwt.JWT;\n\npublic void decode() {\n    JWTVerifier verifier = JWT.require(Algorithm.HMAC256(SECRET_KEY))\n        .withSubject(LOGIN)\n        .build();\n}\n</pre>\n<h3>How does this work?</h3>\n<h4>Always sign your tokens</h4>\n<p>The foremost measure to enhance JWT security is to ensure that every JWT you issue is signed. Unsigned tokens are like open books that anyone can\ntamper with. Signing your JWTs ensures that any alterations to the tokens after they have been issued can be detected. Most JWT libraries support a\nsigning function, and using it is usually as simple as providing a secret key when the token is created.</p>\n<h4>Choose a strong cipher algorithm</h4>\n<p>It is not enough to merely sign your tokens. You need to sign them with a strong cipher algorithm. Algorithms like HS256 (HMAC using SHA-256) are\nconsidered secure for most purposes. But for an additional layer of security, you could use an algorithm like RS256 (RSA Signature with SHA-256),\nwhich uses a private key for signing and a public key for verification. This way, even if someone gains access to the public key, they will not be\nable to forge tokens.</p>\n<h4>Verify the signature of your tokens</h4>\n<p>Resolving a vulnerability concerning the validation of JWT token signatures is mainly about incorporating a critical step into your process:\nvalidating the signature every time a token is decoded. Just having a signed token using a secure algorithm is not enough. If you are not validating\nsignatures, they are not serving their purpose.</p>\n<p>Every time your application receives a JWT, it needs to decode the token to extract the information contained within. It is during this decoding\nprocess that the signature of the JWT should also be checked.</p>\n<p>To resolve the issue, follow these instructions:</p>\n<ol>\n  <li> Use framework-specific functions for signature verification: Most programming frameworks that support JWTs provide specific functions to not\n  only decode a token but also validate its signature simultaneously. Make sure to use these functions when handling incoming tokens. </li>\n  <li> Handle invalid signatures appropriately: If a JWT's signature does not validate correctly, it means the token is not trustworthy, indicating\n  potential tampering. The action to take when encountering an invalid token should be denying the request carrying it and logging the event for\n  further investigation. </li>\n  <li> Incorporate signature validation in your tests: When you are writing tests for your application, include tests that check the signature\n  validation functionality. This can help you catch any instances where signature verification might be unintentionally skipped or bypassed. </li>\n</ol>\n<p>By following these practices, you can ensure the security of your application's JWT handling process, making it resistant to attacks that rely on\ntampering with tokens. Validation of the signature needs to be an integral and non-negotiable part of your token handling process.</p>\n<h3>Going the extra mile</h3>\n<h4>Securely store your secret keys</h4>\n<p>Ensure that your secret keys are stored securely. They should not be hard-coded into your application code or checked into your version control\nsystem. Instead, consider using environment variables, secure key management systems, or vault services.</p>\n<h4>Rotate your secret keys</h4>\n<p>Even with the strongest cipher algorithms, there is a risk that your secret keys may be compromised. Therefore, it is a good practice to\nperiodically rotate your secret keys. By doing so, you limit the amount of time that an attacker can misuse a stolen key. When you rotate keys, be\nsure to allow a grace period where tokens signed with the old key are still accepted to prevent service disruptions.</p>",
    "moreInfo": "<h3>Standards</h3>\n<ul>\n  <li> OWASP - <a href=\"https://owasp.org/Top10/A02_2021-Cryptographic_Failures/\">Top 10 2021 Category A2 - Cryptographic Failures</a> </li>\n  <li> OWASP - <a href=\"https://owasp.org/www-project-top-ten/2017/A3_2017-Sensitive_Data_Exposure\">Top 10 2017 Category A3 - Sensitive Data\n  Exposure</a> </li>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/347\">CWE-347 - Improper Verification of Cryptographic Signature</a> </li>\n</ul>",
    "status": "READY",
    "name_ko": "JWT는 강력한 암호 알고리즘으로 서명하고 검증해야 합니다",
    "why_ko": "<p>JSON Web Token(JWT)은 당사자 간에 JSON 객체로 정보를 안전하게 전송하는 인기 있는 방법으로, 강력한 암호 알고리즘으로 적절히 서명되지 않거나 전혀 서명되지 않거나 서명이 검증되지 않으면 심각한 보안 위험이 될 수 있습니다. 이 취약점 클래스는 악의적인 행위자가 사기성 토큰을 만들어 효과적으로 사용자 신원을 사칭할 수 있게 합니다. 본질적으로 JWT의 무결성은 서명의 강도와 존재 여부에 달려 있습니다.</p>\n<h3>잠재적 영향은 무엇입니까?</h3>\n<p>JSON Web Token이 강력한 암호 알고리즘으로 적절히 서명되지 않거나 서명이 검증되지 않으면 데이터 보안과 사용자 신원의 개인정보에 심각한 위협이 됩니다.</p>\n<h4>사용자 사칭</h4>\n<p>JWT는 일반적으로 사용자 권한 부여 클레임을 나타내는 데 사용됩니다. 사용자의 신원, 사용자 역할 및 접근 권한에 대한 정보를 포함합니다. 이러한 토큰이 안전하게 서명되지 않으면 공격자가 위조할 수 있습니다. 본질적으로 약하거나 누락된 서명은 공격자에게 모든 사용자를 사칭할 수 있는 토큰을 만들 수 있는 권한을 부여합니다. 예를 들어, 관리자 계정에 대한 토큰을 생성하여 높은 수준의 권한과 민감한 데이터에 접근할 수 있습니다.</p>\n<h4>무단 데이터 접근</h4>\n<p>JWT가 안전하게 서명되지 않으면 공격자가 변조할 수 있으며 전달하는 데이터의 무결성을 신뢰할 수 없습니다. 공격자는 토큰의 내용을 조작하고 가져서는 안 되는 권한을 자신에게 부여하여 무단 데이터 접근으로 이어질 수 있습니다.</p>",
    "howToFix_ko": "<p>다음 코드는 강력한 암호 알고리즘 없이 JWT를 인코딩하고 디코딩하는 예시를 포함합니다.</p>\n<h4>규칙을 준수하지 않는 코드 예시</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\nimport com.auth0.jwt.JWT;\n\npublic void encode() {\n    JWT.create()\n        .withSubject(SUBJECT)\n        .sign(Algorithm.none()); // 규칙 위반\n}\n</pre>\n<pre data-diff-id=\"2\" data-diff-type=\"noncompliant\">\nimport com.auth0.jwt.JWT;\n\npublic void decode() {\n    JWTVerifier verifier = JWT.require(Algorithm.none()) // 규칙 위반\n        .withSubject(LOGIN)\n        .build();\n}\n</pre>\n<h4>규칙을 준수하는 해결책</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\nimport com.auth0.jwt.JWT;\n\npublic void encode() {\n    JWT.create()\n        .withSubject(SUBJECT)\n        .sign(Algorithm.HMAC256(SECRET_KEY));\n}\n</pre>\n<pre data-diff-id=\"2\" data-diff-type=\"compliant\">\nimport com.auth0.jwt.JWT;\n\npublic void decode() {\n    JWTVerifier verifier = JWT.require(Algorithm.HMAC256(SECRET_KEY))\n        .withSubject(LOGIN)\n        .build();\n}\n</pre>\n<h3>어떻게 작동합니까?</h3>\n<h4>항상 토큰에 서명하세요</h4>\n<p>JWT 보안을 강화하는 가장 중요한 조치는 발급하는 모든 JWT에 서명하는 것입니다. 서명되지 않은 토큰은 누구나 변조할 수 있는 열린 책과 같습니다. JWT에 서명하면 발급된 후 토큰에 대한 모든 변경 사항을 감지할 수 있습니다. 대부분의 JWT 라이브러리는 서명 함수를 지원하며, 토큰 생성 시 비밀 키를 제공하는 것만큼 간단하게 사용할 수 있습니다.</p>\n<h4>강력한 암호 알고리즘 선택</h4>\n<p>토큰에 단순히 서명하는 것만으로는 충분하지 않습니다. 강력한 암호 알고리즘으로 서명해야 합니다. HS256(SHA-256을 사용하는 HMAC)과 같은 알고리즘은 대부분의 목적에 안전한 것으로 간주됩니다. 하지만 추가적인 보안 계층을 위해 서명에 개인 키를 사용하고 검증에 공개 키를 사용하는 RS256(SHA-256을 사용하는 RSA 서명)과 같은 알고리즘을 사용할 수 있습니다. 이렇게 하면 누군가가 공개 키에 접근하더라도 토큰을 위조할 수 없습니다.</p>\n<h4>토큰의 서명 검증</h4>\n<p>JWT 토큰 서명 검증과 관련된 취약점을 해결하는 것은 주로 프로세스에 중요한 단계를 통합하는 것입니다: 토큰이 디코딩될 때마다 서명을 검증합니다. 안전한 알고리즘을 사용하여 서명된 토큰만 있는 것으로는 충분하지 않습니다. 서명을 검증하지 않으면 목적을 달성하지 못합니다.</p>\n<p>애플리케이션이 JWT를 수신할 때마다 포함된 정보를 추출하기 위해 토큰을 디코딩해야 합니다. 이 디코딩 과정에서 JWT의 서명도 확인해야 합니다.</p>\n<p>문제를 해결하려면 다음 지침을 따르세요:</p>\n<ol>\n  <li> 서명 검증을 위해 프레임워크별 함수 사용: JWT를 지원하는 대부분의 프로그래밍 프레임워크는 토큰을 디코딩할 뿐만 아니라 동시에 서명을 검증하는 특정 함수를 제공합니다. 들어오는 토큰을 처리할 때 이러한 함수를 사용하세요. </li>\n  <li> 유효하지 않은 서명을 적절히 처리: JWT의 서명이 올바르게 검증되지 않으면 토큰을 신뢰할 수 없으며 잠재적인 변조를 나타냅니다. 유효하지 않은 토큰을 만났을 때 취할 조치는 해당 토큰을 포함한 요청을 거부하고 추가 조사를 위해 이벤트를 로깅하는 것입니다. </li>\n  <li> 테스트에 서명 검증 포함: 애플리케이션에 대한 테스트를 작성할 때 서명 검증 기능을 확인하는 테스트를 포함하세요. 이를 통해 서명 검증이 의도치 않게 건너뛰거나 우회될 수 있는 경우를 포착할 수 있습니다. </li>\n</ol>\n<p>이러한 관행을 따르면 애플리케이션의 JWT 처리 프로세스의 보안을 보장하여 토큰 변조에 의존하는 공격에 저항력을 갖출 수 있습니다. 서명 검증은 토큰 처리 프로세스의 필수적이고 협상 불가능한 부분이어야 합니다.</p>\n<h3>추가 조치</h3>\n<h4>비밀 키를 안전하게 저장</h4>\n<p>비밀 키가 안전하게 저장되어 있는지 확인하세요. 애플리케이션 코드에 하드코딩되거나 버전 관리 시스템에 체크인되어서는 안 됩니다. 대신 환경 변수, 안전한 키 관리 시스템 또는 볼트 서비스 사용을 고려하세요.</p>\n<h4>비밀 키 순환</h4>\n<p>가장 강력한 암호 알고리즘을 사용하더라도 비밀 키가 손상될 위험이 있습니다. 따라서 비밀 키를 주기적으로 순환하는 것이 좋은 관행입니다. 이렇게 하면 공격자가 도난당한 키를 오용할 수 있는 시간을 제한합니다. 키를 순환할 때 서비스 중단을 방지하기 위해 이전 키로 서명된 토큰이 여전히 허용되는 유예 기간을 허용해야 합니다.</p>",
    "moreInfo_ko": "<h3>표준</h3>\n<ul>\n  <li> OWASP - <a href=\"https://owasp.org/Top10/A02_2021-Cryptographic_Failures/\">Top 10 2021 Category A2 - Cryptographic Failures</a> </li>\n  <li> OWASP - <a href=\"https://owasp.org/www-project-top-ten/2017/A3_2017-Sensitive_Data_Exposure\">Top 10 2017 Category A3 - Sensitive Data Exposure</a> </li>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/347\">CWE-347 - 암호화 서명의 부적절한 검증</a> </li>\n</ul>"
  },
  {
    "id": "S6833",
    "key": "java:S6833",
    "name": "\"@Controller\" should be replaced with \"@RestController\"",
    "type": "code-smell",
    "severity": "major",
    "tags": [
      "spring"
    ],
    "why": "<p>Classes annotated as <code>@Controller</code> in Spring are responsible for handling incoming web requests. When annotating methods or the entire\ncontroller with <code>@ResponseBody</code>, the return value of said methods will be serialized and set as the response body. In other words, it tells\nthe Spring framework that this method does not produce a view. This mechanism is commonly used to create API endpoints.</p>\n<p>Spring provides <code>@RestController</code> as a convenient annotation to replace the combination of <code>@Controller</code> and\n<code>@ResponseBody</code>. The two are functionally identical, so the single annotation approach is preferred.</p>\n<p>This rule will raise an issue on a class that is annotated with <code>@Controller</code> if:</p>\n<ul>\n  <li> the class is also annotated with <code>@ResponseBody</code> or </li>\n  <li> all methods in said class are annotated with <code>@ResponseBody</code>. </li>\n</ul>",
    "howToFix": "<p>Replace the <code>@Controller</code> annotation with the <code>@RestController</code> annotation and remove all <code>@ResponseBody</code>\nannotations from the class and its methods.</p>\n\n<h4>Noncompliant code example</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\n@Controller\n@ResponseBody\npublic class MyController {\n    @GetMapping(\"/hello\")\n    public String hello() {\n        return \"Hello World!\";\n    }\n}\n</pre>\n<h4>Compliant solution</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\n@RestController\npublic class MyController {\n    @GetMapping(\"/hello\")\n    public String hello() {\n        return \"Hello World!\";\n    }\n}\n</pre>\n<h4>Noncompliant code example</h4>\n<pre data-diff-id=\"2\" data-diff-type=\"noncompliant\">\n@Controller\npublic class MyController {\n    @ResponseBody\n    @GetMapping(\"/hello\")\n    public String hello() {\n        return \"Hello World!\";\n    }\n\n    @ResponseBody\n    @GetMapping(\"/foo\")\n    public String foo() {\n        return \"Foo\";\n    }\n}\n</pre>\n<h4>Compliant solution</h4>\n<pre data-diff-id=\"2\" data-diff-type=\"compliant\">\n@RestController\npublic class MyController {\n    @GetMapping(\"/hello\")\n    public String hello() {\n        return \"Hello World!\";\n    }\n\n    @GetMapping(\"/foo\")\n    public String foo() {\n        return \"Foo\";\n    }\n}\n</pre>",
    "moreInfo": "<h3>Articles &amp; blog posts</h3>\n<ul>\n  <li> Spring Guides - <a href=\"https://spring.io/guides/gs/rest-service/\">Building a RESTful Web Service</a> </li>\n  <li> Baeldung - <a href=\"https://www.baeldung.com/spring-controller-vs-restcontroller\">The Spring @Controller and @RestController Annotations</a>\n  </li>\n  <li> Baeldung - <a href=\"https://www.baeldung.com/spring-request-response-body\">Spring's RequestBody and ResponseBody Annotations</a> </li>\n</ul>",
    "status": "READY",
    "name_ko": "\"@Controller\"는 \"@RestController\"로 교체해야 합니다",
    "why_ko": "<p>Spring에서 <code>@Controller</code>로 어노테이션된 클래스는 들어오는 웹 요청을 처리하는 역할을 합니다. 메서드나 전체 컨트롤러에 <code>@ResponseBody</code>를 어노테이션하면 해당 메서드의 반환 값이 직렬화되어 응답 본문으로 설정됩니다. 즉, 이 메서드가 뷰를 생성하지 않음을 Spring 프레임워크에 알립니다. 이 메커니즘은 일반적으로 API 엔드포인트를 만드는 데 사용됩니다.</p>\n<p>Spring은 <code>@Controller</code>와 <code>@ResponseBody</code>의 조합을 대체하기 위한 편의 어노테이션으로 <code>@RestController</code>를 제공합니다. 두 가지는 기능적으로 동일하므로 단일 어노테이션 접근 방식이 선호됩니다.</p>\n<p>이 규칙은 다음의 경우 <code>@Controller</code>로 어노테이션된 클래스에서 문제를 발생시킵니다:</p>\n<ul>\n  <li> 클래스에 <code>@ResponseBody</code>도 어노테이션되어 있거나 </li>\n  <li> 해당 클래스의 모든 메서드에 <code>@ResponseBody</code>가 어노테이션되어 있는 경우. </li>\n</ul>",
    "howToFix_ko": "<p><code>@Controller</code> 어노테이션을 <code>@RestController</code> 어노테이션으로 교체하고 클래스와 해당 메서드에서 모든 <code>@ResponseBody</code> 어노테이션을 제거하세요.</p>\n\n<h4>규칙을 준수하지 않는 코드 예시</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\n@Controller\n@ResponseBody\npublic class MyController {\n    @GetMapping(\"/hello\")\n    public String hello() {\n        return \"Hello World!\";\n    }\n}\n</pre>\n<h4>규칙을 준수하는 해결책</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\n@RestController\npublic class MyController {\n    @GetMapping(\"/hello\")\n    public String hello() {\n        return \"Hello World!\";\n    }\n}\n</pre>\n<h4>규칙을 준수하지 않는 코드 예시</h4>\n<pre data-diff-id=\"2\" data-diff-type=\"noncompliant\">\n@Controller\npublic class MyController {\n    @ResponseBody\n    @GetMapping(\"/hello\")\n    public String hello() {\n        return \"Hello World!\";\n    }\n\n    @ResponseBody\n    @GetMapping(\"/foo\")\n    public String foo() {\n        return \"Foo\";\n    }\n}\n</pre>\n<h4>규칙을 준수하는 해결책</h4>\n<pre data-diff-id=\"2\" data-diff-type=\"compliant\">\n@RestController\npublic class MyController {\n    @GetMapping(\"/hello\")\n    public String hello() {\n        return \"Hello World!\";\n    }\n\n    @GetMapping(\"/foo\")\n    public String foo() {\n        return \"Foo\";\n    }\n}\n</pre>",
    "moreInfo_ko": "<h3>기사 및 블로그 게시물</h3>\n<ul>\n  <li> Spring Guides - <a href=\"https://spring.io/guides/gs/rest-service/\">RESTful 웹 서비스 구축하기</a> </li>\n  <li> Baeldung - <a href=\"https://www.baeldung.com/spring-controller-vs-restcontroller\">Spring @Controller와 @RestController 어노테이션</a> </li>\n  <li> Baeldung - <a href=\"https://www.baeldung.com/spring-request-response-body\">Spring의 RequestBody와 ResponseBody 어노테이션</a> </li>\n</ul>"
  },
  {
    "id": "S6219",
    "key": "java:S6219",
    "name": "'serialVersionUID' field should not be set to '0L' in records",
    "type": "code-smell",
    "severity": "minor",
    "tags": [
      "java16"
    ],
    "why": "<p>In Records serialization is not done the same way as for ordinary serializable or externalizable classes. Records serialization does not rely on\nthe <code>serialVersionUID</code> field, because the requirement to have this field equal is waived for record classes. By default, all records will\nhave this field equal to <code>0L</code> and there is no need to specify this field with <code>0L</code> value and it is possible to specify it with\nsome custom value to support serialization/deserialization involving ordinary classes.</p>\n<p>This rule raises an issue when there is a <code>private static final long serialVersionUID</code> field which is set to <code>0L</code> in a Record\nclass.</p>\n<h3>Noncompliant code example</h3>\n<pre>\nrecord Person(String name, int age) implements Serializable {\n@Serial\n  private static final long serialVersionUID = 0L; // Noncompliant\n}\n</pre>\n<h3>Compliant solution</h3>\n<pre>\nrecord Person(String name, int age) implements Serializable {} // Compliant\n\nrecord Person(String name, int age) implements Serializable {\n@Serial\n  private static final long serialVersionUID = 42L; // Compliant\n}\n</pre>",
    "howToFix": "",
    "moreInfo": "<ul>\n  <li> <a href=\"https://docs.oracle.com/javase/specs/jls/se16/html/jls-8.html#jls-8.10\">Records specification</a> </li>\n  <li> <a href=\"https://docs.oracle.com/en/java/javase/16/docs/specs/serialization/serial-arch.html#serialization-of-records\">Serialization of\n  records</a> </li>\n</ul>",
    "status": "READY",
    "name_ko": "Record에서 'serialVersionUID' 필드를 '0L'로 설정하면 안 됩니다",
    "why_ko": "<p>Record에서 직렬화는 일반적인 Serializable 또는 Externalizable 클래스와 동일한 방식으로 수행되지 않습니다. Record 직렬화는 <code>serialVersionUID</code> 필드에 의존하지 않습니다. record 클래스의 경우 이 필드가 동일해야 하는 요구 사항이 면제되기 때문입니다. 기본적으로 모든 record는 이 필드가 <code>0L</code>과 같으며 <code>0L</code> 값으로 이 필드를 지정할 필요가 없고, 일반 클래스와 관련된 직렬화/역직렬화를 지원하기 위해 사용자 정의 값으로 지정할 수 있습니다.</p>\n<p>이 규칙은 Record 클래스에서 <code>private static final long serialVersionUID</code> 필드가 <code>0L</code>로 설정될 때 문제를 보고합니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\nrecord Person(String name, int age) implements Serializable {\n@Serial\n  private static final long serialVersionUID = 0L; // 규칙 위반\n}\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre>\nrecord Person(String name, int age) implements Serializable {} // 규칙 준수\n\nrecord Person(String name, int age) implements Serializable {\n@Serial\n  private static final long serialVersionUID = 42L; // 규칙 준수\n}\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": "<ul>\n  <li> <a href=\"https://docs.oracle.com/javase/specs/jls/se16/html/jls-8.html#jls-8.10\">Record 명세</a> </li>\n  <li> <a href=\"https://docs.oracle.com/en/java/javase/16/docs/specs/serialization/serial-arch.html#serialization-of-records\">Record 직렬화</a> </li>\n</ul>"
  },
  {
    "id": "S923",
    "key": "java:S923",
    "name": "Functions should not be defined with a variable number of arguments",
    "type": "code-smell",
    "severity": "info",
    "tags": [
      "cert",
      "pitfall"
    ],
    "why": "<p>As stated per effective java :</p>\n<blockquote>\n  <p>Varargs methods are a convenient way to define methods that require a variable number of arguments, but they should not be overused. They can\n  produce confusing results if used inappropriately.</p>\n</blockquote>\n<h3>Noncompliant code example</h3>\n<pre>\nvoid fun ( String... strings )\t// Noncompliant\n{\n  // ...\n}\n</pre>",
    "howToFix": "",
    "moreInfo": "<ul>\n  <li> <a href=\"https://wiki.sei.cmu.edu/confluence/display/java/DCL57-J.+Avoid+ambiguous+overloading+of+variable+arity+methods\">CERT, DCL57J</a> -\n  Avoid ambiguous overloading of variable arity methods </li>\n</ul>",
    "status": "READY",
    "name_ko": "가변 인자를 사용하는 함수를 정의하면 안 됩니다",
    "why_ko": "<p>Effective Java에 명시된 대로:</p>\n<blockquote>\n  <p>Varargs 메서드는 가변 수의 인수가 필요한 메서드를 정의하는 편리한 방법이지만 과도하게 사용해서는 안 됩니다. 부적절하게 사용하면 혼란스러운 결과를 생성할 수 있습니다.</p>\n</blockquote>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\nvoid fun ( String... strings )\t// 규칙 위반\n{\n  // ...\n}\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": "<ul>\n  <li> <a href=\"https://wiki.sei.cmu.edu/confluence/display/java/DCL57-J.+Avoid+ambiguous+overloading+of+variable+arity+methods\">CERT, DCL57J</a> - 가변 인자 메서드의 모호한 오버로딩을 피하세요 </li>\n</ul>"
  },
  {
    "id": "S1163",
    "key": "java:S1163",
    "name": "Exceptions should not be thrown in finally blocks",
    "type": "code-smell",
    "severity": "critical",
    "tags": [
      "error-handling",
      "cert",
      "suspicious"
    ],
    "why": "<p>If an exception is already being thrown within the <code>try</code> block or caught in a <code>catch</code> block, throwing another exception in\nthe <code>finally</code> block will override the original exception. This means that the original exception's message and stack trace will be lost,\npotentially making it challenging to diagnose and troubleshoot the root cause of the problem.</p>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\ntry {\n  /* some work which end up throwing an exception */\n  throw new IllegalArgumentException();\n} finally {\n  /* clean up */\n  throw new RuntimeException();       // Noncompliant; masks the IllegalArgumentException\n}\n</pre>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\ntry {\n  /* some work which end up throwing an exception */\n  throw new IllegalArgumentException();\n} finally {\n  /* clean up */\n}\n</pre>",
    "howToFix": "",
    "moreInfo": "<ul>\n  <li> <a href=\"https://wiki.sei.cmu.edu/confluence/x/FTZGBQ\">CERT, ERR05-J.</a> - Do not let checked exceptions escape from a finally block </li>\n</ul>",
    "status": "READY",
    "name_ko": "finally 블록에서 exception을 던지면 안 됩니다",
    "why_ko": "<p><code>try</code> 블록 내에서 이미 예외가 발생하거나 <code>catch</code> 블록에서 예외가 잡힌 경우, <code>finally</code> 블록에서 다른 예외를 던지면 원본 예외가 덮어씌워집니다. 이는 원본 예외의 메시지와 스택 트레이스가 손실되어 문제의 근본 원인을 진단하고 해결하기 어려워질 수 있음을 의미합니다.</p>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\ntry {\n  /* 예외를 발생시키는 일부 작업 */\n  throw new IllegalArgumentException();\n} finally {\n  /* 정리 */\n  throw new RuntimeException();       // 규칙 위반; IllegalArgumentException을 가립니다\n}\n</pre>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\ntry {\n  /* 예외를 발생시키는 일부 작업 */\n  throw new IllegalArgumentException();\n} finally {\n  /* 정리 */\n}\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": "<ul>\n  <li> <a href=\"https://wiki.sei.cmu.edu/confluence/x/FTZGBQ\">CERT, ERR05-J.</a> - checked exception이 finally 블록에서 빠져나가지 않도록 하세요 </li>\n</ul>"
  },
  {
    "id": "S1860",
    "key": "java:S1860",
    "name": "Synchronization should not be done on instances of value-based classes",
    "type": "bug",
    "severity": "major",
    "tags": [
      "multi-threading",
      "cert"
    ],
    "why": "<p>In Java, value-based classes are those for which instances are final and immutable, like <code>String</code>, <code>Integer</code> and so on, and\ntheir identity relies on their value and not their reference. When a variable of one of these types is instantiated, the JVM caches its value, and the\nvariable is just a reference to that value. For example, multiple <code>String</code> variables with the same value \"Hello world!\" will refer to the\nsame cached string literal in memory.</p>\n<p>The <code>synchronized</code> keyword tells the JVM to only allow the execution of the code contained in the following block to one\n<code>Thread</code> at a time. This mechanism relies on the identity of the object that is being synchronized between threads, to prevent that if\nobject X is locked, it will still be possible to lock another object Y.</p>\n<p>It means that the JVM will fail to correctly synchronize threads on instances of the aforementioned value-based classes, for instance:</p>\n<pre>\n// These variables \"a\" and \"b\" will effectively reference the same object in memory\nInteger a = 0;\nInteger b = 0;\n\n// This means that in the following code, the JVM could try to lock and execute\n// on the variable \"a\" because \"b\" was notified to be released, as the two Integer variables\n// are the same object to the JVM\nvoid syncMethod(int x) {\n    synchronized (a) {\n        if (a == x) {\n        // ... do something here\n        }\n    }\n    synchronized (b) {\n        if (b == x) {\n        // ... do something else\n        }\n    }\n}\n</pre>\n<p>This behavior can cause unrelated threads to deadlock with unclear stacktraces.</p>\n<p>Within the JDK, types which should not be used for synchronization include:</p>\n<ul>\n  <li> <code>String</code> literals </li>\n  <li> Primitive wrapper classes in <code>java.lang</code> (such as <code>Boolean</code> with <code>Boolean.FALSE</code> and\n  <code>Boolean.TRUE</code>) </li>\n  <li> The class <code>java.lang.Runtime.Version</code> </li>\n  <li> The <code>Optional*</code> classes in <code>java.util</code>: <code>Optional</code>, <code>OptionalInt</code>, <code>OptionalLong</code>, and\n  <code>OptionalDouble</code> </li>\n  <li> Various classes in the <code>java.time</code> API: <code>Instant</code>, <code>LocalDate</code>, <code>LocalTime</code>,\n  <code>LocalDateTime</code>, <code>ZonedDateTime</code>, <code>ZoneId</code>, <code>OffsetTime</code>, <code>OffsetDateTime</code>,\n  <code>ZoneOffset</code>, <code>Duration</code>, <code>Period</code>, <code>Year</code>, <code>YearMonth</code>, and <code>MonthDay</code> </li>\n  <li> Various classes in the <code>java.time.chrono</code> API: <code>MinguoDate</code>, <code>HijrahDate</code>, <code>JapaneseDate</code>, and\n  <code>ThaiBuddhistDate</code> </li>\n  <li> The interface <code>java.lang.ProcessHandle</code> and its implementation classes </li>\n  <li> The implementation classes of the collection factories in <code>java.util</code>: <code>List.of</code>, <code>List.copyOf</code>,\n  <code>Set.of</code>, <code>Set.copyOf</code>, <code>Map.of</code>, <code>Map.copyOf</code>, <code>Map.ofEntries</code>, and <code>Map.entry</code>.\n  </li>\n</ul>",
    "howToFix": "<p>Replace instances of value-based classes with a new object instance to synchronize on.</p>\n\n<h4>Noncompliant code example</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\nprivate static final Boolean bLock = Boolean.FALSE;\nprivate static final Integer iLock = Integer.valueOf(0);\nprivate static final String sLock = \"LOCK\";\nprivate static final List&lt;String&gt; listLock = List.of(\"a\", \"b\", \"c\", \"d\");\n\npublic void doSomething() {\n\n  synchronized(bLock) {  // Noncompliant\n      ...\n  }\n  synchronized(iLock) {  // Noncompliant\n      ...\n  }\n  synchronized(sLock) {  // Noncompliant\n      ...\n  }\n  synchronized(listLock) {  // Noncompliant\n      ...\n  }\n</pre>\n<h4>Compliant solution</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\nprivate static final Object lock1 = new Object();\nprivate static final Integer iLock = new Integer(42);\nprivate static final String sLock = new String(\"A brand new string in memory!\");\nprivate static final List&lt;String&gt; listLock = new ArrayList&lt;&gt;();\n\npublic void doSomething() {\n\n  synchronized(lock1) { // Compliant\n      ...\n  }\n  synchronized(iLock) { // Compliant\n      ...\n  }\n  synchronized(sLock) { // Compliant\n      ...\n  }\n  synchronized(listLock) { // Compliant\n      ...\n  }\n</pre>",
    "moreInfo": "<ul>\n  <li> CERT - <a href=\"https://wiki.sei.cmu.edu/confluence/x/1zdGBQ\">Do not synchronize on objects that may be reused</a> </li>\n  <li> OpenJDK - <a href=\"https://openjdk.java.net/jeps/390\">JEP 390: Warnings for Value-Based Classes</a> </li>\n  <li> Java Documentation - <a href=\"https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/doc-files/ValueBased.html\">Value-based\n  Classes</a> </li>\n</ul>",
    "status": "READY",
    "name_ko": "값 기반 클래스의 인스턴스에 동기화를 적용하면 안 됩니다",
    "why_ko": "<p>Java에서 값 기반 클래스는 <code>String</code>, <code>Integer</code> 등과 같이 인스턴스가 final이고 불변인 클래스이며, 해당 클래스의 정체성은 참조가 아닌 값에 의존합니다. 이러한 타입의 변수가 인스턴스화되면 JVM은 해당 값을 캐시하고, 변수는 해당 값에 대한 참조일 뿐입니다. 예를 들어, 동일한 값 \"Hello world!\"를 가진 여러 <code>String</code> 변수는 메모리에서 동일한 캐시된 문자열 리터럴을 참조합니다.</p>\n<p><code>synchronized</code> 키워드는 JVM에게 다음 블록에 포함된 코드의 실행을 한 번에 하나의 <code>Thread</code>에서만 허용하도록 지시합니다. 이 메커니즘은 스레드 간에 동기화되는 객체의 정체성에 의존하여, 객체 X가 잠기면 다른 객체 Y를 잠그는 것은 여전히 가능합니다.</p>\n<p>이는 JVM이 앞서 언급한 값 기반 클래스의 인스턴스에 대해 스레드를 올바르게 동기화하지 못한다는 것을 의미합니다. 예를 들어:</p>\n<pre>\n// 이 변수 \"a\"와 \"b\"는 실제로 메모리에서 동일한 객체를 참조함\nInteger a = 0;\nInteger b = 0;\n\n// 이는 다음 코드에서 두 Integer 변수가 JVM에게 동일한 객체이므로\n// \"b\"가 해제 알림을 받았기 때문에 JVM이 변수 \"a\"에서 잠금을 시도하고 실행할 수 있음을 의미\nvoid syncMethod(int x) {\n    synchronized (a) {\n        if (a == x) {\n        // ... 여기서 무언가 수행\n        }\n    }\n    synchronized (b) {\n        if (b == x) {\n        // ... 다른 무언가 수행\n        }\n    }\n}\n</pre>\n<p>이 동작은 관련 없는 스레드가 불명확한 스택 트레이스와 함께 교착 상태에 빠지게 할 수 있습니다.</p>\n<p>JDK 내에서 동기화에 사용하면 안 되는 타입은 다음과 같습니다:</p>\n<ul>\n  <li> <code>String</code> 리터럴 </li>\n  <li> <code>java.lang</code>의 기본형 래퍼 클래스(<code>Boolean.FALSE</code> 및 <code>Boolean.TRUE</code>가 있는 <code>Boolean</code> 등) </li>\n  <li> <code>java.lang.Runtime.Version</code> 클래스 </li>\n  <li> <code>java.util</code>의 <code>Optional*</code> 클래스: <code>Optional</code>, <code>OptionalInt</code>, <code>OptionalLong</code>, <code>OptionalDouble</code> </li>\n  <li> <code>java.time</code> API의 다양한 클래스: <code>Instant</code>, <code>LocalDate</code>, <code>LocalTime</code>, <code>LocalDateTime</code>, <code>ZonedDateTime</code>, <code>ZoneId</code>, <code>OffsetTime</code>, <code>OffsetDateTime</code>, <code>ZoneOffset</code>, <code>Duration</code>, <code>Period</code>, <code>Year</code>, <code>YearMonth</code>, <code>MonthDay</code> </li>\n  <li> <code>java.time.chrono</code> API의 다양한 클래스: <code>MinguoDate</code>, <code>HijrahDate</code>, <code>JapaneseDate</code>, <code>ThaiBuddhistDate</code> </li>\n  <li> <code>java.lang.ProcessHandle</code> 인터페이스 및 그 구현 클래스 </li>\n  <li> <code>java.util</code>의 컬렉션 팩토리 구현 클래스: <code>List.of</code>, <code>List.copyOf</code>, <code>Set.of</code>, <code>Set.copyOf</code>, <code>Map.of</code>, <code>Map.copyOf</code>, <code>Map.ofEntries</code>, <code>Map.entry</code> </li>\n</ul>",
    "howToFix_ko": "<p>값 기반 클래스의 인스턴스를 동기화할 새 객체 인스턴스로 교체하세요.</p>\n\n<h4>규칙을 준수하지 않는 코드 예시</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\nprivate static final Boolean bLock = Boolean.FALSE;\nprivate static final Integer iLock = Integer.valueOf(0);\nprivate static final String sLock = \"LOCK\";\nprivate static final List&lt;String&gt; listLock = List.of(\"a\", \"b\", \"c\", \"d\");\n\npublic void doSomething() {\n\n  synchronized(bLock) {  // 규칙 위반\n      ...\n  }\n  synchronized(iLock) {  // 규칙 위반\n      ...\n  }\n  synchronized(sLock) {  // 규칙 위반\n      ...\n  }\n  synchronized(listLock) {  // 규칙 위반\n      ...\n  }\n</pre>\n<h4>규칙을 준수하는 해결책</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\nprivate static final Object lock1 = new Object();\nprivate static final Integer iLock = new Integer(42);\nprivate static final String sLock = new String(\"A brand new string in memory!\");\nprivate static final List&lt;String&gt; listLock = new ArrayList&lt;&gt;();\n\npublic void doSomething() {\n\n  synchronized(lock1) { // 규칙 준수\n      ...\n  }\n  synchronized(iLock) { // 규칙 준수\n      ...\n  }\n  synchronized(sLock) { // 규칙 준수\n      ...\n  }\n  synchronized(listLock) { // 규칙 준수\n      ...\n  }\n</pre>",
    "moreInfo_ko": "<ul>\n  <li> CERT - <a href=\"https://wiki.sei.cmu.edu/confluence/x/1zdGBQ\">재사용될 수 있는 객체에 동기화하지 마세요</a> </li>\n  <li> OpenJDK - <a href=\"https://openjdk.java.net/jeps/390\">JEP 390: 값 기반 클래스에 대한 경고</a> </li>\n  <li> Java Documentation - <a href=\"https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/doc-files/ValueBased.html\">값 기반 클래스</a> </li>\n</ul>"
  },
  {
    "id": "S2061",
    "key": "java:S2061",
    "name": "Custom serialization methods should have required signatures",
    "type": "bug",
    "severity": "major",
    "tags": [
      "cert"
    ],
    "why": "<p>Java offers a built-in serialization mechanism for classes that implement the <code>Serializable</code> interface. The developer can either rely on\nJava's default serialization and deserialization logic or implement custom methods for these tasks. The JVM will use methods such as\n<code>readObject</code> and <code>writeObject</code> to execute custom behavior. This only works, however, if these methods match exactly the expected\nsignatures. If they do not, the JVM will fall back to the default logic, resulting in unexpected behavior at runtime, while the developer believes\nthat the default logic has been overidden.</p>\n<p>This rule raises an issue if an implementation of <code>writeObject</code>, <code>readObject</code>, <code>readObjectNoData</code>,\n<code>writeReplace</code>, or <code>readResolve</code> has an incorrect access modifier, return type, or is not static when it should be (and\nvice-versa).</p>",
    "howToFix": "<p>Ensure that the serialization-related method's signatures match exactly those required by the JVM.</p>\n\n<h4>Noncompliant code example</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\npublic class Watermelon implements Serializable {\n\n  void writeObject(java.io.ObjectOutputStream out)         // Noncompliant, \"writeObject\" needs to be private, which it is not here\n        throws IOException\n  {...}\n\n  static Object readResolve() throws ObjectStreamException // Noncompliant, \"readResolve\" should not be static\n  {...}\n\n  Watermelon writeReplace() throws ObjectStreamException   // Noncompliant, \"writeReplace\" must return \"java.lang.Object\"\n  {...}\n}\n</pre>\n<h4>Compliant solution</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\npublic class Watermelon implements Serializable {\n\n  private void writeObject(java.io.ObjectOutputStream out)    // Compliant, method declared as private\n        throws IOException\n  {...}\n\n  protected Object readResolve() throws ObjectStreamException // Compliant, method is not static\n  {...}\n\n  private Object writeReplace() throws ObjectStreamException  // Compliant, method returns \"java.lang.Object\"\n  {...}\n}\n</pre>",
    "moreInfo": "<ul>\n  <li> <a href=\"https://wiki.sei.cmu.edu/confluence/x/WTdGBQ\">CERT, SER01-J.</a> - Do not deviate from the proper signatures of serialization methods\n  </li>\n  <li> <a href=\"https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/io/Serializable.html\">Oracle SDK - java.io.Serializable</a> </li>\n</ul>",
    "status": "READY",
    "name_ko": "사용자 정의 직렬화 메서드는 필수 시그니처를 가져야 합니다",
    "why_ko": "<p>Java는 <code>Serializable</code> 인터페이스를 구현하는 클래스를 위한 내장 직렬화 메커니즘을 제공합니다. 개발자는 Java의 기본 직렬화 및 역직렬화 로직에 의존하거나 이러한 작업을 위한 사용자 정의 메서드를 구현할 수 있습니다. JVM은 <code>readObject</code> 및 <code>writeObject</code>와 같은 메서드를 사용하여 사용자 정의 동작을 실행합니다. 그러나 이것은 이러한 메서드가 예상 시그니처와 정확히 일치하는 경우에만 작동합니다. 일치하지 않으면 JVM은 기본 로직으로 폴백하여 런타임에 예기치 않은 동작이 발생하지만 개발자는 기본 로직이 재정의되었다고 생각합니다.</p>\n<p>이 규칙은 <code>writeObject</code>, <code>readObject</code>, <code>readObjectNoData</code>, <code>writeReplace</code> 또는 <code>readResolve</code>의 구현이 잘못된 접근 수정자, 반환 타입을 가지거나 static이어야 할 때 static이 아닌 경우(또는 그 반대) 문제를 제기합니다.</p>",
    "howToFix_ko": "<p>직렬화 관련 메서드의 시그니처가 JVM에서 요구하는 것과 정확히 일치하는지 확인하세요.</p>\n\n<h4>규칙을 준수하지 않는 코드 예시</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\npublic class Watermelon implements Serializable {\n\n  void writeObject(java.io.ObjectOutputStream out)         // 규칙 위반, \"writeObject\"는 private이어야 하지만 여기서는 아닙니다\n        throws IOException\n  {...}\n\n  static Object readResolve() throws ObjectStreamException // 규칙 위반, \"readResolve\"는 static이 아니어야 합니다\n  {...}\n\n  Watermelon writeReplace() throws ObjectStreamException   // 규칙 위반, \"writeReplace\"는 \"java.lang.Object\"를 반환해야 합니다\n  {...}\n}\n</pre>\n<h4>규칙을 준수하는 해결책</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\npublic class Watermelon implements Serializable {\n\n  private void writeObject(java.io.ObjectOutputStream out)    // 규칙 준수, 메서드가 private으로 선언됨\n        throws IOException\n  {...}\n\n  protected Object readResolve() throws ObjectStreamException // 규칙 준수, 메서드가 static이 아님\n  {...}\n\n  private Object writeReplace() throws ObjectStreamException  // 규칙 준수, 메서드가 \"java.lang.Object\"를 반환\n  {...}\n}\n</pre>",
    "moreInfo_ko": "<ul>\n  <li> <a href=\"https://wiki.sei.cmu.edu/confluence/x/WTdGBQ\">CERT, SER01-J.</a> - Do not deviate from the proper signatures of serialization methods </li>\n  <li> <a href=\"https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/io/Serializable.html\">Oracle SDK - java.io.Serializable</a> </li>\n</ul>"
  },
  {
    "id": "S5527",
    "key": "java:S5527",
    "name": "Server hostnames should be verified during SSL/TLS connections",
    "type": "vulnerability",
    "severity": "critical",
    "tags": [
      "cwe",
      "privacy",
      "ssl"
    ],
    "why": "<p>Transport Layer Security (TLS) provides secure communication between systems over the internet by encrypting the data sent between them. In this\nprocess, the role of hostname validation, combined with certificate validation, is to ensure that a system is indeed the one it claims to be, adding\nan extra layer of trust and security.</p>\n<p>When hostname validation is disabled, the client skips this critical check. This creates an opportunity for attackers to pose as a trusted entity\nand intercept, manipulate, or steal the data being transmitted.</p>\n<p>To do so, an attacker would obtain a valid certificate authenticating <code>example.com</code>, serve it using a different hostname, and the\napplication code would still accept it.</p>\n<h3>What is the potential impact?</h3>\n<p>Establishing trust in a secure way is a non-trivial task. When you disable hostname validation, you are removing a key mechanism designed to build\nthis trust in internet communication, opening your system up to a number of potential threats.</p>\n<h4>Identity spoofing</h4>\n<p>If a system does not validate hostnames, it cannot confirm the identity of the other party involved in the communication. An attacker can exploit\nthis by creating a fake server and masquerading it as a legitimate one. For example, they might set up a server that looks like your bank's server,\ntricking your system into thinking it is communicating with the bank. This scenario, called identity spoofing, allows the attacker to collect any data\nyour system sends to them, potentially leading to significant data breaches.</p>",
    "howToFix": "<p>The following code contains examples of disabled hostname validation.</p>\n<p>The hostname validation gets disabled because <code>setSSLCheckServerIdentity</code> is omitted. To enable validation, set it to\n<code>true</code>.</p>\n<h4>Noncompliant code example</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\nimport org.apache.commons.mail.DefaultAuthenticator;\nimport org.apache.commons.mail.Email;\nimport org.apache.commons.mail.SimpleEmail;\n\npublic void sendMail(String message) {\n    Email email = new SimpleEmail();\n\n    email.setMsg(message);\n    email.setSmtpPort(465);\n    email.setAuthenticator(new DefaultAuthenticator(username, password));\n    email.setSSLOnConnect(true); // Noncompliant\n\n    email.send();\n}\n</pre>\n<h4>Compliant solution</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\nimport org.apache.commons.mail.DefaultAuthenticator;\nimport org.apache.commons.mail.Email;\nimport org.apache.commons.mail.SimpleEmail;\n\npublic void sendMail(String message) {\n    Email email = new SimpleEmail();\n\n    email.setMsg(message);\n    email.setSmtpPort(465);\n    email.setAuthenticator(new DefaultAuthenticator(username, password));\n    email.setSSLCheckServerIdentity(true);\n    email.setSSLOnConnect(true);\n\n    email.send();\n}\n</pre>\n<h3>How does this work?</h3>\n<p>To fix the vulnerability of disabled hostname validation, it is strongly recommended to first re-enable the default validation and fix the root\ncause: the validity of the certificate.</p>\n<h4>Use valid certificates</h4>\n<p>If a hostname validation failure prevents connecting to the target server, keep in mind that <strong>one system's code should not work around\nanother system's problems</strong>, as this creates unnecessary dependencies and can lead to reliability issues.</p>\n<p>Therefore, the first solution is to change the remote host's certificate to match its identity. If the remote host is not under your control,\nconsider replicating its service to a server whose certificate you can change yourself.</p>\n<p>In case the contacted host is located on a development machine, and if there is no other choice, try following this solution:</p>\n<ul>\n  <li> Create a self-signed certificate for that machine. </li>\n  <li> Add this self-signed certificate to the system's trust store. </li>\n  <li> If the hostname is not <code>localhost</code>, add the hostname in the <code>/etc/hosts</code> file. </li>\n</ul>\n<p>Here is a sample command to import a certificate to the Java trust store:</p>\n<pre>\nkeytool -import -alias myserver -file myserver.crt -keystore cacerts\n</pre>",
    "moreInfo": "<h3>Standards</h3>\n<ul>\n  <li> OWASP - <a href=\"https://owasp.org/Top10/A02_2021-Cryptographic_Failures/\">Top 10 2021 Category A2 - Cryptographic Failures</a> </li>\n  <li> OWASP - <a href=\"https://owasp.org/Top10/A05_2021-Security_Misconfiguration/\">Top 10 2021 Category A5 - Security Misconfiguration</a> </li>\n  <li> OWASP - <a href=\"https://owasp.org/Top10/A07_2021-Identification_and_Authentication_Failures/\">Top 10 2021 Category A7 - Identification and\n  Authentication Failures</a> </li>\n  <li> OWASP - <a href=\"https://owasp.org/www-project-top-ten/2017/A3_2017-Sensitive_Data_Exposure\">Top 10 2017 Category A3 - Sensitive Data\n  Exposure</a> </li>\n  <li> OWASP - <a href=\"https://owasp.org/www-project-top-ten/2017/A6_2017-Security_Misconfiguration\">Top 10 2017 Category A6 - Security\n  Misconfiguration</a> </li>\n  <li> OWASP - <a href=\"https://mas.owasp.org/checklists/MASVS-NETWORK/\">Mobile AppSec Verification Standard - Network Communication Requirements</a>\n  </li>\n  <li> OWASP - <a href=\"https://owasp.org/www-project-mobile-top-10/2016-risks/m3-insecure-communication\">Mobile Top 10 2016 Category M3 - Insecure\n  Communication</a> </li>\n  <li> OWASP - <a href=\"https://owasp.org/www-project-mobile-top-10/2023-risks/m5-insecure-communication\">Mobile Top 10 2024 Category M5 - Insecure\n  Communication</a> </li>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/297\">CWE-297 - Improper Validation of Certificate with Host Mismatch</a> </li>\n  <li> STIG Viewer - <a href=\"https://stigviewer.com/stigs/application_security_and_development/2024-12-06/finding/V-222550\">Application Security and\n  Development: V-222550</a> - The application must validate certificates by constructing a certification path to an accepted trust anchor. </li>\n  <li> <a\n  href=\"https://wiki.sei.cmu.edu/confluence/display/java/MSC61-J.+Do+not+use+insecure+or+weak+cryptographic+algorithms\">https://wiki.sei.cmu.edu/confluence/display/java/MSC61-J.+Do+not+use+insecure+or+weak+cryptographic+algorithms</a> </li>\n</ul>",
    "status": "READY",
    "name_ko": "SSL/TLS 연결 시 서버 호스트명을 검증해야 합니다",
    "why_ko": "<p>전송 계층 보안(TLS)은 전송되는 데이터를 암호화하여 인터넷을 통해 시스템 간의 안전한 통신을 제공합니다. 이 과정에서 인증서 검증과 결합된 호스트명 검증의 역할은 시스템이 실제로 자신이 주장하는 것임을 확인하여 추가적인 신뢰와 보안 계층을 추가하는 것입니다.</p>\n<p>호스트명 검증이 비활성화되면 클라이언트는 이 중요한 검사를 건너뜁니다. 이는 공격자가 신뢰할 수 있는 엔터티로 가장하여 전송되는 데이터를 가로채거나 조작하거나 훔칠 수 있는 기회를 만듭니다.</p>\n<p>이를 위해 공격자는 <code>example.com</code>을 인증하는 유효한 인증서를 획득하고 다른 호스트명을 사용하여 제공하면 애플리케이션 코드는 여전히 이를 수락합니다.</p>\n<h3>잠재적 영향은 무엇입니까?</h3>\n<p>안전한 방식으로 신뢰를 구축하는 것은 간단하지 않은 작업입니다. 호스트명 검증을 비활성화하면 인터넷 통신에서 이 신뢰를 구축하도록 설계된 핵심 메커니즘을 제거하여 시스템을 여러 잠재적 위협에 노출시킵니다.</p>\n<h4>신원 스푸핑</h4>\n<p>시스템이 호스트명을 검증하지 않으면 통신에 관련된 상대방의 신원을 확인할 수 없습니다. 공격자는 가짜 서버를 만들어 합법적인 서버로 가장하여 이를 악용할 수 있습니다. 예를 들어, 은행 서버처럼 보이는 서버를 설정하여 시스템이 은행과 통신하고 있다고 생각하도록 속일 수 있습니다. 신원 스푸핑이라고 불리는 이 시나리오는 공격자가 시스템이 보내는 모든 데이터를 수집할 수 있게 하여 잠재적으로 심각한 데이터 유출로 이어질 수 있습니다.</p>",
    "howToFix_ko": "<p>다음 코드는 호스트명 검증이 비활성화된 예시를 포함합니다.</p>\n<p><code>setSSLCheckServerIdentity</code>가 생략되어 호스트명 검증이 비활성화됩니다. 검증을 활성화하려면 <code>true</code>로 설정하세요.</p>\n<h4>규칙을 준수하지 않는 코드 예시</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\nimport org.apache.commons.mail.DefaultAuthenticator;\nimport org.apache.commons.mail.Email;\nimport org.apache.commons.mail.SimpleEmail;\n\npublic void sendMail(String message) {\n    Email email = new SimpleEmail();\n\n    email.setMsg(message);\n    email.setSmtpPort(465);\n    email.setAuthenticator(new DefaultAuthenticator(username, password));\n    email.setSSLOnConnect(true); // 규칙 위반\n\n    email.send();\n}\n</pre>\n<h4>규칙을 준수하는 해결책</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\nimport org.apache.commons.mail.DefaultAuthenticator;\nimport org.apache.commons.mail.Email;\nimport org.apache.commons.mail.SimpleEmail;\n\npublic void sendMail(String message) {\n    Email email = new SimpleEmail();\n\n    email.setMsg(message);\n    email.setSmtpPort(465);\n    email.setAuthenticator(new DefaultAuthenticator(username, password));\n    email.setSSLCheckServerIdentity(true);\n    email.setSSLOnConnect(true);\n\n    email.send();\n}\n</pre>\n<h3>어떻게 작동합니까?</h3>\n<p>비활성화된 호스트명 검증의 취약점을 수정하려면 먼저 기본 검증을 다시 활성화하고 근본 원인인 인증서의 유효성을 수정하는 것이 강력히 권장됩니다.</p>\n<h4>유효한 인증서 사용</h4>\n<p>호스트명 검증 실패로 대상 서버에 연결할 수 없는 경우 <strong>한 시스템의 코드가 다른 시스템의 문제를 우회해서는 안 된다</strong>는 점을 명심하세요. 이는 불필요한 종속성을 생성하고 신뢰성 문제로 이어질 수 있기 때문입니다.</p>\n<p>따라서 첫 번째 해결책은 원격 호스트의 인증서를 신원과 일치하도록 변경하는 것입니다. 원격 호스트가 제어 하에 있지 않은 경우 인증서를 직접 변경할 수 있는 서버에 서비스를 복제하는 것을 고려하세요.</p>\n<p>연락하는 호스트가 개발 머신에 있고 다른 선택이 없는 경우 다음 해결책을 시도하세요:</p>\n<ul>\n  <li> 해당 머신에 대한 자체 서명 인증서를 생성합니다. </li>\n  <li> 이 자체 서명 인증서를 시스템의 신뢰 저장소에 추가합니다. </li>\n  <li> 호스트명이 <code>localhost</code>가 아닌 경우 <code>/etc/hosts</code> 파일에 호스트명을 추가합니다. </li>\n</ul>\n<p>다음은 Java 신뢰 저장소에 인증서를 가져오는 샘플 명령입니다:</p>\n<pre>\nkeytool -import -alias myserver -file myserver.crt -keystore cacerts\n</pre>",
    "moreInfo_ko": "<h3>표준</h3>\n<ul>\n  <li> OWASP - <a href=\"https://owasp.org/Top10/A02_2021-Cryptographic_Failures/\">Top 10 2021 Category A2 - Cryptographic Failures</a> </li>\n  <li> OWASP - <a href=\"https://owasp.org/Top10/A05_2021-Security_Misconfiguration/\">Top 10 2021 Category A5 - Security Misconfiguration</a> </li>\n  <li> OWASP - <a href=\"https://owasp.org/Top10/A07_2021-Identification_and_Authentication_Failures/\">Top 10 2021 Category A7 - Identification and Authentication Failures</a> </li>\n  <li> OWASP - <a href=\"https://owasp.org/www-project-top-ten/2017/A3_2017-Sensitive_Data_Exposure\">Top 10 2017 Category A3 - Sensitive Data Exposure</a> </li>\n  <li> OWASP - <a href=\"https://owasp.org/www-project-top-ten/2017/A6_2017-Security_Misconfiguration\">Top 10 2017 Category A6 - Security Misconfiguration</a> </li>\n  <li> OWASP - <a href=\"https://mas.owasp.org/checklists/MASVS-NETWORK/\">Mobile AppSec Verification Standard - Network Communication Requirements</a> </li>\n  <li> OWASP - <a href=\"https://owasp.org/www-project-mobile-top-10/2016-risks/m3-insecure-communication\">Mobile Top 10 2016 Category M3 - Insecure Communication</a> </li>\n  <li> OWASP - <a href=\"https://owasp.org/www-project-mobile-top-10/2023-risks/m5-insecure-communication\">Mobile Top 10 2024 Category M5 - Insecure Communication</a> </li>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/297\">CWE-297 - 호스트 불일치로 인한 인증서 검증 부적절</a> </li>\n  <li> STIG Viewer - <a href=\"https://stigviewer.com/stigs/application_security_and_development/2024-12-06/finding/V-222550\">Application Security and Development: V-222550</a> - 애플리케이션은 허용된 신뢰 앵커로의 인증 경로를 구성하여 인증서를 검증해야 합니다. </li>\n  <li> <a href=\"https://wiki.sei.cmu.edu/confluence/display/java/MSC61-J.+Do+not+use+insecure+or+weak+cryptographic+algorithms\">https://wiki.sei.cmu.edu/confluence/display/java/MSC61-J.+Do+not+use+insecure+or+weak+cryptographic+algorithms</a> </li>\n</ul>"
  },
  {
    "id": "S2718",
    "key": "java:S2718",
    "name": "\"DateUtils.truncate\" from Apache Commons Lang library should not be used",
    "type": "code-smell",
    "severity": "major",
    "tags": [
      "performance",
      "java8"
    ],
    "why": "<p>The <code>ZonedDateTime</code> is an immutable representation of a date-time with a time-zone, introduced in Java 8. This class stores all date and\ntime fields, to a precision of nanoseconds, and a time zone, with a zone offset used to handle ambiguous local date times.</p>\n<p>Date truncation to a specific time unit means setting the values up to the specific time unit to zero while keeping the values of the larger time\nunits unchanged.</p>\n<p>The <code>ZonedDateTime</code> class provides a <code>truncatedTo</code> method that allows truncating the date in a significantly faster way than\nthe <code>DateUtils</code> class from Commons Lang.</p>\n<p><strong>Note</strong> that this rule is automatically disabled when the project's <code>sonar.java.source</code> is lower than <code>8</code>.</p>\n<h3>Noncompliant code example</h3>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\npublic Date trunc(Date date) {\n  return DateUtils.truncate(date, Calendar.SECOND);  // Noncompliant\n}\n</pre>\n<h3>Compliant solution</h3>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\npublic Date trunc(Date date) {\n  Instant instant = date.toInstant();\n  ZonedDateTime zonedDateTime = instant.atZone(ZoneId.systemDefault());\n  ZonedDateTime truncatedZonedDateTime = zonedDateTime.truncatedTo(ChronoUnit.SECONDS);\n  Instant truncatedInstant = truncatedZonedDateTime.toInstant();\n  return Date.from(truncatedInstant);\n}\n</pre>",
    "howToFix": "",
    "moreInfo": "<ul>\n  <li> <a\n  href=\"https://docs.oracle.com/en/java/javase/20/docs/api/java.base/java/time/ZonedDateTime.html#truncatedTo(java.time.temporal.TemporalUnit)\">Oracle\n  SDK 20 - ZonedDateTime#truncatedTo</a> </li>\n</ul>",
    "status": "READY",
    "name_ko": "Apache Commons Lang 라이브러리의 \"DateUtils.truncate\"를 사용하면 안 됩니다",
    "why_ko": "<p><code>ZonedDateTime</code>은 Java 8에서 도입된 시간대가 있는 날짜-시간의 불변 표현입니다. 이 클래스는 나노초 정밀도까지의 모든 날짜 및 시간 필드와 모호한 로컬 날짜 시간을 처리하는 데 사용되는 영역 오프셋이 있는 시간대를 저장합니다.</p>\n<p>특정 시간 단위로 날짜를 자르는 것은 특정 시간 단위까지의 값을 0으로 설정하고 더 큰 시간 단위의 값은 변경하지 않는 것을 의미합니다.</p>\n<p><code>ZonedDateTime</code> 클래스는 Commons Lang의 <code>DateUtils</code> 클래스보다 훨씬 빠른 방식으로 날짜를 자를 수 있는 <code>truncatedTo</code> 메서드를 제공합니다.</p>\n<p><strong>참고</strong> 이 규칙은 프로젝트의 <code>sonar.java.source</code>가 <code>8</code>보다 낮을 때 자동으로 비활성화됩니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\npublic Date trunc(Date date) {\n  return DateUtils.truncate(date, Calendar.SECOND);  // 규칙 위반\n}\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\npublic Date trunc(Date date) {\n  Instant instant = date.toInstant();\n  ZonedDateTime zonedDateTime = instant.atZone(ZoneId.systemDefault());\n  ZonedDateTime truncatedZonedDateTime = zonedDateTime.truncatedTo(ChronoUnit.SECONDS);\n  Instant truncatedInstant = truncatedZonedDateTime.toInstant();\n  return Date.from(truncatedInstant);\n}\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": "<ul>\n  <li> <a\n  href=\"https://docs.oracle.com/en/java/javase/20/docs/api/java.base/java/time/ZonedDateTime.html#truncatedTo(java.time.temporal.TemporalUnit)\">Oracle\n  SDK 20 - ZonedDateTime#truncatedTo</a> </li>\n</ul>"
  },
  {
    "id": "S1134",
    "key": "java:S1134",
    "name": "Track uses of \"FIXME\" tags",
    "type": "code-smell",
    "severity": "major",
    "tags": [
      "cwe"
    ],
    "why": "<p><code>FIXME</code> tags are commonly used to mark places where a bug is suspected, but which the developer wants to deal with later.</p>\n<p>Sometimes the developer will not have the time or will simply forget to get back to that tag.</p>\n<p>This rule is meant to track those tags and to ensure that they do not go unnoticed.</p>\n<pre>\nint divide(int numerator, int denominator) {\n  return numerator / denominator;              // FIXME denominator value might be  0\n}\n</pre>",
    "howToFix": "",
    "moreInfo": "<h3>Documentation</h3>\n<ul>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/546\">CWE-546 - Suspicious Comment</a> </li>\n</ul>",
    "status": "READY",
    "name_ko": "\"FIXME\" 태그 사용을 추적합니다",
    "why_ko": "<p><code>FIXME</code> 태그는 버그가 의심되지만 개발자가 나중에 처리하려는 곳을 표시하는 데 일반적으로 사용됩니다.</p>\n<p>때때로 개발자는 시간이 없거나 해당 태그로 돌아가는 것을 잊어버릴 수 있습니다.</p>\n<p>이 규칙은 이러한 태그를 추적하고 눈에 띄지 않게 지나가지 않도록 하기 위한 것입니다.</p>\n<pre>\nint divide(int numerator, int denominator) {\n  return numerator / denominator;              // FIXME denominator 값이 0일 수 있음\n}\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": "<h3>문서</h3>\n<ul>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/546\">CWE-546 - 의심스러운 주석</a> </li>\n</ul>"
  },
  {
    "id": "S5803",
    "key": "java:S5803",
    "name": "Class members annotated with \"@VisibleForTesting\" should not be accessed from production code",
    "type": "code-smell",
    "severity": "critical",
    "tags": [
      "pitfall"
    ],
    "why": "<p>@VisibleForTesting can be used to mark methods, fields and classes whose visibility restrictions have been relaxed more than necessary for the API\nto allow for easier unit testing.</p>\n<p>Access to such methods, fields and classes only possible thanks to this relaxed visibility is fine for test code, but it should be avoided in\nproduction code. In production code these methods should be treated as if they are private.</p>\n<p>Supported framework:</p>\n<ul>\n  <li> Guava: <code>com.google.common.annotations.VisibleForTesting</code> </li>\n  <li> AssertJ: <code>org.assertj.core.util.VisibleForTesting</code> </li>\n  <li> Android: <code>androidx.annotation.VisibleForTesting</code> </li>\n  <li> Apache Flink: <code>org.apache.flink.annotation.VisibleForTesting</code> </li>\n</ul>\n<p>or any other annotation named <code>VisibleForTesting</code></p>\n<h3>Noncompliant code example</h3>\n<pre>\n/** src/main/java/MyObject.java */\n\n@VisibleForTesting String foo;\n\n/** src/main/java/Service.java */\n\nnew MyObject().foo; // Noncompliant, foo is accessed from production code\n</pre>\n<h3>Compliant solution</h3>\n<pre>\n/** src/main/java/MyObject.java */\n\n@VisibleForTesting String foo;\n\n/** src/test/java/MyObjectTest.java */\n\nnew MyObject().foo; // Compliant, foo is accessed from test code\n</pre>",
    "howToFix": "",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "\"@VisibleForTesting\"으로 주석 처리된 클래스 멤버는 프로덕션 코드에서 접근하면 안 됩니다",
    "why_ko": "<p>@VisibleForTesting은 더 쉬운 단위 테스트를 위해 API에 필요한 것보다 가시성 제한이 완화된 메서드, 필드 및 클래스를 표시하는 데 사용할 수 있습니다.</p>\n<p>이러한 완화된 가시성 덕분에만 가능한 메서드, 필드 및 클래스에 대한 접근은 테스트 코드에서는 괜찮지만 프로덕션 코드에서는 피해야 합니다. 프로덕션 코드에서 이러한 메서드는 private인 것처럼 취급해야 합니다.</p>\n<p>지원되는 프레임워크:</p>\n<ul>\n  <li> Guava: <code>com.google.common.annotations.VisibleForTesting</code> </li>\n  <li> AssertJ: <code>org.assertj.core.util.VisibleForTesting</code> </li>\n  <li> Android: <code>androidx.annotation.VisibleForTesting</code> </li>\n  <li> Apache Flink: <code>org.apache.flink.annotation.VisibleForTesting</code> </li>\n</ul>\n<p>또는 <code>VisibleForTesting</code>이라는 이름의 다른 어노테이션</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\n/** src/main/java/MyObject.java */\n\n@VisibleForTesting String foo;\n\n/** src/main/java/Service.java */\n\nnew MyObject().foo; // 규칙 위반, foo가 프로덕션 코드에서 접근됨\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre>\n/** src/main/java/MyObject.java */\n\n@VisibleForTesting String foo;\n\n/** src/test/java/MyObjectTest.java */\n\nnew MyObject().foo; // 규칙 준수, foo가 테스트 코드에서 접근됨\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": ""
  },
  {
    "id": "S1143",
    "key": "java:S1143",
    "name": "Jump statements should not occur in \"finally\" blocks",
    "type": "bug",
    "severity": "critical",
    "tags": [
      "error-handling",
      "cwe",
      "cert"
    ],
    "why": "<p>Using <code>return</code>, <code>break</code>, <code>throw</code>, and so on from a <code>finally</code> block suppresses the propagation of any\nunhandled <code>Throwable</code> which was thrown in the <code>try</code> or <code>catch</code> block.</p>\n<p>This rule raises an issue when a jump statement (<code>break</code>, <code>continue</code>, <code>return</code>, <code>throw</code>, and\n<code>goto</code>) would force control flow to leave a <code>finally</code> block.</p>\n<h3>Noncompliant code example</h3>\n<pre>\npublic static void main(String[] args) {\n  try {\n    doSomethingWhichThrowsException();\n    System.out.println(\"OK\");   // incorrect \"OK\" message is printed\n  } catch (RuntimeException e) {\n    System.out.println(\"ERROR\");  // this message is not shown\n  }\n}\n\npublic static void doSomethingWhichThrowsException() {\n  try {\n    throw new RuntimeException();\n  } finally {\n    for (int i = 0; i &lt; 10; i ++) {\n      //...\n      if (q == i) {\n        break; // ignored\n      }\n    }\n\n    /* ... */\n    return;      // Noncompliant - prevents the RuntimeException from being propagated\n  }\n}\n</pre>\n<h3>Compliant solution</h3>\n<pre>\npublic static void main(String[] args) {\n  try {\n    doSomethingWhichThrowsException();\n    System.out.println(\"OK\");\n  } catch (RuntimeException e) {\n    System.out.println(\"ERROR\");  // \"ERROR\" is printed as expected\n  }\n}\n\npublic static void doSomethingWhichThrowsException() {\n  try {\n    throw new RuntimeException();\n  } finally {\n    for (int i = 0; i &lt; 10; i ++) {\n      //...\n      if (q == i) {\n        break; // ignored\n      }\n    }\n\n    /* ... */\n  }\n}\n</pre>",
    "howToFix": "",
    "moreInfo": "<ul>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/584\">CWE-584 - Return Inside Finally Block</a> </li>\n  <li> <a href=\"https://wiki.sei.cmu.edu/confluence/x/BTdGBQ\">CERT, ERR04-J.</a> - Do not complete abruptly from a finally block </li>\n</ul>",
    "status": "READY",
    "name_ko": "점프 문은 \"finally\" 블록에서 발생하면 안 됩니다",
    "why_ko": "<p><code>finally</code> 블록에서 <code>return</code>, <code>break</code>, <code>throw</code> 등을 사용하면 <code>try</code> 또는 <code>catch</code> 블록에서 던져진 처리되지 않은 <code>Throwable</code>의 전파가 억제됩니다.</p>\n<p>이 규칙은 점프 문(<code>break</code>, <code>continue</code>, <code>return</code>, <code>throw</code>, <code>goto</code>)이 <code>finally</code> 블록을 벗어나도록 제어 흐름을 강제할 때 이슈를 제기합니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\npublic static void main(String[] args) {\n  try {\n    doSomethingWhichThrowsException();\n    System.out.println(\"OK\");   // 잘못된 \"OK\" 메시지가 출력됨\n  } catch (RuntimeException e) {\n    System.out.println(\"ERROR\");  // 이 메시지는 표시되지 않음\n  }\n}\n\npublic static void doSomethingWhichThrowsException() {\n  try {\n    throw new RuntimeException();\n  } finally {\n    for (int i = 0; i &lt; 10; i ++) {\n      //...\n      if (q == i) {\n        break; // 무시됨\n      }\n    }\n\n    /* ... */\n    return;      // 규칙 위반 - RuntimeException의 전파를 방지함\n  }\n}\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre>\npublic static void main(String[] args) {\n  try {\n    doSomethingWhichThrowsException();\n    System.out.println(\"OK\");\n  } catch (RuntimeException e) {\n    System.out.println(\"ERROR\");  // 예상대로 \"ERROR\"가 출력됨\n  }\n}\n\npublic static void doSomethingWhichThrowsException() {\n  try {\n    throw new RuntimeException();\n  } finally {\n    for (int i = 0; i &lt; 10; i ++) {\n      //...\n      if (q == i) {\n        break; // 무시됨\n      }\n    }\n\n    /* ... */\n  }\n}\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": "<ul>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/584\">CWE-584 - Finally 블록 내부의 Return</a> </li>\n  <li> <a href=\"https://wiki.sei.cmu.edu/confluence/x/BTdGBQ\">CERT, ERR04-J.</a> - finally 블록에서 갑작스럽게 완료하지 마세요 </li>\n</ul>"
  },
  {
    "id": "S1905",
    "key": "java:S1905",
    "name": "Redundant casts should not be used",
    "type": "code-smell",
    "severity": "minor",
    "tags": [
      "redundant",
      "clumsy"
    ],
    "why": "<p>Casting expressions are utilized to convert one data type to another, such as transforming an integer into a string. This is especially crucial in\nstrongly typed languages like C, C++, C#, Java, Python, and others.</p>\n<p>However, there are instances where casting expressions are not needed. These include situations like:</p>\n<ul>\n  <li> casting a variable to its own type </li>\n  <li> casting a subclass to a parent class (in the case of polymorphism) </li>\n  <li> the programming language is capable of automatically converting the given type to another </li>\n</ul>\n<p>These scenarios are considered unnecessary casting expressions. They can complicate the code and make it more difficult to understand, without\noffering any advantages.</p>\n<p>As a result, it's generally advised to avoid unnecessary casting expressions. Instead, rely on the language's type system to ensure type safety and\ncode clarity.</p>\n<h3>Exceptions</h3>\n<p>Casting may be required to distinguish the method to call in the case of overloading:</p>\n<pre>\nclass A {}\nclass B extends A{}\nclass C {\n  void fun(A a){}\n  void fun(B b){}\n\n  void foo() {\n    B b = new B();\n    fun(b);\n    fun((A) b); // Compliant, required to call the first method so cast is not redundant.\n  }\n}\n</pre>",
    "howToFix": "<p>To fix your code remove the unnecessary casting expression.</p>\n\n<h4>Noncompliant code example</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\nclass Example {\n    public void example(List&lt;String&gt; list) {\n        for (String item: (List&lt;String&gt;) list) {  // Noncompliant, Remove this unnecessary cast to \"List\".\n          //...\n        }\n    }\n}\n</pre>\n<h4>Compliant solution</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\nclass Example {\n    public void example() {\n        for (String foo : getFoos()) {\n          //...\n        }\n    }\n\n    public List&lt;String&gt; getFoos() {\n        return List.of(\"foo1\", \"foo2\");\n    }\n}\n</pre>",
    "moreInfo": "<h3>Documentation</h3>\n<ul>\n  <li> Geeksforgeeks - <a href=\"https://www.geeksforgeeks.org/type-conversion-java-examples/\">Type conversion in Java with Examples</a> </li>\n  <li> Wikipedia - <a href=\"https://en.wikipedia.org/wiki/Type_conversion\">Type Conversion</a> </li>\n  <li> Wikipedia - <a href=\"https://en.wikipedia.org/wiki/Strong_and_weak_typing\">Strong and Weak Typing</a> </li>\n  <li> Wikipedia - <a href=\"https://en.wikipedia.org/wiki/Polymorphism_(computer_science)\"> Polymorphism (Computer Science)</a> </li>\n</ul>",
    "status": "READY",
    "name_ko": "불필요한 형변환을 사용하면 안 됩니다",
    "why_ko": "<p>형변환 표현식은 정수를 문자열로 변환하는 것과 같이 한 데이터 타입을 다른 타입으로 변환하는 데 사용됩니다. 이것은 C, C++, C#, Java, Python 등과 같은 강타입 언어에서 특히 중요합니다.</p>\n<p>그러나 형변환 표현식이 필요하지 않은 경우가 있습니다. 이러한 상황에는 다음이 포함됩니다:</p>\n<ul>\n  <li> 변수를 자신의 타입으로 형변환 </li>\n  <li> 서브클래스를 부모 클래스로 형변환(다형성의 경우) </li>\n  <li> 프로그래밍 언어가 주어진 타입을 다른 타입으로 자동 변환할 수 있는 경우 </li>\n</ul>\n<p>이러한 시나리오는 불필요한 형변환 표현식으로 간주됩니다. 어떤 이점도 제공하지 않으면서 코드를 복잡하게 하고 이해하기 어렵게 만들 수 있습니다.</p>\n<p>결과적으로, 일반적으로 불필요한 형변환 표현식을 피하는 것이 좋습니다. 대신 타입 안전성과 코드 명확성을 보장하기 위해 언어의 타입 시스템에 의존하세요.</p>\n<h3>예외</h3>\n<p>오버로딩의 경우 호출할 메서드를 구별하기 위해 형변환이 필요할 수 있습니다:</p>\n<pre>\nclass A {}\nclass B extends A{}\nclass C {\n  void fun(A a){}\n  void fun(B b){}\n\n  void foo() {\n    B b = new B();\n    fun(b);\n    fun((A) b); // 규칙 준수, 첫 번째 메서드를 호출하기 위해 필요하므로 형변환이 중복되지 않음\n  }\n}\n</pre>",
    "howToFix_ko": "<p>코드를 수정하려면 불필요한 형변환 표현식을 제거하세요.</p>\n\n<h4>규칙을 준수하지 않는 코드 예시</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\nclass Example {\n    public void example(List&lt;String&gt; list) {\n        for (String item: (List&lt;String&gt;) list) {  // 규칙 위반, \"List\"로의 불필요한 형변환을 제거하세요.\n          //...\n        }\n    }\n}\n</pre>\n<h4>규칙을 준수하는 해결책</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\nclass Example {\n    public void example() {\n        for (String foo : getFoos()) {\n          //...\n        }\n    }\n\n    public List&lt;String&gt; getFoos() {\n        return List.of(\"foo1\", \"foo2\");\n    }\n}\n</pre>",
    "moreInfo_ko": "<h3>문서</h3>\n<ul>\n  <li> Geeksforgeeks - <a href=\"https://www.geeksforgeeks.org/type-conversion-java-examples/\">예제로 배우는 Java의 타입 변환</a> </li>\n  <li> Wikipedia - <a href=\"https://en.wikipedia.org/wiki/Type_conversion\">타입 변환</a> </li>\n  <li> Wikipedia - <a href=\"https://en.wikipedia.org/wiki/Strong_and_weak_typing\">강타입과 약타입</a> </li>\n  <li> Wikipedia - <a href=\"https://en.wikipedia.org/wiki/Polymorphism_(computer_science)\">다형성 (컴퓨터 과학)</a> </li>\n</ul>"
  },
  {
    "id": "S6813",
    "key": "java:S6813",
    "name": "Field dependency injection should be avoided",
    "type": "code-smell",
    "severity": "major",
    "tags": [],
    "why": "<p>Dependency injection frameworks such as Spring, Quarkus, and others support dependency injection by using annotations such as <code>@Inject</code>\nand <code>@Autowired</code>. These annotations can be used to inject beans via constructor, setter, and field injection.</p>\n<p>Generally speaking, field injection is discouraged. It allows the creation of objects in an invalid state and makes testing more difficult. The\ndependencies are not explicit when instantiating a class that uses field injection.</p>\n<p>In addition, field injection is not compatible with final fields. Keeping dependencies immutable where possible makes the code easier to\nunderstand, easing development and maintenance.</p>\n<p>Finally, because values are injected into fields after the object has been constructed, they cannot be used to initialize other non-injected fields\ninline.</p>\n<p>This rule raises an issue when the <code>@Autowired</code> or <code>@Inject</code> annotations are used on a field.</p>",
    "howToFix": "<p>Use constructor injection instead.</p>\n<p>By using constructor injection, the dependencies are explicit and must be passed during an object's construction. This avoids the possibility of\ninstantiating an object in an invalid state and makes types more testable. Fields can be declared final, which makes the code easier to understand, as\ndependencies don't change after instantiation.</p>\n\n<h4>Noncompliant code example</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\npublic class SomeService {\n    @Autowired\n    private SomeDependency someDependency; // Noncompliant\n\n    private String name = someDependency.getName(); // Will throw a NullPointerException\n}\n</pre>\n<h4>Compliant solution</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\npublic class SomeService {\n    private final SomeDependency someDependency;\n    private final String name;\n\n    @Autowired\n    public SomeService(SomeDependency someDependency) {\n        this.someDependency = someDependency;\n        name = someDependency.getName();\n    }\n}\n</pre>",
    "moreInfo": "<h3>Articles &amp; blog posts</h3>\n<ul>\n  <li> Baeldung - <a href=\"https://www.baeldung.com/java-spring-field-injection-cons\">Why Is Field Injection Not Recommended?</a> </li>\n  <li> Baeldung - <a href=\"https://www.baeldung.com/constructor-injection-in-spring\">Constructor Dependency Injection in Spring</a> </li>\n  <li> Oliver Drotbohm - <a href=\"https://odrotbohm.de/2013/11/why-field-injection-is-evil/\">Why field injection is evil</a> </li>\n  <li> GitHub Discussions - <a href=\"https://github.com/quarkusio/quarkus/discussions/38474\">Field injection in quarkus</a> </li>\n</ul>",
    "status": "READY",
    "name_ko": "필드 의존성 주입은 피해야 합니다",
    "why_ko": "<p>Spring, Quarkus 등의 의존성 주입 프레임워크는 <code>@Inject</code>와 <code>@Autowired</code>와 같은 어노테이션을 사용하여 의존성 주입을 지원합니다. 이러한 어노테이션은 생성자, 세터, 필드 주입을 통해 빈을 주입하는 데 사용할 수 있습니다.</p>\n<p>일반적으로 필드 주입은 권장되지 않습니다. 유효하지 않은 상태의 객체 생성을 허용하고 테스트를 더 어렵게 만듭니다. 필드 주입을 사용하는 클래스를 인스턴스화할 때 의존성이 명시적이지 않습니다.</p>\n<p>또한 필드 주입은 final 필드와 호환되지 않습니다. 가능한 경우 의존성을 불변으로 유지하면 코드를 이해하기 쉬워지고 개발 및 유지 관리가 용이해집니다.</p>\n<p>마지막으로, 객체가 생성된 후에 값이 필드에 주입되기 때문에 다른 주입되지 않은 필드를 인라인으로 초기화하는 데 사용할 수 없습니다.</p>\n<p>이 규칙은 <code>@Autowired</code> 또는 <code>@Inject</code> 어노테이션이 필드에 사용될 때 문제를 발생시킵니다.</p>",
    "howToFix_ko": "<p>대신 생성자 주입을 사용하세요.</p>\n<p>생성자 주입을 사용하면 의존성이 명시적이며 객체 생성 중에 전달되어야 합니다. 이렇게 하면 유효하지 않은 상태로 객체를 인스턴스화할 가능성이 없어지고 타입을 더 테스트하기 쉽게 만듭니다. 필드를 final로 선언할 수 있어 인스턴스화 후 의존성이 변경되지 않으므로 코드를 이해하기 쉬워집니다.</p>\n\n<h4>규칙을 준수하지 않는 코드 예시</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\npublic class SomeService {\n    @Autowired\n    private SomeDependency someDependency; // 규칙 위반\n\n    private String name = someDependency.getName(); // NullPointerException 발생\n}\n</pre>\n<h4>규칙을 준수하는 해결책</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\npublic class SomeService {\n    private final SomeDependency someDependency;\n    private final String name;\n\n    @Autowired\n    public SomeService(SomeDependency someDependency) {\n        this.someDependency = someDependency;\n        name = someDependency.getName();\n    }\n}\n</pre>",
    "moreInfo_ko": "<h3>기사 및 블로그 게시물</h3>\n<ul>\n  <li> Baeldung - <a href=\"https://www.baeldung.com/java-spring-field-injection-cons\">필드 주입이 권장되지 않는 이유</a> </li>\n  <li> Baeldung - <a href=\"https://www.baeldung.com/constructor-injection-in-spring\">Spring에서의 생성자 의존성 주입</a> </li>\n  <li> Oliver Drotbohm - <a href=\"https://odrotbohm.de/2013/11/why-field-injection-is-evil/\">필드 주입이 나쁜 이유</a> </li>\n  <li> GitHub Discussions - <a href=\"https://github.com/quarkusio/quarkus/discussions/38474\">Quarkus에서의 필드 주입</a> </li>\n</ul>"
  },
  {
    "id": "S2153",
    "key": "java:S2153",
    "name": "Unnecessary boxing and unboxing should be avoided",
    "type": "bug",
    "severity": "minor",
    "tags": [
      "clumsy"
    ],
    "why": "<p>Boxing is the process of putting a primitive value into a wrapper object, such as creating an <code>Integer</code> to hold an <code>int</code>\nvalue. Unboxing is the process of retrieving the primitive value from such an object. Since the original value is unchanged during boxing and\nunboxing, there is no point in doing either when not needed.</p>\n<p>Instead, you should rely on Java's implicit boxing/unboxing to convert from the primitive type to the wrapper type and vice versa, for better\nreadability.</p>\n<h3>Noncompliant code example</h3>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\npublic void examinePrimitiveInt(int a) {\n  //...\n}\n\npublic void examineBoxedInteger(Integer a) {\n  // ...\n}\n\npublic void func() {\n  int primitiveInt = 0;\n  Integer boxedInt = Integer.valueOf(0);\n  double d = 1.0;\n\n  int dIntValue = Double.valueOf(d).intValue(); // Noncompliant; should be replaced with a simple cast\n\n  examinePrimitiveInt(boxedInt.intValue()); // Noncompliant; unnecessary unboxing\n  examinePrimitiveInt(Integer.valueOf(primitiveInt));  // Noncompliant; boxed int will be auto-unboxed\n\n  examineBoxedInteger(Integer.valueOf(primitiveInt)); // Noncompliant; unnecessary boxing\n  examineBoxedInteger(boxedInt.intValue()); // Noncompliant; unboxed int will be autoboxed\n}\n</pre>\n<h3>Compliant solution</h3>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\npublic void examinePrimitiveInt(int a) {\n  //...\n}\n\npublic void examineBoxedInteger(Integer a) {\n  // ...\n}\n\npublic void func() {\n  int primitiveInt = 0;\n  Integer boxedInt = Integer.valueOf(0);\n  double d = 1.0;\n\n  int dIntValue = (int) d;\n\n  examinePrimitiveInt(primitiveInt);\n  examinePrimitiveInt(boxedInt);\n\n  examineBoxedInteger(primitiveInt);\n  examineBoxedInteger(boxedInt);\n}\n</pre>",
    "howToFix": "",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "불필요한 boxing과 unboxing은 피해야 합니다",
    "why_ko": "<p>Boxing은 <code>int</code> 값을 담기 위해 <code>Integer</code>를 생성하는 것처럼 primitive 값을 wrapper 객체에 넣는 과정입니다. Unboxing은 그러한 객체에서 primitive 값을 가져오는 과정입니다. boxing과 unboxing 중에 원래 값이 변경되지 않으므로 필요하지 않을 때 둘 중 하나를 수행하는 것은 무의미합니다.</p>\n<p>대신 더 나은 가독성을 위해 Java의 암시적 boxing/unboxing을 사용하여 primitive 타입에서 wrapper 타입으로 또는 그 반대로 변환해야 합니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\npublic void examinePrimitiveInt(int a) {\n  //...\n}\n\npublic void examineBoxedInteger(Integer a) {\n  // ...\n}\n\npublic void func() {\n  int primitiveInt = 0;\n  Integer boxedInt = Integer.valueOf(0);\n  double d = 1.0;\n\n  int dIntValue = Double.valueOf(d).intValue(); // 규칙 위반; 간단한 캐스트로 대체해야 함\n\n  examinePrimitiveInt(boxedInt.intValue()); // 규칙 위반; 불필요한 unboxing\n  examinePrimitiveInt(Integer.valueOf(primitiveInt));  // 규칙 위반; boxed int가 자동으로 unbox됨\n\n  examineBoxedInteger(Integer.valueOf(primitiveInt)); // 규칙 위반; 불필요한 boxing\n  examineBoxedInteger(boxedInt.intValue()); // 규칙 위반; unboxed int가 자동으로 autobox됨\n}\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\npublic void examinePrimitiveInt(int a) {\n  //...\n}\n\npublic void examineBoxedInteger(Integer a) {\n  // ...\n}\n\npublic void func() {\n  int primitiveInt = 0;\n  Integer boxedInt = Integer.valueOf(0);\n  double d = 1.0;\n\n  int dIntValue = (int) d;\n\n  examinePrimitiveInt(primitiveInt);\n  examinePrimitiveInt(boxedInt);\n\n  examineBoxedInteger(primitiveInt);\n  examineBoxedInteger(boxedInt);\n}\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": ""
  },
  {
    "id": "S4087",
    "key": "java:S4087",
    "name": "\"close()\" calls should not be redundant",
    "type": "code-smell",
    "severity": "minor",
    "tags": [
      "redundant"
    ],
    "why": "<p>Java 7's try-with-resources structure automatically handles closing the resources that the <code>try</code> itself opens. Thus, adding an explicit\n<code>close()</code> call is redundant and potentially confusing.</p>\n<h3>Noncompliant code example</h3>\n<pre>\ntry (PrintWriter writer = new PrintWriter(process.getOutputStream())) {\n  String contents = file.contents();\n  writer.write(new Gson().toJson(new MyObject(contents)));\n  writer.flush();\n  writer.close();  // Noncompliant\n}\n</pre>\n<h3>Compliant solution</h3>\n<pre>\ntry (PrintWriter writer = new PrintWriter(process.getOutputStream())) {\n  String contents = file.contents();\n  writer.write(new Gson().toJson(new MyObject(contents)));\n  writer.flush();\n}\n</pre>",
    "howToFix": "",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "불필요한 \"close()\" 호출이 있으면 안 됩니다",
    "why_ko": "<p>Java 7의 try-with-resources 구조는 <code>try</code> 자체가 여는 리소스를 자동으로 닫습니다. 따라서 명시적인 <code>close()</code> 호출을 추가하는 것은 중복되고 혼란을 줄 수 있습니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\ntry (PrintWriter writer = new PrintWriter(process.getOutputStream())) {\n  String contents = file.contents();\n  writer.write(new Gson().toJson(new MyObject(contents)));\n  writer.flush();\n  writer.close();  // 규칙 위반\n}\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre>\ntry (PrintWriter writer = new PrintWriter(process.getOutputStream())) {\n  String contents = file.contents();\n  writer.write(new Gson().toJson(new MyObject(contents)));\n  writer.flush();\n}\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": ""
  },
  {
    "id": "S2446",
    "key": "java:S2446",
    "name": "\"notifyAll()\" should be preferred over \"notify()\"",
    "type": "bug",
    "severity": "major",
    "tags": [
      "multi-threading",
      "cert"
    ],
    "why": "<p><code>notify</code> and <code>notifyAll</code> both wake up sleeping threads waiting on the object's monitor, but <code>notify</code> only wakes up\none single thread, while <code>notifyAll</code> wakes them all up. Unless you do not care which specific thread is woken up, <code>notifyAll</code>\nshould be used instead.</p>\n<h3>Noncompliant code example</h3>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\nclass MyThread implements Runnable {\n  Object lock = new Object();\n\n  @Override\n  public void run() {\n    synchronized(lock) {\n      // ...\n      lock.notify();  // Noncompliant\n    }\n  }\n}\n</pre>\n<h3>Compliant solution</h3>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\nclass MyThread implements Runnable {\n  Object lock = new Object();\n\n  @Override\n  public void run() {\n    synchronized(lock) {\n      // ...\n      lock.notifyAll();\n    }\n  }\n}\n</pre>",
    "howToFix": "",
    "moreInfo": "<ul>\n  <li> <a href=\"https://wiki.sei.cmu.edu/confluence/x/MTdGBQ\">CERT, THI02-J.</a> - Notify all waiting threads rather than a single thread </li>\n</ul>",
    "status": "READY",
    "name_ko": "\"notify()\" 대신 \"notifyAll()\"을 사용해야 합니다",
    "why_ko": "<p><code>notify</code>와 <code>notifyAll</code>은 둘 다 객체의 모니터에서 대기 중인 잠자는 스레드를 깨우지만, <code>notify</code>는 단일 스레드만 깨우는 반면 <code>notifyAll</code>은 모두 깨웁니다. 어떤 특정 스레드가 깨어날지 상관하지 않는 경우가 아니라면, <code>notifyAll</code>을 대신 사용해야 합니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\nclass MyThread implements Runnable {\n  Object lock = new Object();\n\n  @Override\n  public void run() {\n    synchronized(lock) {\n      // ...\n      lock.notify();  // 규칙 위반\n    }\n  }\n}\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\nclass MyThread implements Runnable {\n  Object lock = new Object();\n\n  @Override\n  public void run() {\n    synchronized(lock) {\n      // ...\n      lock.notifyAll();\n    }\n  }\n}\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": "<ul>\n  <li> <a href=\"https://wiki.sei.cmu.edu/confluence/x/MTdGBQ\">CERT, THI02-J.</a> - 단일 스레드가 아닌 모든 대기 중인 스레드에 알림 </li>\n</ul>"
  },
  {
    "id": "S5679",
    "key": "java:S5679",
    "name": "OpenSAML2 should be configured to prevent authentication bypass",
    "type": "vulnerability",
    "severity": "major",
    "tags": [
      "spring"
    ],
    "why": "<p>If the Service Provider does not manage to properly validate the incoming SAML response message signatures, attackers might be able to manipulate\nthe response content without the application noticing. Especially, they might be able to alter the authentication-targeted user.</p>\n<h3>What is the potential impact?</h3>\n<p>By exploiting this vulnerability, an attacker can manipulate the SAML Response to impersonate a different user. This, in turn, can have various\nconsequences on the application's security.</p>\n<h3>Unauthorized Access</h3>\n<p>Exploiting this vulnerability allows an attacker with authenticated access to impersonate other users within the SAML-based SSO system. This can\nlead to unauthorized access to sensitive information, resources, or functionalities the attacker should not have. By masquerading as legitimate users,\nthe attacker can bypass authentication mechanisms and gain unauthorized privileges, potentially compromising the entire system. By impersonating a\nuser with higher privileges, the attacker can gain access to additional resources. Privilege escalation can lead to further compromise of other\nsystems and unauthorized access to critical infrastructure.</p>\n<h3>Data Breaches</h3>\n<p>With the ability to impersonate other users, an attacker can gain access to sensitive data stored within the SAML-based SSO system. This includes\npersonally identifiable information (PII), financial data, intellectual property, or any other confidential information. Data breaches can result in\nreputational damage, legal consequences, financial losses, and harm to individuals whose data is exposed.</p>",
    "howToFix": "<p>The following code examples are vulnerable because they explicitly include comments in signature checks. An attacker is able to change the field\nidentifying the authenticated user with XML comments.</p>\n<h4>Noncompliant code example</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\nimport org.opensaml.xml.parse.StaticBasicParserPool;\nimport org.opensaml.xml.parse.ParserPool;\n\npublic ParserPool parserPool() {\n  StaticBasicParserPool staticBasicParserPool = new StaticBasicParserPool();\n  staticBasicParserPool.setIgnoreComments(false); // Noncompliant\n  return staticBasicParserPool;\n}\n</pre>\n<pre data-diff-id=\"2\" data-diff-type=\"noncompliant\">\nimport org.opensaml.xml.parse.BasicParserPool;\nimport org.opensaml.xml.parse.ParserPool;\n\npublic ParserPool parserPool() {\n  BasicParserPool basicParserPool = new BasicParserPool();\n  basicParserPool.setIgnoreComments(false); // Noncompliant\n  return basicParserPool;\n}\n</pre>\n<h4>Compliant solution</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\nimport org.opensaml.xml.parse.StaticBasicParserPool;\nimport org.opensaml.xml.parse.ParserPool;\n\npublic ParserPool parserPool() {\n  return new StaticBasicParserPool();\n}\n</pre>\n<pre data-diff-id=\"2\" data-diff-type=\"compliant\">\nimport org.opensaml.xml.parse.BasicParserPool;\nimport org.opensaml.xml.parse.ParserPool;\n\npublic ParserPool parserPool() {\n  return new BasicParserPool();\n}\n</pre>",
    "moreInfo": "<h3>Documentation</h3>\n<ul>\n  <li> OpenSAML API - <a href=\"https://javadoc.io/doc/org.opensaml/xmltooling/latest/org/opensaml/xml/parse/BasicParserPool.html\">Class\n  BasicParserPool</a> </li>\n  <li> OpenSAML API - <a href=\"https://javadoc.io/doc/org.opensaml/xmltooling/latest/org/opensaml/xml/parse/StaticBasicParserPool.html\">Class\n  StaticBasicParserPool</a> </li>\n  <li> W3C Recommendation - <a href=\"https://www.w3.org/TR/xml-c14n11/\">Canonical XML Version 1.1</a> </li>\n  <li> W3C Recommendation - <a href=\"https://www.w3.org/TR/xmldsig-core1/\">XML Signature Syntax and Processing Version 1.1</a> </li>\n</ul>\n<h3>Articles &amp; blog posts</h3>\n<ul>\n  <li> Cisco Duo - <a href=\"https://duo.com/blog/duo-finds-saml-vulnerabilities-affecting-multiple-implementations\">Duo Finds SAML Vulnerabilities\n  Affecting Multiple Implementations</a> </li>\n  <li> Spring blog - <a href=\"https://spring.io/blog/2018/03/01/spring-security-saml-and-this-week-s-saml-vulnerability\">Spring Security SAML and this\n  week's SAML Vulnerability</a> </li>\n  <li> Spring Security SAML - <a href=\"https://github.com/spring-projects/spring-security-saml/issues/228\">Issue #228 Multiple SAML libraries may\n  allow authentication bypass via incorrect XML canonicalization and DOM traversal</a> </li>\n  <li> CVE - <a href=\"https://www.cve.org/CVERecord?id=CVE-2017-11427\">CVE-2017-11427</a> </li>\n  <li> CVE - <a href=\"https://www.cve.org/CVERecord?id=CVE-2017-11428\">CVE-2017-11428</a> </li>\n  <li> CVE - <a href=\"https://www.cve.org/CVERecord?id=CVE-2017-11429\">CVE-2017-11429</a> </li>\n  <li> CVE - <a href=\"https://www.cve.org/CVERecord?id=CVE-2017-11430\">CVE-2017-11430</a> </li>\n  <li> CVE - <a href=\"https://www.cve.org/CVERecord?id=CVE-2018-0489\">CVE-2018-0489</a> </li>\n  <li> CVE - <a href=\"https://www.cve.org/CVERecord?id=CVE-2018-7340\">CVE-2018-7340</a> </li>\n</ul>\n<h3>Standards</h3>\n<ul>\n  <li> OWASP - <a href=\"https://owasp.org/Top10/A07_2021-Identification_and_Authentication_Failures/\">Top 10 2021 Category A7 - Identification and\n  Authentication Failures</a> </li>\n  <li> OWASP - <a href=\"https://owasp.org/www-project-top-ten/2017/A2_2017-Broken_Authentication\">Top 10 2017 Category A2 - Broken Authentication</a>\n  </li>\n</ul>",
    "status": "READY",
    "name_ko": "OpenSAML2는 인증 우회를 방지하도록 구성해야 합니다",
    "why_ko": "<p>서비스 제공자가 수신되는 SAML 응답 메시지 서명을 제대로 검증하지 못하면 공격자가 애플리케이션이 알아차리지 못하게 응답 내용을 조작할 수 있습니다. 특히 인증 대상 사용자를 변경할 수 있습니다.</p>\n<h3>잠재적 영향은 무엇입니까?</h3>\n<p>이 취약점을 악용하면 공격자는 SAML 응답을 조작하여 다른 사용자로 가장할 수 있습니다. 이는 애플리케이션 보안에 다양한 결과를 초래할 수 있습니다.</p>\n<h3>무단 접근</h3>\n<p>이 취약점을 악용하면 인증된 접근 권한을 가진 공격자가 SAML 기반 SSO 시스템 내에서 다른 사용자로 가장할 수 있습니다. 이는 공격자가 가져서는 안 되는 민감한 정보, 리소스 또는 기능에 대한 무단 접근으로 이어질 수 있습니다. 합법적인 사용자로 위장함으로써 공격자는 인증 메커니즘을 우회하고 권한 없는 특권을 얻어 잠재적으로 전체 시스템을 침해할 수 있습니다. 더 높은 권한을 가진 사용자로 가장하면 공격자는 추가 리소스에 접근할 수 있습니다. 권한 상승은 다른 시스템의 추가 침해와 중요 인프라에 대한 무단 접근으로 이어질 수 있습니다.</p>\n<h3>데이터 유출</h3>\n<p>다른 사용자로 가장할 수 있는 능력으로 공격자는 SAML 기반 SSO 시스템 내에 저장된 민감한 데이터에 접근할 수 있습니다. 여기에는 개인 식별 정보(PII), 재무 데이터, 지적 재산 또는 기타 기밀 정보가 포함됩니다. 데이터 유출은 평판 손상, 법적 결과, 재정적 손실 및 데이터가 노출된 개인에 대한 피해를 초래할 수 있습니다.</p>",
    "howToFix_ko": "<p>다음 코드 예시는 서명 검사에 명시적으로 주석을 포함하기 때문에 취약합니다. 공격자는 XML 주석으로 인증된 사용자를 식별하는 필드를 변경할 수 있습니다.</p>\n<h4>규칙을 준수하지 않는 코드 예시</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\nimport org.opensaml.xml.parse.StaticBasicParserPool;\nimport org.opensaml.xml.parse.ParserPool;\n\npublic ParserPool parserPool() {\n  StaticBasicParserPool staticBasicParserPool = new StaticBasicParserPool();\n  staticBasicParserPool.setIgnoreComments(false); // 규칙 위반\n  return staticBasicParserPool;\n}\n</pre>\n<pre data-diff-id=\"2\" data-diff-type=\"noncompliant\">\nimport org.opensaml.xml.parse.BasicParserPool;\nimport org.opensaml.xml.parse.ParserPool;\n\npublic ParserPool parserPool() {\n  BasicParserPool basicParserPool = new BasicParserPool();\n  basicParserPool.setIgnoreComments(false); // 규칙 위반\n  return basicParserPool;\n}\n</pre>\n<h4>규칙을 준수하는 해결책</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\nimport org.opensaml.xml.parse.StaticBasicParserPool;\nimport org.opensaml.xml.parse.ParserPool;\n\npublic ParserPool parserPool() {\n  return new StaticBasicParserPool();\n}\n</pre>\n<pre data-diff-id=\"2\" data-diff-type=\"compliant\">\nimport org.opensaml.xml.parse.BasicParserPool;\nimport org.opensaml.xml.parse.ParserPool;\n\npublic ParserPool parserPool() {\n  return new BasicParserPool();\n}\n</pre>",
    "moreInfo_ko": "<h3>문서</h3>\n<ul>\n  <li> OpenSAML API - <a href=\"https://javadoc.io/doc/org.opensaml/xmltooling/latest/org/opensaml/xml/parse/BasicParserPool.html\">Class BasicParserPool</a> </li>\n  <li> OpenSAML API - <a href=\"https://javadoc.io/doc/org.opensaml/xmltooling/latest/org/opensaml/xml/parse/StaticBasicParserPool.html\">Class StaticBasicParserPool</a> </li>\n  <li> W3C Recommendation - <a href=\"https://www.w3.org/TR/xml-c14n11/\">Canonical XML Version 1.1</a> </li>\n  <li> W3C Recommendation - <a href=\"https://www.w3.org/TR/xmldsig-core1/\">XML Signature Syntax and Processing Version 1.1</a> </li>\n</ul>\n<h3>기사 및 블로그 게시물</h3>\n<ul>\n  <li> Cisco Duo - <a href=\"https://duo.com/blog/duo-finds-saml-vulnerabilities-affecting-multiple-implementations\">Duo Finds SAML Vulnerabilities Affecting Multiple Implementations</a> </li>\n  <li> Spring blog - <a href=\"https://spring.io/blog/2018/03/01/spring-security-saml-and-this-week-s-saml-vulnerability\">Spring Security SAML and this week's SAML Vulnerability</a> </li>\n  <li> Spring Security SAML - <a href=\"https://github.com/spring-projects/spring-security-saml/issues/228\">Issue #228 Multiple SAML libraries may allow authentication bypass via incorrect XML canonicalization and DOM traversal</a> </li>\n  <li> CVE - <a href=\"https://www.cve.org/CVERecord?id=CVE-2017-11427\">CVE-2017-11427</a> </li>\n  <li> CVE - <a href=\"https://www.cve.org/CVERecord?id=CVE-2017-11428\">CVE-2017-11428</a> </li>\n  <li> CVE - <a href=\"https://www.cve.org/CVERecord?id=CVE-2017-11429\">CVE-2017-11429</a> </li>\n  <li> CVE - <a href=\"https://www.cve.org/CVERecord?id=CVE-2017-11430\">CVE-2017-11430</a> </li>\n  <li> CVE - <a href=\"https://www.cve.org/CVERecord?id=CVE-2018-0489\">CVE-2018-0489</a> </li>\n  <li> CVE - <a href=\"https://www.cve.org/CVERecord?id=CVE-2018-7340\">CVE-2018-7340</a> </li>\n</ul>\n<h3>표준</h3>\n<ul>\n  <li> OWASP - <a href=\"https://owasp.org/Top10/A07_2021-Identification_and_Authentication_Failures/\">Top 10 2021 Category A7 - Identification and Authentication Failures</a> </li>\n  <li> OWASP - <a href=\"https://owasp.org/www-project-top-ten/2017/A2_2017-Broken_Authentication\">Top 10 2017 Category A2 - Broken Authentication</a> </li>\n</ul>"
  },
  {
    "id": "S2692",
    "key": "java:S2692",
    "name": "\"indexOf\" checks should not be for positive numbers",
    "type": "code-smell",
    "severity": "critical",
    "tags": [
      "suspicious"
    ],
    "why": "<p>Most checks against an <code>indexOf</code> value compare it with -1 because 0 is a valid index. Checking against <code>&gt; 0</code> ignores the\nfirst element, which is likely a bug.</p>\n<pre>\nString name = \"ishmael\";\n\nif (name.indexOf(\"ish\") &gt; 0) { // Noncompliant\n  // ...\n}\n</pre>\n<p>Moreover, if the intent is merely to check the inclusion of a value in a <code>String</code> or a <code>List</code>, consider using the\n<code>contains</code> method instead.</p>\n<pre>\nString name = \"ishmael\";\n\nif (name.contains(\"ish\") {\n  // ...\n}\n</pre>\n<p>If the intent is really to skip the first element, comparing it with <code>&gt;=1</code> will make it more straightforward.</p>\n<pre>\nString name = \"ishmael\";\n\nif (name.indexOf(\"ish\") &gt;= 1) {\n  // ...\n}\n</pre>\n<p>This rule raises an issue when an <code>indexOf</code> value retrieved from a <code>String</code> or a <code>List</code> is tested against\n<code>&gt; 0</code>.</p>",
    "howToFix": "",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "\"indexOf\" 검사에서 양수를 확인하면 안 됩니다",
    "why_ko": "<p><code>indexOf</code> 값에 대한 대부분의 검사는 0이 유효한 인덱스이기 때문에 -1과 비교합니다. <code>&gt; 0</code>으로 검사하면 첫 번째 요소를 무시하게 되며, 이는 버그일 가능성이 높습니다.</p>\n<pre>\nString name = \"ishmael\";\n\nif (name.indexOf(\"ish\") &gt; 0) { // 규칙 위반\n  // ...\n}\n</pre>\n<p>또한 <code>String</code>이나 <code>List</code>에 값이 포함되어 있는지만 확인하려는 의도라면 <code>contains</code> 메서드를 대신 사용하는 것을 고려하세요.</p>\n<pre>\nString name = \"ishmael\";\n\nif (name.contains(\"ish\") {\n  // ...\n}\n</pre>\n<p>첫 번째 요소를 실제로 건너뛰려는 의도라면 <code>&gt;=1</code>과 비교하는 것이 더 명확합니다.</p>\n<pre>\nString name = \"ishmael\";\n\nif (name.indexOf(\"ish\") &gt;= 1) {\n  // ...\n}\n</pre>\n<p>이 규칙은 <code>String</code> 또는 <code>List</code>에서 가져온 <code>indexOf</code> 값이 <code>&gt; 0</code>으로 테스트될 때 문제를 제기합니다.</p>",
    "howToFix_ko": "",
    "moreInfo_ko": ""
  },
  {
    "id": "S1114",
    "key": "java:S1114",
    "name": "\"super.finalize()\" should be called at the end of \"Object.finalize()\" implementations",
    "type": "bug",
    "severity": "critical",
    "tags": [],
    "why": "<p>Overriding the <code>Object.finalize()</code> method must be done with caution to dispose some system resources.</p>\n<p>Calling the <code>super.finalize()</code> at the end of this method implementation is highly recommended in case parent implementations must also\ndispose some system resources.</p>\n<h3>Noncompliant code example</h3>\n<pre>\nprotected void finalize() {   // Noncompliant; no call to super.finalize();\n  releaseSomeResources();\n}\n\nprotected void finalize() {\n  super.finalize();  // Noncompliant; this call should come last\n  releaseSomeResources();\n}\n</pre>\n<h3>Compliant solution</h3>\n<pre>\nprotected void finalize() {\n  releaseSomeResources();\n  super.finalize();\n}\n</pre>",
    "howToFix": "",
    "moreInfo": "<ul>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/568\">CWE-568 - finalize() Method Without super.finalize()</a> </li>\n  <li> <a href=\"https://wiki.sei.cmu.edu/confluence/x/4jZGBQ\">CERT, MET12-J.</a> - Do not use finalizers </li>\n</ul>",
    "status": "DEPRECATED",
    "name_ko": "\"Object.finalize()\" 구현의 마지막에 \"super.finalize()\"를 호출해야 합니다",
    "why_ko": "<p><code>Object.finalize()</code> 메서드를 오버라이드할 때는 일부 시스템 리소스를 해제하기 위해 주의해서 수행해야 합니다.</p>\n<p>부모 구현도 일부 시스템 리소스를 해제해야 하는 경우 이 메서드 구현의 마지막에 <code>super.finalize()</code>를 호출하는 것이 강력히 권장됩니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\nprotected void finalize() {   // 규칙 위반; super.finalize() 호출이 없음;\n  releaseSomeResources();\n}\n\nprotected void finalize() {\n  super.finalize();  // 규칙 위반; 이 호출은 마지막에 와야 합니다\n  releaseSomeResources();\n}\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre>\nprotected void finalize() {\n  releaseSomeResources();\n  super.finalize();\n}\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": "<ul>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/568\">CWE-568 - super.finalize()가 없는 finalize() 메서드</a> </li>\n  <li> <a href=\"https://wiki.sei.cmu.edu/confluence/x/4jZGBQ\">CERT, MET12-J.</a> - finalizer를 사용하지 마세요 </li>\n</ul>"
  },
  {
    "id": "S5854",
    "key": "java:S5854",
    "name": "Regexes containing characters subject to normalization should use the CANON_EQ flag",
    "type": "code-smell",
    "severity": "major",
    "tags": [
      "regex"
    ],
    "why": "<p>Characters like <code>'é'</code> can be expressed either as a single code point or as a cluster of the letter <code>'e'</code> and a combining\naccent mark. Without the <code>CANON_EQ</code> flag, a regex will only match a string in which the characters are expressed in the same way.</p>\n<h3>Noncompliant code example</h3>\n<pre>\nString s = \"e\\u0300\";\nPattern p = Pattern.compile(\"é|ë|è\"); // Noncompliant\nSystem.out.println(p.matcher(s).replaceAll(\"e\")); // print 'è'\n</pre>\n<h3>Compliant solution</h3>\n<pre>\nString s = \"e\\u0300\";\nPattern p = Pattern.compile(\"é|ë|è\", Pattern.CANON_EQ);\nSystem.out.println(p.matcher(s).replaceAll(\"e\")); // print 'e'\n</pre>",
    "howToFix": "",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "정규화 대상 문자를 포함하는 정규식은 CANON_EQ 플래그를 사용해야 합니다",
    "why_ko": "<p><code>'é'</code>와 같은 문자는 단일 코드 포인트로 표현하거나 문자 <code>'e'</code>와 결합 악센트 기호의 클러스터로 표현할 수 있습니다. <code>CANON_EQ</code> 플래그 없이는 정규식이 문자가 동일한 방식으로 표현된 문자열만 일치시킵니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\nString s = \"e\\u0300\";\nPattern p = Pattern.compile(\"é|ë|è\"); // 규칙 위반\nSystem.out.println(p.matcher(s).replaceAll(\"e\")); // 'è' 출력\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre>\nString s = \"e\\u0300\";\nPattern p = Pattern.compile(\"é|ë|è\", Pattern.CANON_EQ);\nSystem.out.println(p.matcher(s).replaceAll(\"e\")); // 'e' 출력\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": ""
  },
  {
    "id": "S7185",
    "key": "java:S7185",
    "name": "@EventListener methods should have one parameter at most",
    "type": "bug",
    "severity": "critical",
    "tags": [
      "spring"
    ],
    "why": "<p>Spring provides the <code>@EventListener</code> annotation as a simpler alternative to implementing the <code>ApplicationListener</code> interface\nfor handling events. The <code>@EventListener</code> annotation registers a method as an event handler. This allows to skip the implementation of the\n<code>ApplicationListener</code> interface, making it easier to handle events.</p>\n<p>The <code>@EventListener</code> annotation can only be used on methods that have at most one parameter, which should be the specific event that we\nwant to handle. To listen to several types of events, use the <code>classes</code> argument of the <code>@EventListener</code> annotation.</p>\n<p>This rule raises an issue on all methods annotated with <code>@EventListener</code> that have more than one parameter.</p>",
    "howToFix": "<h4>Noncompliant code example</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\n@EventListener\nvoid handleEvent(CustomerEvent customerEvent, ExceptionalEvent exceptionalEvent) { // Non compliant, this will cause a runtime error\n    //... some event handling\n}\n</pre>\n<h4>Compliant solution</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\n@EventListener(classes = {CustomerEvent.class, ExceptionalEvent.class})\nvoid handleEvent(ApplicationEvent event) { // Only one parameter, of the super type `ApplicationEvent`\n    //... some event handling\n}\n</pre>",
    "moreInfo": "<h3>Documentation</h3>\n<p>Spring API - <a\nhref=\"https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/context/event/EventListener.html\">@EventListener</a></p>",
    "status": "READY",
    "name_ko": "@EventListener 메서드는 최대 하나의 매개변수만 가져야 합니다",
    "why_ko": "<p>Spring은 이벤트 처리를 위해 <code>ApplicationListener</code> 인터페이스를 구현하는 것보다 더 간단한 대안으로 <code>@EventListener</code> 어노테이션을 제공합니다. <code>@EventListener</code> 어노테이션은 메서드를 이벤트 핸들러로 등록합니다. 이를 통해 <code>ApplicationListener</code> 인터페이스의 구현을 건너뛰고 이벤트를 더 쉽게 처리할 수 있습니다.</p>\n<p><code>@EventListener</code> 어노테이션은 처리하려는 특정 이벤트여야 하는 최대 하나의 매개변수를 가진 메서드에만 사용할 수 있습니다. 여러 유형의 이벤트를 수신하려면 <code>@EventListener</code> 어노테이션의 <code>classes</code> 인수를 사용하세요.</p>\n<p>이 규칙은 하나 이상의 매개변수를 가진 <code>@EventListener</code>로 어노테이션된 모든 메서드에서 문제를 발생시킵니다.</p>",
    "howToFix_ko": "<h4>규칙을 준수하지 않는 코드 예시</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\n@EventListener\nvoid handleEvent(CustomerEvent customerEvent, ExceptionalEvent exceptionalEvent) { // 규칙 위반, 런타임 오류가 발생합니다\n    //... 이벤트 처리\n}\n</pre>\n<h4>규칙을 준수하는 해결책</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\n@EventListener(classes = {CustomerEvent.class, ExceptionalEvent.class})\nvoid handleEvent(ApplicationEvent event) { // 슈퍼 타입 `ApplicationEvent`의 매개변수 하나만 있음\n    //... 이벤트 처리\n}\n</pre>",
    "moreInfo_ko": "<h3>문서</h3>\n<p>Spring API - <a href=\"https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/context/event/EventListener.html\">@EventListener</a></p>"
  },
  {
    "id": "S2387",
    "key": "java:S2387",
    "name": "Child class fields should not shadow parent class fields",
    "type": "code-smell",
    "severity": "blocker",
    "tags": [
      "confusing"
    ],
    "why": "<p>Having a variable with the same name in two unrelated classes is fine, but do the same thing within a class hierarchy and you'll get confusion at\nbest, chaos at worst.</p>\n<h3>Noncompliant code example</h3>\n<pre>\npublic class Fruit {\n  protected Season ripe;\n  protected Color flesh;\n\n  // ...\n}\n\npublic class Raspberry extends Fruit {\n  private boolean ripe;  // Noncompliant\n  private static Color FLESH; // Noncompliant\n}\n</pre>\n<h3>Compliant solution</h3>\n<pre>\npublic class Fruit {\n  protected Season ripe;\n  protected Color flesh;\n\n  // ...\n}\n\npublic class Raspberry extends Fruit {\n  private boolean ripened;\n  private static Color FLESH_COLOR;\n\n}\n</pre>\n<h3>Exceptions</h3>\n<p>This rule ignores same-name fields that are <code>static</code> in both the parent and child classes. This rule ignores <code>private</code> parent\nclass fields, but in all other such cases, the child class field should be renamed.</p>\n<pre>\npublic class Fruit {\n  private Season ripe;\n  // ...\n}\n\npublic class Raspberry extends Fruit {\n  private Season ripe;  // Compliant as parent field 'ripe' is anyway not visible from Raspberry\n  // ...\n}\n</pre>",
    "howToFix": "",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "자식 클래스 필드가 부모 클래스 필드를 숨기면 안 됩니다",
    "why_ko": "<p>서로 관련 없는 두 클래스에서 같은 이름의 변수를 갖는 것은 괜찮지만, 클래스 계층 구조 내에서 같은 일을 하면 최선의 경우 혼란이, 최악의 경우 혼돈이 발생합니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\npublic class Fruit {\n  protected Season ripe;\n  protected Color flesh;\n\n  // ...\n}\n\npublic class Raspberry extends Fruit {\n  private boolean ripe;  // 규칙 위반\n  private static Color FLESH; // 규칙 위반\n}\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre>\npublic class Fruit {\n  protected Season ripe;\n  protected Color flesh;\n\n  // ...\n}\n\npublic class Raspberry extends Fruit {\n  private boolean ripened;\n  private static Color FLESH_COLOR;\n\n}\n</pre>\n<h3>예외</h3>\n<p>이 규칙은 부모와 자식 클래스 모두에서 <code>static</code>인 동일 이름 필드를 무시합니다. 이 규칙은 <code>private</code> 부모 클래스 필드를 무시하지만, 다른 모든 경우에는 자식 클래스 필드의 이름을 변경해야 합니다.</p>\n<pre>\npublic class Fruit {\n  private Season ripe;\n  // ...\n}\n\npublic class Raspberry extends Fruit {\n  private Season ripe;  // 규칙 준수, 부모 필드 'ripe'는 어차피 Raspberry에서 보이지 않음\n  // ...\n}\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": ""
  },
  {
    "id": "S112",
    "key": "java:S112",
    "name": "Generic exceptions should never be thrown",
    "type": "code-smell",
    "severity": "major",
    "tags": [
      "cwe",
      "error-handling",
      "cert"
    ],
    "why": "<p>Throwing generic exceptions such as <code>Error</code>, <code>RuntimeException</code>, <code>Throwable</code>, and <code>Exception</code> will have\na negative impact on any code trying to catch these exceptions.</p>\n<p>From a consumer perspective, it is generally a best practice to only catch exceptions you intend to handle. Other exceptions should ideally be let\nto propagate up the stack trace so that they can be dealt with appropriately. When a generic exception is thrown, it forces consumers to catch\nexceptions they do not intend to handle, which they then have to re-throw.</p>\n<p>Besides, when working with a generic type of exception, the only way to distinguish between multiple exceptions is to check their message, which is\nerror-prone and difficult to maintain. Legitimate exceptions may be unintentionally silenced and errors may be hidden.</p>\n<p>For instance, when a <code>Throwable</code> is caught and not re-thrown, it may mask errors such as <code>OutOfMemoryError</code> and prevent the\nprogram from terminating gracefully.</p>\n<p>When throwing an exception, it is therefore recommended to throw the most specific exception possible so that it can be handled intentionally by\nconsumers.</p>\n<h3>Exceptions</h3>\n<p>Generic exceptions in the signatures of overriding methods are ignored, because an overriding method has to follow the signature of the throw\ndeclaration in the superclass. The issue will be raised on superclass declaration of the method (or won't be raised at all if superclass is not part\nof the analysis).</p>\n<pre>\n@Override\npublic void myMethod() throws Exception {...}\n</pre>\n<p>Generic exceptions are also ignored in the signatures of methods that make calls to methods that throw generic exceptions.</p>\n<pre>\npublic void myOtherMethod() throws Exception {\n  doTheThing();  // this method throws Exception\n}\n</pre>",
    "howToFix": "<p>To fix this issue, make sure to throw specific exceptions that are relevant to the context in which they arise. It is recommended to either:</p>\n<ul>\n  <li> Raise a specific exception from the Java standard library when one matches. For example an <code>IllegalArgumentException</code> should be\n  thrown when a method receives an invalid argument. </li>\n  <li> Create a custom exception class deriving from <code>Exception</code> or one of its subclasses. </li>\n</ul>\n\n<h4>Noncompliant code example</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\nvoid checkValue(int value) throws Throwable { // Noncompliant: signature is too broad\n    if (value == 42) {\n        throw new RuntimeException(\"Value is 42\"); // Noncompliant: This will be difficult for consumers to handle\n    }\n}\n</pre>\n<h4>Compliant solution</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\nvoid checkValue(int value) {\n    if (value == 42) {\n        throw new IllegalArgumentException(\"Value is 42\"); // Compliant\n    }\n}\n</pre>",
    "moreInfo": "<h3>Standards</h3>\n<ul>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/397\">CWE-397 Declaration of Throws for Generic Exception</a> </li>\n  <li> CERT - <a href=\"https://wiki.sei.cmu.edu/confluence/x/_DdGBQ\">ERR07-J. Do not throw RuntimeException, Exception, or Throwable</a> </li>\n</ul>\n<h3>Related rules</h3>\n<ul>\n  <li> <a href='/coding_rules#rule_key=java%3AS1181'>S1181</a> - Generic exceptions should not be caught </li>\n</ul>",
    "status": "READY",
    "name_ko": "일반적인 Exception을 던지면 안 됩니다",
    "why_ko": "<p><code>Error</code>, <code>RuntimeException</code>, <code>Throwable</code>, <code>Exception</code>과 같은 일반적인 예외를 던지면 이러한 예외를 catch하려는 모든 코드에 부정적인 영향을 미칩니다.</p>\n<p>소비자 관점에서 일반적으로 처리하려는 예외만 catch하는 것이 모범 사례입니다. 다른 예외는 적절하게 처리될 수 있도록 스택 트레이스 위로 전파되도록 하는 것이 이상적입니다. 일반적인 예외가 던져지면 소비자가 처리할 의도가 없는 예외를 catch하도록 강제하고, 그런 다음 다시 던져야 합니다.</p>\n<p>게다가 일반적인 유형의 예외로 작업할 때 여러 예외를 구별하는 유일한 방법은 메시지를 확인하는 것인데, 이는 오류가 발생하기 쉽고 유지 관리하기 어렵습니다. 합법적인 예외가 의도치 않게 무시될 수 있고 오류가 숨겨질 수 있습니다.</p>\n<p>예를 들어 <code>Throwable</code>이 catch되고 다시 던져지지 않으면 <code>OutOfMemoryError</code>와 같은 오류가 마스킹되어 프로그램이 정상적으로 종료되지 않을 수 있습니다.</p>\n<p>따라서 예외를 던질 때 소비자가 의도적으로 처리할 수 있도록 가능한 가장 구체적인 예외를 던지는 것이 권장됩니다.</p>\n<h3>예외</h3>\n<p>오버라이딩 메서드의 시그니처에 있는 일반 예외는 무시됩니다. 오버라이딩 메서드는 슈퍼클래스의 throw 선언 시그니처를 따라야 하기 때문입니다. 이슈는 메서드의 슈퍼클래스 선언에서 발생합니다(또는 슈퍼클래스가 분석의 일부가 아닌 경우 전혀 발생하지 않습니다).</p>\n<pre>\n@Override\npublic void myMethod() throws Exception {...}\n</pre>\n<p>일반 예외를 던지는 메서드를 호출하는 메서드의 시그니처에 있는 일반 예외도 무시됩니다.</p>\n<pre>\npublic void myOtherMethod() throws Exception {\n  doTheThing();  // 이 메서드는 Exception을 던집니다\n}\n</pre>",
    "howToFix_ko": "<p>이 이슈를 수정하려면 발생하는 컨텍스트와 관련된 구체적인 예외를 던지도록 하세요. 다음 중 하나를 권장합니다:</p>\n<ul>\n  <li> 일치하는 것이 있으면 Java 표준 라이브러리에서 구체적인 예외를 발생시킵니다. 예를 들어 메서드가 잘못된 인수를 받으면 <code>IllegalArgumentException</code>을 던져야 합니다. </li>\n  <li> <code>Exception</code> 또는 그 하위 클래스 중 하나에서 파생되는 사용자 정의 예외 클래스를 만듭니다. </li>\n</ul>\n\n<h4>규칙을 준수하지 않는 코드 예시</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\nvoid checkValue(int value) throws Throwable { // 규칙 위반: 시그니처가 너무 광범위함\n    if (value == 42) {\n        throw new RuntimeException(\"Value is 42\"); // 규칙 위반: 소비자가 처리하기 어려움\n    }\n}\n</pre>\n<h4>규칙을 준수하는 해결책</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\nvoid checkValue(int value) {\n    if (value == 42) {\n        throw new IllegalArgumentException(\"Value is 42\"); // 규칙 준수\n    }\n}\n</pre>",
    "moreInfo_ko": "<h3>표준</h3>\n<ul>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/397\">CWE-397 일반 예외에 대한 Throws 선언</a> </li>\n  <li> CERT - <a href=\"https://wiki.sei.cmu.edu/confluence/x/_DdGBQ\">ERR07-J. RuntimeException, Exception 또는 Throwable을 던지지 마세요</a> </li>\n</ul>\n<h3>관련 규칙</h3>\n<ul>\n  <li> <a href='/coding_rules#rule_key=java%3AS1181'>S1181</a> - 일반적인 예외를 catch하면 안 됩니다 </li>\n</ul>"
  },
  {
    "id": "S6901",
    "key": "java:S6901",
    "name": "\"setDaemon\", \"setPriority\" and \"getThreadGroup\" should not be invoked on virtual threads",
    "type": "bug",
    "severity": "major",
    "tags": [
      "java21"
    ],
    "why": "<p>The <code>Thread</code> class has some methods that are used to monitor and manage its execution. With the introduction of virtual threads in Java\n21, there are three of these methods that behave differently between the standard platform threads and the virtual ones.</p>\n<p>For virtual threads:</p>\n<ul>\n  <li> <code>Thread.setDaemon(boolean)</code> will throw an <code>IllegalArgumentException</code> if <code>false</code> is passed as an argument as a\n  virtual thread daemon status is always true. </li>\n  <li> <code>Thread.setPriority(int priority)</code> will never change the actual priority of a virtual thread, which is always equal to\n  <code>Thread.NORM_PRIORITY</code> </li>\n  <li> <code>Thread.getThreadGroup()</code> will return a dummy \"VirtualThreads\" group that is empty and should not be used </li>\n</ul>\n<p>This rule reports an issue when one of these methods is invoked on a virtual thread.</p>\n\n<h4>Noncompliant code example</h4>\n<pre>\nThread t = Thread.ofVirtual().unstarted(()-&gt;{/* some task */});\nt.setPriority(1); // Noncompliant; virtual threads' priority cannot be changed\nt.setDaemon(false); // Noncompliant; will throw IllegalArgumentException\nt.setDaemon(true); // Noncompliant; redundant\nt.start();\nvar threadGroup = t.getThreadGroup(); // Noncompliant; virtual thread groups should not be used\n</pre>",
    "howToFix": "",
    "moreInfo": "<h3>Documentation</h3>\n<ul>\n  <li> Java Documentation - <a\n  href=\"https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/Thread.html#setDaemon(boolean)\">Thread.setDaemon</a> </li>\n  <li> Java Documentation - <a\n  href=\"https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/Thread.html#setPriority(int)\">Thread.setPriority</a> </li>\n  <li> Java Documentation - <a\n  href=\"https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/Thread.html#getThreadGroup()\">Thread.getThreadGroup</a> </li>\n  <li> Java Documentation - <a\n  href=\"https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/ThreadGroup.html#virtualthreadgroup\">Virtual threads group</a> </li>\n</ul>",
    "status": "READY",
    "name_ko": "가상 스레드에서 setDaemon, setPriority, getThreadGroup을 호출하면 안 됩니다",
    "why_ko": "<p><code>Thread</code> 클래스에는 실행을 모니터링하고 관리하는 데 사용되는 몇 가지 메서드가 있습니다. Java 21에서 가상 스레드가 도입됨에 따라 표준 플랫폼 스레드와 가상 스레드 간에 다르게 동작하는 세 가지 메서드가 있습니다.</p>\n<p>가상 스레드의 경우:</p>\n<ul>\n  <li> <code>Thread.setDaemon(boolean)</code>은 가상 스레드의 데몬 상태가 항상 true이므로 <code>false</code>가 인수로 전달되면 <code>IllegalArgumentException</code>을 발생시킵니다. </li>\n  <li> <code>Thread.setPriority(int priority)</code>는 가상 스레드의 실제 우선순위를 변경하지 않으며, 항상 <code>Thread.NORM_PRIORITY</code>와 같습니다. </li>\n  <li> <code>Thread.getThreadGroup()</code>은 비어 있고 사용해서는 안 되는 더미 \"VirtualThreads\" 그룹을 반환합니다. </li>\n</ul>\n<p>이 규칙은 이러한 메서드 중 하나가 가상 스레드에서 호출될 때 문제를 보고합니다.</p>\n\n<h4>규칙을 준수하지 않는 코드 예시</h4>\n<pre>\nThread t = Thread.ofVirtual().unstarted(()-&gt;{/* 어떤 작업 */});\nt.setPriority(1); // 규칙 위반; 가상 스레드의 우선순위는 변경할 수 없습니다\nt.setDaemon(false); // 규칙 위반; IllegalArgumentException이 발생합니다\nt.setDaemon(true); // 규칙 위반; 중복\nt.start();\nvar threadGroup = t.getThreadGroup(); // 규칙 위반; 가상 스레드 그룹은 사용해서는 안 됩니다\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": "<h3>문서</h3>\n<ul>\n  <li> Java 문서 - <a href=\"https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/Thread.html#setDaemon(boolean)\">Thread.setDaemon</a> </li>\n  <li> Java 문서 - <a href=\"https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/Thread.html#setPriority(int)\">Thread.setPriority</a> </li>\n  <li> Java 문서 - <a href=\"https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/Thread.html#getThreadGroup()\">Thread.getThreadGroup</a> </li>\n  <li> Java 문서 - <a href=\"https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/ThreadGroup.html#virtualthreadgroup\">Virtual threads 그룹</a> </li>\n</ul>"
  },
  {
    "id": "S6002",
    "key": "java:S6002",
    "name": "Regex lookahead assertions should not be contradictory",
    "type": "bug",
    "severity": "critical",
    "tags": [
      "regex"
    ],
    "why": "<p>Lookahead assertions are a regex feature that makes it possible to look ahead in the input without consuming it. It is often used at the end of\nregular expressions to make sure that substrings only match when they are followed by a specific pattern.</p>\n<p>For example, the following pattern will match an \"a\" only if it is directly followed by a \"b\". This does not consume the \"b\" in the process:</p>\n<pre>\nPattern.compile(\"a(?=b)\");\n</pre>\n<p>However, lookaheads can also be used in the middle (or at the beginning) of a regex. In that case there is the possibility that what comes after\nthe lookahead contradicts the pattern inside the lookahead. Since the lookahead does not consume input, this makes the lookahead impossible to match\nand is a sign that there's a mistake in the regular expression that should be fixed.</p>\n\n<h4>Noncompliant code example</h4>\n<pre>\nPattern.compile(\"(?=a)b\"); // Noncompliant, the same character can't be equal to 'a' and 'b' at the same time\n</pre>\n<h4>Compliant solution</h4>\n<pre>\nPattern.compile(\"(?&lt;=a)b\");\nPattern.compile(\"a(?=b)\");\n</pre>",
    "howToFix": "",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "정규 표현식 전방 탐색 어설션은 모순되지 않아야 합니다",
    "why_ko": "<p>전방 탐색 어설션은 입력을 소비하지 않고 앞을 볼 수 있게 해주는 정규식 기능입니다. 부분 문자열이 특정 패턴 뒤에 올 때만 일치하도록 하기 위해 정규 표현식 끝에 자주 사용됩니다.</p>\n<p>예를 들어, 다음 패턴은 \"a\" 바로 뒤에 \"b\"가 오는 경우에만 \"a\"와 일치합니다. 이 과정에서 \"b\"를 소비하지 않습니다:</p>\n<pre>\nPattern.compile(\"a(?=b)\");\n</pre>\n<p>그러나 전방 탐색은 정규식의 중간(또는 시작)에서도 사용할 수 있습니다. 이 경우 전방 탐색 뒤에 오는 것이 전방 탐색 내부의 패턴과 모순될 가능성이 있습니다. 전방 탐색은 입력을 소비하지 않으므로 전방 탐색이 일치할 수 없게 되며 이는 수정해야 할 정규 표현식에 실수가 있다는 신호입니다.</p>\n\n<h4>규칙을 준수하지 않는 코드 예시</h4>\n<pre>\nPattern.compile(\"(?=a)b\"); // 규칙 위반, 같은 문자가 동시에 'a'와 'b'가 될 수 없음\n</pre>\n<h4>규칙을 준수하는 해결책</h4>\n<pre>\nPattern.compile(\"(?&lt;=a)b\");\nPattern.compile(\"a(?=b)\");\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": ""
  },
  {
    "id": "S5842",
    "key": "java:S5842",
    "name": "Repeated patterns in regular expressions should not match the empty string",
    "type": "bug",
    "severity": "minor",
    "tags": [
      "regex"
    ],
    "why": "<p>A regex should never include a repetitive pattern whose body would match the empty string. This is usually a sign that a part of the regex is\nredundant or does not do what the author intended.</p>\n<h3>Noncompliant code example</h3>\n<pre>\n\"(?:)*\"      // same as the empty regex, the '*' accomplishes nothing\n\"(?:|x)*\"    // same as the empty regex, the alternative has no effect\n\"(?:x|)*\"    // same as 'x*', the empty alternative has no effect\n\"(?:x*|y*)*\" // same as 'x*', the first alternative would always match, y* is never tried\n\"(?:x?)*\"    // same as 'x*'\n\"(?:x?)+\"    // same as 'x*'\n</pre>\n<h3>Compliant solution</h3>\n<pre>\n\"x*\"\n</pre>",
    "howToFix": "",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "정규식의 반복 패턴은 빈 문자열과 일치하면 안 됩니다",
    "why_ko": "<p>정규식에는 본문이 빈 문자열과 일치하는 반복 패턴이 포함되면 안 됩니다. 이는 일반적으로 정규식의 일부가 중복되거나 작성자가 의도한 대로 작동하지 않는다는 신호입니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\n\"(?:)*\"      // 빈 정규식과 동일, '*'가 아무 것도 수행하지 않음\n\"(?:|x)*\"    // 빈 정규식과 동일, 대안이 효과가 없음\n\"(?:x|)*\"    // 'x*'와 동일, 빈 대안이 효과가 없음\n\"(?:x*|y*)*\" // 'x*'와 동일, 첫 번째 대안이 항상 일치하여 y*는 시도되지 않음\n\"(?:x?)*\"    // 'x*'와 동일\n\"(?:x?)+\"    // 'x*'와 동일\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre>\n\"x*\"\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": ""
  },
  {
    "id": "S104",
    "key": "java:S104",
    "name": "Files should not have too many lines of code",
    "type": "code-smell",
    "severity": "major",
    "tags": [
      "brain-overload"
    ],
    "why": "<p>When a source file grows too much, it can accumulate numerous responsibilities and become challenging to understand and maintain.</p>\n<p>Above a specific threshold, refactor the file into smaller files whose code focuses on well-defined tasks. Those smaller files will be easier to\nunderstand and test.</p>",
    "howToFix": "",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "파일에 너무 많은 코드 라인이 있으면 안 됩니다","why_ko": "<p>소스 파일이 너무 커지면 수많은 책임이 축적되어 이해하고 유지보수하기 어려워질 수 있습니다.</p>\n<p>특정 임계값을 초과하면 파일을 잘 정의된 작업에 집중하는 더 작은 파일들로 리팩토링하세요. 그러한 작은 파일들은 이해하고 테스트하기 더 쉬울 것입니다.</p>",
    "howToFix_ko": "",
    "moreInfo_ko": ""
  },
  {
    "id": "S2112",
    "key": "java:S2112",
    "name": "\"URL.hashCode\" and \"URL.equals\" should be avoided",
    "type": "code-smell",
    "severity": "major",
    "tags": [
      "performance"
    ],
    "why": "<p>The <code>equals</code> and <code>hashCode</code> methods of <code>java.net.URL</code> may trigger a name service lookup (typically DNS) to resolve\nthe hostname or IP address. Depending on the configuration, and network status, this lookup can be time-consuming.</p>\n<p>On the other hand, the <code>URI</code> class does not perform such lookups and is a better choice unless you specifically require the\nfunctionality provided by <code>URL</code>.</p>\n<p>In general, it is better to use the <code>URI</code> class until access to the resource is actually needed, at which point you can convert the\n<code>URI</code> to a <code>URL</code> using <code>URI.toURL()</code>.</p>\n<p>This rule checks for uses of <code>URL</code> 's in <code>Map</code> and <code>Set</code> , and for explicit calls to the <code>equals</code> and\n<code>hashCode</code> methods. It suggests reconsidering the use of <code>URL</code> in such scenarios to avoid potential performance issues related\nto name service lookups.</p>",
    "howToFix": "<p>Use the <code>URI</code> class until access to the resource is actually needed.</p>\n\n<h4>Noncompliant code example</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\npublic void checkUrl(URL url) {\n  Set&lt;URL&gt; sites = new HashSet&lt;URL&gt;();               // Noncompliant\n\n  URL homepage = new URL(\"http://sonarsource.com\");  // Compliant\n  if (homepage.equals(url)) {                        // Noncompliant\n    // ...\n  }\n}\n</pre>\n<h4>Compliant solution</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\npublic void checkUrl(URL url) {\n  Set&lt;URI&gt; sites = new HashSet&lt;URI&gt;();               // Compliant\n\n  URI homepage = new URI(\"http://sonarsource.com\");  // Compliant\n  URI uri = url.toURI();\n  if (homepage.equals(uri)) {                        // Compliant\n    // ...\n  }\n}\n</pre>",
    "moreInfo": "<ul>\n  <li> <a href=\"https://docs.oracle.com/en/java/javase/20/docs/api/java.base/java/net/URL.html\">Oracle Java SE - java.net.URL</a> </li>\n</ul>",
    "status": "READY",
    "name_ko": "\"URL.hashCode\"와 \"URL.equals\"는 피해야 합니다",
    "why_ko": "<p><code>java.net.URL</code>의 <code>equals</code>와 <code>hashCode</code> 메서드는 호스트명이나 IP 주소를 확인하기 위해 이름 서비스 조회(일반적으로 DNS)를 트리거할 수 있습니다. 구성과 네트워크 상태에 따라 이 조회는 시간이 오래 걸릴 수 있습니다.</p>\n<p>반면에 <code>URI</code> 클래스는 그러한 조회를 수행하지 않으며, <code>URL</code>이 제공하는 기능이 특별히 필요하지 않은 한 더 나은 선택입니다.</p>\n<p>일반적으로 리소스에 대한 실제 접근이 필요할 때까지 <code>URI</code> 클래스를 사용하고, 그 시점에 <code>URI.toURL()</code>을 사용하여 <code>URI</code>를 <code>URL</code>로 변환하는 것이 좋습니다.</p>\n<p>이 규칙은 <code>Map</code>과 <code>Set</code>에서 <code>URL</code>의 사용과 <code>equals</code> 및 <code>hashCode</code> 메서드에 대한 명시적 호출을 검사합니다. 이름 서비스 조회와 관련된 잠재적 성능 문제를 피하기 위해 이러한 시나리오에서 <code>URL</code> 사용을 재고할 것을 제안합니다.</p>",
    "howToFix_ko": "<p>리소스에 대한 실제 접근이 필요할 때까지 <code>URI</code> 클래스를 사용하세요.</p>\n\n<h4>규칙을 준수하지 않는 코드 예시</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\npublic void checkUrl(URL url) {\n  Set&lt;URL&gt; sites = new HashSet&lt;URL&gt;();               // 규칙 위반\n\n  URL homepage = new URL(\"http://sonarsource.com\");  // 규칙 준수\n  if (homepage.equals(url)) {                        // 규칙 위반\n    // ...\n  }\n}\n</pre>\n<h4>규칙을 준수하는 해결책</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\npublic void checkUrl(URL url) {\n  Set&lt;URI&gt; sites = new HashSet&lt;URI&gt;();               // 규칙 준수\n\n  URI homepage = new URI(\"http://sonarsource.com\");  // 규칙 준수\n  URI uri = url.toURI();\n  if (homepage.equals(uri)) {                        // 규칙 준수\n    // ...\n  }\n}\n</pre>",
    "moreInfo_ko": "<ul>\n  <li> <a href=\"https://docs.oracle.com/en/java/javase/20/docs/api/java.base/java/net/URL.html\">Oracle Java SE - java.net.URL</a> </li>\n</ul>"
  },
  {
    "id": "S1694",
    "key": "java:S1694",
    "name": "An abstract class should have both abstract and concrete methods",
    "type": "code-smell",
    "severity": "minor",
    "tags": [
      "convention"
    ],
    "why": "<p>The purpose of an abstract class is to provide some heritable behaviors while also defining methods which must be implemented by sub-classes.</p>\n<p>A class with no abstract methods that was made abstract purely to prevent instantiation should be converted to a concrete class (i.e. remove the\n<code>abstract</code> keyword) with a private constructor.</p>\n<p>A class with only abstract methods and no inheritable behavior should be converted to an interface.</p>\n<h3>Noncompliant code example</h3>\n<pre>\npublic abstract class Animal {  // Noncompliant; should be an interface\n  abstract void move();\n  abstract void feed();\n}\n\npublic abstract class Color {  // Noncompliant; should be concrete with a private constructor\n  private int red = 0;\n  private int green = 0;\n  private int blue = 0;\n\n  public int getRed() {\n    return red;\n  }\n}\n</pre>\n<h3>Compliant solution</h3>\n<pre>\npublic interface Animal {\n  void move();\n  void feed();\n}\n\npublic class Color {\n  private int red = 0;\n  private int green = 0;\n  private int blue = 0;\n\n  private Color () {}\n\n  public int getRed() {\n    return red;\n  }\n}\n\npublic abstract class Lamp {\n\n  private boolean switchLamp=false;\n\n  public abstract void glow();\n\n  public void flipSwitch() {\n    switchLamp = !switchLamp;\n    if (switchLamp) {\n      glow();\n    }\n  }\n}\n</pre>",
    "howToFix": "",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "추상 클래스는 추상 메서드와 구체 메서드를 모두 가져야 합니다",
    "why_ko": "<p>추상 클래스의 목적은 일부 상속 가능한 동작을 제공하면서 서브클래스가 구현해야 하는 메서드를 정의하는 것입니다.</p>\n<p>인스턴스화를 방지하기 위해 순수하게 abstract로 만들어진 추상 메서드가 없는 클래스는 private 생성자가 있는 구체 클래스(즉, <code>abstract</code> 키워드 제거)로 변환해야 합니다.</p>\n<p>추상 메서드만 있고 상속 가능한 동작이 없는 클래스는 인터페이스로 변환해야 합니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\npublic abstract class Animal {  // 규칙 위반; 인터페이스여야 함\n  abstract void move();\n  abstract void feed();\n}\n\npublic abstract class Color {  // 규칙 위반; private 생성자가 있는 구체 클래스여야 함\n  private int red = 0;\n  private int green = 0;\n  private int blue = 0;\n\n  public int getRed() {\n    return red;\n  }\n}\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre>\npublic interface Animal {\n  void move();\n  void feed();\n}\n\npublic class Color {\n  private int red = 0;\n  private int green = 0;\n  private int blue = 0;\n\n  private Color () {}\n\n  public int getRed() {\n    return red;\n  }\n}\n\npublic abstract class Lamp {\n\n  private boolean switchLamp=false;\n\n  public abstract void glow();\n\n  public void flipSwitch() {\n    switchLamp = !switchLamp;\n    if (switchLamp) {\n      glow();\n    }\n  }\n}\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": ""
  },
  {
    "id": "S2057",
    "key": "java:S2057",
    "name": "\"Serializable\" classes should have a \"serialVersionUID\"",
    "type": "code-smell",
    "severity": "critical",
    "tags": [
      "serialization",
      "cert",
      "pitfall"
    ],
    "why": "<p>A <code>serialVersionUID</code> field is strongly recommended in all <code>Serializable</code> classes. If you do not provide one, one will be\ncalculated for you by the compiler. The danger in not explicitly choosing the value is that when the class changes, the compiler will generate an\nentirely new id, and you will be suddenly unable to deserialize (read from file) objects that were serialized with the previous version of the\nclass.</p>\n<p><code>serialVersionUID</code>'s should be declared with all of these modifiers: <code>static final long</code>.</p>\n<h3>Noncompliant code example</h3>\n<pre>\npublic class Raspberry extends Fruit  // Noncompliant; no serialVersionUID.\n        implements Serializable {\n  private String variety;\n\n  public Raspberry(Season ripe, String variety) { ...}\n  public void setVariety(String variety) {...}\n  public String getVarity() {...}\n}\n\npublic class Raspberry extends Fruit\n        implements Serializable {\n  private final int serialVersionUID = 1; // Noncompliant; not static &amp; int rather than long\n</pre>\n<h3>Compliant solution</h3>\n<pre>\npublic class Raspberry extends Fruit\n        implements Serializable {\n  private static final long serialVersionUID = 1;\n  private String variety;\n\n  public Raspberry(Season ripe, String variety) { ...}\n  public void setVariety(String variety) {...}\n  public String getVarity() {...}\n}\n</pre>\n<h3>Exceptions</h3>\n<p>Records, Swing and AWT classes, <code>abstract</code> classes, <code>Throwable</code> and its subclasses (<code>Exception</code>s and\n<code>Error</code>s), and classes marked with <code>@SuppressWarnings(\"serial\")</code> are ignored.</p>",
    "howToFix": "",
    "moreInfo": "<ul>\n  <li> <a href=\"https://wiki.sei.cmu.edu/confluence/x/ajdGBQ\">CERT, SER00-J.</a> - Enable serialization compatibility during class evolution </li>\n  <li> <a href=\"https://docs.oracle.com/en/java/javase/16/docs/specs/serialization/serial-arch.html#serialization-of-records\">Record Serialization</a>\n  - Serialization of Records </li>\n</ul>",
    "status": "READY",
    "name_ko": "\"Serializable\" 클래스는 \"serialVersionUID\"를 가져야 합니다",
    "why_ko": "<p><code>serialVersionUID</code> 필드는 모든 <code>Serializable</code> 클래스에서 강력히 권장됩니다. 제공하지 않으면 컴파일러가 자동으로 계산합니다. 값을 명시적으로 선택하지 않는 위험은 클래스가 변경될 때 컴파일러가 완전히 새로운 id를 생성하여 이전 버전의 클래스로 직렬화된 객체를 갑자기 역직렬화(파일에서 읽기)할 수 없게 된다는 것입니다.</p>\n<p><code>serialVersionUID</code>는 다음의 모든 수정자로 선언해야 합니다: <code>static final long</code>.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\npublic class Raspberry extends Fruit  // 규칙 위반; serialVersionUID 없음.\n        implements Serializable {\n  private String variety;\n\n  public Raspberry(Season ripe, String variety) { ...}\n  public void setVariety(String variety) {...}\n  public String getVarity() {...}\n}\n\npublic class Raspberry extends Fruit\n        implements Serializable {\n  private final int serialVersionUID = 1; // 규칙 위반; static이 아니며 long이 아닌 int\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre>\npublic class Raspberry extends Fruit\n        implements Serializable {\n  private static final long serialVersionUID = 1;\n  private String variety;\n\n  public Raspberry(Season ripe, String variety) { ...}\n  public void setVariety(String variety) {...}\n  public String getVarity() {...}\n}\n</pre>\n<h3>예외</h3>\n<p>Records, Swing 및 AWT 클래스, <code>abstract</code> 클래스, <code>Throwable</code> 및 그 하위 클래스(<code>Exception</code> 및 <code>Error</code>), 그리고 <code>@SuppressWarnings(\"serial\")</code>로 표시된 클래스는 무시됩니다.</p>",
    "howToFix_ko": "",
    "moreInfo_ko": "<ul>\n  <li> <a href=\"https://wiki.sei.cmu.edu/confluence/x/ajdGBQ\">CERT, SER00-J.</a> - Enable serialization compatibility during class evolution </li>\n  <li> <a href=\"https://docs.oracle.com/en/java/javase/16/docs/specs/serialization/serial-arch.html#serialization-of-records\">Record Serialization</a> - Serialization of Records </li>\n</ul>"
  },
  {
    "id": "S1155",
    "key": "java:S1155",
    "name": "\"Collection.isEmpty()\" should be used to test for emptiness",
    "type": "code-smell",
    "severity": "minor",
    "tags": [
      "clumsy"
    ],
    "why": "<p>When you call <code>isEmpty()</code>, it clearly communicates the code's intention, which is to check if the collection is empty. Using\n<code>size() == 0</code> for this purpose is less direct and makes the code slightly more complex.</p>\n<p>Moreover, depending on the implementation, the <code>size()</code> method can have a time complexity of <code>O(n)</code> where <code>n</code> is\nthe number of elements in the collection. On the other hand, <code>isEmpty()</code> simply checks if there is at least one element in the collection,\nwhich is a constant time operation, <code>O(1)</code>.</p>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\npublic class MyClass {\n  public void doSomething(Collection&lt;String&gt; myCollection) {\n    if (myCollection.size() == 0) { // Noncompliant\n      doSomethingElse();\n    }\n  }\n}\n</pre>\n<p>Prefer using <code>isEmpty()</code> to test for emptiness over <code>size()</code>.</p>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\npublic class MyClass {\n  public void doSomething(Collection&lt;String&gt; myCollection) {\n    if (myCollection.isEmpty()) {\n      doSomethingElse();\n    }\n  }\n}\n</pre>",
    "howToFix": "",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "빈 컬렉션 확인에는 \"Collection.isEmpty()\"를 사용해야 합니다",
    "why_ko": "<p><code>isEmpty()</code>를 호출하면 컬렉션이 비어 있는지 확인하려는 코드의 의도가 명확하게 전달됩니다. 이 목적으로 <code>size() == 0</code>을 사용하는 것은 덜 직접적이고 코드를 약간 더 복잡하게 만듭니다.</p>\n<p>또한 구현에 따라 <code>size()</code> 메서드는 컬렉션의 요소 수인 <code>n</code>에 대해 <code>O(n)</code>의 시간 복잡도를 가질 수 있습니다. 반면 <code>isEmpty()</code>는 단순히 컬렉션에 요소가 하나 이상 있는지 확인하는 상수 시간 연산 <code>O(1)</code>입니다.</p>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\npublic class MyClass {\n  public void doSomething(Collection&lt;String&gt; myCollection) {\n    if (myCollection.size() == 0) { // 규칙 위반\n      doSomethingElse();\n    }\n  }\n}\n</pre>\n<p>빈 컬렉션 확인에는 <code>size()</code>보다 <code>isEmpty()</code>를 사용하는 것이 좋습니다.</p>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\npublic class MyClass {\n  public void doSomething(Collection&lt;String&gt; myCollection) {\n    if (myCollection.isEmpty()) {\n      doSomethingElse();\n    }\n  }\n}\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": ""
  },
  {
    "id": "S4838",
    "key": "java:S4838",
    "name": "An iteration on a Collection should be performed on the type handled by the Collection",
    "type": "code-smell",
    "severity": "minor",
    "tags": [
      "bad-practice",
      "clumsy"
    ],
    "why": "<p>When iterating over an <code>Iterable</code> with a <code>for</code> loop, the iteration variable could have the same type as the type returned by\nthe iterator (the item type of the <code>Iterable</code>). This rule reports when a supertype of the item type is used for the variable instead, but\nthe variable is then explicitly downcast in the loop body.</p>\n<p>Using explicit type casts instead of leveraging the language's type system is a bad practice. It disables static type checking by the compiler for\nthe cast expressions, but potential errors will throw a <code>ClassCastException</code> during runtime instead.</p>",
    "howToFix": "<h4>Noncompliant code example</h4>\n<p>When declaring the iteration variable, use the item type for it instead of a supertype. Remove the explicit downcasts in the loop body.</p>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\nfor (Object item : getPersons()) { // Noncompliant, iteration element is implicitly upcast here\n  Person person = (Person) item; // Noncompliant, item is explicitly downcast here\n  person.getAddress();\n}\n</pre>\n<h4>Compliant solution</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\nfor (Person person : getPersons()) { // Compliant\n  person.getAddress();\n}\n</pre>\n<h4>Noncompliant code example</h4>\n<p>Alternatively, use the <code>var</code> keyword to automatically infer the variable type (since Java 10).</p>\n<pre data-diff-id=\"2\" data-diff-type=\"noncompliant\">\nfor (Object item : getPersons()) { // Noncompliant, iteration element is implicitly upcast here\n  Person person = (Person) item; // Noncompliant, item is explicitly downcast here\n  person.getAddress();\n}\n</pre>\n<h4>Compliant solution</h4>\n<pre data-diff-id=\"2\" data-diff-type=\"compliant\">\nfor (var person : getPersons()) { // Compliant\n  person.getAddress();\n}\n</pre>\n<h4>Compliant solution</h4>\n<p>The implicit upcast in the loop header is not reported when there is no downcast in the loop body.</p>\n<pre>\nfor (Object item : getPersons()) { // Compliant\n  System.out.println(item);\n}\n</pre>",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "Collection 반복은 해당 Collection이 처리하는 타입으로 수행해야 합니다",
    "why_ko": "<p><code>for</code> 루프로 <code>Iterable</code>을 반복할 때 반복 변수는 iterator가 반환하는 타입(<code>Iterable</code>의 항목 타입)과 동일한 타입을 가질 수 있습니다. 이 규칙은 변수에 항목 타입의 상위 타입이 대신 사용되지만 루프 본문에서 변수가 명시적으로 다운캐스트되는 경우를 보고합니다.</p>\n<p>언어의 타입 시스템을 활용하는 대신 명시적 타입 캐스트를 사용하는 것은 나쁜 관행입니다. 이것은 캐스트 표현식에 대한 컴파일러의 정적 타입 검사를 비활성화하지만 잠재적인 오류는 런타임 중에 <code>ClassCastException</code>을 던질 것입니다.</p>",
    "howToFix_ko": "<h4>규칙을 준수하지 않는 코드 예시</h4>\n<p>반복 변수를 선언할 때 상위 타입 대신 항목 타입을 사용하세요. 루프 본문에서 명시적 다운캐스트를 제거하세요.</p>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\nfor (Object item : getPersons()) { // 규칙 위반, 반복 요소가 여기서 암시적으로 업캐스트됨\n  Person person = (Person) item; // 규칙 위반, item이 여기서 명시적으로 다운캐스트됨\n  person.getAddress();\n}\n</pre>\n<h4>규칙을 준수하는 해결책</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\nfor (Person person : getPersons()) { // 규칙 준수\n  person.getAddress();\n}\n</pre>\n<h4>규칙을 준수하지 않는 코드 예시</h4>\n<p>또는 <code>var</code> 키워드를 사용하여 변수 타입을 자동으로 추론하세요(Java 10부터).</p>\n<pre data-diff-id=\"2\" data-diff-type=\"noncompliant\">\nfor (Object item : getPersons()) { // 규칙 위반, 반복 요소가 여기서 암시적으로 업캐스트됨\n  Person person = (Person) item; // 규칙 위반, item이 여기서 명시적으로 다운캐스트됨\n  person.getAddress();\n}\n</pre>\n<h4>규칙을 준수하는 해결책</h4>\n<pre data-diff-id=\"2\" data-diff-type=\"compliant\">\nfor (var person : getPersons()) { // 규칙 준수\n  person.getAddress();\n}\n</pre>\n<h4>규칙을 준수하는 해결책</h4>\n<p>루프 본문에 다운캐스트가 없으면 루프 헤더의 암시적 업캐스트는 보고되지 않습니다.</p>\n<pre>\nfor (Object item : getPersons()) { // 규칙 준수\n  System.out.println(item);\n}\n</pre>",
    "moreInfo_ko": ""
  },
  {
    "id": "S2647",
    "key": "java:S2647",
    "name": "Basic authentication should not be used",
    "type": "vulnerability",
    "severity": "critical",
    "tags": [],
    "why": "<p>Basic authentication is a simple and widely used method of user authentication for HTTP requests. When a client sends a request to a server that\nrequires authentication, the client includes the username and password (concatenated together and Base64 encoded) in the \"Authorization\" header of the\nHTTP request. The server verifies the credentials and grants access if they are valid. Every request sent to the server to a protected endpoint must\ninclude these credentials.</p>\n<p>Basic authentication is considered insecure for several reasons:</p>\n<ul>\n  <li> It transmits user credentials in plain text, making them susceptible to interception and eavesdropping. </li>\n  <li> It relies solely on the server's ability to verify the provided credentials. There is no mechanism for additional security measures like\n  multi-factor authentication or account lockouts after multiple failed login attempts. </li>\n  <li> It does not provide a way to manage user sessions securely. The client typically includes the credentials in every request, which creates more\n  opportunities for an attacker to steal these credentials. </li>\n</ul>\n<p>These security limitations make basic authentication an insecure choice for authentication or authorization over HTTP.</p>\n<h3>What is the potential impact?</h3>\n<p>Basic authentication transmits passwords in plain text, which makes it vulnerable to interception by attackers.</p>\n<h4>Session hijacking and man-in-the-middle attack</h4>\n<p>If an attacker gains access to the network traffic, they can easily capture the username and password. Basic authentication does not provide any\nmechanism to protect against session hijacking attacks. Once a user is authenticated, the session identifier (the username and password) is sent in\nclear text with each subsequent request. If attackers can intercept one request, they can use it to impersonate the authenticated user, gaining\nunauthorized access to their account and potentially performing malicious actions.</p>\n<h4>Brute-force attacks</h4>\n<p>Basic authentication does not have any built-in protection against brute-force attacks. Attackers can repeatedly guess passwords until they find\nthe correct one, especially if weak or commonly used passwords are used. This can lead to unauthorized access to user accounts and potential data\nbreaches.</p>",
    "howToFix": "<p>The following code uses basic authentication to send out an HTTP request to a protected endpoint.</p>\n<h4>Noncompliant code example</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\nimport org.apache.http.client.methods.HttpPost;\n\nString encoded = Base64.getEncoder().encodeToString(\"login:passwd\".getBytes());\nHttpPost httpPost = new HttpPost(\"http://api.example.com/foo\");\nhttpPost.setHeader(\"Authorization\", \"Basic \" + encoded); // Noncompliant\n</pre>\n<h4>Compliant solution</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\nimport org.apache.http.client.methods.HttpPost;\n\n// An access token should be retrieved before the HTTP request\nString accessToken = System.getenv(\"ACCESS_TOKEN\");\nHttpPost httpPost = new HttpPost(\"http://api.example.com/foo\");\nhttpPost.setHeader(\"Authorization\", \"Bearer \" + accessToken);\n</pre>\n<h3>How does this work?</h3>\n<h4>Token-based authentication and OAuth</h4>\n<p>Token-based authentication is a safer alternative than basic authentication. A unique token is generated upon successful authentication and sent to\nthe client, which is then included in subsequent requests. Therefore, it eliminates the need to transmit sensitive credentials with each request.\nOAuth also works by authenticating users via tokens. It gives even more flexibility on top of this by offering scopes, which limit an application's\naccess to a user's account.</p>\n<p>Additionally, both token-based authentication and OAuth support mechanisms for token expiration, revocation, and refresh. This gives more\nflexibility than basic authentication, as compromised tokens carry much less risk than a compromised password.</p>\n<h4>SSL encryption for HTTP requests</h4>\n<p>With basic authentication, user credentials are transmitted in plain text, which makes them vulnerable to interception and eavesdropping. However,\nwhen HTTPS is employed, the data is encrypted before transmission, making it significantly more difficult for attackers to intercept and decipher the\ncredentials. If no other form of authentication is possible for this code, then every request must be sent over HTTPS to ensure credentials are kept\nsafe.</p>",
    "moreInfo": "<h3>Documentation</h3>\n<ul>\n  <li> MDN web docs - <a href=\"https://developer.mozilla.org/en-US/docs/Web/HTTP/Authentication\">HTTP authentication</a> </li>\n</ul>\n<h3>Standards</h3>\n<ul>\n  <li> OWASP - <a href=\"https://owasp.org/Top10/A04_2021-Insecure_Design/\">Top 10 2021 Category A4 - Insecure Design</a> </li>\n  <li> OWASP - <a href=\"https://owasp.org/www-project-top-ten/2017/A3_2017-Sensitive_Data_Exposure\">Top 10 2017 Category A3 - Sensitive Data\n  Exposure</a> </li>\n  <li> <a href=\"https://cheatsheetseries.owasp.org/cheatsheets/Web_Service_Security_Cheat_Sheet.html#user-authentication\">OWASP Web Service Security\n  Cheat Sheet</a> </li>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/522\">CWE-522 - Insufficiently Protected Credentials</a> </li>\n  <li> STIG Viewer - <a href=\"https://stigviewer.com/stigs/application_security_and_development/2024-12-06/finding/V-222533\">Application Security and\n  Development: V-222533</a> - The application must authenticate all network connected endpoint devices before establishing any connection. </li>\n</ul>",
    "status": "DEPRECATED",
    "name_ko": "Basic 인증을 사용하면 안 됩니다",
    "why_ko": "<p>Basic 인증은 HTTP 요청에 대한 간단하고 널리 사용되는 사용자 인증 방법입니다. 클라이언트가 인증이 필요한 서버에 요청을 보내면 클라이언트는 HTTP 요청의 \"Authorization\" 헤더에 사용자 이름과 비밀번호(함께 연결되고 Base64로 인코딩됨)를 포함합니다. 서버는 자격 증명을 확인하고 유효하면 액세스를 허용합니다. 보호된 엔드포인트에 대한 서버로의 모든 요청에는 이러한 자격 증명이 포함되어야 합니다.</p>\n<p>Basic 인증은 여러 가지 이유로 안전하지 않은 것으로 간주됩니다:</p>\n<ul>\n  <li> 사용자 자격 증명을 일반 텍스트로 전송하여 가로채기 및 도청에 취약합니다. </li>\n  <li> 제공된 자격 증명을 확인하는 서버의 기능에만 의존합니다. 다중 요소 인증이나 여러 번의 로그인 시도 실패 후 계정 잠금과 같은 추가 보안 조치를 위한 메커니즘이 없습니다. </li>\n  <li> 사용자 세션을 안전하게 관리하는 방법을 제공하지 않습니다. 클라이언트는 일반적으로 모든 요청에 자격 증명을 포함하므로 공격자가 이러한 자격 증명을 훔칠 기회가 더 많아집니다. </li>\n</ul>\n<p>이러한 보안 제한으로 인해 Basic 인증은 HTTP를 통한 인증 또는 권한 부여에 안전하지 않은 선택입니다.</p>\n<h3>잠재적인 영향은 무엇입니까?</h3>\n<p>Basic 인증은 비밀번호를 일반 텍스트로 전송하므로 공격자의 가로채기에 취약합니다.</p>\n<h4>세션 하이재킹 및 중간자 공격</h4>\n<p>공격자가 네트워크 트래픽에 접근하면 사용자 이름과 비밀번호를 쉽게 캡처할 수 있습니다. Basic 인증은 세션 하이재킹 공격을 방지하는 메커니즘을 제공하지 않습니다. 사용자가 인증되면 세션 식별자(사용자 이름 및 비밀번호)가 각 후속 요청과 함께 일반 텍스트로 전송됩니다. 공격자가 한 요청을 가로챌 수 있다면 이를 사용하여 인증된 사용자로 가장하여 계정에 무단 액세스하고 잠재적으로 악의적인 작업을 수행할 수 있습니다.</p>\n<h4>무차별 대입 공격</h4>\n<p>Basic 인증은 무차별 대입 공격에 대한 기본 보호 기능이 없습니다. 공격자는 특히 약하거나 일반적으로 사용되는 비밀번호가 사용되는 경우 올바른 비밀번호를 찾을 때까지 반복적으로 비밀번호를 추측할 수 있습니다. 이로 인해 사용자 계정에 대한 무단 액세스와 잠재적인 데이터 침해가 발생할 수 있습니다.</p>",
    "howToFix_ko": "<p>다음 코드는 Basic 인증을 사용하여 보호된 엔드포인트에 HTTP 요청을 보냅니다.</p>\n<h4>규칙을 준수하지 않는 코드 예시</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\nimport org.apache.http.client.methods.HttpPost;\n\nString encoded = Base64.getEncoder().encodeToString(\"login:passwd\".getBytes());\nHttpPost httpPost = new HttpPost(\"http://api.example.com/foo\");\nhttpPost.setHeader(\"Authorization\", \"Basic \" + encoded); // 규칙 위반\n</pre>\n<h4>규칙을 준수하는 해결책</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\nimport org.apache.http.client.methods.HttpPost;\n\n// HTTP 요청 전에 액세스 토큰을 검색해야 함\nString accessToken = System.getenv(\"ACCESS_TOKEN\");\nHttpPost httpPost = new HttpPost(\"http://api.example.com/foo\");\nhttpPost.setHeader(\"Authorization\", \"Bearer \" + accessToken);\n</pre>\n<h3>어떻게 작동하나요?</h3>\n<h4>토큰 기반 인증 및 OAuth</h4>\n<p>토큰 기반 인증은 Basic 인증보다 안전한 대안입니다. 성공적인 인증 시 고유한 토큰이 생성되어 클라이언트로 전송되며, 이후 요청에 포함됩니다. 따라서 각 요청과 함께 민감한 자격 증명을 전송할 필요가 없습니다. OAuth도 토큰을 통해 사용자를 인증합니다. 또한 애플리케이션의 사용자 계정 액세스를 제한하는 스코프를 제공하여 더 많은 유연성을 제공합니다.</p>\n<p>또한 토큰 기반 인증과 OAuth 모두 토큰 만료, 취소 및 새로 고침 메커니즘을 지원합니다. 이는 Basic 인증보다 더 많은 유연성을 제공하며, 손상된 토큰은 손상된 비밀번호보다 훨씬 적은 위험을 수반합니다.</p>\n<h4>HTTP 요청에 대한 SSL 암호화</h4>\n<p>Basic 인증을 사용하면 사용자 자격 증명이 일반 텍스트로 전송되어 가로채기 및 도청에 취약합니다. 그러나 HTTPS를 사용하면 전송 전에 데이터가 암호화되어 공격자가 자격 증명을 가로채고 해독하기가 훨씬 더 어려워집니다. 이 코드에 다른 형태의 인증이 불가능한 경우 모든 요청은 자격 증명을 안전하게 유지하기 위해 HTTPS를 통해 전송되어야 합니다.</p>",
    "moreInfo_ko": "<h3>문서</h3>\n<ul>\n  <li> MDN web docs - <a href=\"https://developer.mozilla.org/en-US/docs/Web/HTTP/Authentication\">HTTP authentication</a> </li>\n</ul>\n<h3>표준</h3>\n<ul>\n  <li> OWASP - <a href=\"https://owasp.org/Top10/A04_2021-Insecure_Design/\">Top 10 2021 Category A4 - Insecure Design</a> </li>\n  <li> OWASP - <a href=\"https://owasp.org/www-project-top-ten/2017/A3_2017-Sensitive_Data_Exposure\">Top 10 2017 Category A3 - Sensitive Data Exposure</a> </li>\n  <li> <a href=\"https://cheatsheetseries.owasp.org/cheatsheets/Web_Service_Security_Cheat_Sheet.html#user-authentication\">OWASP Web Service Security Cheat Sheet</a> </li>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/522\">CWE-522 - Insufficiently Protected Credentials</a> </li>\n  <li> STIG Viewer - <a href=\"https://stigviewer.com/stigs/application_security_and_development/2024-12-06/finding/V-222533\">Application Security and Development: V-222533</a> - 애플리케이션은 연결을 설정하기 전에 모든 네트워크 연결 엔드포인트 장치를 인증해야 합니다. </li>\n</ul>"
  },
  {
    "id": "S128",
    "key": "java:S128",
    "name": "Switch cases should end with an unconditional \"break\" statement",
    "type": "code-smell",
    "severity": "blocker",
    "tags": [
      "cwe",
      "cert",
      "suspicious"
    ],
    "why": "<p>When the execution is not explicitly terminated at the end of a switch case, it continues to execute the statements of the following case. While\nthis is sometimes intentional, it often is a mistake which leads to unexpected behavior.</p>\n<h3>Noncompliant code example</h3>\n<pre>\nswitch (myVariable) {\n  case 1:\n    foo();\n    break;\n  case 2:  // Both 'doSomething()' and 'doSomethingElse()' will be executed. Is it on purpose ?\n    doSomething();\n  default:\n    doSomethingElse();\n    break;\n}\n</pre>\n<h3>Compliant solution</h3>\n<pre>\nswitch (myVariable) {\n  case 1:\n    foo();\n    break;\n  case 2:\n    doSomething();\n    break;\n  default:\n    doSomethingElse();\n    break;\n}\n</pre>\n<h3>Exceptions</h3>\n<p>This rule is relaxed in the following cases:</p>\n<pre>\nswitch (myVariable) {\n  case 0:                                // Empty case used to specify the same behavior for a group of cases.\n  case 1:\n    doSomething();\n    break;\n  case 2:                                // Use of a fallthrough comment\n    // fallthrough\n  case 3:                                // Use of return statement\n    return;\n  case 4:                                // Use of throw statement\n    throw new IllegalStateException();\n  case 5:                                // Use of continue statement\n    continue;\n  default:                               // For the last case, use of break statement is optional\n    doSomethingElse();\n}\n</pre>",
    "howToFix": "",
    "moreInfo": "<ul>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/484\">CWE-484 - Omitted Break Statement in Switch</a> </li>\n  <li> <a href=\"https://wiki.sei.cmu.edu/confluence/x/ldYxBQ\">CERT, MSC17-C.</a> - Finish every set of statements associated with a case label with a\n  break statement </li>\n  <li> <a href=\"https://wiki.sei.cmu.edu/confluence/x/1DdGBQ\">CERT, MSC52-J.</a> - Finish every set of statements associated with a case label with a\n  break statement </li>\n</ul>",
    "status": "READY",
    "name_ko": "Switch case는 무조건적인 \"break\" 문으로 끝나야 합니다",
    "why_ko": "<p>switch case 끝에서 실행이 명시적으로 종료되지 않으면 다음 case의 문장을 계속 실행합니다. 이것이 의도적인 경우도 있지만, 종종 예기치 않은 동작으로 이어지는 실수입니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\nswitch (myVariable) {\n  case 1:\n    foo();\n    break;\n  case 2:  // 'doSomething()'과 'doSomethingElse()' 둘 다 실행됩니다. 의도한 건가요?\n    doSomething();\n  default:\n    doSomethingElse();\n    break;\n}\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre>\nswitch (myVariable) {\n  case 1:\n    foo();\n    break;\n  case 2:\n    doSomething();\n    break;\n  default:\n    doSomethingElse();\n    break;\n}\n</pre>\n<h3>예외</h3>\n<p>이 규칙은 다음 경우에 완화됩니다:</p>\n<pre>\nswitch (myVariable) {\n  case 0:                                // case 그룹에 동일한 동작을 지정하기 위해 사용되는 빈 case\n  case 1:\n    doSomething();\n    break;\n  case 2:                                // fallthrough 주석 사용\n    // fallthrough\n  case 3:                                // return 문 사용\n    return;\n  case 4:                                // throw 문 사용\n    throw new IllegalStateException();\n  case 5:                                // continue 문 사용\n    continue;\n  default:                               // 마지막 case의 경우 break 문 사용은 선택 사항입니다\n    doSomethingElse();\n}\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": "<ul>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/484\">CWE-484 - Switch에서 Break 문 생략</a> </li>\n  <li> <a href=\"https://wiki.sei.cmu.edu/confluence/x/ldYxBQ\">CERT, MSC17-C.</a> - case 레이블과 관련된 모든 문장 집합을 break 문으로 끝내세요 </li>\n  <li> <a href=\"https://wiki.sei.cmu.edu/confluence/x/1DdGBQ\">CERT, MSC52-J.</a> - case 레이블과 관련된 모든 문장 집합을 break 문으로 끝내세요 </li>\n</ul>"
  },
  {
    "id": "S6891",
    "key": "java:S6891",
    "name": "Exact alarms should not be abused",
    "type": "code-smell",
    "severity": "major",
    "tags": [
      "java",
      "android",
      "sustainability"
    ],
    "why": "<p>The use of exact alarms triggers the device to wake up at precise times that can lead several wake-ups in a short period of time. The wake-up\nmechanism is a significant battery drain because it requires powering up the main processor and pulling it out of a low-power state.</p>\n<p>It's highly recommended to create an inexact alarm whenever possible.</p>\n<p>It is also recommended for normal timing operations, such as ticks and timeouts, using the <code>Handler</code>, and for long-running operations,\nsuch as network downloads, using <code>WorkManager</code> or <code>JobScheduler</code>.</p>\n<h3>What is the potential impact?</h3>\n<ul>\n  <li> <em>Usability</em>: the device may run out of battery faster than expected. </li>\n  <li> <em>Sustainability</em>: the extra battery usage has a negative impact on the environment. </li>\n</ul>",
    "howToFix": "<p>Replace occurrences of <code>setExact</code> with <code>set</code> and <code>setExactAndAllowWhileIdle</code> with\n<code>setAndAllowWhileIdle</code>, and avoid to use <code>setWindow</code> with a window less than 10 minutes.</p>\n<p>Alternatively, consider using <code>Handler</code>, <code>WorkManager</code> or <code>JobScheduler</code> instead of <code>AlarmManager</code> when\npossible, depending on your use case.</p>\n\n<h4>Noncompliant code example</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\npublic class AlarmScheduler {\n    private Context context;\n\n    public AlarmScheduler(Context context) {\n        this.context = context;\n    }\n\n    public void scheduleAlarm(long triggerTime) {\n        AlarmManager alarmManager = (AlarmManager) context.getSystemService(Context.ALARM_SERVICE);\n        Intent intent = new Intent(context, AlarmReceiver.class);\n        PendingIntent pendingIntent = PendingIntent.getBroadcast(context, 0, intent, 0);\n\n        alarmManager.setExact(AlarmManager.RTC_WAKEUP, triggerTime, pendingIntent); // Noncompliant, avoid using exact alarms unless necessary\n        alarmManager.setExactAndAllowWhileIdle(AlarmManager.RTC_WAKEUP, triggerTime, pendingIntent); // Noncompliant, avoid using exact alarms unless necessary\n\n        long windowLengthMillis = 5 * 60 * 1000; // 5 minutes in milliseconds\n        alarmManager.setWindow(AlarmManager.RTC_WAKEUP, triggerTime, windowLengthMillis, pendingIntent); // Noncompliant, don't use windows below 10 minutes\n    }\n}\n</pre>\n<h4>Compliant solution</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\npublic class AlarmScheduler {\n    private Context context;\n\n    public AlarmScheduler(Context context) {\n        this.context = context;\n    }\n\n    public void scheduleAlarm(long triggerTime) {\n        AlarmManager alarmManager = (AlarmManager) context.getSystemService(Context.ALARM_SERVICE);\n        Intent intent = new Intent(context, AlarmReceiver.class);\n        PendingIntent pendingIntent = PendingIntent.getBroadcast(context, 0, intent, 0);\n\n        alarmManager.set(AlarmManager.RTC_WAKEUP, triggerTime, pendingIntent); // Compliant\n        alarmManager.setAndAllowWhileIdle(AlarmManager.RTC_WAKEUP, triggerTime, pendingIntent);  // Compliant\n\n        long windowLengthMillis = 10 * 60 * 1000; // 10 minutes in milliseconds\n        alarmManager.setWindow(AlarmManager.RTC_WAKEUP, triggerTime, windowLengthMillis, pendingIntent); // Compliant\n    }\n}\n</pre>",
    "moreInfo": "<h3>Documentation</h3>\n<ul>\n  <li> <a href=\"https://developer.android.com/reference/android/app/AlarmManager\">Android for Developers - AlarmManager</a> </li>\n  <li> <a href=\"https://developer.android.com/about/versions/kitkat/android-4.4\">Android for Developers - AlarmManager with SDK Version 19</a> </li>\n  <li> <a href=\"https://developer.android.com/develop/background-work/services/alarms/schedule#exact-acceptable-use-cases\">Android for Developers -\n  Schedule alarms</a> </li>\n  <li> <a href=\"https://developer.android.com/reference/android/os/Handler\">Android for Developers - Handler</a> </li>\n  <li> <a href=\"https://developer.android.com/reference/androidx/work/WorkManager\">Android for Developers - WorkManager</a> </li>\n  <li> <a href=\"https://developer.android.com/reference/android/app/job/JobScheduler\">Android for Developers - JobScheduler</a> </li>\n</ul>",
    "status": "READY",
    "name_ko": "정확한 알람을 남용하면 안 됩니다",
    "why_ko": "<p>정확한 알람을 사용하면 장치가 정확한 시간에 깨어나도록 트리거되어 짧은 기간에 여러 번 깨어날 수 있습니다. 깨우기 메커니즘은 메인 프로세서를 켜고 저전력 상태에서 빠져나와야 하기 때문에 배터리 소모가 상당합니다.</p>\n<p>가능하면 부정확한 알람을 생성하는 것이 권장됩니다.</p>\n<p>또한 틱 및 타임아웃과 같은 일반적인 타이밍 작업에는 <code>Handler</code>를, 네트워크 다운로드와 같은 장기 실행 작업에는 <code>WorkManager</code> 또는 <code>JobScheduler</code>를 사용하는 것이 권장됩니다.</p>\n<h3>잠재적 영향은 무엇인가요?</h3>\n<ul>\n  <li> <em>사용성</em>: 장치의 배터리가 예상보다 빨리 소진될 수 있습니다. </li>\n  <li> <em>지속 가능성</em>: 추가 배터리 사용은 환경에 부정적인 영향을 미칩니다. </li>\n</ul>",
    "howToFix_ko": "<p><code>setExact</code>를 <code>set</code>으로, <code>setExactAndAllowWhileIdle</code>을 <code>setAndAllowWhileIdle</code>로 교체하고, 10분 미만의 윈도우로 <code>setWindow</code>를 사용하지 마세요.</p>\n<p>또는 사용 사례에 따라 가능한 경우 <code>AlarmManager</code> 대신 <code>Handler</code>, <code>WorkManager</code> 또는 <code>JobScheduler</code>를 사용하는 것을 고려하세요.</p>\n\n<h4>규칙을 준수하지 않는 코드 예시</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\npublic class AlarmScheduler {\n    private Context context;\n\n    public AlarmScheduler(Context context) {\n        this.context = context;\n    }\n\n    public void scheduleAlarm(long triggerTime) {\n        AlarmManager alarmManager = (AlarmManager) context.getSystemService(Context.ALARM_SERVICE);\n        Intent intent = new Intent(context, AlarmReceiver.class);\n        PendingIntent pendingIntent = PendingIntent.getBroadcast(context, 0, intent, 0);\n\n        alarmManager.setExact(AlarmManager.RTC_WAKEUP, triggerTime, pendingIntent); // 규칙 위반, 필요하지 않으면 정확한 알람 사용을 피하세요\n        alarmManager.setExactAndAllowWhileIdle(AlarmManager.RTC_WAKEUP, triggerTime, pendingIntent); // 규칙 위반, 필요하지 않으면 정확한 알람 사용을 피하세요\n\n        long windowLengthMillis = 5 * 60 * 1000; // 5분(밀리초)\n        alarmManager.setWindow(AlarmManager.RTC_WAKEUP, triggerTime, windowLengthMillis, pendingIntent); // 규칙 위반, 10분 미만의 윈도우를 사용하지 마세요\n    }\n}\n</pre>\n<h4>규칙을 준수하는 해결책</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\npublic class AlarmScheduler {\n    private Context context;\n\n    public AlarmScheduler(Context context) {\n        this.context = context;\n    }\n\n    public void scheduleAlarm(long triggerTime) {\n        AlarmManager alarmManager = (AlarmManager) context.getSystemService(Context.ALARM_SERVICE);\n        Intent intent = new Intent(context, AlarmReceiver.class);\n        PendingIntent pendingIntent = PendingIntent.getBroadcast(context, 0, intent, 0);\n\n        alarmManager.set(AlarmManager.RTC_WAKEUP, triggerTime, pendingIntent); // 규칙 준수\n        alarmManager.setAndAllowWhileIdle(AlarmManager.RTC_WAKEUP, triggerTime, pendingIntent);  // 규칙 준수\n\n        long windowLengthMillis = 10 * 60 * 1000; // 10분(밀리초)\n        alarmManager.setWindow(AlarmManager.RTC_WAKEUP, triggerTime, windowLengthMillis, pendingIntent); // 규칙 준수\n    }\n}\n</pre>",
    "moreInfo_ko": "<h3>문서</h3>\n<ul>\n  <li> <a href=\"https://developer.android.com/reference/android/app/AlarmManager\">Android 개발자 - AlarmManager</a> </li>\n  <li> <a href=\"https://developer.android.com/about/versions/kitkat/android-4.4\">Android 개발자 - SDK 버전 19의 AlarmManager</a> </li>\n  <li> <a href=\"https://developer.android.com/develop/background-work/services/alarms/schedule#exact-acceptable-use-cases\">Android 개발자 - 알람 예약</a> </li>\n  <li> <a href=\"https://developer.android.com/reference/android/os/Handler\">Android 개발자 - Handler</a> </li>\n  <li> <a href=\"https://developer.android.com/reference/androidx/work/WorkManager\">Android 개발자 - WorkManager</a> </li>\n  <li> <a href=\"https://developer.android.com/reference/android/app/job/JobScheduler\">Android 개발자 - JobScheduler</a> </li>\n</ul>"
  },
  {
    "id": "S7629",
    "key": "java:S7629",
    "name": "When a defaultFinisher is passed to a Gatherer factory, use the overload that does not take a finisher",
    "type": "code-smell",
    "severity": "minor",
    "tags": [
      "java24"
    ],
    "why": "<p>Passing an empty finisher to <code>Gatherer.of</code> or to <code>Gatherer.ofSequential</code> provides no additional value and removing the\nfinisher clearly communicates that no finisher is applied.</p>",
    "howToFix": "<p>Call the overload of <code>Gatherer.of</code> or <code>Gatherer.ofSequential</code> that does not take a finisher.</p>\n\n<h4>Noncompliant code example</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\nGatherer&lt;Integer, AtomicInteger, Integer&gt; gatherer = Gatherer.ofSequential(\n  () -&gt; new AtomicInteger(-1),\n  (state, number, downstream) -&gt; {\n    if (state.get() &lt; 0) {\n      state.set(number);\n      return true;\n    }\n    return downstream.push(number - state.get());\n  },\n  Gatherer.defaultFinisher()); // Noncompliant: useless finisher\n</pre>\n<h4>Compliant solution</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\nGatherer&lt;Integer, AtomicInteger, Integer&gt; gatherer = Gatherer.ofSequential(\n  () -&gt; new AtomicInteger(-1),\n  (state, number, downstream) -&gt; {\n    if (state.get() &lt; 0) {\n      state.set(number);\n      return true;\n    }\n    return downstream.push(number - state.get());\n  }); // Compliant\n</pre>",
    "moreInfo": "<ul>\n  <li> Oracle Documentation - <a href=\"https://docs.oracle.com/en/java/javase/24/docs/api/java.base/java/util/stream/Gatherer.html\">Gatherer API</a>\n  </li>\n</ul>",
    "status": "READY",
    "name_ko": "Gatherer 팩토리에 defaultFinisher를 전달할 때는 finisher를 받지 않는 오버로드를 사용하세요",
    "why_ko": "<p><code>Gatherer.of</code> 또는 <code>Gatherer.ofSequential</code>에 빈 finisher를 전달하는 것은 추가적인 가치를 제공하지 않으며, finisher를 제거하면 finisher가 적용되지 않음을 명확하게 전달합니다.</p>",
    "howToFix_ko": "<p>finisher를 받지 않는 <code>Gatherer.of</code> 또는 <code>Gatherer.ofSequential</code>의 오버로드를 호출하세요.</p>\n\n<h4>규칙을 준수하지 않는 코드 예시</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\nGatherer&lt;Integer, AtomicInteger, Integer&gt; gatherer = Gatherer.ofSequential(\n  () -&gt; new AtomicInteger(-1),\n  (state, number, downstream) -&gt; {\n    if (state.get() &lt; 0) {\n      state.set(number);\n      return true;\n    }\n    return downstream.push(number - state.get());\n  },\n  Gatherer.defaultFinisher()); // 규칙 위반: 쓸모없는 finisher\n</pre>\n<h4>규칙을 준수하는 해결책</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\nGatherer&lt;Integer, AtomicInteger, Integer&gt; gatherer = Gatherer.ofSequential(\n  () -&gt; new AtomicInteger(-1),\n  (state, number, downstream) -&gt; {\n    if (state.get() &lt; 0) {\n      state.set(number);\n      return true;\n    }\n    return downstream.push(number - state.get());\n  }); // 규칙 준수\n</pre>",
    "moreInfo_ko": "<ul>\n  <li> Oracle 문서 - <a href=\"https://docs.oracle.com/en/java/javase/24/docs/api/java.base/java/util/stream/Gatherer.html\">Gatherer API</a> </li>\n</ul>"
  },
  {
    "id": "S5301",
    "key": "java:S5301",
    "name": "\"ActiveMQConnectionFactory\" should not be vulnerable to malicious code deserialization",
    "type": "vulnerability",
    "severity": "minor",
    "tags": [
      "cwe"
    ],
    "why": "<p>When the application does not implement controls over the JMS object types, its clients could be able to force the deserialization of arbitrary\nobjects. This may lead to deserialization injection attacks.</p>\n<h3>What is the potential impact?</h3>\n<p>Attackers will be able to force the deserialization of arbitrary objects. This process will trigger the execution of magic unmarshalling methods on\nthe object and its properties. With a specially crafted serialized object, the attackers can exploit those magic methods to achieve malicious\npurposes.</p>\n<p>While the exact impact depends on the types available in the execution context at the time of deserialization, such an attack can generally lead to\nthe execution of arbitrary code on the application server.</p>\n<h4>Application-specific attacks</h4>\n<p>By exploiting the behavior of some of the application-defined types and objects, the attacker could manage to affect the application's business\nlogic. The exact consequences will depend on the application's nature:</p>\n<ul>\n  <li> Payment bypass in an e-commerce application. </li>\n  <li> Privilege escalation. </li>\n  <li> Unauthorized users' data access. </li>\n</ul>\n<h4>Publicly-known exploitation</h4>\n<p>In some cases, depending on the library the application uses and their versions, there may exist publicly known deserialization attack payloads\nknown as <strong>gadget chains</strong>. In general, they are designed to have severe consequences, such as:</p>\n<ul>\n  <li> Arbitrary code execution </li>\n  <li> Arbitrary file read or write </li>\n  <li> Server-side request forgery </li>\n</ul>\n<p>Those attacks are independent of the application's own logic and from the types it specifies.</p>",
    "howToFix": "<p>The following code example is vulnerable to a deserialization injection attack because it allows the deserialization of arbitrary types from JMS\nmessages.</p>\n<h4>Noncompliant code example</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\nActiveMQConnectionFactory factory = new ActiveMQConnectionFactory(\"tcp://localhost:61616\");\nfactory.setTrustAllPackages(true); // Noncompliant\n</pre>\n<h4>Compliant solution</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\nActiveMQConnectionFactory factory = new ActiveMQConnectionFactory(\"tcp://localhost:61616\");\nfactory.setTrustedPackages(Arrays.asList(\"org.mypackage1\", \"org.mypackage2\"));\n</pre>\n<h3>How does this work?</h3>\n<p>The noncompliant code example calls the <code>setTrustAllPackages</code> method that explicitly allows the deserialization of arbitrary types. On\nthe contrary, the compliant code example, thanks to the <code>setTrustedPackages</code> method, defines a short list of classes allowed for the\ndeserialization.</p>\n<p>While defining a short list of trusted types is generally the state-of-the-art solution to avoid deserialization injection attacks, it is important\nto ensure that the allowed classes and packages can not be used to exploit the issue. In that case, a vulnerability would still be present.</p>\n<p>Note that ActiveMQ, starting with version 5.12.2, forces developers to explicitly list packages that JMS messages can contain. This limits the risk\nof successful exploitation. In versions before that one, calling the <code>ActiveMQConnectionFactory</code> constructor without further configuration\nwould leave the application at risk.</p>",
    "moreInfo": "<h3>Documentation</h3>\n<ul>\n  <li> Apache ActiveMQ Documentation - <a href=\"https://activemq.apache.org/objectmessage.html\">ObjectMessage</a> </li>\n  <li> CVE - <a href=\"https://www.cve.org/CVERecord?id=CVE-2015-5254\">CVE-2015-5254</a> </li>\n</ul>\n<h3>Standards</h3>\n<ul>\n  <li> OWASP - <a href=\"https://owasp.org/Top10/A08_2021-Software_and_Data_Integrity_Failures/\">Top 10 2021 - Category A8 - Software and Data\n  Integrity Failures</a> </li>\n  <li> OWASP - <a href=\"https://owasp.org/www-project-top-ten/2017/A8_2017-Insecure_Deserialization\">Top 10 2017 - Category A8 - Insecure\n  Deserialization</a> </li>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/502\">CWE-502 - Deserialization of Untrusted Data</a> </li>\n</ul>",
    "status": "READY",
    "name_ko": "\"ActiveMQConnectionFactory\"는 악성 코드 역직렬화에 취약하면 안 됩니다",
    "why_ko": "<p>애플리케이션이 JMS 객체 타입에 대한 제어를 구현하지 않으면 클라이언트가 임의의 객체를 강제로 역직렬화할 수 있습니다. 이는 역직렬화 주입 공격으로 이어질 수 있습니다.</p>\n<h3>잠재적 영향은 무엇입니까?</h3>\n<p>공격자는 임의의 객체를 강제로 역직렬화할 수 있습니다. 이 프로세스는 객체와 그 속성에서 매직 언마샬링 메서드의 실행을 트리거합니다. 특별히 제작된 직렬화된 객체를 사용하여 공격자는 이러한 매직 메서드를 악용하여 악의적인 목적을 달성할 수 있습니다.</p>\n<p>정확한 영향은 역직렬화 시점에 실행 컨텍스트에서 사용 가능한 타입에 따라 다르지만, 이러한 공격은 일반적으로 애플리케이션 서버에서 임의 코드 실행으로 이어질 수 있습니다.</p>\n<h4>애플리케이션별 공격</h4>\n<p>애플리케이션에서 정의한 일부 타입과 객체의 동작을 악용하여 공격자는 애플리케이션의 비즈니스 로직에 영향을 미칠 수 있습니다. 정확한 결과는 애플리케이션의 특성에 따라 다릅니다:</p>\n<ul>\n  <li> 전자상거래 애플리케이션에서 결제 우회 </li>\n  <li> 권한 상승 </li>\n  <li> 무단 사용자 데이터 접근 </li>\n</ul>\n<h4>공개적으로 알려진 공격</h4>\n<p>경우에 따라 애플리케이션이 사용하는 라이브러리와 그 버전에 따라 <strong>가젯 체인</strong>이라고 알려진 공개적으로 알려진 역직렬화 공격 페이로드가 존재할 수 있습니다. 일반적으로 다음과 같은 심각한 결과를 초래하도록 설계되어 있습니다:</p>\n<ul>\n  <li> 임의 코드 실행 </li>\n  <li> 임의 파일 읽기 또는 쓰기 </li>\n  <li> 서버 측 요청 위조 </li>\n</ul>\n<p>이러한 공격은 애플리케이션 자체의 로직과 지정하는 타입과 무관합니다.</p>",
    "howToFix_ko": "<p>다음 코드 예제는 JMS 메시지에서 임의 타입의 역직렬화를 허용하기 때문에 역직렬화 주입 공격에 취약합니다.</p>\n<h4>규칙을 준수하지 않는 코드 예시</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\nActiveMQConnectionFactory factory = new ActiveMQConnectionFactory(\"tcp://localhost:61616\");\nfactory.setTrustAllPackages(true); // 규칙 위반\n</pre>\n<h4>규칙을 준수하는 해결책</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\nActiveMQConnectionFactory factory = new ActiveMQConnectionFactory(\"tcp://localhost:61616\");\nfactory.setTrustedPackages(Arrays.asList(\"org.mypackage1\", \"org.mypackage2\"));\n</pre>\n<h3>작동 원리</h3>\n<p>규칙을 준수하지 않는 코드 예제는 임의 타입의 역직렬화를 명시적으로 허용하는 <code>setTrustAllPackages</code> 메서드를 호출합니다. 반대로 규칙을 준수하는 코드 예제는 <code>setTrustedPackages</code> 메서드 덕분에 역직렬화가 허용된 클래스의 짧은 목록을 정의합니다.</p>\n<p>신뢰할 수 있는 타입의 짧은 목록을 정의하는 것이 일반적으로 역직렬화 주입 공격을 피하기 위한 최신 솔루션이지만, 허용된 클래스와 패키지가 문제를 악용하는 데 사용될 수 없도록 하는 것이 중요합니다. 그렇지 않으면 취약점이 여전히 존재합니다.</p>\n<p>ActiveMQ는 버전 5.12.2부터 개발자가 JMS 메시지에 포함될 수 있는 패키지를 명시적으로 나열하도록 강제합니다. 이는 성공적인 악용의 위험을 제한합니다. 그 이전 버전에서는 추가 구성 없이 <code>ActiveMQConnectionFactory</code> 생성자를 호출하면 애플리케이션이 위험에 노출됩니다.</p>",
    "moreInfo_ko": "<h3>문서</h3>\n<ul>\n  <li> Apache ActiveMQ 문서 - <a href=\"https://activemq.apache.org/objectmessage.html\">ObjectMessage</a> </li>\n  <li> CVE - <a href=\"https://www.cve.org/CVERecord?id=CVE-2015-5254\">CVE-2015-5254</a> </li>\n</ul>\n<h3>표준</h3>\n<ul>\n  <li> OWASP - <a href=\"https://owasp.org/Top10/A08_2021-Software_and_Data_Integrity_Failures/\">상위 10가지 2021 - 카테고리 A8 - 소프트웨어 및 데이터 무결성 실패</a> </li>\n  <li> OWASP - <a href=\"https://owasp.org/www-project-top-ten/2017/A8_2017-Insecure_Deserialization\">상위 10가지 2017 - 카테고리 A8 - 안전하지 않은 역직렬화</a> </li>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/502\">CWE-502 - 신뢰할 수 없는 데이터의 역직렬화</a> </li>\n</ul>"
  },
  {
    "id": "S2094",
    "key": "java:S2094",
    "name": "Classes should not be empty",
    "type": "code-smell",
    "severity": "minor",
    "tags": [
      "clumsy"
    ],
    "why": "<p>There is no good excuse for an empty class. If it's being used simply as a common extension point, it should be replaced with an\n<code>interface</code>. If it was stubbed in as a placeholder for future development it should be fleshed-out. In any other case, it should be\neliminated.</p>\n<h3>Noncompliant code example</h3>\n<pre>\npublic class Nothing {  // Noncompliant\n}\n</pre>\n<h3>Compliant solution</h3>\n<pre>\npublic interface Nothing {\n}\n</pre>\n<h3>Exceptions</h3>\n<p>Empty classes can be used as marker types (for Spring for instance), therefore empty classes that are annotated will be ignored.</p>\n<pre>\n@Configuration\n@EnableWebMvc\npublic final class ApplicationConfiguration {\n\n}\n</pre>",
    "howToFix": "",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "클래스는 비어 있으면 안 됩니다",
    "why_ko": "<p>빈 클래스에 대한 좋은 이유는 없습니다. 단순히 공통 확장 지점으로 사용되는 경우 <code>interface</code>로 대체해야 합니다. 향후 개발을 위한 플레이스홀더로 스텁된 경우 구체화해야 합니다. 다른 경우에는 제거해야 합니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\npublic class Nothing {  // 규칙 위반\n}\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre>\npublic interface Nothing {\n}\n</pre>\n<h3>예외</h3>\n<p>빈 클래스는 마커 타입(예: Spring용)으로 사용될 수 있으므로 어노테이션이 있는 빈 클래스는 무시됩니다.</p>\n<pre>\n@Configuration\n@EnableWebMvc\npublic final class ApplicationConfiguration {\n\n}\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": ""
  },
  {
    "id": "S6203",
    "key": "java:S6203",
    "name": "Text blocks should not be used in complex expressions",
    "type": "code-smell",
    "severity": "minor",
    "tags": [],
    "why": "<p>In Java 15 Text Blocks are official and can be used just like an ordinary String. However, when they are used to represent a big chunk of text,\nthey should not be used directly in complex expressions, as it decreases the readability. In this case, it is better to extract the text block into a\nvariable or a field.</p>\n<p>This rule reports an issue when a text block longer than a number of lines given as a parameter is directly used within a lambda expression.</p>\n<h3>Noncompliant code example</h3>\n<pre>\nlistOfString.stream()\n  .map(str -&gt; !\"\"\"\n    &lt;project&gt;\n      &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;\n      &lt;parent&gt;\n        &lt;groupId&gt;com.mycompany.app&lt;/groupId&gt;\n        &lt;artifactId&gt;my-app&lt;/artifactId&gt;\n        &lt;version&gt;1&lt;/version&gt;\n      &lt;/parent&gt;\n\n      &lt;groupId&gt;com.mycompany.app&lt;/groupId&gt;\n      &lt;artifactId&gt;my-module&lt;/artifactId&gt;\n      &lt;version&gt;1&lt;/version&gt;\n    &lt;/project&gt;\n    \"\"\".equals(str));\n</pre>\n<h3>Compliant solution</h3>\n<pre>\nString myTextBlock = \"\"\"\n    &lt;project&gt;\n      &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;\n      &lt;parent&gt;\n        &lt;groupId&gt;com.mycompany.app&lt;/groupId&gt;\n        &lt;artifactId&gt;my-app&lt;/artifactId&gt;\n        &lt;version&gt;1&lt;/version&gt;\n      &lt;/parent&gt;\n\n      &lt;groupId&gt;com.mycompany.app&lt;/groupId&gt;\n      &lt;artifactId&gt;my-module&lt;/artifactId&gt;\n      &lt;version&gt;1&lt;/version&gt;\n    &lt;/project&gt;\n    \"\"\";\n\nlistOfString.stream()\n  .map(str -&gt; !myTextBlock.equals(str));\n</pre>",
    "howToFix": "",
    "moreInfo": "<ul>\n  <li> <a href=\"https://openjdk.java.net/jeps/378\">JEP 378: Text Blocks</a> </li>\n  <li> <a href=\"https://openjdk.org/projects/amber/guides/text-blocks-guide\">Programmer's Guide To Text Blocks</a>, by Jim Laskey and Stuart Marks\n  </li>\n</ul>",
    "status": "READY",
    "name_ko": "텍스트 블록은 복잡한 표현식에서 사용하면 안 됩니다",
    "why_ko": "<p>Java 15에서 Text Block은 공식화되어 일반 String처럼 사용할 수 있습니다. 그러나 큰 텍스트 덩어리를 나타내는 데 사용할 때는 복잡한 표현식에서 직접 사용하면 가독성이 저하되므로 사용하지 않아야 합니다. 이 경우 텍스트 블록을 변수나 필드로 추출하는 것이 좋습니다.</p>\n<p>이 규칙은 매개변수로 지정된 줄 수보다 긴 텍스트 블록이 람다 표현식 내에서 직접 사용될 때 문제를 보고합니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\nlistOfString.stream()\n  .map(str -&gt; !\"\"\"\n    &lt;project&gt;\n      &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;\n      &lt;parent&gt;\n        &lt;groupId&gt;com.mycompany.app&lt;/groupId&gt;\n        &lt;artifactId&gt;my-app&lt;/artifactId&gt;\n        &lt;version&gt;1&lt;/version&gt;\n      &lt;/parent&gt;\n\n      &lt;groupId&gt;com.mycompany.app&lt;/groupId&gt;\n      &lt;artifactId&gt;my-module&lt;/artifactId&gt;\n      &lt;version&gt;1&lt;/version&gt;\n    &lt;/project&gt;\n    \"\"\".equals(str));\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre>\nString myTextBlock = \"\"\"\n    &lt;project&gt;\n      &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;\n      &lt;parent&gt;\n        &lt;groupId&gt;com.mycompany.app&lt;/groupId&gt;\n        &lt;artifactId&gt;my-app&lt;/artifactId&gt;\n        &lt;version&gt;1&lt;/version&gt;\n      &lt;/parent&gt;\n\n      &lt;groupId&gt;com.mycompany.app&lt;/groupId&gt;\n      &lt;artifactId&gt;my-module&lt;/artifactId&gt;\n      &lt;version&gt;1&lt;/version&gt;\n    &lt;/project&gt;\n    \"\"\";\n\nlistOfString.stream()\n  .map(str -&gt; !myTextBlock.equals(str));\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": "<ul>\n  <li> <a href=\"https://openjdk.java.net/jeps/378\">JEP 378: Text Blocks</a> </li>\n  <li> <a href=\"https://openjdk.org/projects/amber/guides/text-blocks-guide\">Programmer's Guide To Text Blocks</a>, Jim Laskey, Stuart Marks 작성\n  </li>\n</ul>"
  },
  {
    "id": "S5993",
    "key": "java:S5993",
    "name": "Constructors of an \"abstract\" class should not be declared \"public\"",
    "type": "code-smell",
    "severity": "major",
    "tags": [
      "design"
    ],
    "why": "<p>Abstract classes should not have public constructors. Constructors of abstract classes can only be called in constructors of their subclasses. So\nthere is no point in making them public. The <code>protected</code> modifier should be enough.</p>\n<h3>Noncompliant code example</h3>\n<pre>\npublic abstract class AbstractClass1 {\n    public AbstractClass1 () { // Noncompliant, has public modifier\n        // do something here\n    }\n}\n</pre>\n<h3>Compliant solution</h3>\n<pre>\npublic abstract class AbstractClass2 {\n    protected AbstractClass2 () {\n        // do something here\n    }\n}\n</pre>",
    "howToFix": "",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "abstract 클래스의 생성자를 public으로 선언하면 안 됩니다",
    "why_ko": "<p>추상 클래스에는 public 생성자가 없어야 합니다. 추상 클래스의 생성자는 하위 클래스의 생성자에서만 호출할 수 있습니다. 따라서 public으로 만들 이유가 없습니다. <code>protected</code> 수정자로 충분합니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\npublic abstract class AbstractClass1 {\n    public AbstractClass1 () { // 규칙 위반, public 수정자 사용\n        // 여기서 작업 수행\n    }\n}\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre>\npublic abstract class AbstractClass2 {\n    protected AbstractClass2 () {\n        // 여기서 작업 수행\n    }\n}\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": ""
  },
  {
    "id": "S2755",
    "key": "java:S2755",
    "name": "XML parsers should not be vulnerable to XXE attacks",
    "type": "vulnerability",
    "severity": "blocker",
    "tags": [
      "symbolic-execution",
      "cwe"
    ],
    "why": "<p>External Entity Processing allows for XML parsing with the involvement of external entities. However, when this functionality is enabled without\nproper precautions, it can lead to a vulnerability known as XML External Entity (XXE) attack.</p>\n<h3>What is the potential impact?</h3>\n<h4>Exposing sensitive data</h4>\n<p>One significant danger of XXE vulnerabilities is the potential for sensitive data exposure. By crafting malicious XML payloads, attackers can\nreference external entities that contain sensitive information, such as system files, database credentials, or configuration files. When these\nentities are processed during XML parsing, the attacker can extract the contents and gain unauthorized access to sensitive data. This poses a severe\nthreat to the confidentiality of critical information.</p>\n<h4>Exhausting system resources</h4>\n<p>Another consequence of XXE vulnerabilities is the potential for denial-of-service attacks. By exploiting the ability to include external entities,\nattackers can construct XML payloads that cause resource exhaustion. This can overwhelm the system's memory, CPU, or other critical resources, leading\nto system unresponsiveness or crashes. A successful DoS attack can disrupt the availability of services and negatively impact the user experience.</p>\n<h4>Forging requests</h4>\n<p>XXE vulnerabilities can also enable Server-Side Request Forgery (SSRF) attacks. By leveraging the ability to include external entities, an attacker\ncan make the vulnerable application send arbitrary requests to other internal or external systems. This can result in unintended actions, such as\nretrieving data from internal resources, scanning internal networks, or attacking other systems. SSRF attacks can lead to severe consequences,\nincluding unauthorized data access, system compromise, or even further exploitation within the network infrastructure.</p>",
    "howToFix": "<p>The following code contains examples of XML parsers that have external entity processing enabled. As a result, the parsers are vulnerable to XXE\nattacks if an attacker can control the XML file that is processed.</p>\n<h4>Noncompliant code example</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\nimport javax.xml.XMLConstants;\nimport javax.xml.parsers.DocumentBuilderFactory;\n\npublic void decode() {\n    DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance(); // Noncompliant\n}\n</pre>\n<pre data-diff-id=\"2\" data-diff-type=\"noncompliant\">\nimport javax.xml.stream.XMLInputFactory;\n\npublic void decode() {\n    XMLInputFactory factory = XMLInputFactory.newInstance(); // Noncompliant\n}\n</pre>\n<h4>Compliant solution</h4>\n<p>For <code>DocumentBuilderFactory</code>, <code>SAXParserFactory</code>, <code>TransformerFactory</code>, and <code>SchemaFactory</code> set\n<code>XMLConstants.FEATURE_SECURE_PROCESSING</code> to <code>true</code>.</p>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\nimport javax.xml.XMLConstants;\nimport javax.xml.parsers.DocumentBuilderFactory;\n\npublic void decode() {\n    DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n    factory.setFeature(XMLConstants.FEATURE_SECURE_PROCESSING, true);\n}\n</pre>\n<p>For <code>XMLInputFactory</code> set <code>SUPPORT_DTD</code> to <code>false</code>.</p>\n<pre data-diff-id=\"2\" data-diff-type=\"compliant\">\nimport javax.xml.stream.XMLInputFactory;\n\npublic void decode() {\n    XMLInputFactory factory = XMLInputFactory.newInstance();\n    factory.setProperty(XMLInputFactory.SUPPORT_DTD, false);\n}\n</pre>\n<p>Other combinations of settings are secure, but in general, it is recommendable to use the approaches shown here, as they are the most clear.</p>\n<h3>How does this work?</h3>\n<h4>Disable external entities</h4>\n<p>The most effective approach to prevent XXE vulnerabilities is to disable external entity processing entirely, unless it is explicitly required for\nspecific use cases. By default, XML parsers should be configured to reject the processing of external entities. This can be achieved by setting the\nappropriate properties or options in your XML parser library or framework.</p>\n<p>If external entity processing is necessary for certain scenarios, adopt a whitelisting approach to restrict the entities that can be resolved\nduring XML parsing. Create a list of trusted external entities and disallow all others. This approach ensures that only known and safe entities are\nprocessed.<br> You should rely on features provided by your XML parser to restrict the external entities.</p>\n<h3>Going the extra mile</h3>\n<h4>Disable entity expansion</h4>\n<p>Specifically for <code>DocumentBuilderFactory</code>, it is possible to disable the entity expansion. Note, however, that this does not prevent the\nretrieval of external entities.</p>\n<pre>\nfactory.setExpandEntityReferences(false);\n</pre>",
    "moreInfo": "<h3>Standards</h3>\n<ul>\n  <li> OWASP - <a href=\"https://owasp.org/Top10/A05_2021-Security_Misconfiguration/\">Top 10 2021 Category A5 - Security Misconfiguration</a> </li>\n  <li> OWASP - <a href=\"https://owasp.org/www-project-top-ten/2017/A4_2017-XML_External_Entities_(XXE)\">Top 10 2017 Category A4 - XML External\n  Entities (XXE)</a> </li>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/611\">CWE-611 - Information Exposure Through XML External Entity Reference</a> </li>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/827\">CWE-827 - Improper Control of Document Type Definition</a> </li>\n  <li> STIG Viewer - <a href=\"https://stigviewer.com/stig/application_security_and_development/2023-06-08/finding/V-222608\">Application Security and\n  Development: V-222608</a> - The application must not be vulnerable to XML-oriented attacks. </li>\n</ul>",
    "status": "READY",
    "name_ko": "XML 파서는 XXE 공격에 취약하면 안 됩니다",
    "why_ko": "<p>외부 엔티티 처리는 외부 엔티티의 관여와 함께 XML 파싱을 가능하게 합니다. 그러나 이 기능이 적절한 예방 조치 없이 활성화되면 XML 외부 엔티티(XXE) 공격으로 알려진 취약점이 발생할 수 있습니다.</p>\n<h3>잠재적인 영향은 무엇입니까?</h3>\n<h4>민감한 데이터 노출</h4>\n<p>XXE 취약점의 중요한 위험 중 하나는 민감한 데이터 노출의 가능성입니다. 악의적인 XML 페이로드를 만들어 공격자는 시스템 파일, 데이터베이스 자격 증명 또는 구성 파일과 같은 민감한 정보가 포함된 외부 엔티티를 참조할 수 있습니다. 이러한 엔티티가 XML 파싱 중에 처리되면 공격자는 내용을 추출하고 민감한 데이터에 무단으로 액세스할 수 있습니다. 이는 중요한 정보의 기밀성에 심각한 위협을 가합니다.</p>\n<h4>시스템 리소스 고갈</h4>\n<p>XXE 취약점의 또 다른 결과는 서비스 거부 공격의 가능성입니다. 외부 엔티티를 포함하는 기능을 악용하여 공격자는 리소스 고갈을 유발하는 XML 페이로드를 구성할 수 있습니다. 이로 인해 시스템의 메모리, CPU 또는 기타 중요한 리소스가 과부하되어 시스템 응답 불능 또는 충돌이 발생할 수 있습니다. 성공적인 DoS 공격은 서비스 가용성을 방해하고 사용자 경험에 부정적인 영향을 미칠 수 있습니다.</p>\n<h4>요청 위조</h4>\n<p>XXE 취약점은 서버 측 요청 위조(SSRF) 공격도 가능하게 합니다. 외부 엔티티를 포함하는 기능을 활용하여 공격자는 취약한 애플리케이션이 다른 내부 또는 외부 시스템에 임의의 요청을 보내도록 만들 수 있습니다. 이로 인해 내부 리소스에서 데이터 검색, 내부 네트워크 스캔 또는 다른 시스템 공격과 같은 의도하지 않은 작업이 발생할 수 있습니다. SSRF 공격은 무단 데이터 액세스, 시스템 손상 또는 네트워크 인프라 내에서의 추가적인 악용을 포함한 심각한 결과를 초래할 수 있습니다.</p>",
    "howToFix_ko": "<p>다음 코드는 외부 엔티티 처리가 활성화된 XML 파서의 예시를 포함합니다. 결과적으로 공격자가 처리되는 XML 파일을 제어할 수 있는 경우 파서는 XXE 공격에 취약합니다.</p>\n<h4>규칙을 준수하지 않는 코드 예시</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\nimport javax.xml.XMLConstants;\nimport javax.xml.parsers.DocumentBuilderFactory;\n\npublic void decode() {\n    DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance(); // 규칙 위반\n}\n</pre>\n<pre data-diff-id=\"2\" data-diff-type=\"noncompliant\">\nimport javax.xml.stream.XMLInputFactory;\n\npublic void decode() {\n    XMLInputFactory factory = XMLInputFactory.newInstance(); // 규칙 위반\n}\n</pre>\n<h4>규칙을 준수하는 해결책</h4>\n<p><code>DocumentBuilderFactory</code>, <code>SAXParserFactory</code>, <code>TransformerFactory</code>, <code>SchemaFactory</code>의 경우 <code>XMLConstants.FEATURE_SECURE_PROCESSING</code>을 <code>true</code>로 설정합니다.</p>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\nimport javax.xml.XMLConstants;\nimport javax.xml.parsers.DocumentBuilderFactory;\n\npublic void decode() {\n    DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n    factory.setFeature(XMLConstants.FEATURE_SECURE_PROCESSING, true);\n}\n</pre>\n<p><code>XMLInputFactory</code>의 경우 <code>SUPPORT_DTD</code>를 <code>false</code>로 설정합니다.</p>\n<pre data-diff-id=\"2\" data-diff-type=\"compliant\">\nimport javax.xml.stream.XMLInputFactory;\n\npublic void decode() {\n    XMLInputFactory factory = XMLInputFactory.newInstance();\n    factory.setProperty(XMLInputFactory.SUPPORT_DTD, false);\n}\n</pre>\n<p>다른 설정 조합도 안전하지만, 일반적으로 여기에 표시된 접근 방식이 가장 명확하므로 이를 사용하는 것이 좋습니다.</p>\n<h3>어떻게 작동하나요?</h3>\n<h4>외부 엔티티 비활성화</h4>\n<p>XXE 취약점을 방지하는 가장 효과적인 접근 방식은 특정 사용 사례에 명시적으로 필요하지 않는 한 외부 엔티티 처리를 완전히 비활성화하는 것입니다. 기본적으로 XML 파서는 외부 엔티티 처리를 거부하도록 구성되어야 합니다. 이는 XML 파서 라이브러리 또는 프레임워크에서 적절한 속성이나 옵션을 설정하여 달성할 수 있습니다.</p>\n<p>특정 시나리오에서 외부 엔티티 처리가 필요한 경우, XML 파싱 중에 확인할 수 있는 엔티티를 제한하기 위해 화이트리스트 접근 방식을 채택하세요. 신뢰할 수 있는 외부 엔티티 목록을 만들고 다른 모든 것을 허용하지 않습니다. 이 접근 방식은 알려져 있고 안전한 엔티티만 처리되도록 보장합니다.<br> XML 파서에서 제공하는 기능을 사용하여 외부 엔티티를 제한해야 합니다.</p>\n<h3>한 단계 더 나아가기</h3>\n<h4>엔티티 확장 비활성화</h4>\n<p><code>DocumentBuilderFactory</code>의 경우 특히 엔티티 확장을 비활성화할 수 있습니다. 그러나 이것이 외부 엔티티의 검색을 방지하지는 않습니다.</p>\n<pre>\nfactory.setExpandEntityReferences(false);\n</pre>",
    "moreInfo_ko": "<h3>표준</h3>\n<ul>\n  <li> OWASP - <a href=\"https://owasp.org/Top10/A05_2021-Security_Misconfiguration/\">Top 10 2021 Category A5 - Security Misconfiguration</a> </li>\n  <li> OWASP - <a href=\"https://owasp.org/www-project-top-ten/2017/A4_2017-XML_External_Entities_(XXE)\">Top 10 2017 Category A4 - XML External Entities (XXE)</a> </li>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/611\">CWE-611 - XML 외부 엔티티 참조를 통한 정보 노출</a> </li>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/827\">CWE-827 - 문서 유형 정의의 부적절한 제어</a> </li>\n  <li> STIG Viewer - <a href=\"https://stigviewer.com/stig/application_security_and_development/2023-06-08/finding/V-222608\">Application Security and Development: V-222608</a> - 애플리케이션은 XML 관련 공격에 취약하면 안 됩니다. </li>\n</ul>"
  },
  {
    "id": "S2885",
    "key": "java:S2885",
    "name": "Non-thread-safe fields should not be static",
    "type": "bug",
    "severity": "major",
    "tags": [
      "multi-threading"
    ],
    "why": "<p>When an object is marked as <code>static</code>, it means that it belongs to the class rather than any class instance. This means there is only one\ncopy of the static object in memory, regardless of how many class instances are created. Static objects are shared among all instances of the class\nand can be accessed using the class name rather than an instance of the class.</p>\n<p>A data type is considered thread-safe if it can be used correctly by multiple threads, regardless of how those threads are executed, without\nrequiring additional coordination from the calling code. In other words, a thread-safe data type can be accessed and modified by multiple threads\nsimultaneously without causing any issues or requiring extra work from the programmer to ensure correct behavior.</p>\n<p>Non-thread-safe objects are objects that are not designed to be used in a multi-threaded environment and can lead to race conditions and data\ninconsistencies when accessed by multiple threads simultaneously. Using them in a multi-threaded manner is highly likely to cause data problems or\nexceptions at runtime.</p>\n<p>When a non-thread-safe object is marked as static in a multi-threaded environment, it can cause issues because the non-thread-safe object will be\nshared across different instances of the containing class.</p>\n<p>This rule raises an issue when any of the following instances and their subtypes are marked as <code>static</code>:</p>\n<ul>\n  <li> <code>java.util.Calendar</code>, </li>\n  <li> <code>java.text.DateFormat</code>, </li>\n  <li> <code>javax.xml.xpath.XPath</code>, or </li>\n  <li> <code>javax.xml.validation.SchemaFactory</code>. </li>\n</ul>",
    "howToFix": "<p>Remove the <code>static</code> keyword from non-thread-safe fields.</p>\n\n<h4>Noncompliant code example</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\npublic class MyClass {\n  private static Calendar calendar = Calendar.getInstance();  // Noncompliant\n  private static SimpleDateFormat format = new SimpleDateFormat(\"HH-mm-ss\");  // Noncompliant\n}\n</pre>\n<h4>Compliant solution</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\npublic class MyClass {\n  private Calendar calendar = Calendar.getInstance();\n  private SimpleDateFormat format = new SimpleDateFormat(\"HH-mm-ss\");\n}\n</pre>",
    "moreInfo": "<h3>Articles &amp; blog posts</h3>\n<ul>\n  <li> <a href=\"https://web.mit.edu/6.005/www/fa14/classes/18-thread-safety/\">MIT - Thread safety</a> </li>\n  <li> <a href=\"https://www.baeldung.com/java-thread-safety\">Baeldung - Thread safety</a> </li>\n  <li> <a href=\"https://www.baeldung.com/java-static\">Baeldung - Static</a> </li>\n</ul>\n<h3>Standards</h3>\n<ul>\n  <li> STIG Viewer - <a href=\"https://stigviewer.com/stigs/application_security_and_development/2024-12-06/finding/V-222567\">Application Security and\n  Development: V-222567</a> - The application must not be vulnerable to race conditions. </li>\n</ul>",
    "status": "READY",
    "name_ko": "스레드 안전하지 않은 필드를 static으로 선언하면 안 됩니다",
    "why_ko": "<p>객체가 <code>static</code>으로 표시되면 클래스 인스턴스가 아닌 클래스에 속함을 의미합니다. 이는 생성된 클래스 인스턴스 수에 관계없이 메모리에 static 객체의 복사본이 하나만 있음을 의미합니다. static 객체는 클래스의 모든 인스턴스 간에 공유되며 클래스 인스턴스가 아닌 클래스 이름을 사용하여 액세스할 수 있습니다.</p>\n<p>데이터 타입은 호출 코드의 추가 조정 없이 스레드가 어떻게 실행되든 관계없이 여러 스레드에서 올바르게 사용할 수 있으면 스레드 안전한 것으로 간주됩니다. 즉, 스레드 안전한 데이터 타입은 문제를 일으키거나 올바른 동작을 보장하기 위해 프로그래머의 추가 작업을 요구하지 않고 여러 스레드에서 동시에 액세스하고 수정할 수 있습니다.</p>\n<p>스레드 안전하지 않은 객체는 멀티스레드 환경에서 사용하도록 설계되지 않은 객체로, 여러 스레드가 동시에 액세스할 때 경쟁 조건과 데이터 불일치를 초래할 수 있습니다. 멀티스레드 방식으로 사용하면 런타임에 데이터 문제나 예외가 발생할 가능성이 높습니다.</p>\n<p>멀티스레드 환경에서 스레드 안전하지 않은 객체가 static으로 표시되면 포함 클래스의 다른 인스턴스 간에 스레드 안전하지 않은 객체가 공유되므로 문제가 발생할 수 있습니다.</p>\n<p>이 규칙은 다음 인스턴스와 그 하위 타입이 <code>static</code>으로 표시될 때 문제를 제기합니다:</p>\n<ul>\n  <li> <code>java.util.Calendar</code>, </li>\n  <li> <code>java.text.DateFormat</code>, </li>\n  <li> <code>javax.xml.xpath.XPath</code>, 또는 </li>\n  <li> <code>javax.xml.validation.SchemaFactory</code>. </li>\n</ul>",
    "howToFix_ko": "<p>스레드 안전하지 않은 필드에서 <code>static</code> 키워드를 제거하세요.</p>\n\n<h4>규칙을 준수하지 않는 코드 예시</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\npublic class MyClass {\n  private static Calendar calendar = Calendar.getInstance();  // 규칙 위반\n  private static SimpleDateFormat format = new SimpleDateFormat(\"HH-mm-ss\");  // 규칙 위반\n}\n</pre>\n<h4>규칙을 준수하는 해결책</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\npublic class MyClass {\n  private Calendar calendar = Calendar.getInstance();\n  private SimpleDateFormat format = new SimpleDateFormat(\"HH-mm-ss\");\n}\n</pre>",
    "moreInfo_ko": "<h3>관련 문서 및 블로그 게시물</h3>\n<ul>\n  <li> <a href=\"https://web.mit.edu/6.005/www/fa14/classes/18-thread-safety/\">MIT - Thread safety</a> </li>\n  <li> <a href=\"https://www.baeldung.com/java-thread-safety\">Baeldung - Thread safety</a> </li>\n  <li> <a href=\"https://www.baeldung.com/java-static\">Baeldung - Static</a> </li>\n</ul>\n<h3>표준</h3>\n<ul>\n  <li> STIG Viewer - <a href=\"https://stigviewer.com/stigs/application_security_and_development/2024-12-06/finding/V-222567\">Application Security and Development: V-222567</a> - 애플리케이션은 경쟁 조건에 취약하면 안 됩니다. </li>\n</ul>"
  },
  {
    "id": "S2186",
    "key": "java:S2186",
    "name": "JUnit assertions should not be used in \"run\" methods",
    "type": "code-smell",
    "severity": "critical",
    "tags": [
      "junit",
      "tests"
    ],
    "why": "<p>JUnit assertions should not be made from the <code>run</code> method of a <code>Runnable</code>, because their failure may not be detected in the\ntest that initiated them. Failed assertions throw assertion errors. However, if the error is thrown from another thread than the one that initiated\nthe test, the thread will exit but the test will not fail.</p>",
    "howToFix": "<p>Assertions in <code>Runnable</code> tasks should be extracted or executed by the main thread to make the whole test fail.</p>\n\n<h4>Noncompliant code example</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\nclass RunnableWithAnAssertion extends Thread {\n  @Override\n  public void run() {\n    Assert.assertEquals(expected, actual);  // Noncompliant\n  }\n\n  @Test\n  void test() {\n    RunnableWithAnAssertion otherThread = new RunnableWithAnAssertion();\n    otherThread.start(); // The assertion in the run method above will be executed by other thread than the current one\n    // ...\n    // Perform some actions that do not make the test fail\n    // ...\n    Assert.assertTrue(true);\n  }\n}\n</pre>\n<h4>Compliant solution</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\nclass RunnableWithAnAssertion extends Thread {\n  @Override\n  public void run() {\n    Assert.assertEquals(expected, actual);  // Noncompliant\n  }\n\n  @Test\n  void test() {\n    RunnableWithAnAssertion otherThread = new RunnableWithAnAssertion();\n    otherThread.run();\n    // ...\n    // The failed assertions in the run method will prevent us from reaching the assertion below\n    // ...\n    Assert.assertTrue(true);\n  }\n}\n</pre>",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "JUnit assertion을 \"run\" 메서드에서 사용하면 안 됩니다",
    "why_ko": "<p>JUnit assertion은 <code>Runnable</code>의 <code>run</code> 메서드에서 만들어서는 안 됩니다. 실패가 테스트를 시작한 곳에서 감지되지 않을 수 있기 때문입니다. 실패한 assertion은 assertion 오류를 던집니다. 그러나 테스트를 시작한 스레드가 아닌 다른 스레드에서 오류가 던져지면 스레드는 종료되지만 테스트는 실패하지 않습니다.</p>",
    "howToFix_ko": "<p><code>Runnable</code> 작업의 assertion은 전체 테스트가 실패하도록 메인 스레드에서 추출하거나 실행해야 합니다.</p>\n\n<h4>규칙을 준수하지 않는 코드 예시</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\nclass RunnableWithAnAssertion extends Thread {\n  @Override\n  public void run() {\n    Assert.assertEquals(expected, actual);  // 규칙 위반\n  }\n\n  @Test\n  void test() {\n    RunnableWithAnAssertion otherThread = new RunnableWithAnAssertion();\n    otherThread.start(); // 위의 run 메서드의 assertion은 현재 스레드가 아닌 다른 스레드에서 실행됨\n    // ...\n    // 테스트가 실패하지 않도록 하는 일부 작업 수행\n    // ...\n    Assert.assertTrue(true);\n  }\n}\n</pre>\n<h4>규칙을 준수하는 해결책</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\nclass RunnableWithAnAssertion extends Thread {\n  @Override\n  public void run() {\n    Assert.assertEquals(expected, actual);  // 규칙 위반\n  }\n\n  @Test\n  void test() {\n    RunnableWithAnAssertion otherThread = new RunnableWithAnAssertion();\n    otherThread.run();\n    // ...\n    // run 메서드의 실패한 assertion은 아래 assertion에 도달하는 것을 방지함\n    // ...\n    Assert.assertTrue(true);\n  }\n}\n</pre>",
    "moreInfo_ko": ""
  },
  {
    "id": "S6829",
    "key": "java:S6829",
    "name": "\"@Autowired\" should be used when multiple constructors are provided",
    "type": "code-smell",
    "severity": "major",
    "tags": [
      "spring"
    ],
    "why": "<p>The Spring dependency injection mechanism cannot identify which constructor to use for auto-wiring when multiple constructors are present in a\nclass. This ambiguity can cause the application to crash at runtime, and it makes the code less clear to understand and more complex to extend and\nmaintain.</p>\n<h3>What is the potential impact?</h3>\n<ul>\n  <li> <strong>incorrect instantiation</strong>: the wrong constructor is selected for instantiation, leading to a bean not being correctly\n  initialized. </li>\n  <li> <strong>unsatisfied dependency exception</strong>: the constructor selected by Spring requires beans that are not available in the Spring\n  context. </li>\n  <li> <strong>non-deterministic behavior</strong>: the constructor selected by Spring can vary, based on the number of dependencies that can be\n  satisfied at runtime, leading to unpredictable application behavior. </li>\n  <li> <strong>maintainability issues</strong>: adding more constructors in the future could lead to further confusion and potential bugs. </li>\n</ul>",
    "howToFix": "<p>Use the <code>@Autowired</code> annotation to specify which constructor to use for auto-wiring.</p>\n\n<h4>Noncompliant code example</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\n@Component\npublic class ExampleClass { // Noncompliant: multiple constructors present and no @Autowired annotation to specify which one to use\n\n    private final DependencyClass1 dependency1;\n\n    public ExampleClass() {\n        throw new UnsupportedOperationException(\"Not supported yet.\");\n    }\n\n    public ExampleClass(DependencyClass1 dependency1) {\n        this.dependency1 = dependency1;\n    }\n\n    // ...\n}\n</pre>\n<h4>Compliant solution</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\n@Component\npublic class ExampleClass {\n\n    private final DependencyClass1 dependency1;\n\n    public ExampleClass() {\n        throw new UnsupportedOperationException(\"Not supported yet.\");\n    }\n\n    @Autowired\n    public ExampleClass(DependencyClass1 dependency1) {\n        this.dependency1 = dependency1;\n    }\n\n    // ...\n}\n</pre>",
    "moreInfo": "<h3>Documentation</h3>\n<ul>\n  <li> Spring - <a href=\"https://docs.spring.io/spring-framework/reference/core/beans/annotation-config/autowired.html\">Annotation Config:\n  Autowired</a> </li>\n</ul>\n<h3>Articles &amp; blog posts</h3>\n<ul>\n  <li> Java Guides - <a href=\"https://www.javaguides.net/2023/08/unsatisfieddependencyexception-in.html\">UnsatisfiedDependencyException in Spring\n  Boot</a> </li>\n</ul>",
    "status": "READY",
    "name_ko": "여러 생성자가 제공될 때 \"@Autowired\"를 사용해야 합니다",
    "why_ko": "<p>Spring 의존성 주입 메커니즘은 클래스에 여러 생성자가 있을 때 자동 연결에 사용할 생성자를 식별할 수 없습니다. 이 모호성으로 인해 런타임에 애플리케이션이 충돌할 수 있으며 코드를 이해하기 어렵고 확장 및 유지 관리하기 복잡해집니다.</p>\n<h3>잠재적 영향은 무엇인가요?</h3>\n<ul>\n  <li> <strong>잘못된 인스턴스화</strong>: 인스턴스화를 위해 잘못된 생성자가 선택되어 빈이 올바르게 초기화되지 않습니다. </li>\n  <li> <strong>충족되지 않은 의존성 예외</strong>: Spring이 선택한 생성자가 Spring 컨텍스트에서 사용할 수 없는 빈을 필요로 합니다. </li>\n  <li> <strong>비결정적 동작</strong>: Spring이 선택한 생성자가 런타임에 충족할 수 있는 의존성 수에 따라 달라져 예측할 수 없는 애플리케이션 동작이 발생합니다. </li>\n  <li> <strong>유지 관리 문제</strong>: 향후 더 많은 생성자를 추가하면 더 많은 혼란과 잠재적 버그가 발생할 수 있습니다. </li>\n</ul>",
    "howToFix_ko": "<p><code>@Autowired</code> 어노테이션을 사용하여 자동 연결에 사용할 생성자를 지정하세요.</p>\n\n<h4>규칙을 준수하지 않는 코드 예시</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\n@Component\npublic class ExampleClass { // 규칙 위반: 여러 생성자가 있지만 어떤 것을 사용할지 지정하는 @Autowired 어노테이션이 없음\n\n    private final DependencyClass1 dependency1;\n\n    public ExampleClass() {\n        throw new UnsupportedOperationException(\"아직 지원되지 않습니다.\");\n    }\n\n    public ExampleClass(DependencyClass1 dependency1) {\n        this.dependency1 = dependency1;\n    }\n\n    // ...\n}\n</pre>\n<h4>규칙을 준수하는 해결책</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\n@Component\npublic class ExampleClass {\n\n    private final DependencyClass1 dependency1;\n\n    public ExampleClass() {\n        throw new UnsupportedOperationException(\"아직 지원되지 않습니다.\");\n    }\n\n    @Autowired\n    public ExampleClass(DependencyClass1 dependency1) {\n        this.dependency1 = dependency1;\n    }\n\n    // ...\n}\n</pre>",
    "moreInfo_ko": "<h3>문서</h3>\n<ul>\n  <li> Spring - <a href=\"https://docs.spring.io/spring-framework/reference/core/beans/annotation-config/autowired.html\">어노테이션 구성: Autowired</a> </li>\n</ul>\n<h3>기사 및 블로그 게시물</h3>\n<ul>\n  <li> Java Guides - <a href=\"https://www.javaguides.net/2023/08/unsatisfieddependencyexception-in.html\">Spring Boot의 UnsatisfiedDependencyException</a> </li>\n</ul>"
  },
  {
    "id": "S1315",
    "key": "java:S1315",
    "name": "Track uses of \"CHECKSTYLE:OFF\" suppression comments",
    "type": "code-smell",
    "severity": "minor",
    "tags": [
      "bad-practice"
    ],
    "why": "<p>This rule allows you to track the use of the Checkstyle suppression comment mechanism.</p>\n<h3>Noncompliant code example</h3>\n<pre>\n// CHECKSTYLE:OFF\n</pre>",
    "howToFix": "",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "\"CHECKSTYLE:OFF\" 억제 주석 사용을 추적합니다",
    "why_ko": "<p>이 규칙을 사용하면 Checkstyle 억제 주석 메커니즘의 사용을 추적할 수 있습니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\n// CHECKSTYLE:OFF\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": ""
  },
  {
    "id": "S4551",
    "key": "java:S4551",
    "name": "Enum values should be compared with \"==\"",
    "type": "code-smell",
    "severity": "major",
    "tags": [],
    "why": "<p>Testing equality of an enum value with <code>equals</code> is perfectly valid because an enum is an Object and every Java developer knows \"==\"\nshould not be used to compare the content of an Object. At the same time, using \"==\" on enums:</p>\n<ul>\n  <li> provides the same expected comparison (content) as <code>equals</code> </li>\n  <li> is more null-safe than equals() </li>\n  <li> provides compile-time (static) checking rather than runtime checking </li>\n</ul>\n<p>For these reasons, use of \"==\" should be preferred to <code>equals</code>.</p>\n<h3>Noncompliant code example</h3>\n<pre>\npublic enum Fruit {\n   APPLE, BANANA, GRAPE\n}\n\npublic enum Cake {\n  LEMON_TART, CHEESE_CAKE\n}\n\npublic boolean isFruitGrape(Fruit candidateFruit) {\n  return candidateFruit.equals(Fruit.GRAPE); // Noncompliant; this will raise an NPE if candidateFruit is NULL\n}\n\npublic boolean isFruitGrape(Cake candidateFruit) {\n  return candidateFruit.equals(Fruit.GRAPE); // Noncompliant; always returns false\n}\n</pre>\n<h3>Compliant solution</h3>\n<pre>\npublic boolean isFruitGrape(Fruit candidateFruit) {\n  return candidateFruit == Fruit.GRAPE; // Compliant; there is only one instance of Fruit.GRAPE - if candidateFruit is a GRAPE it will have the same reference as Fruit.GRAPE\n}\n\npublic boolean isFruitGrape(Cake candidateFruit) {\n  return candidateFruit == Fruit.GRAPE; // Compliant; compilation time failure\n}\n</pre>",
    "howToFix": "",
    "moreInfo": "<ul>\n  <li> <a href=\"https://www.infoworld.com/article/2074292/use-----or-----to-compare-java-enums.html\">Use == (or !=) to Compare Java Enums</a> </li>\n</ul>",
    "status": "READY",
    "name_ko": "Enum 값은 \"==\"로 비교해야 합니다",
    "why_ko": "<p>enum은 Object이고 모든 Java 개발자는 \"==\"가 Object의 내용을 비교하는 데 사용되어서는 안 된다는 것을 알기 때문에 <code>equals</code>로 enum 값의 동등성을 테스트하는 것은 완벽하게 유효합니다. 동시에 enum에 \"==\"를 사용하면:</p>\n<ul>\n  <li> <code>equals</code>와 동일한 예상 비교(내용)를 제공합니다 </li>\n  <li> equals()보다 null에 안전합니다 </li>\n  <li> 런타임 검사 대신 컴파일 시간(정적) 검사를 제공합니다 </li>\n</ul>\n<p>이러한 이유로 <code>equals</code>보다 \"==\"의 사용이 선호되어야 합니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\npublic enum Fruit {\n   APPLE, BANANA, GRAPE\n}\n\npublic enum Cake {\n  LEMON_TART, CHEESE_CAKE\n}\n\npublic boolean isFruitGrape(Fruit candidateFruit) {\n  return candidateFruit.equals(Fruit.GRAPE); // 규칙 위반; candidateFruit이 NULL이면 NPE가 발생합니다\n}\n\npublic boolean isFruitGrape(Cake candidateFruit) {\n  return candidateFruit.equals(Fruit.GRAPE); // 규칙 위반; 항상 false를 반환합니다\n}\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre>\npublic boolean isFruitGrape(Fruit candidateFruit) {\n  return candidateFruit == Fruit.GRAPE; // 규칙 준수; Fruit.GRAPE의 인스턴스는 하나뿐입니다 - candidateFruit이 GRAPE이면 Fruit.GRAPE와 동일한 참조를 가집니다\n}\n\npublic boolean isFruitGrape(Cake candidateFruit) {\n  return candidateFruit == Fruit.GRAPE; // 규칙 준수; 컴파일 시간 실패\n}\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": "<ul>\n  <li> <a href=\"https://www.infoworld.com/article/2074292/use-----or-----to-compare-java-enums.html\">Java Enum을 비교할 때 == (또는 !=) 사용하기</a> </li>\n</ul>"
  },
  {
    "id": "S2201",
    "key": "java:S2201",
    "name": "Return values from functions without side effects should not be ignored",
    "type": "bug",
    "severity": "major",
    "tags": [
      "cert"
    ],
    "why": "<p>When the call to a function doesn't have any side effects, what is the point of making the call if the results are ignored? In such case, either\nthe function call is useless and should be dropped or the source code doesn't behave as expected.</p>\n<p>To prevent generating any false-positives, this rule triggers an issue only on the following predefined list of immutable classes in the Java API\n:</p>\n<ul>\n  <li> <code>java.lang.String</code> </li>\n  <li> <code>java.lang.Boolean</code> </li>\n  <li> <code>java.lang.Integer</code> </li>\n  <li> <code>java.lang.Double</code> </li>\n  <li> <code>java.lang.Float</code> </li>\n  <li> <code>java.lang.Byte</code> </li>\n  <li> <code>java.lang.Character</code> </li>\n  <li> <code>java.lang.Short</code> </li>\n  <li> <code>java.lang.StackTraceElement</code> </li>\n  <li> <code>java.time.DayOfWeek</code> </li>\n  <li> <code>java.time.Duration</code> </li>\n  <li> <code>java.time.Instant</code> </li>\n  <li> <code>java.time.LocalDate</code> </li>\n  <li> <code>java.time.LocalDateTime</code> </li>\n  <li> <code>java.time.LocalTime</code> </li>\n  <li> <code>java.time.Month</code> </li>\n  <li> <code>java.time.MonthDay</code> </li>\n  <li> <code>java.time.OffsetDateTime</code> </li>\n  <li> <code>java.time.OffsetTime</code> </li>\n  <li> <code>java.time.Period</code> </li>\n  <li> <code>java.time.Year</code> </li>\n  <li> <code>java.time.YearMonth</code> </li>\n  <li> <code>java.time.ZonedDateTime</code> </li>\n  <li> <code>java.math.BigInteger</code> </li>\n  <li> <code>java.math.BigDecimal</code> </li>\n  <li> <code>java.util.Optional</code> </li>\n</ul>\n<p>As well as methods of the following classes:</p>\n<ul>\n  <li> <code>java.util.Collection</code>:\n    <ul>\n      <li> <code>size()</code> </li>\n      <li> <code>isEmpty()</code> </li>\n      <li> <code>contains(...)</code> </li>\n      <li> <code>containsAll(...)</code> </li>\n      <li> <code>iterator()</code> </li>\n      <li> <code>toArray()</code> </li>\n    </ul>  </li>\n  <li> <code>java.util.Map</code>:\n    <ul>\n      <li> <code>size()</code> </li>\n      <li> <code>isEmpty()</code> </li>\n      <li> <code>containsKey(...)</code> </li>\n      <li> <code>containsValue(...)</code> </li>\n      <li> <code>get(...)</code> </li>\n      <li> <code>getOrDefault(...)</code> </li>\n      <li> <code>keySet()</code> </li>\n      <li> <code>entrySet()</code> </li>\n      <li> <code>values()</code> </li>\n    </ul>  </li>\n  <li> <code>java.util.stream.Stream</code>\n    <ul>\n      <li> <code>toArray</code> </li>\n      <li> <code>reduce</code> </li>\n      <li> <code>collect</code> </li>\n      <li> <code>min</code> </li>\n      <li> <code>max</code> </li>\n      <li> <code>count</code> </li>\n      <li> <code>anyMatch</code> </li>\n      <li> <code>allMatch</code> </li>\n      <li> <code>noneMatch</code> </li>\n      <li> <code>findFirst</code> </li>\n      <li> <code>findAny</code> </li>\n      <li> <code>toList</code> </li>\n    </ul>  </li>\n</ul>\n<h3>Noncompliant code example</h3>\n<pre>\npublic void handle(String command){\n  command.toLowerCase(); // Noncompliant; result of method thrown away\n  ...\n}\n</pre>\n<h3>Compliant solution</h3>\n<pre>\npublic void handle(String command){\n  String formattedCommand = command.toLowerCase();\n  ...\n}\n</pre>\n<h3>Exceptions</h3>\n<p>This rule will not raise an issue when both these conditions are met:</p>\n<ul>\n  <li> The method call is in a <code>try</code> block with an associated <code>catch</code> clause. </li>\n  <li> The method name starts with \"parse\", \"format\", \"decode\" or \"valueOf\" or the method is <code>String.getBytes(Charset)</code>. </li>\n</ul>\n<pre>\nprivate boolean textIsInteger(String textToCheck) {\n\n    try {\n        Integer.parseInt(textToCheck, 10); // OK\n        return true;\n    } catch (NumberFormatException ignored) {\n        return false;\n    }\n}\n</pre>",
    "howToFix": "",
    "moreInfo": "<ul>\n  <li> <a href=\"https://wiki.sei.cmu.edu/confluence/x/xzdGBQ\">CERT, EXP00-J.</a> - Do not ignore values returned by methods </li>\n</ul>",
    "status": "READY",
    "name_ko": "부작용이 없는 함수의 반환값을 무시하면 안 됩니다",
    "why_ko": "<p>함수 호출에 부작용이 없는데 결과를 무시한다면 그 호출의 의미는 무엇인가요? 이러한 경우 함수 호출이 불필요하여 제거해야 하거나 소스 코드가 예상대로 동작하지 않는 것입니다.</p>\n<p>거짓 양성을 방지하기 위해 이 규칙은 Java API의 다음 사전 정의된 불변 클래스 목록에서만 이슈를 발생시킵니다:</p>\n<ul>\n  <li> <code>java.lang.String</code> </li>\n  <li> <code>java.lang.Boolean</code> </li>\n  <li> <code>java.lang.Integer</code> </li>\n  <li> <code>java.lang.Double</code> </li>\n  <li> <code>java.lang.Float</code> </li>\n  <li> <code>java.lang.Byte</code> </li>\n  <li> <code>java.lang.Character</code> </li>\n  <li> <code>java.lang.Short</code> </li>\n  <li> <code>java.lang.StackTraceElement</code> </li>\n  <li> <code>java.time.DayOfWeek</code> </li>\n  <li> <code>java.time.Duration</code> </li>\n  <li> <code>java.time.Instant</code> </li>\n  <li> <code>java.time.LocalDate</code> </li>\n  <li> <code>java.time.LocalDateTime</code> </li>\n  <li> <code>java.time.LocalTime</code> </li>\n  <li> <code>java.time.Month</code> </li>\n  <li> <code>java.time.MonthDay</code> </li>\n  <li> <code>java.time.OffsetDateTime</code> </li>\n  <li> <code>java.time.OffsetTime</code> </li>\n  <li> <code>java.time.Period</code> </li>\n  <li> <code>java.time.Year</code> </li>\n  <li> <code>java.time.YearMonth</code> </li>\n  <li> <code>java.time.ZonedDateTime</code> </li>\n  <li> <code>java.math.BigInteger</code> </li>\n  <li> <code>java.math.BigDecimal</code> </li>\n  <li> <code>java.util.Optional</code> </li>\n</ul>\n<p>그리고 다음 클래스의 메서드도 포함됩니다:</p>\n<ul>\n  <li> <code>java.util.Collection</code>:\n    <ul>\n      <li> <code>size()</code> </li>\n      <li> <code>isEmpty()</code> </li>\n      <li> <code>contains(...)</code> </li>\n      <li> <code>containsAll(...)</code> </li>\n      <li> <code>iterator()</code> </li>\n      <li> <code>toArray()</code> </li>\n    </ul>  </li>\n  <li> <code>java.util.Map</code>:\n    <ul>\n      <li> <code>size()</code> </li>\n      <li> <code>isEmpty()</code> </li>\n      <li> <code>containsKey(...)</code> </li>\n      <li> <code>containsValue(...)</code> </li>\n      <li> <code>get(...)</code> </li>\n      <li> <code>getOrDefault(...)</code> </li>\n      <li> <code>keySet()</code> </li>\n      <li> <code>entrySet()</code> </li>\n      <li> <code>values()</code> </li>\n    </ul>  </li>\n  <li> <code>java.util.stream.Stream</code>\n    <ul>\n      <li> <code>toArray</code> </li>\n      <li> <code>reduce</code> </li>\n      <li> <code>collect</code> </li>\n      <li> <code>min</code> </li>\n      <li> <code>max</code> </li>\n      <li> <code>count</code> </li>\n      <li> <code>anyMatch</code> </li>\n      <li> <code>allMatch</code> </li>\n      <li> <code>noneMatch</code> </li>\n      <li> <code>findFirst</code> </li>\n      <li> <code>findAny</code> </li>\n      <li> <code>toList</code> </li>\n    </ul>  </li>\n</ul>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\npublic void handle(String command){\n  command.toLowerCase(); // 규칙 위반; 메서드 결과가 버려짐\n  ...\n}\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre>\npublic void handle(String command){\n  String formattedCommand = command.toLowerCase();\n  ...\n}\n</pre>\n<h3>예외</h3>\n<p>이 규칙은 다음 두 조건이 모두 충족될 때 이슈를 발생시키지 않습니다:</p>\n<ul>\n  <li> 메서드 호출이 관련 <code>catch</code> 절이 있는 <code>try</code> 블록 내에 있음 </li>\n  <li> 메서드 이름이 \"parse\", \"format\", \"decode\" 또는 \"valueOf\"로 시작하거나 메서드가 <code>String.getBytes(Charset)</code>임 </li>\n</ul>\n<pre>\nprivate boolean textIsInteger(String textToCheck) {\n\n    try {\n        Integer.parseInt(textToCheck, 10); // OK\n        return true;\n    } catch (NumberFormatException ignored) {\n        return false;\n    }\n}\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": "<ul>\n  <li> <a href=\"https://wiki.sei.cmu.edu/confluence/x/xzdGBQ\">CERT, EXP00-J.</a> - 메서드가 반환하는 값을 무시하지 마세요 </li>\n</ul>"
  },
  {
    "id": "S5194",
    "key": "java:S5194",
    "name": "Use Java 14 \"switch\" expression",
    "type": "code-smell",
    "severity": "minor",
    "tags": [
      "java14"
    ],
    "why": "<p>Many existing switch statements are essentially simulations of switch expressions, where each arm either assigns to a common target variable or\nreturns a value. Expressing this as a statement is roundabout, repetitive, and error-prone.</p>\n<p>Java 14 added support for switch expressions, which provide more succinct and less error-prone version of switch.</p>\n<h3>Noncompliant code example</h3>\n<pre>\nvoid day_of_week(DoW day) {\n    int numLetters;\n    switch (day) {  // Noncompliant\n      case MONDAY:\n      case FRIDAY:\n      case SUNDAY:\n        numLetters = 6;\n        break;\n      case TUESDAY:\n        numLetters = 7;\n        break;\n      case THURSDAY:\n      case SATURDAY:\n        numLetters = 8;\n        break;\n      case WEDNESDAY:\n        numLetters = 9;\n        break;\n      default:\n        throw new IllegalStateException(\"Wat: \" + day);\n    }\n}\n\nint return_switch(int x) {\n    switch (x) { // Noncompliant\n      case 1:\n        return 1;\n      case 2:\n        return 2;\n      default:\n        throw new IllegalStateException();\n    }\n}\n</pre>\n<h3>Compliant solution</h3>\n<pre>\nint numLetters = switch (day) {\n    case MONDAY, FRIDAY, SUNDAY -&gt; 6;\n    case TUESDAY                -&gt; 7;\n    case THURSDAY, SATURDAY     -&gt; 8;\n    case WEDNESDAY              -&gt; 9;\n};\n</pre>",
    "howToFix": "",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "Java 14 \"switch\" 표현식을 사용해야 합니다",
    "why_ko": "<p>많은 기존 switch 문은 본질적으로 switch 표현식의 시뮬레이션으로, 각 분기에서 공통 대상 변수에 할당하거나 값을 반환합니다. 이를 문으로 표현하는 것은 우회적이고 반복적이며 오류가 발생하기 쉽습니다.</p>\n<p>Java 14에서는 switch 표현식에 대한 지원이 추가되어 더 간결하고 오류가 적은 switch 버전을 제공합니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\nvoid day_of_week(DoW day) {\n    int numLetters;\n    switch (day) {  // 규칙 위반\n      case MONDAY:\n      case FRIDAY:\n      case SUNDAY:\n        numLetters = 6;\n        break;\n      case TUESDAY:\n        numLetters = 7;\n        break;\n      case THURSDAY:\n      case SATURDAY:\n        numLetters = 8;\n        break;\n      case WEDNESDAY:\n        numLetters = 9;\n        break;\n      default:\n        throw new IllegalStateException(\"Wat: \" + day);\n    }\n}\n\nint return_switch(int x) {\n    switch (x) { // 규칙 위반\n      case 1:\n        return 1;\n      case 2:\n        return 2;\n      default:\n        throw new IllegalStateException();\n    }\n}\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre>\nint numLetters = switch (day) {\n    case MONDAY, FRIDAY, SUNDAY -&gt; 6;\n    case TUESDAY                -&gt; 7;\n    case THURSDAY, SATURDAY     -&gt; 8;\n    case WEDNESDAY              -&gt; 9;\n};\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": ""
  },
  {
    "id": "S6242",
    "key": "java:S6242",
    "name": "Credentials Provider should be set explicitly when creating a new \"AwsClient\"",
    "type": "code-smell",
    "severity": "major",
    "tags": [
      "startup-time",
      "aws"
    ],
    "why": "<p>If the credentials provider is not specified when creating a new AwsClient with an <a\nhref=\"https://sdk.amazonaws.com/java/api/latest/software/amazon/awssdk/awscore/client/builder/AwsClientBuilder.html\">AwsClientBuilder</a>, the AWS SDK\nwill execute some logic to identify it automatically.</p>\n<p>While it will probably identify the correct one, this extra logic will slow down startup time, already known to be a hotspot.</p>\n<p>You should therefore always define the logic to set the credentials provider yourself. This is typically done by retrieving it from the Lambda\nprovided environment variable.</p>\n<p>This will make the code more explicit and spare initialization time.</p>\n<p>This rule reports an issue when the credentials provider is not set when creating an AwsClient.</p>\n<h3>Noncompliant code example</h3>\n<pre>\nS3Client.builder()\n    .region(Region.of(System.getenv(SdkSystemSetting.AWS_REGION.environmentVariable())))\n    .build();\n</pre>\n<h3>Compliant solution</h3>\n<pre>\nS3Client.builder()\n    .region(Region.of(System.getenv(SdkSystemSetting.AWS_REGION.environmentVariable()))\n    .credentialsProvider(EnvironmentVariableCredentialsProvider.create())\n    .build();\n</pre>",
    "howToFix": "",
    "moreInfo": "<ul>\n  <li> <a href=\"https://aws.amazon.com/fr/blogs/developer/tuning-the-aws-java-sdk-2-x-to-reduce-startup-time/\">Tuning the AWS Java SDK 2.x to reduce\n  startup time</a> </li>\n  <li> <a href=\"https://docs.aws.amazon.com/sdk-for-java/latest/developer-guide/lambda-optimize-starttime.html\">Optimizing cold start performance for\n  AWS Lambda</a> </li>\n  <li> <a href=\"https://docs.aws.amazon.com/lambda/latest/dg/configuration-envvars.html\">Environment variable configuration</a> </li>\n  <li> <a href=\"https://docs.aws.amazon.com/sdk-for-java/v1/developer-guide/credentials.html\">Default Credential Provider Chain</a> </li>\n</ul>",
    "status": "READY",
    "name_ko": "새 \"AwsClient\" 생성 시 Credentials Provider를 명시적으로 설정해야 합니다",
    "why_ko": "<p><a href=\"https://sdk.amazonaws.com/java/api/latest/software/amazon/awssdk/awscore/client/builder/AwsClientBuilder.html\">AwsClientBuilder</a>로 새 AwsClient를 생성할 때 credentials provider가 지정되지 않으면 AWS SDK는 자동으로 식별하는 로직을 실행합니다.</p>\n<p>올바른 것을 식별할 가능성이 높지만, 이 추가 로직은 이미 핫스팟으로 알려진 시작 시간을 느리게 합니다.</p>\n<p>따라서 항상 credentials provider를 직접 설정하는 로직을 정의해야 합니다. 일반적으로 Lambda가 제공하는 환경 변수에서 가져와서 수행합니다.</p>\n<p>이렇게 하면 코드가 더 명시적이고 초기화 시간을 절약할 수 있습니다.</p>\n<p>이 규칙은 AwsClient를 생성할 때 credentials provider가 설정되지 않으면 문제를 보고합니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\nS3Client.builder()\n    .region(Region.of(System.getenv(SdkSystemSetting.AWS_REGION.environmentVariable())))\n    .build();\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre>\nS3Client.builder()\n    .region(Region.of(System.getenv(SdkSystemSetting.AWS_REGION.environmentVariable()))\n    .credentialsProvider(EnvironmentVariableCredentialsProvider.create())\n    .build();\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": "<ul>\n  <li> <a href=\"https://aws.amazon.com/fr/blogs/developer/tuning-the-aws-java-sdk-2-x-to-reduce-startup-time/\">AWS Java SDK 2.x를 튜닝하여 시작 시간 단축</a> </li>\n  <li> <a href=\"https://docs.aws.amazon.com/sdk-for-java/latest/developer-guide/lambda-optimize-starttime.html\">AWS Lambda 콜드 스타트 성능 최적화</a> </li>\n  <li> <a href=\"https://docs.aws.amazon.com/lambda/latest/dg/configuration-envvars.html\">환경 변수 구성</a> </li>\n  <li> <a href=\"https://docs.aws.amazon.com/sdk-for-java/v1/developer-guide/credentials.html\">기본 Credential Provider 체인</a> </li>\n</ul>"
  },
  {
    "id": "S1641",
    "key": "java:S1641",
    "name": "Sets with elements that are enum values should be replaced with EnumSet",
    "type": "code-smell",
    "severity": "minor",
    "tags": [
      "performance"
    ],
    "why": "<p>When all the elements in a Set are values from the same enum, the Set can be replaced with an EnumSet, which can be much more efficient than other\nsets because the underlying data structure is a simple bitmap.</p>\n<h3>Noncompliant code example</h3>\n<pre>\npublic class MyClass {\n\n  public enum COLOR {\n    RED, GREEN, BLUE, ORANGE;\n  }\n\n  public void doSomething() {\n    Set&lt;COLOR&gt; warm = new HashSet&lt;COLOR&gt;();\n    warm.add(COLOR.RED);\n    warm.add(COLOR.ORANGE);\n  }\n}\n</pre>\n<h3>Compliant solution</h3>\n<pre>\npublic class MyClass {\n\n  public enum COLOR {\n    RED, GREEN, BLUE, ORANGE;\n  }\n\n  public void doSomething() {\n    Set&lt;COLOR&gt; warm = EnumSet.of(COLOR.RED, COLOR.ORANGE);\n  }\n}\n</pre>",
    "howToFix": "",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "enum 값을 요소로 가진 Set은 EnumSet으로 대체해야 합니다",
    "why_ko": "<p>Set의 모든 요소가 동일한 enum의 값인 경우 Set을 EnumSet으로 대체할 수 있으며, 이는 기본 데이터 구조가 간단한 비트맵이므로 다른 Set보다 훨씬 더 효율적일 수 있습니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\npublic class MyClass {\n\n  public enum COLOR {\n    RED, GREEN, BLUE, ORANGE;\n  }\n\n  public void doSomething() {\n    Set&lt;COLOR&gt; warm = new HashSet&lt;COLOR&gt;();\n    warm.add(COLOR.RED);\n    warm.add(COLOR.ORANGE);\n  }\n}\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre>\npublic class MyClass {\n\n  public enum COLOR {\n    RED, GREEN, BLUE, ORANGE;\n  }\n\n  public void doSomething() {\n    Set&lt;COLOR&gt; warm = EnumSet.of(COLOR.RED, COLOR.ORANGE);\n  }\n}\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": ""
  },
  {
    "id": "S1210",
    "key": "java:S1210",
    "name": "\"equals(Object obj)\" should be overridden along with the \"compareTo(T obj)\" method",
    "type": "code-smell",
    "severity": "minor",
    "tags": [],
    "why": "<p>According to the Java <code>Comparable.compareTo(T o)</code> documentation:</p>\n<blockquote>\n  <p>It is strongly recommended, but not strictly required that <code>(x.compareTo(y)==0) == (x.equals(y))</code>.</p>\n  <p>Generally speaking, any class that implements the Comparable interface and violates this condition should clearly indicate this fact.</p>\n  <p>The recommended language is \"Note: this class has a natural ordering that is inconsistent with equals.\"</p>\n</blockquote>\n<p>If this rule is violated, weird and unpredictable failures can occur.</p>\n<p>For example, in Java 5 the <code>PriorityQueue.remove()</code> method relied on <code>compareTo()</code>, but since Java 6 it has relied on\n<code>equals()</code>.</p>\n<h3>Noncompliant code example</h3>\n<pre>\npublic class Foo implements Comparable&lt;Foo&gt; {\n  @Override\n  public int compareTo(Foo foo) { /* ... */ }      // Noncompliant as the equals(Object obj) method is not overridden\n}\n</pre>\n<h3>Compliant solution</h3>\n<pre>\npublic class Foo implements Comparable&lt;Foo&gt; {\n  @Override\n  public int compareTo(Foo foo) { /* ... */ }      // Compliant\n\n  @Override\n  public boolean equals(Object obj) { /* ... */ }\n}\n</pre>",
    "howToFix": "",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "\"compareTo(T obj)\" 메서드와 함께 \"equals(Object obj)\"도 오버라이드해야 합니다",
    "why_ko": "<p>Java <code>Comparable.compareTo(T o)</code> 문서에 따르면:</p>\n<blockquote>\n  <p><code>(x.compareTo(y)==0) == (x.equals(y))</code>인 것이 강력히 권장되지만, 엄격하게 필수는 아닙니다.</p>\n  <p>일반적으로, Comparable 인터페이스를 구현하고 이 조건을 위반하는 모든 클래스는 이 사실을 명확하게 표시해야 합니다.</p>\n  <p>권장되는 문구는 \"참고: 이 클래스는 equals와 일치하지 않는 자연 순서를 가집니다.\"입니다.</p>\n</blockquote>\n<p>이 규칙을 위반하면 이상하고 예측할 수 없는 오류가 발생할 수 있습니다.</p>\n<p>예를 들어, Java 5에서 <code>PriorityQueue.remove()</code> 메서드는 <code>compareTo()</code>에 의존했지만, Java 6부터는 <code>equals()</code>에 의존합니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\npublic class Foo implements Comparable&lt;Foo&gt; {\n  @Override\n  public int compareTo(Foo foo) { /* ... */ }      // 규칙 위반 - equals(Object obj) 메서드가 오버라이드되지 않음\n}\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre>\npublic class Foo implements Comparable&lt;Foo&gt; {\n  @Override\n  public int compareTo(Foo foo) { /* ... */ }      // 규칙 준수\n\n  @Override\n  public boolean equals(Object obj) { /* ... */ }\n}\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": ""
  },
  {
    "id": "S1640",
    "key": "java:S1640",
    "name": "Maps with keys that are enum values should use the EnumMap implementation",
    "type": "code-smell",
    "severity": "minor",
    "tags": [
      "performance"
    ],
    "why": "<p>If all the keys in a <code>Map</code> are values from a single enum, it is recommended to use an <code>EnumMap</code> as the specific\nimplementation. An <code>EnumMap</code>, which has the advantage of knowing all possible keys in advance, is more efficient compared to other\nimplementations, as it can use a simple array as its underlying data structure.</p>\n<h3>Noncompliant code example</h3>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\npublic enum Color {\n  RED, GREEN, BLUE, ORANGE;\n}\n\nMap&lt;Color, String&gt; colorMap = new HashMap&lt;&gt;(); // Noncompliant\n</pre>\n<h3>Compliant solution</h3>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\npublic enum Color {\n  RED, GREEN, BLUE, ORANGE;\n}\n\nMap&lt;Color, String&gt; colorMap = new EnumMap&lt;&gt;(Color.class); // Compliant\n</pre>",
    "howToFix": "",
    "moreInfo": "<ul>\n  <li> <a href=\"https://www.baeldung.com/java-enum-map\">A Guide to EnumMap - Baeldung</a> </li>\n</ul>",
    "status": "READY",
    "name_ko": "enum 값을 키로 사용하는 Map은 EnumMap 구현을 사용해야 합니다",
    "why_ko": "<p><code>Map</code>의 모든 키가 단일 enum의 값인 경우 <code>EnumMap</code>을 특정 구현으로 사용하는 것이 좋습니다. <code>EnumMap</code>은 가능한 모든 키를 미리 알고 있다는 장점이 있어 기본 데이터 구조로 간단한 배열을 사용할 수 있으므로 다른 구현에 비해 더 효율적입니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\npublic enum Color {\n  RED, GREEN, BLUE, ORANGE;\n}\n\nMap&lt;Color, String&gt; colorMap = new HashMap&lt;&gt;(); // 규칙 위반\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\npublic enum Color {\n  RED, GREEN, BLUE, ORANGE;\n}\n\nMap&lt;Color, String&gt; colorMap = new EnumMap&lt;&gt;(Color.class); // 규칙 준수\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": "<ul>\n  <li> <a href=\"https://www.baeldung.com/java-enum-map\">EnumMap 가이드 - Baeldung</a> </li>\n</ul>"
  },
  {
    "id": "S2129",
    "key": "java:S2129",
    "name": "Constructors should not be used to instantiate \"String\", \"BigInteger\", \"BigDecimal\" and primitive-wrapper classes",
    "type": "code-smell",
    "severity": "major",
    "tags": [
      "performance"
    ],
    "why": "<p>Calling constructors for <code>String</code>, <code>BigInteger</code>, <code>BigDecimal</code> and the objects used to wrap primitives is less\nefficient and less clear than relying on autoboxing or <code>valueOf</code>.</p>\n<p>Consider simplifying when possible for more efficient and cleaner code.</p>\n<h3>Noncompliant code example</h3>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\nString empty = new String(); // Noncompliant; yields essentially \"\", so just use that.\nString nonempty = new String(\"Hello world\"); // Noncompliant\nDouble myDouble = new Double(1.1); // Noncompliant; use valueOf\nInteger integer = new Integer(1); // Noncompliant\nBoolean bool = new Boolean(true); // Noncompliant\nBigInteger bigInteger1 = new BigInteger(\"3\"); // Noncompliant\nBigInteger bigInteger2 = new BigInteger(\"9223372036854775807\"); // Noncompliant\nBigInteger bigInteger3 = new BigInteger(\"111222333444555666777888999\"); // Compliant, greater than Long.MAX_VALUE\nBigDecimal bigDecimal = new BigDecimal(\"42.0\"); // Compliant (see Exceptions section)\n</pre>\n<h3>Compliant solution</h3>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\nString empty = \"\";\nString nonempty = \"Hello world\";\nDouble myDouble = 1.1;\nInteger integer = 1;\nBoolean bool = true;\nBigInteger bigInteger1 = BigInteger.valueOf(3);\nBigInteger bigInteger2 = BigInteger.valueOf(9223372036854775807L);\nBigInteger bigInteger3 = new BigInteger(\"111222333444555666777888999\");\nBigDecimal bigDecimal = new BigDecimal(\"42.0\");\n</pre>\n<h3>Exceptions</h3>\n<p><code>BigDecimal</code> constructor with a <code>double</code> argument is ignored as using <code>valueOf</code> instead might change the resulting\nvalue. See <a href='/coding_rules#rule_key=java%3AS2111'>S2111</a>.</p>",
    "howToFix": "",
    "moreInfo": "<ul>\n  <li> <a href=\"https://docs.oracle.com/javase/tutorial/java/data/autoboxing.html\">Oracle - Learning the Java Language</a> - Autoboxing and Unboxing\n  </li>\n</ul>",
    "status": "READY",
    "name_ko": "String, BigInteger, BigDecimal 및 primitive-wrapper 클래스 인스턴스화에 생성자를 사용하면 안 됩니다",
    "why_ko": "<p><code>String</code>, <code>BigInteger</code>, <code>BigDecimal</code> 및 primitive를 래핑하는 데 사용되는 객체의 생성자를 호출하는 것은 오토박싱이나 <code>valueOf</code>에 의존하는 것보다 덜 효율적이고 덜 명확합니다.</p>\n<p>더 효율적이고 깨끗한 코드를 위해 가능한 경우 단순화하는 것을 고려하세요.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\nString empty = new String(); // 규칙 위반; 본질적으로 \"\"를 생성하므로 그냥 그것을 사용하세요.\nString nonempty = new String(\"Hello world\"); // 규칙 위반\nDouble myDouble = new Double(1.1); // 규칙 위반; valueOf 사용\nInteger integer = new Integer(1); // 규칙 위반\nBoolean bool = new Boolean(true); // 규칙 위반\nBigInteger bigInteger1 = new BigInteger(\"3\"); // 규칙 위반\nBigInteger bigInteger2 = new BigInteger(\"9223372036854775807\"); // 규칙 위반\nBigInteger bigInteger3 = new BigInteger(\"111222333444555666777888999\"); // 규칙 준수, Long.MAX_VALUE보다 큼\nBigDecimal bigDecimal = new BigDecimal(\"42.0\"); // 규칙 준수 (예외 섹션 참조)\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\nString empty = \"\";\nString nonempty = \"Hello world\";\nDouble myDouble = 1.1;\nInteger integer = 1;\nBoolean bool = true;\nBigInteger bigInteger1 = BigInteger.valueOf(3);\nBigInteger bigInteger2 = BigInteger.valueOf(9223372036854775807L);\nBigInteger bigInteger3 = new BigInteger(\"111222333444555666777888999\");\nBigDecimal bigDecimal = new BigDecimal(\"42.0\");\n</pre>\n<h3>예외</h3>\n<p><code>double</code> 인수가 있는 <code>BigDecimal</code> 생성자는 대신 <code>valueOf</code>를 사용하면 결과 값이 변경될 수 있으므로 무시됩니다. <a href='/coding_rules#rule_key=java%3AS2111'>S2111</a>을 참조하세요.</p>",
    "howToFix_ko": "",
    "moreInfo_ko": "<ul>\n  <li> <a href=\"https://docs.oracle.com/javase/tutorial/java/data/autoboxing.html\">Oracle - Java 언어 학습</a> - 오토박싱과 언박싱 </li>\n</ul>"
  },
  {
    "id": "S4507",
    "key": "java:S4507",
    "name": "Delivering code in production with debug features activated is security-sensitive",
    "type": "security-hotspot",
    "severity": "minor",
    "tags": [
      "spring",
      "error-handling",
      "cwe",
      "debug",
      "user-experience"
    ],
    "why": "<p>Development tools and frameworks usually have options to make debugging easier for developers. Although these features are useful during\ndevelopment, they should never be enabled for applications deployed in production. Debug instructions or error messages can leak detailed information\nabout the system, like the application's path or file names.</p>\n",
    "howToFix": "<h2>Recommended Secure Coding Practices</h2>\n<p>Do not enable debugging features on production servers or applications distributed to end users.</p>\n<h2>Compliant Solution</h2>\n<p>Loggers should be used (instead of <code>printStackTrace</code>) to print throwables:</p>\n<pre>\ntry {\n  /* ... */\n} catch(Exception e) {\n  LOGGER.log(\"context\", e);\n}\n</pre>\n<p><a\nhref=\"https://docs.spring.io/spring-security/site/docs/current/api/org/springframework/security/config/annotation/web/configuration/EnableWebSecurity.html\">EnableWebSecurity</a>\nannotation for SpringFramework with <code>debug</code> to <code>false</code> disables debugging support:</p>\n<pre>\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;\n\n@Configuration\n@EnableWebSecurity(debug = false)\npublic class WebSecurityConfig extends WebSecurityConfigurerAdapter {\n  // ...\n}\n</pre>\n<p><a\nhref=\"https://developer.android.com/reference/android/webkit/WebView#setWebContentsDebuggingEnabled(boolean)\">WebView.setWebContentsDebuggingEnabled(false)</a>\nfor Android disables debugging support:</p>\n<pre>\nimport android.webkit.WebView;\n\nWebView.setWebContentsDebuggingEnabled(false);\nWebView.getFactory().getStatics().setWebContentsDebuggingEnabled(false);\n</pre>\n<h2>See</h2>\n<ul>\n  <li> OWASP - <a href=\"https://owasp.org/Top10/A05_2021-Security_Misconfiguration/\">Top 10 2021 Category A5 - Security Misconfiguration</a> </li>\n  <li> OWASP - <a href=\"https://owasp.org/www-project-top-ten/2017/A3_2017-Sensitive_Data_Exposure\">Top 10 2017 Category A3 - Sensitive Data\n  Exposure</a> </li>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/489\">CWE-489 - Active Debug Code</a> </li>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/215\">CWE-215 - Information Exposure Through Debug Information</a> </li>\n</ul>",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "디버그 기능이 활성화된 코드를 프로덕션에 배포하는 것은 보안에 민감합니다",
    "why_ko": "<p>개발 도구와 프레임워크에는 일반적으로 개발자가 디버깅을 더 쉽게 할 수 있는 옵션이 있습니다. 이러한 기능은 개발 중에 유용하지만 프로덕션에 배포된 애플리케이션에서는 절대로 활성화하면 안 됩니다. 디버그 명령어나 오류 메시지는 애플리케이션의 경로나 파일 이름과 같은 시스템에 대한 자세한 정보를 누출할 수 있습니다.</p>\n",
    "howToFix_ko": "<h2>권장 보안 코딩 방법</h2>\n<p>프로덕션 서버나 최종 사용자에게 배포되는 애플리케이션에서 디버깅 기능을 활성화하지 마세요.</p>\n<h2>규칙을 준수하는 해결책</h2>\n<p>throwable을 출력하려면 (<code>printStackTrace</code> 대신) 로거를 사용해야 합니다:</p>\n<pre>\ntry {\n  /* ... */\n} catch(Exception e) {\n  LOGGER.log(\"context\", e);\n}\n</pre>\n<p><code>debug</code>를 <code>false</code>로 설정한 SpringFramework용 <a href=\"https://docs.spring.io/spring-security/site/docs/current/api/org/springframework/security/config/annotation/web/configuration/EnableWebSecurity.html\">EnableWebSecurity</a> 어노테이션은 디버깅 지원을 비활성화합니다:</p>\n<pre>\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;\n\n@Configuration\n@EnableWebSecurity(debug = false)\npublic class WebSecurityConfig extends WebSecurityConfigurerAdapter {\n  // ...\n}\n</pre>\n<p>Android용 <a href=\"https://developer.android.com/reference/android/webkit/WebView#setWebContentsDebuggingEnabled(boolean)\">WebView.setWebContentsDebuggingEnabled(false)</a>는 디버깅 지원을 비활성화합니다:</p>\n<pre>\nimport android.webkit.WebView;\n\nWebView.setWebContentsDebuggingEnabled(false);\nWebView.getFactory().getStatics().setWebContentsDebuggingEnabled(false);\n</pre>\n<h2>참고</h2>\n<ul>\n  <li> OWASP - <a href=\"https://owasp.org/Top10/A05_2021-Security_Misconfiguration/\">Top 10 2021 Category A5 - Security Misconfiguration</a> </li>\n  <li> OWASP - <a href=\"https://owasp.org/www-project-top-ten/2017/A3_2017-Sensitive_Data_Exposure\">Top 10 2017 Category A3 - Sensitive Data Exposure</a> </li>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/489\">CWE-489 - Active Debug Code</a> </li>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/215\">CWE-215 - Information Exposure Through Debug Information</a> </li>\n</ul>",
    "moreInfo_ko": ""
  },
  {
    "id": "S2200",
    "key": "java:S2200",
    "name": "\"compareTo\" results should not be checked for specific values",
    "type": "bug",
    "severity": "minor",
    "tags": [
      "unpredictable"
    ],
    "why": "<p>Assuming that a comparator or <code>compareTo</code> method always returns -1 or 1 if the first operand is less than or greater than the second is\nincorrect.</p>\n<p>The specifications for both methods, <code>Comparator.compare</code> and <code>Comparable.compareTo</code>, state that their return value is \"a\nnegative integer, zero, or a positive integer as this object is less than, equal to, or greater than the specified object.\" Even if a specific\ncomparator always returns -1, 0, or 1, this is only an implementation detail, not the API contract developers can rely on.</p>",
    "howToFix": "<p>Replace</p>\n<ul>\n  <li> <code>== -1</code> with <code>&lt; 0</code> (the first operand is less than the second) </li>\n  <li> <code>== 1</code> with <code>&gt; 0</code> (the first operand is greater than the second) </li>\n  <li> <code>!= -1</code> with <code>&gt;= 0</code> (the first operand is greater than or equal to the second) </li>\n  <li> <code>!= 1</code> with <code>&lt;= 0</code> (the first operand is less than or equal to the second) </li>\n</ul>\n\n<h4>Noncompliant code example</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\npublic class Main {\n\n  boolean isAGreaterThanB(Comparable&lt;Integer&gt; a, Integer b) {\n    return a.compareTo(b) == 1; // Noncompliant, check for constant return value\n  }\n\n  public static void main(String[] args) {\n    ByteComparator comparator = new ByteComparator();\n    if (comparator.compare((byte) 23, (byte) 42) == -1) { // Noncompliant, check for constant return value\n      System.out.println(\"23 &lt; 42\");\n    } else {\n      System.out.println(\"23 &gt;= 42\");\n    }\n  }\n\n  static class ByteComparator implements Comparator&lt;Byte&gt; {\n    @Override\n    public int compare(Byte a, Byte b) {\n      return a - b;\n    }\n  }\n}\n</pre>\n<h4>Compliant solution</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\npublic class Main {\n\n  boolean isAGreaterThanB(Comparable&lt;Integer&gt; a, Integer b) {\n    return a.compareTo(b) &gt; 0; // Compliant, check for positive return value\n  }\n\n  public static void main(String[] args) {\n    ByteComparator comparator = new ByteComparator();\n    if (comparator.compare((byte) 23, (byte) 42) &lt; 0) { // Compliant, check for negative return value\n      System.out.println(\"23 &lt; 42\");\n    } else {\n      System.out.println(\"23 &gt;= 42\");\n    }\n  }\n\n  static class ByteComparator implements Comparator&lt;Byte&gt; {\n    @Override\n    public int compare(Byte a, Byte b) {\n      return a - b;\n    }\n  }\n}\n</pre>",
    "moreInfo": "<h3>Documentation</h3>\n<ul>\n  <li> <a href=\"https://docs.oracle.com/javase/8/docs/api/java/lang/Comparable.html#compareTo-T-\">Java SE 8 API Specification:\n  Comparable.compareTo</a> </li>\n  <li> <a href=\"https://docs.oracle.com/javase/8/docs/api/java/util/Comparator.html#compare-T-T-\">Java SE 8 API Specification: Comparator.compare</a>\n  </li>\n</ul>",
    "status": "READY",
    "name_ko": "\"compareTo\" 결과를 특정 값과 비교하면 안 됩니다",
    "why_ko": "<p>comparator나 <code>compareTo</code> 메서드가 첫 번째 피연산자가 두 번째보다 작거나 클 때 항상 -1 또는 1을 반환한다고 가정하는 것은 잘못된 것입니다.</p>\n<p><code>Comparator.compare</code>와 <code>Comparable.compareTo</code> 두 메서드의 명세는 반환 값이 \"이 객체가 지정된 객체보다 작으면 음의 정수, 같으면 0, 크면 양의 정수\"라고 명시합니다. 특정 comparator가 항상 -1, 0, 또는 1을 반환하더라도 이는 구현 세부사항일 뿐 개발자가 의존할 수 있는 API 계약이 아닙니다.</p>",
    "howToFix_ko": "<p>다음과 같이 교체하세요</p>\n<ul>\n  <li> <code>== -1</code>을 <code>&lt; 0</code>으로 (첫 번째 피연산자가 두 번째보다 작음) </li>\n  <li> <code>== 1</code>을 <code>&gt; 0</code>으로 (첫 번째 피연산자가 두 번째보다 큼) </li>\n  <li> <code>!= -1</code>을 <code>&gt;= 0</code>으로 (첫 번째 피연산자가 두 번째보다 크거나 같음) </li>\n  <li> <code>!= 1</code>을 <code>&lt;= 0</code>으로 (첫 번째 피연산자가 두 번째보다 작거나 같음) </li>\n</ul>\n\n<h4>규칙을 준수하지 않는 코드 예시</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\npublic class Main {\n\n  boolean isAGreaterThanB(Comparable&lt;Integer&gt; a, Integer b) {\n    return a.compareTo(b) == 1; // 규칙 위반, 상수 반환 값 확인\n  }\n\n  public static void main(String[] args) {\n    ByteComparator comparator = new ByteComparator();\n    if (comparator.compare((byte) 23, (byte) 42) == -1) { // 규칙 위반, 상수 반환 값 확인\n      System.out.println(\"23 &lt; 42\");\n    } else {\n      System.out.println(\"23 &gt;= 42\");\n    }\n  }\n\n  static class ByteComparator implements Comparator&lt;Byte&gt; {\n    @Override\n    public int compare(Byte a, Byte b) {\n      return a - b;\n    }\n  }\n}\n</pre>\n<h4>규칙을 준수하는 해결책</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\npublic class Main {\n\n  boolean isAGreaterThanB(Comparable&lt;Integer&gt; a, Integer b) {\n    return a.compareTo(b) &gt; 0; // 규칙 준수, 양수 반환 값 확인\n  }\n\n  public static void main(String[] args) {\n    ByteComparator comparator = new ByteComparator();\n    if (comparator.compare((byte) 23, (byte) 42) &lt; 0) { // 규칙 준수, 음수 반환 값 확인\n      System.out.println(\"23 &lt; 42\");\n    } else {\n      System.out.println(\"23 &gt;= 42\");\n    }\n  }\n\n  static class ByteComparator implements Comparator&lt;Byte&gt; {\n    @Override\n    public int compare(Byte a, Byte b) {\n      return a - b;\n    }\n  }\n}\n</pre>",
    "moreInfo_ko": "<h3>문서</h3>\n<ul>\n  <li> <a href=\"https://docs.oracle.com/javase/8/docs/api/java/lang/Comparable.html#compareTo-T-\">Java SE 8 API 명세: Comparable.compareTo</a> </li>\n  <li> <a href=\"https://docs.oracle.com/javase/8/docs/api/java/util/Comparator.html#compare-T-T-\">Java SE 8 API 명세: Comparator.compare</a> </li>\n</ul>"
  },
  {
    "id": "S6243",
    "key": "java:S6243",
    "name": "Reusable resources should be initialized at construction time of Lambda functions",
    "type": "code-smell",
    "severity": "major",
    "tags": [
      "aws"
    ],
    "why": "<p>Resources that can be reused across multiple invocations of the Lambda function should be initialized at construction time. For example in the\nconstructor of the class, or in field initializers. This way, when the same container is reused for multiple function invocations, the existing\ninstance can be reused, along with all resources stored in its fields. It is a good practice to reuse SDK clients and database connections by\ninitializing them at class construction time, to avoid recreating them on every lambda invocation. Failing to do so can lead to performance\ndegradation, and when not closed properly, even out of memory errors.</p>\n<p>This rule reports an issue when the SDK client or the database connection is initialized locally inside a Lambda function.</p>\n<h3>Noncompliant code example</h3>\n<pre>\npublic class App implements RequestHandler&lt;Object, Object&gt; {\n    @Override\n    public Object handleRequest(final Object input, final Context context) {\n      S3Client s3Client = DependencyFactory.s3Client();\n      s3Client.listBuckets();\n      // ...\n    }\n}\n</pre>\n<h3>Compliant solution</h3>\n<pre>\npublic class App implements RequestHandler&lt;Object, Object&gt; {\n    private final S3Client s3Client;\n\n    public App() {\n      s3Client = DependencyFactory.s3Client();\n    }\n\n    @Override\n    public Object handleRequest(final Object input, final Context context) {\n      s3Client.listBuckets();\n      // ...\n    }\n}\n</pre>",
    "howToFix": "",
    "moreInfo": "<ul>\n  <li> <a href=\"https://aws.amazon.com/fr/blogs/developer/tuning-the-aws-java-sdk-2-x-to-reduce-startup-time/\">Tuning the AWS Java SDK 2.x to reduce\n  startup time</a> </li>\n  <li> <a href=\"https://docs.aws.amazon.com/lambda/latest/dg/best-practices.html\">Best practices for working with AWS Lambda functions</a> </li>\n  <li> <a href=\"https://aws.amazon.com/fr/blogs/compute/container-reuse-in-lambda/\">Understanding Container Reuse in AWS Lambda</a> </li>\n</ul>",
    "status": "READY",
    "name_ko": "재사용 가능한 리소스는 Lambda 함수 생성 시점에 초기화해야 합니다",
    "why_ko": "<p>Lambda 함수의 여러 호출에서 재사용할 수 있는 리소스는 생성 시점에 초기화해야 합니다. 예를 들어 클래스의 생성자나 필드 초기화자에서 초기화합니다. 이렇게 하면 동일한 컨테이너가 여러 함수 호출에 재사용될 때 기존 인스턴스와 필드에 저장된 모든 리소스를 재사용할 수 있습니다. 매번 lambda 호출 시 재생성하는 것을 피하기 위해 클래스 생성 시점에 SDK 클라이언트와 데이터베이스 연결을 초기화하여 재사용하는 것이 좋은 관행입니다. 그렇게 하지 않으면 성능 저하가 발생할 수 있고, 제대로 닫히지 않으면 메모리 부족 오류까지 발생할 수 있습니다.</p>\n<p>이 규칙은 SDK 클라이언트나 데이터베이스 연결이 Lambda 함수 내부에서 로컬로 초기화될 때 문제를 보고합니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\npublic class App implements RequestHandler&lt;Object, Object&gt; {\n    @Override\n    public Object handleRequest(final Object input, final Context context) {\n      S3Client s3Client = DependencyFactory.s3Client();\n      s3Client.listBuckets();\n      // ...\n    }\n}\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre>\npublic class App implements RequestHandler&lt;Object, Object&gt; {\n    private final S3Client s3Client;\n\n    public App() {\n      s3Client = DependencyFactory.s3Client();\n    }\n\n    @Override\n    public Object handleRequest(final Object input, final Context context) {\n      s3Client.listBuckets();\n      // ...\n    }\n}\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": "<ul>\n  <li> <a href=\"https://aws.amazon.com/fr/blogs/developer/tuning-the-aws-java-sdk-2-x-to-reduce-startup-time/\">AWS Java SDK 2.x를 튜닝하여 시작 시간 단축</a> </li>\n  <li> <a href=\"https://docs.aws.amazon.com/lambda/latest/dg/best-practices.html\">AWS Lambda 함수 작업 모범 사례</a> </li>\n  <li> <a href=\"https://aws.amazon.com/fr/blogs/compute/container-reuse-in-lambda/\">AWS Lambda 컨테이너 재사용 이해</a> </li>\n</ul>"
  },
  {
    "id": "S1181",
    "key": "java:S1181",
    "name": "Throwable and Error should not be caught",
    "type": "code-smell",
    "severity": "major",
    "tags": [
      "error-handling",
      "cwe",
      "bad-practice",
      "cert"
    ],
    "why": "<p><code>Throwable</code> is the superclass of all errors and exceptions in Java. <code>Error</code> is the superclass of all errors, which are not\nmeant to be caught by applications.</p>\n<p>Catching either <code>Throwable</code> or <code>Error</code> will also catch <code>OutOfMemoryError</code> and <code>InternalError</code>, from\nwhich an application should not attempt to recover.</p>\n<h3>Noncompliant code example</h3>\n<pre>\ntry { /* ... */ } catch (Throwable t) { /* ... */ }\ntry { /* ... */ } catch (Error e) { /* ... */ }\n</pre>\n<h3>Compliant solution</h3>\n<pre>\ntry { /* ... */ } catch (RuntimeException e) { /* ... */ }\ntry { /* ... */ } catch (MyException e) { /* ... */ }\n</pre>",
    "howToFix": "",
    "moreInfo": "<ul>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/396\">CWE-396 - Declaration of Catch for Generic Exception</a> </li>\n  <li> <a href=\"https://wiki.sei.cmu.edu/confluence/display/java/ERR08-J.+Do+not+catch+NullPointerException+or+any+of+its+ancestors\">CERT,\n  ERR08-J.</a> - Do not catch NullPointerException or any of its ancestors </li>\n</ul>",
    "status": "READY",
    "name_ko": "Throwable과 Error는 catch하면 안 됩니다",
    "why_ko": "<p><code>Throwable</code>은 Java의 모든 오류와 예외의 슈퍼클래스입니다. <code>Error</code>는 애플리케이션이 catch하도록 의도되지 않은 모든 오류의 슈퍼클래스입니다.</p>\n<p><code>Throwable</code>이나 <code>Error</code>를 catch하면 <code>OutOfMemoryError</code>와 <code>InternalError</code>도 catch하게 되는데, 애플리케이션은 이러한 오류에서 복구를 시도해서는 안 됩니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\ntry { /* ... */ } catch (Throwable t) { /* ... */ }\ntry { /* ... */ } catch (Error e) { /* ... */ }\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre>\ntry { /* ... */ } catch (RuntimeException e) { /* ... */ }\ntry { /* ... */ } catch (MyException e) { /* ... */ }\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": "<ul>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/396\">CWE-396 - 일반 예외에 대한 Catch 선언</a> </li>\n  <li> <a href=\"https://wiki.sei.cmu.edu/confluence/display/java/ERR08-J.+Do+not+catch+NullPointerException+or+any+of+its+ancestors\">CERT, ERR08-J.</a> - NullPointerException이나 그 상위 예외를 catch하지 마세요 </li>\n</ul>"
  },
  {
    "id": "S2257",
    "key": "java:S2257",
    "name": "Using non-standard cryptographic algorithms is security-sensitive",
    "type": "security-hotspot",
    "severity": "critical",
    "tags": [
      "cwe"
    ],
    "why": "<p>The use of a non-standard algorithm is dangerous because a determined attacker may be able to break the algorithm and compromise whatever data has\nbeen protected. Standard algorithms like <code>SHA-256</code>, <code>SHA-384</code>, <code>SHA-512</code>, …​ should be used instead.</p>\n<p>This rule tracks creation of <code>java.security.MessageDigest</code> subclasses.</p>\n",
    "howToFix": "<h2>Recommended Secure Coding Practices</h2>\n<ul>\n  <li> Use a standard algorithm instead of creating a custom one. </li>\n</ul>\n<h2>Compliant Solution</h2>\n<pre>\nMessageDigest digest = MessageDigest.getInstance(\"SHA-256\");\n</pre>\n<h2>See</h2>\n<ul>\n  <li> OWASP - <a href=\"https://owasp.org/Top10/A02_2021-Cryptographic_Failures/\">Top 10 2021 Category A2 - Cryptographic Failures</a> </li>\n  <li> OWASP - <a href=\"https://owasp.org/www-project-top-ten/2017/A3_2017-Sensitive_Data_Exposure\">Top 10 2017 Category A3 - Sensitive Data\n  Exposure</a> </li>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/327\">CWE-327 - Use of a Broken or Risky Cryptographic Algorithm</a> </li>\n  <li> Derived from FindSecBugs rule <a href=\"https://h3xstream.github.io/find-sec-bugs/bugs.htm#CUSTOM_MESSAGE_DIGEST\">MessageDigest is Custom</a>\n  </li>\n</ul>",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "비표준 암호화 알고리즘 사용은 보안에 민감합니다",
    "why_ko": "<p>비표준 알고리즘의 사용은 위험합니다. 왜냐하면 결단력 있는 공격자가 알고리즘을 깨고 보호된 데이터를 손상시킬 수 있기 때문입니다. 대신 <code>SHA-256</code>, <code>SHA-384</code>, <code>SHA-512</code> 등과 같은 표준 알고리즘을 사용해야 합니다.</p>\n<p>이 규칙은 <code>java.security.MessageDigest</code> 하위 클래스의 생성을 추적합니다.</p>",
    "howToFix_ko": "<h2>권장되는 보안 코딩 관행</h2>\n<ul>\n  <li> 커스텀 알고리즘을 만드는 대신 표준 알고리즘을 사용하세요. </li>\n</ul>\n<h2>규칙을 준수하는 해결책</h2>\n<pre>\nMessageDigest digest = MessageDigest.getInstance(\"SHA-256\");\n</pre>\n<h2>참조</h2>\n<ul>\n  <li> OWASP - <a href=\"https://owasp.org/Top10/A02_2021-Cryptographic_Failures/\">Top 10 2021 카테고리 A2 - 암호화 실패</a> </li>\n  <li> OWASP - <a href=\"https://owasp.org/www-project-top-ten/2017/A3_2017-Sensitive_Data_Exposure\">Top 10 2017 카테고리 A3 - 민감한 데이터 노출</a> </li>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/327\">CWE-327 - 취약하거나 위험한 암호화 알고리즘 사용</a> </li>\n  <li> FindSecBugs 규칙에서 파생됨 <a href=\"https://h3xstream.github.io/find-sec-bugs/bugs.htm#CUSTOM_MESSAGE_DIGEST\">MessageDigest is Custom</a> </li>\n</ul>",
    "moreInfo_ko": ""
  },
  {
    "id": "S2187",
    "key": "java:S2187",
    "name": "TestCases should contain tests",
    "type": "code-smell",
    "severity": "blocker",
    "tags": [
      "junit",
      "tests",
      "unused",
      "confusing"
    ],
    "why": "<p>There's no point in having a JUnit <code>TestCase</code> without any test methods. Similarly, you shouldn't have a file in the tests directory\nnamed <code>*Test</code>, <code>*Tests</code>, or <code>*TestCase</code>, but no tests in the file. Doing either of these things may lead someone to\nthink that uncovered classes have been tested.</p>\n<p>This rule raises an issue when files in the test directory are named <code>*Test</code>, <code>*Tests</code>, or <code>*TestCase</code> or\nimplement <code>TestCase</code> but don't contain any tests.</p>\n<p>Supported frameworks:</p>\n<ul>\n  <li> JUnit3 </li>\n  <li> JUnit4 </li>\n  <li> JUnit5 </li>\n  <li> TestNG </li>\n  <li> Zohhak </li>\n  <li> ArchUnit </li>\n  <li> Pact </li>\n</ul>",
    "howToFix": "",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "TestCase에는 테스트가 포함되어야 합니다",
    "why_ko": "<p>테스트 메서드 없이 JUnit <code>TestCase</code>를 갖는 것은 의미가 없습니다. 마찬가지로 테스트 디렉토리에 <code>*Test</code>, <code>*Tests</code> 또는 <code>*TestCase</code>라는 이름의 파일이 있지만 파일에 테스트가 없어서는 안 됩니다. 이 중 하나라도 하면 커버되지 않은 클래스가 테스트되었다고 생각하게 만들 수 있습니다.</p>\n<p>이 규칙은 테스트 디렉토리의 파일이 <code>*Test</code>, <code>*Tests</code> 또는 <code>*TestCase</code>로 이름이 지어지거나 <code>TestCase</code>를 구현하지만 테스트를 포함하지 않을 때 문제를 제기합니다.</p>\n<p>지원되는 프레임워크:</p>\n<ul>\n  <li> JUnit3 </li>\n  <li> JUnit4 </li>\n  <li> JUnit5 </li>\n  <li> TestNG </li>\n  <li> Zohhak </li>\n  <li> ArchUnit </li>\n  <li> Pact </li>\n</ul>",
    "howToFix_ko": "",
    "moreInfo_ko": ""
  },
  {
    "id": "S2168",
    "key": "java:S2168",
    "name": "Double-checked locking should not be used",
    "type": "bug",
    "severity": "blocker",
    "tags": [
      "singleton",
      "cwe",
      "multi-threading",
      "design",
      "cert"
    ],
    "why": "<p>Double-checked locking is the practice of checking a lazy-initialized object's state both before and after a <code>synchronized</code> block is\nentered to determine whether to initialize the object. In early JVM versions, synchronizing entire methods was not performant, which sometimes caused\nthis practice to be used in its place.</p>\n<p>Apart from <code>float</code> and <code>int</code> types, this practice does not work reliably in a platform-independent manner without additional\nsynchronization of mutable instances. Using double-checked locking for the lazy initialization of any other type of primitive or mutable object risks\na second thread using an uninitialized or partially initialized member while the first thread is still creating it. The results can be unexpected,\npotentially even causing the application to crash.</p>",
    "howToFix": "<p>Given significant performance improvements of <code>synchronized</code> methods in recent JVM versions, <code>synchronized</code> methods are now\npreferred over the less robust double-checked locking.</p>\n<p>If marking the entire method as <code>synchronized</code> is not an option, consider using an inner <code>static class</code> to hold the reference\ninstead. Inner static classes are guaranteed to be initialized lazily.</p>\n\n<h4>Noncompliant code example</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\npublic class ResourceFactory {\n    private static Resource resource;\n\n    public static Resource getInstance() {\n        if (resource == null) {\n            synchronized (DoubleCheckedLocking.class) { // Noncompliant, not thread-safe due to the use of double-checked locking.\n                if (resource == null)\n                    resource = new Resource();\n            }\n        }\n        return resource;\n    }\n}\n</pre>\n<h4>Compliant solution</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\npublic class ResourceFactory {\n    private static Resource resource;\n\n    public static synchronized Resource getInstance() { // Compliant, the entire method is synchronized and hence thread-safe\n        if (resource == null)\n            resource = new Resource();\n        return resource;\n    }\n}\n</pre>\n<h4>Compliant solution</h4>\n<p>Alternatively, a static inner class can be used. However, this solution is less explicit in its intention and hence should be used with care.</p>\n<pre>\npublic class ResourceFactory {\n    private static class ResourceHolder {\n        public static Resource resource = new Resource(); // Compliant, as this will be lazily initialised by the JVM\n    }\n\n    public static Resource getResource() {\n        return ResourceFactory.ResourceHolder.resource;\n    }\n}\n</pre>",
    "moreInfo": "<ul>\n  <li> <a href=\"https://www.cs.umd.edu/~pugh/java/memoryModel/DoubleCheckedLocking.html\">The \"Double-Checked Locking is Broken\" Declaration</a> </li>\n  <li> <a href=\"https://wiki.sei.cmu.edu/confluence/x/6zdGBQ\">CERT, LCK10-J.</a> - Use a correct form of the double-checked locking idiom </li>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/609\">CWE-609 - Double-checked locking</a> </li>\n  <li> <a href=\"https://docs.oracle.com/javase/specs/jls/se7/html/jls-12.html#jls-12.4\">JLS 12.4</a> - Initialization of Classes and Interfaces </li>\n  <li> Wikipedia: <a href=\"https://en.wikipedia.org/wiki/Double-checked_locking#Usage_in_Java\">Double-checked locking</a> </li>\n</ul>",
    "status": "READY",
    "name_ko": "이중 검사 잠금은 사용하면 안 됩니다",
    "why_ko": "<p>이중 검사 잠금(Double-checked locking)은 객체를 초기화할지 여부를 결정하기 위해 <code>synchronized</code> 블록에 진입하기 전과 후에 지연 초기화 객체의 상태를 검사하는 관행입니다. 초기 JVM 버전에서는 전체 메서드를 동기화하는 것이 성능에 좋지 않았기 때문에 이 관행이 대신 사용되기도 했습니다.</p>\n<p><code>float</code>과 <code>int</code> 타입을 제외하고, 이 관행은 가변 인스턴스의 추가 동기화 없이는 플랫폼 독립적인 방식으로 신뢰성 있게 작동하지 않습니다. 다른 타입의 기본형이나 가변 객체의 지연 초기화에 이중 검사 잠금을 사용하면 첫 번째 스레드가 아직 생성 중인 동안 두 번째 스레드가 초기화되지 않았거나 부분적으로 초기화된 멤버를 사용할 위험이 있습니다. 결과는 예측할 수 없으며 애플리케이션 충돌을 일으킬 수도 있습니다.</p>",
    "howToFix_ko": "<p>최신 JVM 버전에서 <code>synchronized</code> 메서드의 상당한 성능 향상을 고려할 때, 덜 견고한 이중 검사 잠금보다 <code>synchronized</code> 메서드가 이제 선호됩니다.</p>\n<p>전체 메서드를 <code>synchronized</code>로 표시하는 것이 옵션이 아닌 경우, 대신 내부 <code>static class</code>를 사용하여 참조를 보유하는 것을 고려하세요. 내부 정적 클래스는 지연 초기화가 보장됩니다.</p>\n\n<h4>규칙을 준수하지 않는 코드 예시</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\npublic class ResourceFactory {\n    private static Resource resource;\n\n    public static Resource getInstance() {\n        if (resource == null) {\n            synchronized (DoubleCheckedLocking.class) { // 규칙 위반, 이중 검사 잠금 사용으로 인해 스레드 안전하지 않음\n                if (resource == null)\n                    resource = new Resource();\n            }\n        }\n        return resource;\n    }\n}\n</pre>\n<h4>규칙을 준수하는 해결책</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\npublic class ResourceFactory {\n    private static Resource resource;\n\n    public static synchronized Resource getInstance() { // 규칙 준수, 전체 메서드가 동기화되어 스레드 안전함\n        if (resource == null)\n            resource = new Resource();\n        return resource;\n    }\n}\n</pre>\n<h4>규칙을 준수하는 해결책</h4>\n<p>또는 정적 내부 클래스를 사용할 수 있습니다. 그러나 이 해결책은 의도가 덜 명시적이므로 주의해서 사용해야 합니다.</p>\n<pre>\npublic class ResourceFactory {\n    private static class ResourceHolder {\n        public static Resource resource = new Resource(); // 규칙 준수, JVM에 의해 지연 초기화됨\n    }\n\n    public static Resource getResource() {\n        return ResourceFactory.ResourceHolder.resource;\n    }\n}\n</pre>",
    "moreInfo_ko": "<ul>\n  <li> <a href=\"https://www.cs.umd.edu/~pugh/java/memoryModel/DoubleCheckedLocking.html\">The \"Double-Checked Locking is Broken\" Declaration</a> </li>\n  <li> <a href=\"https://wiki.sei.cmu.edu/confluence/x/6zdGBQ\">CERT, LCK10-J.</a> - 이중 검사 잠금 관용구의 올바른 형태를 사용하세요 </li>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/609\">CWE-609 - Double-checked locking</a> </li>\n  <li> <a href=\"https://docs.oracle.com/javase/specs/jls/se7/html/jls-12.html#jls-12.4\">JLS 12.4</a> - Initialization of Classes and Interfaces </li>\n  <li> Wikipedia: <a href=\"https://en.wikipedia.org/wiki/Double-checked_locking#Usage_in_Java\">Double-checked locking</a> </li>\n</ul>"
  },
  {
    "id": "S1314",
    "key": "java:S1314",
    "name": "Octal values should not be used",
    "type": "code-smell",
    "severity": "blocker",
    "tags": [
      "cert",
      "pitfall"
    ],
    "why": "<p>Integer literals starting with a zero are octal rather than decimal values. While using octal values is fully supported, most developers do not\nhave experience with them. They may not recognize octal values as such, mistaking them instead for decimal values.</p>\n<h3>Noncompliant code example</h3>\n<pre>\nint myNumber = 010; // Noncompliant. myNumber will hold 8, not 10 - was this really expected?\n</pre>\n<h3>Compliant solution</h3>\n<pre>\nint myNumber = 8;\n</pre>",
    "howToFix": "",
    "moreInfo": "<ul>\n  <li> <a href=\"https://wiki.sei.cmu.edu/confluence/x/atYxBQ\">CERT, DCL18-C.</a> - Do not begin integer constants with 0 when specifying a decimal\n  value </li>\n  <li> <a href=\"https://wiki.sei.cmu.edu/confluence/x/7DZGBQ\">CERT, DCL50-J.</a> - Use visually distinct identifiers </li>\n</ul>",
    "status": "READY",
    "name_ko": "8진수 값을 사용하면 안 됩니다",
    "why_ko": "<p>0으로 시작하는 정수 리터럴은 10진수가 아닌 8진수 값입니다. 8진수 값 사용이 완전히 지원되지만 대부분의 개발자는 이에 대한 경험이 없습니다. 그들은 8진수 값을 인식하지 못하고 대신 10진수 값으로 착각할 수 있습니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\nint myNumber = 010; // 규칙 위반. myNumber는 10이 아닌 8을 가집니다 - 이것이 정말 의도한 것인가요?\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre>\nint myNumber = 8;\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": "<ul>\n  <li> <a href=\"https://wiki.sei.cmu.edu/confluence/x/atYxBQ\">CERT, DCL18-C.</a> - 10진수 값을 지정할 때 정수 상수를 0으로 시작하지 마세요 </li>\n  <li> <a href=\"https://wiki.sei.cmu.edu/confluence/x/7DZGBQ\">CERT, DCL50-J.</a> - 시각적으로 구별되는 식별자를 사용하세요 </li>\n</ul>"
  },
  {
    "id": "S3329",
    "key": "java:S3329",
    "name": "Cipher Block Chaining IVs should be unpredictable",
    "type": "vulnerability",
    "severity": "critical",
    "tags": [
      "cwe"
    ],
    "why": "<p>암호화 알고리즘은 민감한 정보를 보호하고 다양한 영역에서 안전한 통신을 보장하는 데 필수적입니다. 여러 중요한 이유로 사용됩니다:</p>\n<ul>\n  <li> 기밀성, 프라이버시 및 지적 재산 보호 </li>\n  <li> 전송 중 또는 저장 장치에서의 보안 </li>\n  <li> 데이터 무결성, 일반적인 신뢰 및 인증 </li>\n</ul>\n<p>암호화 알고리즘, 도구 또는 조합을 선택할 때 두 가지를 고려해야 합니다:</p>\n<ol>\n  <li> 깨지지 않는 암호화는 없습니다. </li>\n  <li> 암호화 알고리즘의 강도는 일반적으로 합리적인 시간 내에 해독하는 데 필요한 노력으로 측정됩니다. </li>\n</ol>\n<p>Cipher Block Chaining (CBC) 모드에서 각 블록은 다음 블록의 암호화 입력으로 사용됩니다. 이러한 이유로 첫 번째 블록에는 \"시작 변수\"(SV)라고도 하는 초기화 벡터(IV)가 필요합니다.</p>\n<p>여러 암호화 세션이나 메시지에 동일한 IV가 사용되면 동일한 평문 입력의 새 암호화마다 항상 동일한 암호문 출력이 생성됩니다. 이로 인해 공격자가 암호문에서 패턴을 감지할 수 있습니다.</p>\n<h3>잠재적 영향은 무엇인가요?</h3>\n<p>암호화된 데이터를 검색하고 주어진 시간 내에 암호 공격을 수행한 후 공격자는 암호화가 보호해야 했던 평문을 복구할 수 있습니다.</p>\n<p>복구된 데이터에 따라 영향이 다를 수 있습니다.</p>\n<p>아래는 공격자가 취약점을 악용했을 때의 잠재적 영향을 보여주는 실제 시나리오입니다.</p>\n<h4>추가 공격 표면</h4>\n<p>암호화된 메시지의 평문을 수정함으로써 공격자는 코드에서 추가 취약점을 유발할 수 있습니다. 공격자는 더 많은 정보를 얻기 위해 시스템을 추가로 악용할 수 있습니다.<br> 정상적인 상황에서는 제3자가 수정할 수 없기 때문에 암호화된 값은 종종 신뢰할 수 있는 것으로 간주됩니다.</p>\n<h4>기밀성 및 프라이버시 침해</h4>\n<p>암호화된 데이터에 개인 정보나 민감한 정보가 포함되어 있을 때 공격자가 이를 검색하면 프라이버시 침해, 신원 도용, 재정적 손실, 평판 손상 또는 기밀 시스템에 대한 무단 액세스로 이어질 수 있습니다.</p>\n<p>이 시나리오에서 회사, 직원, 사용자 및 파트너가 심각하게 영향을 받을 수 있습니다.</p>\n<p>데이터 유출 및 암호화된 데이터 노출은 조직에 대한 신뢰를 훼손할 수 있으므로 영향은 두 가지입니다. 고객, 클라이언트 및 이해관계자는 민감한 데이터를 보호하는 조직의 능력에 대한 신뢰를 잃을 수 있습니다.</p>\n<h4>법적 및 규정 준수 문제</h4>\n<p>많은 산업 및 지역에서 민감한 데이터를 보호하기 위한 법적 및 규정 준수 요구 사항이 있습니다. 암호화된 데이터가 손상되고 평문이 복구될 수 있는 경우 회사는 법적 결과, 벌금 또는 개인정보 보호법 위반에 직면합니다.</p>",
    "howToFix": "<h4>Noncompliant code example</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\nimport java.nio.charset.StandardCharsets;\nimport java.security.NoSuchAlgorithmException;\nimport java.security.InvalidKeyException;\nimport java.security.InvalidAlgorithmParameterException;\nimport javax.crypto.Cipher;\nimport javax.crypto.spec.IvParameterSpec;\nimport javax.crypto.spec.SecretKeySpec;\nimport javax.crypto.NoSuchPaddingException;\n\npublic void encrypt(String key, String plainText) {\n\n    byte[] RandomBytes = \"7cVgr5cbdCZVw5WY\".getBytes(StandardCharsets.UTF_8);\n\n    IvParameterSpec iv   = new IvParameterSpec(RandomBytes);\n    SecretKeySpec keySpec = new SecretKeySpec(key.getBytes(StandardCharsets.UTF_8), \"AES\");\n\n    try {\n        Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n        cipher.init(Cipher.ENCRYPT_MODE, keySpec, iv);\n\n    } catch(NoSuchAlgorithmException|InvalidKeyException|\n            NoSuchPaddingException|InvalidAlgorithmParameterException e) {\n        // ...\n    }\n}\n</pre>\n<h4>Compliant solution</h4>\n<p>In this example, the code explicitly uses a number generator that is considered <strong>strong</strong>.</p>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\nimport java.nio.charset.StandardCharsets;\nimport java.security.SecureRandom;\nimport java.security.NoSuchAlgorithmException;\nimport java.security.InvalidKeyException;\nimport java.security.InvalidAlgorithmParameterException;\nimport javax.crypto.Cipher;\nimport javax.crypto.spec.IvParameterSpec;\nimport javax.crypto.spec.SecretKeySpec;\nimport javax.crypto.NoSuchPaddingException;\n\npublic void encrypt(String key, String plainText) {\n\n    SecureRandom random = new SecureRandom();\n    byte[] randomBytes  = new byte[128];\n    random.nextBytes(randomBytes);\n\n    IvParameterSpec iv   = new IvParameterSpec(randomBytes);\n    SecretKeySpec keySpec = new SecretKeySpec(key.getBytes(StandardCharsets.UTF_8), \"AES\");\n\n    try {\n        Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n        cipher.init(Cipher.ENCRYPT_MODE, keySpec, iv);\n\n    } catch(NoSuchAlgorithmException|InvalidKeyException|\n            NoSuchPaddingException|InvalidAlgorithmParameterException e) {\n        // ...\n    }\n}\n</pre>\n<h3>How does this work?</h3>\n<h4>Use unique IVs</h4>\n<p>To ensure high security, initialization vectors must meet two important criteria:</p>\n<ul>\n  <li> IVs must be unique for each encryption operation. </li>\n  <li> For CBC and CFB modes, a secure FIPS-compliant random number generator should be used to generate unpredictable IVs. </li>\n</ul>\n<p>The IV does not need be secret, so the IV or information sufficient to determine the IV may be transmitted along with the ciphertext.</p>\n<p>In the previous non-compliant example, the problem is not that the IV is hard-coded.<br> It is that the same IV is used for multiple encryption\nattempts.</p>",
    "moreInfo": "<h3>Standards</h3>\n<ul>\n  <li> OWASP - <a href=\"https://owasp.org/Top10/A02_2021-Cryptographic_Failures/\">Top 10 2021 Category A2 - Cryptographic Failures</a> </li>\n  <li> OWASP - <a href=\"https://owasp.org/www-project-top-ten/2017/A3_2017-Sensitive_Data_Exposure\">Top 10 2017 Category A3 - Sensitive Data\n  Exposure</a> </li>\n  <li> OWASP - <a href=\"https://owasp.org/www-project-top-ten/2017/A6_2017-Security_Misconfiguration\">Top 10 2017 Category A6 - Security\n  Misconfiguration</a> </li>\n  <li> OWASP - <a href=\"https://mas.owasp.org/checklists/MASVS-CRYPTO/\">Mobile AppSec Verification Standard - Cryptography Requirements</a> </li>\n  <li> OWASP - <a href=\"https://owasp.org/www-project-mobile-top-10/2016-risks/m5-insufficient-cryptography\">Mobile Top 10 2016 Category M5 -\n  Insufficient Cryptography</a> </li>\n  <li> OWASP - <a href=\"https://owasp.org/www-project-mobile-top-10/2023-risks/m10-insufficient-cryptography\">Mobile Top 10 2024 Category M10 -\n  Insufficient Cryptography</a> </li>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/329\">CWE-329 - Not Using an Unpredictable IV with CBC Mode</a> </li>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/780\">CWE-780 - Use of RSA Algorithm without OAEP</a> </li>\n  <li> <a href=\"https://nvlpubs.nist.gov/nistpubs/Legacy/SP/nistspecialpublication800-38a.pdf\">NIST, SP-800-38A</a> - Recommendation for Block Cipher\n  Modes of Operation </li>\n</ul>",
    "status": "READY",
    "name_ko": "Cipher Block Chaining IV는 예측 불가능해야 합니다",
    "why_ko": "<p>암호화 알고리즘은 민감한 정보를 보호하고 다양한 영역에서 안전한 통신을 보장하는 데 필수적입니다. 여러 중요한 이유로 사용됩니다:</p>\n<ul>\n  <li> 기밀성, 프라이버시 및 지적 재산 보호 </li>\n  <li> 전송 중 또는 저장 장치에서의 보안 </li>\n  <li> 데이터 무결성, 일반적인 신뢰 및 인증 </li>\n</ul>\n<p>암호화 알고리즘, 도구 또는 조합을 선택할 때 두 가지를 고려해야 합니다:</p>\n<ol>\n  <li> 깨지지 않는 암호화는 없습니다. </li>\n  <li> 암호화 알고리즘의 강도는 일반적으로 합리적인 시간 내에 해독하는 데 필요한 노력으로 측정됩니다. </li>\n</ol>\n<p>Cipher Block Chaining (CBC) 모드에서 각 블록은 다음 블록의 암호화 입력으로 사용됩니다. 이러한 이유로 첫 번째 블록에는 \"시작 변수\"(SV)라고도 하는 초기화 벡터(IV)가 필요합니다.</p>\n<p>여러 암호화 세션이나 메시지에 동일한 IV가 사용되면 동일한 평문 입력의 새 암호화마다 항상 동일한 암호문 출력이 생성됩니다. 이로 인해 공격자가 암호문에서 패턴을 감지할 수 있습니다.</p>\n<h3>잠재적 영향은 무엇인가요?</h3>\n<p>암호화된 데이터를 검색하고 주어진 시간 내에 암호 공격을 수행한 후 공격자는 암호화가 보호해야 했던 평문을 복구할 수 있습니다.</p>\n<p>복구된 데이터에 따라 영향이 다를 수 있습니다.</p>\n<p>아래는 공격자가 취약점을 악용했을 때의 잠재적 영향을 보여주는 실제 시나리오입니다.</p>\n<h4>추가 공격 표면</h4>\n<p>암호화된 메시지의 평문을 수정함으로써 공격자는 코드에서 추가 취약점을 유발할 수 있습니다. 공격자는 더 많은 정보를 얻기 위해 시스템을 추가로 악용할 수 있습니다.<br> 정상적인 상황에서는 제3자가 수정할 수 없기 때문에 암호화된 값은 종종 신뢰할 수 있는 것으로 간주됩니다.</p>\n<h4>기밀성 및 프라이버시 침해</h4>\n<p>암호화된 데이터에 개인 정보나 민감한 정보가 포함되어 있을 때 공격자가 이를 검색하면 프라이버시 침해, 신원 도용, 재정적 손실, 평판 손상 또는 기밀 시스템에 대한 무단 액세스로 이어질 수 있습니다.</p>\n<p>이 시나리오에서 회사, 직원, 사용자 및 파트너가 심각하게 영향을 받을 수 있습니다.</p>\n<p>데이터 유출 및 암호화된 데이터 노출은 조직에 대한 신뢰를 훼손할 수 있으므로 영향은 두 가지입니다. 고객, 클라이언트 및 이해관계자는 민감한 데이터를 보호하는 조직의 능력에 대한 신뢰를 잃을 수 있습니다.</p>\n<h4>법적 및 규정 준수 문제</h4>\n<p>많은 산업 및 지역에서 민감한 데이터를 보호하기 위한 법적 및 규정 준수 요구 사항이 있습니다. 암호화된 데이터가 손상되고 평문이 복구될 수 있는 경우 회사는 법적 결과, 벌금 또는 개인정보 보호법 위반에 직면합니다.</p>",
    "howToFix_ko": "<h4>규칙을 준수하지 않는 코드 예시</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\nimport java.nio.charset.StandardCharsets;\nimport java.security.NoSuchAlgorithmException;\nimport java.security.InvalidKeyException;\nimport java.security.InvalidAlgorithmParameterException;\nimport javax.crypto.Cipher;\nimport javax.crypto.spec.IvParameterSpec;\nimport javax.crypto.spec.SecretKeySpec;\nimport javax.crypto.NoSuchPaddingException;\n\npublic void encrypt(String key, String plainText) {\n\n    byte[] RandomBytes = \"7cVgr5cbdCZVw5WY\".getBytes(StandardCharsets.UTF_8);\n\n    IvParameterSpec iv   = new IvParameterSpec(RandomBytes);\n    SecretKeySpec keySpec = new SecretKeySpec(key.getBytes(StandardCharsets.UTF_8), \"AES\");\n\n    try {\n        Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n        cipher.init(Cipher.ENCRYPT_MODE, keySpec, iv);\n\n    } catch(NoSuchAlgorithmException|InvalidKeyException|\n            NoSuchPaddingException|InvalidAlgorithmParameterException e) {\n        // ...\n    }\n}\n</pre>\n<h4>규칙을 준수하는 해결책</h4>\n<p>이 예시에서 코드는 <strong>강력한</strong> 것으로 간주되는 숫자 생성기를 명시적으로 사용합니다.</p>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\nimport java.nio.charset.StandardCharsets;\nimport java.security.SecureRandom;\nimport java.security.NoSuchAlgorithmException;\nimport java.security.InvalidKeyException;\nimport java.security.InvalidAlgorithmParameterException;\nimport javax.crypto.Cipher;\nimport javax.crypto.spec.IvParameterSpec;\nimport javax.crypto.spec.SecretKeySpec;\nimport javax.crypto.NoSuchPaddingException;\n\npublic void encrypt(String key, String plainText) {\n\n    SecureRandom random = new SecureRandom();\n    byte[] randomBytes  = new byte[128];\n    random.nextBytes(randomBytes);\n\n    IvParameterSpec iv   = new IvParameterSpec(randomBytes);\n    SecretKeySpec keySpec = new SecretKeySpec(key.getBytes(StandardCharsets.UTF_8), \"AES\");\n\n    try {\n        Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n        cipher.init(Cipher.ENCRYPT_MODE, keySpec, iv);\n\n    } catch(NoSuchAlgorithmException|InvalidKeyException|\n            NoSuchPaddingException|InvalidAlgorithmParameterException e) {\n        // ...\n    }\n}\n</pre>\n<h3>어떻게 작동하나요?</h3>\n<h4>고유한 IV 사용</h4>\n<p>높은 보안을 보장하려면 초기화 벡터가 두 가지 중요한 기준을 충족해야 합니다:</p>\n<ul>\n  <li> IV는 각 암호화 작업에 대해 고유해야 합니다. </li>\n  <li> CBC 및 CFB 모드의 경우 예측 불가능한 IV를 생성하기 위해 안전한 FIPS 호환 난수 생성기를 사용해야 합니다. </li>\n</ul>\n<p>IV는 비밀일 필요가 없으므로 IV 또는 IV를 결정하기에 충분한 정보가 암호문과 함께 전송될 수 있습니다.</p>\n<p>이전의 규칙을 준수하지 않는 예시에서 문제는 IV가 하드코딩되어 있다는 것이 아닙니다.<br> 동일한 IV가 여러 암호화 시도에 사용된다는 것입니다.</p>",
    "moreInfo_ko": "<h3>표준</h3>\n<ul>\n  <li> OWASP - <a href=\"https://owasp.org/Top10/A02_2021-Cryptographic_Failures/\">Top 10 2021 Category A2 - Cryptographic Failures</a> </li>\n  <li> OWASP - <a href=\"https://owasp.org/www-project-top-ten/2017/A3_2017-Sensitive_Data_Exposure\">Top 10 2017 Category A3 - Sensitive Data\n  Exposure</a> </li>\n  <li> OWASP - <a href=\"https://owasp.org/www-project-top-ten/2017/A6_2017-Security_Misconfiguration\">Top 10 2017 Category A6 - Security\n  Misconfiguration</a> </li>\n  <li> OWASP - <a href=\"https://mas.owasp.org/checklists/MASVS-CRYPTO/\">Mobile AppSec Verification Standard - Cryptography Requirements</a> </li>\n  <li> OWASP - <a href=\"https://owasp.org/www-project-mobile-top-10/2016-risks/m5-insufficient-cryptography\">Mobile Top 10 2016 Category M5 -\n  Insufficient Cryptography</a> </li>\n  <li> OWASP - <a href=\"https://owasp.org/www-project-mobile-top-10/2023-risks/m10-insufficient-cryptography\">Mobile Top 10 2024 Category M10 -\n  Insufficient Cryptography</a> </li>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/329\">CWE-329 - Not Using an Unpredictable IV with CBC Mode</a> </li>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/780\">CWE-780 - Use of RSA Algorithm without OAEP</a> </li>\n  <li> <a href=\"https://nvlpubs.nist.gov/nistpubs/Legacy/SP/nistspecialpublication800-38a.pdf\">NIST, SP-800-38A</a> - Recommendation for Block Cipher\n  Modes of Operation </li>\n</ul>"
  },
  {
    "id": "S1197",
    "key": "java:S1197",
    "name": "Array designators \"[]\" should be on the type, not the variable",
    "type": "code-smell",
    "severity": "minor",
    "tags": [
      "convention"
    ],
    "why": "<p>Array designators should always be located on the type for better code readability. Otherwise, developers must look both at the type and the\nvariable name to know whether or not a variable is an array.</p>\n<h3>Noncompliant code example</h3>\n<pre>\nint matrix[][];   // Noncompliant\nint[] matrix[];   // Noncompliant\n</pre>\n<h3>Compliant solution</h3>\n<pre>\nint[][] matrix;   // Compliant\n</pre>",
    "howToFix": "",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "배열 지정자 \"[]\"는 변수가 아닌 타입에 위치해야 합니다",
    "why_ko": "<p>배열 지정자는 코드 가독성을 위해 항상 타입에 위치해야 합니다. 그렇지 않으면 개발자가 변수가 배열인지 여부를 알기 위해 타입과 변수 이름을 모두 확인해야 합니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\nint matrix[][];   // 규칙 위반\nint[] matrix[];   // 규칙 위반\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre>\nint[][] matrix;   // 규칙 준수\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": ""
  },
  {
    "id": "S6202",
    "key": "java:S6202",
    "name": "Operator \"instanceof\" should be used instead of \"A.class.isInstance()\"",
    "type": "code-smell",
    "severity": "major",
    "tags": [],
    "why": "<p>The <code>instanceof</code> construction is a preferred way to check whether a variable can be cast to some type statically because a compile-time\nerror will occur in case of incompatible types. The method <a\nhref=\"https://docs.oracle.com/javase/8/docs/api/java/lang/Class.html#isInstance-java.lang.Object-\">isInstance()</a> from <code>java.lang.Class</code>\nworks differently and does type check at runtime only, incompatible types will therefore not be detected early in the development, potentially\nresulting in dead code. The <code>isInstance()</code> method should only be used in dynamic cases when the <code>instanceof</code> operator can't be\nused.</p>\n<p>This rule raises an issue when <code>isInstance()</code> is used and could be replaced with an <code>instanceof</code> check.</p>\n<h3>Noncompliant code example</h3>\n<pre>\nint f(Object o) {\n&nbsp; if (String.class.isInstance(o)) {&nbsp; // Noncompliant\n&nbsp; &nbsp; return 42;\n&nbsp; }\n&nbsp; return 0;\n}\n\nint f(Number n) {\n&nbsp; if (String.class.isInstance(n)) {&nbsp; // Noncompliant\n&nbsp; &nbsp; return 42;\n&nbsp; }\n&nbsp; return 0;\n}\n</pre>\n<h3>Compliant solution</h3>\n<pre>\nint f(Object o) {\n&nbsp; if (o instanceof String) {&nbsp; // Compliant\n&nbsp; &nbsp; return 42;\n&nbsp; }\n&nbsp; return 0;\n}\n\nint f(Number n) {\n&nbsp; if (n instanceof String) {&nbsp; // Compile-time error\n&nbsp; &nbsp; return 42;\n&nbsp; }\n&nbsp; return 0;\n}\n\nboolean fun(Object o, String c) throws ClassNotFoundException\n{\n  return Class.forName(c).isInstance(o); // Compliant, can't use instanceof operator here\n}\n</pre>",
    "howToFix": "",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "\"A.class.isInstance()\" 대신 \"instanceof\" 연산자를 사용해야 합니다",
    "why_ko": "<p><code>instanceof</code> 구문은 변수가 특정 타입으로 캐스트될 수 있는지 정적으로 확인하는 선호되는 방법입니다. 호환되지 않는 타입의 경우 컴파일 타임 오류가 발생하기 때문입니다. <code>java.lang.Class</code>의 <a\nhref=\"https://docs.oracle.com/javase/8/docs/api/java/lang/Class.html#isInstance-java.lang.Object-\">isInstance()</a> 메서드는 다르게 작동하며 런타임에만 타입 검사를 수행하므로, 호환되지 않는 타입이 개발 초기에 감지되지 않아 잠재적으로 죽은 코드가 될 수 있습니다. <code>isInstance()</code> 메서드는 <code>instanceof</code> 연산자를 사용할 수 없는 동적인 경우에만 사용해야 합니다.</p>\n<p>이 규칙은 <code>isInstance()</code>가 사용되고 <code>instanceof</code> 검사로 대체될 수 있을 때 문제를 보고합니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\nint f(Object o) {\n&nbsp; if (String.class.isInstance(o)) {&nbsp; // 규칙 위반\n&nbsp; &nbsp; return 42;\n&nbsp; }\n&nbsp; return 0;\n}\n\nint f(Number n) {\n&nbsp; if (String.class.isInstance(n)) {&nbsp; // 규칙 위반\n&nbsp; &nbsp; return 42;\n&nbsp; }\n&nbsp; return 0;\n}\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre>\nint f(Object o) {\n&nbsp; if (o instanceof String) {&nbsp; // 규칙 준수\n&nbsp; &nbsp; return 42;\n&nbsp; }\n&nbsp; return 0;\n}\n\nint f(Number n) {\n&nbsp; if (n instanceof String) {&nbsp; // 컴파일 타임 오류\n&nbsp; &nbsp; return 42;\n&nbsp; }\n&nbsp; return 0;\n}\n\nboolean fun(Object o, String c) throws ClassNotFoundException\n{\n  return Class.forName(c).isInstance(o); // 규칙 준수, 여기서는 instanceof 연산자를 사용할 수 없음\n}\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": ""
  },
  {
    "id": "S5838",
    "key": "java:S5838",
    "name": "Chained AssertJ assertions should be simplified to the corresponding dedicated assertion",
    "type": "code-smell",
    "severity": "minor",
    "tags": [
      "tests",
      "assertj"
    ],
    "why": "<p>AssertJ contains many assertions methods specific to common types. Both versions will test the same things, but the dedicated one will provide a\nbetter error message, simplifying the debugging process.</p>\n<p>This rule reports an issue when an assertion can be simplified to a dedicated one.</p>\n<p>The array below gives a non-exhaustive list of assertion reported by the rule. Code behaving similarly, or with a negation will also be\nreported.</p>\n<table>\n  <colgroup>\n    <col style=\"width: 50%;\">\n    <col style=\"width: 50%;\">\n  </colgroup>\n  <thead>\n    <tr>\n      <th>Original</th>\n      <th>Dedicated</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td><p><strong>Related to Object</strong></p></td>\n      <td></td>\n    </tr>\n    <tr>\n      <td><p><code>assertThat(getObject()).isEqualTo(null)</code></p></td>\n      <td><p><code>assertThat(getObject()).isNull()</code></p></td>\n    </tr>\n    <tr>\n      <td><p><code>assertThat(getBoolean()).isEqualTo(true)</code></p></td>\n      <td><p><code>assertThat(getBoolean()).isTrue()</code></p></td>\n    </tr>\n    <tr>\n      <td><p><code>assertThat(getBoolean()).isEqualTo(false)</code></p></td>\n      <td><p><code>assertThat(getBoolean()).isFalse()</code></p></td>\n    </tr>\n    <tr>\n      <td><p><code>assertThat(x.equals(y)).isTrue()</code></p></td>\n      <td><p><code>assertThat(x).isEqualTo(y)</code></p></td>\n    </tr>\n    <tr>\n      <td><p><code>assertThat(x == y).isTrue()</code></p></td>\n      <td><p><code>assertThat(x).isSameAs(y)</code></p></td>\n    </tr>\n    <tr>\n      <td><p><code>assertThat(x == null).isTrue()</code></p></td>\n      <td><p><code>assertThat(x).isNull()</code></p></td>\n    </tr>\n    <tr>\n      <td><p><code>assertThat(x.toString()).isEqualTo(y)</code></p></td>\n      <td><p><code>assertThat(x).hasToString(y)</code></p></td>\n    </tr>\n    <tr>\n      <td><p><code>assertThat(x.hashCode()).isEqualTo(y.hashCode())</code></p></td>\n      <td><p><code>assertThat(x).hasSameHashCodeAs(y)</code></p></td>\n    </tr>\n    <tr>\n      <td><p><code>assertThat(getObject() instanceof MyClass).isTrue()</code></p></td>\n      <td><p><code>assertThat(getObject()).isInstanceOf(MyClass.class)</code></p></td>\n    </tr>\n    <tr>\n      <td><p><strong>Related to <code>Comparable</code></strong></p></td>\n      <td></td>\n    </tr>\n    <tr>\n      <td><p><code>assertThat(x.compareTo(y)).isZero()</code></p></td>\n      <td><p><code>assertThat(x).isEqualByComparingTo(y)</code></p></td>\n    </tr>\n    <tr>\n      <td><p><code>assertThat(x &gt;= y).isTrue()</code></p></td>\n      <td><p><code>assertThat(x).isGreaterThanOrEqualTo(y)</code></p></td>\n    </tr>\n    <tr>\n      <td><p><code>assertThat(x &gt; y).isTrue()</code></p></td>\n      <td><p><code>assertThat(x).isGreaterThan(y)</code></p></td>\n    </tr>\n    <tr>\n      <td><p><code>assertThat(x &lt;= y).isTrue()</code></p></td>\n      <td><p><code>assertThat(x).isLessThanOrEqualTo(y)</code></p></td>\n    </tr>\n    <tr>\n      <td><p><code>assertThat(x &lt; y).isTrue()</code></p></td>\n      <td><p><code>assertThat(x).isLessThan(y)</code></p></td>\n    </tr>\n    <tr>\n      <td><p><strong>Related to <code>String</code></strong></p></td>\n      <td></td>\n    </tr>\n    <tr>\n      <td><p><code>assertThat(getString().isEmpty()).isTrue()</code></p></td>\n      <td><p><code>assertThat(getString()).isEmpty()</code></p></td>\n    </tr>\n    <tr>\n      <td><p><code>assertThat(getString()).hasSize(0)</code></p></td>\n      <td><p><code>assertThat(getString()).isEmpty()</code></p></td>\n    </tr>\n    <tr>\n      <td><p><code>assertThat(getString().equals(expected)).isTrue()</code></p></td>\n      <td><p><code>assertThat(getString()).isEqualTo(expected)</code></p></td>\n    </tr>\n    <tr>\n      <td><p><code>assertThat(getString().equalsIgnoreCase(expected)).isTrue()</code></p></td>\n      <td><p><code>assertThat(getString()).isEqualToIgnoringCase(expected)</code></p></td>\n    </tr>\n    <tr>\n      <td><p><code>assertThat(getString().contains(expected)).isTrue()</code></p></td>\n      <td><p><code>assertThat(getString()).contains(expected)</code></p></td>\n    </tr>\n    <tr>\n      <td><p><code>assertThat(getString().startsWith(expected)).isTrue()</code></p></td>\n      <td><p><code>assertThat(getString()).startsWith(expected)</code></p></td>\n    </tr>\n    <tr>\n      <td><p><code>assertThat(getString().endsWith(expected)).isTrue()</code></p></td>\n      <td><p><code>assertThat(getString()).endsWith(expected)</code></p></td>\n    </tr>\n    <tr>\n      <td><p><code>assertThat(getString().matches(expected)).isTrue()</code></p></td>\n      <td><p><code>assertThat(getString()).matches(expected)</code></p></td>\n    </tr>\n    <tr>\n      <td><p><code>assertThat(getString().trim()).isEmpty()</code></p></td>\n      <td><p><code>assertThat(getString()).isBlank()</code></p></td>\n    </tr>\n    <tr>\n      <td><p><code>assertThat(getString().length()).isEqualTo(length)</code></p></td>\n      <td><p><code>assertThat(getString()).hasSize(length)</code></p></td>\n    </tr>\n    <tr>\n      <td><p><code>assertThat(getString().length()).hasSize(expected.length())</code></p></td>\n      <td><p><code>assertThat(getString()).hasSameSizeAs(expected)</code></p></td>\n    </tr>\n    <tr>\n      <td><p><strong>&nbsp;Related to <code>File</code></strong></p></td>\n      <td></td>\n    </tr>\n    <tr>\n      <td><p><code>assertThat(getFile()).hasSize(0)</code></p></td>\n      <td><p><code>assertThat(getFile()).isEmpty()</code></p></td>\n    </tr>\n    <tr>\n      <td><p><code>assertThat(getFile().length()).isZero()</code></p></td>\n      <td><p><code>assertThat(getFile()).isEmpty()</code></p></td>\n    </tr>\n    <tr>\n      <td><p><code>assertThat(getFile().length()).isEqualTo(length)</code></p></td>\n      <td><p><code>assertThat(getFile()).hasSize(length)</code></p></td>\n    </tr>\n    <tr>\n      <td><p><code>assertThat(getFile().canRead()).isTrue()</code></p></td>\n      <td><p><code>assertThat(getFile()).canRead()</code></p></td>\n    </tr>\n    <tr>\n      <td><p><code>assertThat(getFile().canWrite()).isTrue()</code></p></td>\n      <td><p><code>assertThat(getFile()).canWrite()</code></p></td>\n    </tr>\n    <tr>\n      <td><p><code>assertThat(getFile().exists()).isTrue()</code></p></td>\n      <td><p><code>assertThat(getFile()).exists()</code></p></td>\n    </tr>\n    <tr>\n      <td><p><code>assertThat(getFile().getName()).isEqualTo(name)</code></p></td>\n      <td><p><code>assertThat(getFile()).hasName(name)</code></p></td>\n    </tr>\n    <tr>\n      <td><p><code>assertThat(getFile().getParent()).isEqualTo(pathname)</code></p></td>\n      <td><p><code>assertThat(getFile()).hasParent(pathname)</code></p></td>\n    </tr>\n    <tr>\n      <td><p><code>assertThat(getFile().getParentFile()).isNull()</code></p></td>\n      <td><p><code>assertThat(getFile()).hasNoParent()</code></p></td>\n    </tr>\n    <tr>\n      <td><p><code>assertThat(getFile().isAbsolute()).isTrue()</code></p></td>\n      <td><p><code>assertThat(getFile()).isAbsolute()</code></p></td>\n    </tr>\n    <tr>\n      <td><p><code>assertThat(getFile().isAbsolute()).isFalse()</code></p></td>\n      <td><p><code>assertThat(getFile()).isRelative()</code></p></td>\n    </tr>\n    <tr>\n      <td><p><code>assertThat(getFile().isDirectory()).isTrue()</code></p></td>\n      <td><p><code>assertThat(getFile()).isDirectory()</code></p></td>\n    </tr>\n    <tr>\n      <td><p><code>assertThat(getFile().isFile()).isTrue()</code></p></td>\n      <td><p><code>assertThat(getFile()).isFile()</code></p></td>\n    </tr>\n    <tr>\n      <td><p><code>assertThat(getFile().list()).isEmpty()</code></p></td>\n      <td><p><code>assertThat(getFile()).isEmptyDirectory()</code></p></td>\n    </tr>\n    <tr>\n      <td><p><strong>&nbsp;Related to <code>Path</code></strong></p></td>\n      <td></td>\n    </tr>\n    <tr>\n      <td><p><code>assertThat(getPath().startsWith(path)).isTrue()</code></p></td>\n      <td><p><code>assertThat(getPath()).startsWithRaw(path)</code></p></td>\n    </tr>\n    <tr>\n      <td><p><code>assertThat(getPath().endsWith(path)).isTrue()</code></p></td>\n      <td><p><code>assertThat(getPath()).endsWithRaw(path)</code></p></td>\n    </tr>\n    <tr>\n      <td><p><code>assertThat(getPath().getParent()).isEqualTo(name)</code></p></td>\n      <td><p><code>assertThat(getPath()).hasParentRaw(name)</code></p></td>\n    </tr>\n    <tr>\n      <td><p><code>assertThat(getPath().getParent()).isNull()</code></p></td>\n      <td><p><code>assertThat(getPath()).hasNoParentRaw()</code></p></td>\n    </tr>\n    <tr>\n      <td><p><code>assertThat(getPath().isAbsolute()).isTrue()</code></p></td>\n      <td><p><code>assertThat(getPath()).isAbsolute()</code></p></td>\n    </tr>\n    <tr>\n      <td><p><code>assertThat(getPath().isAbsolute()).isFalse()</code></p></td>\n      <td><p><code>assertThat(getPath()).isRelative()</code></p></td>\n    </tr>\n    <tr>\n      <td><p><strong>&nbsp;Related to <code>Array</code></strong></p></td>\n      <td></td>\n    </tr>\n    <tr>\n      <td><p><code>assertThat(getArray().length).isZero()</code></p></td>\n      <td><p><code>assertThat(getArray()).isEmpty()</code></p></td>\n    </tr>\n    <tr>\n      <td><p><code>assertThat(getArray().length).isEqualTo(length)</code></p></td>\n      <td><p><code>assertThat(getArray()).hasSize(length)</code></p></td>\n    </tr>\n    <tr>\n      <td><p><code>assertThat(getArray().length).isEqualTo(anotherArray.length)</code></p></td>\n      <td><p><code>assertThat(getArray()).hasSameSizeAs(anotherArray)</code></p></td>\n    </tr>\n    <tr>\n      <td><p><code>assertThat(getArray().length).isLessThanOrEqualTo(expression)</code></p></td>\n      <td><p><code>assertThat(getArray()).hasSizeLessThanOrEqualTo(expression)</code></p></td>\n    </tr>\n    <tr>\n      <td><p><code>assertThat(getArray().length).isLessThan(expression)</code></p></td>\n      <td><p><code>assertThat(getArray()).hasSizeLessThan(expression)</code></p></td>\n    </tr>\n    <tr>\n      <td><p><code>assertThat(getArray().length).isGreaterThan(expression)</code></p></td>\n      <td><p><code>assertThat(getArray()).hasSizeGreaterThan(expression)</code></p></td>\n    </tr>\n    <tr>\n      <td><p><code>assertThat(getArray().length).isGreaterThanOrEqualTo(expression)</code></p></td>\n      <td><p><code>assertThat(getArray()).hasSizeGreaterThanOrEqualTo(expression)</code></p></td>\n    </tr>\n    <tr>\n      <td><p><strong>Related to <code>Collection</code></strong></p></td>\n      <td></td>\n    </tr>\n    <tr>\n      <td><p><code>assertThat(getCollection().isEmpty()).isTrue()</code></p></td>\n      <td><p><code>assertThat(getCollection()).isEmpty()</code></p></td>\n    </tr>\n    <tr>\n      <td><p><code>assertThat(getCollection().size()).isZero()</code></p></td>\n      <td><p><code>assertThat(getCollection()).isEmpty()</code></p></td>\n    </tr>\n    <tr>\n      <td><p><code>assertThat(getCollection().contains(something)).isTrue()</code></p></td>\n      <td><p><code>assertThat(getCollection()).contains(something)</code></p></td>\n    </tr>\n    <tr>\n      <td><p><code>assertThat(getCollection().containsAll(otherCollection)).isTrue()</code></p></td>\n      <td><p><code>assertThat(getCollection()).containsAll(otherCollection)</code></p></td>\n    </tr>\n    <tr>\n      <td><p><strong>Related to <code>Map</code></strong></p></td>\n      <td></td>\n    </tr>\n    <tr>\n      <td><p><code>assertThat(getMap().size()).isEqualTo(otherMap().size()</code></p></td>\n      <td><p><code>assertThat(getMap()).hasSameSizeAs(otherMap())</code></p></td>\n    </tr>\n    <tr>\n      <td><p><code>assertThat(getMap().containsKey(key)).isTrue()</code></p></td>\n      <td><p><code>assertThat(getMap()).containsKey(key)</code></p></td>\n    </tr>\n    <tr>\n      <td><p><code>assertThat(getMap().keySet()).contains(key)</code></p></td>\n      <td><p><code>assertThat(getMap()).containsKey(key)</code></p></td>\n    </tr>\n    <tr>\n      <td><p><code>assertThat(getMap().keySet()).containsOnlyKey(key)</code></p></td>\n      <td><p><code>assertThat(getMap()).containsOnlyKey(key)</code></p></td>\n    </tr>\n    <tr>\n      <td><p><code>assertThat(getMap().containsValue(value)).isTrue()</code></p></td>\n      <td><p><code>assertThat(getMap()).containsValue(value)</code></p></td>\n    </tr>\n    <tr>\n      <td><p><code>assertThat(getMap().values()).contains(value)</code></p></td>\n      <td><p><code>assertThat(getMap()).containsValue(value)</code></p></td>\n    </tr>\n    <tr>\n      <td><p><code>assertThat(getMap().get(key)).isEqualTo(value)</code></p></td>\n      <td><p><code>assertThat(getMap()).containsEntry(key, value)</code></p></td>\n    </tr>\n    <tr>\n      <td><p><strong>Related to <code>Optional</code></strong></p></td>\n      <td></td>\n    </tr>\n    <tr>\n      <td><p><code>assertThat(getOptional().isPresent()).isTrue()</code></p></td>\n      <td><p><code>assertThat(getOptional()).isPresent()</code></p></td>\n    </tr>\n    <tr>\n      <td><p><code>assertThat(getOptional().get()).isEqualTo(something)</code></p></td>\n      <td><p><code>assertThat(getOptional()).contains(something)</code></p></td>\n    </tr>\n    <tr>\n      <td><p><code>assertThat(getOptional().get()).isSameAs(something)</code></p></td>\n      <td><p><code>assertThat(getOptional()).containsSame(something)</code></p></td>\n    </tr>\n  </tbody>\n</table>\n<h3>Noncompliant code example</h3>\n<pre>\nassertThat(getObject()).isEqualTo(null); // Noncompliant\nassertThat(getObject()).isNotEqualTo(null); // Noncompliant - not listed above but also supported\n\nassertThat(getString().trim()).isEmpty();\nassertThat(getFile().canRead()).isTrue();\nassertThat(getPath().getParent()).isNull();\n</pre>\n<h3>Compliant solution</h3>\n<pre>\nassertThat(getObject()).isNull();\nassertThat(getObject()).isNotNull();\n\nassertThat(getString()).isBlank();\nassertThat(getFile()).canRead();\nassertThat(getPath()).hasNoParentRaw();\n</pre>",
    "howToFix": "",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "체이닝된 AssertJ assertion은 해당 전용 assertion으로 단순화해야 합니다",
    "why_ko": "<p>AssertJ는 일반적인 타입에 특화된 많은 assertion 메서드를 포함하고 있습니다. 두 버전 모두 동일한 것을 테스트하지만 전용 버전은 더 나은 오류 메시지를 제공하여 디버깅 과정을 단순화합니다.</p>\n<p>이 규칙은 assertion이 전용 assertion으로 단순화될 수 있을 때 문제를 보고합니다.</p>\n<p>아래 표는 규칙에서 보고되는 assertion의 비완전한 목록입니다. 유사하게 동작하거나 부정이 있는 코드도 보고됩니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\nassertThat(getObject()).isEqualTo(null); // 규칙 위반\nassertThat(getObject()).isNotEqualTo(null); // 규칙 위반 - 위에 나열되지 않았지만 지원됨\n\nassertThat(getString().trim()).isEmpty();\nassertThat(getFile().canRead()).isTrue();\nassertThat(getPath().getParent()).isNull();\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre>\nassertThat(getObject()).isNull();\nassertThat(getObject()).isNotNull();\n\nassertThat(getString()).isBlank();\nassertThat(getFile()).canRead();\nassertThat(getPath()).hasNoParentRaw();\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": ""
  },
  {
    "id": "S4454",
    "key": "java:S4454",
    "name": "\"equals\" method parameters should not be marked \"@Nonnull\"",
    "type": "code-smell",
    "severity": "critical",
    "tags": [],
    "why": "<p>By contract, the <code>equals(Object)</code> method, from <code>java.lang.Object</code>, should accept a <code>null</code> argument. Among all the\nother cases, the <code>null</code> case is even explicitly detailed in the <code>Object.equals(...)</code> Javadoc, stating <em>\"For any non-null\nreference value x, x.equals(null) should return false.\"</em></p>\n<p>Assuming that the argument to <code>equals</code> is always non-null, and enforcing that assumption with an annotation is not only a fundamental\nviolation of the contract of <code>equals</code>, but it is also likely to cause problems in the future as the use of the class evolves over time.</p>\n<p>The rule raises an issue when the <code>equals</code> method is overridden and its parameter annotated with any kind of <code>@Nonnull</code>\nannotation.</p>\n<h3>Noncompliant code example</h3>\n<pre>\npublic boolean equals(@javax.annotation.Nonnull Object obj) { // Noncompliant\n  // ...\n}\n</pre>\n<h3>Compliant solution</h3>\n<pre>\npublic boolean equals(Object obj) {\n  if (obj == null) {\n    return false;\n  }\n  // ...\n}\n</pre>",
    "howToFix": "",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "\"equals\" 메서드 매개변수에 \"@Nonnull\"을 표시하면 안 됩니다",
    "why_ko": "<p>계약상 <code>java.lang.Object</code>의 <code>equals(Object)</code> 메서드는 <code>null</code> 인수를 수락해야 합니다. 다른 모든 경우 중에서도 <code>null</code> 경우는 <code>Object.equals(...)</code> Javadoc에 <em>\"null이 아닌 참조 값 x에 대해 x.equals(null)은 false를 반환해야 합니다.\"</em>라고 명시적으로 자세히 설명되어 있습니다.</p>\n<p><code>equals</code>에 대한 인수가 항상 null이 아니라고 가정하고 어노테이션으로 이 가정을 강제하는 것은 <code>equals</code> 계약의 근본적인 위반일 뿐만 아니라 시간이 지남에 따라 클래스 사용이 발전하면서 향후 문제를 일으킬 가능성이 높습니다.</p>\n<p>이 규칙은 <code>equals</code> 메서드가 재정의되고 매개변수에 어떤 종류의 <code>@Nonnull</code> 어노테이션이 달렸을 때 문제를 제기합니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\npublic boolean equals(@javax.annotation.Nonnull Object obj) { // 규칙 위반\n  // ...\n}\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre>\npublic boolean equals(Object obj) {\n  if (obj == null) {\n    return false;\n  }\n  // ...\n}\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": ""
  },
  {
    "id": "S1656",
    "key": "java:S1656",
    "name": "Variables should not be self-assigned",
    "type": "bug",
    "severity": "major",
    "tags": [
      "cert"
    ],
    "why": "<p>There is no reason to re-assign a variable to itself. Either this statement is redundant and should be removed, or the re-assignment is a mistake\nand some other value or variable was intended for the assignment instead.</p>\n<h3>Noncompliant code example</h3>\n<pre>\npublic void setName(String name) {\n  name = name;\n}\n</pre>\n<h3>Compliant solution</h3>\n<pre>\npublic void setName(String name) {\n  this.name = name;\n}\n</pre>",
    "howToFix": "",
    "moreInfo": "<ul>\n  <li> <a href=\"https://wiki.sei.cmu.edu/confluence/x/5dUxBQ\">CERT, MSC12-C.</a> - Detect and remove code that has no effect or is never executed\n  </li>\n</ul>",
    "status": "READY",
    "name_ko": "변수에 자기 자신을 할당하면 안 됩니다",
    "why_ko": "<p>변수에 자기 자신을 다시 할당할 이유가 없습니다. 이 문은 중복되어 제거해야 하거나, 재할당이 실수이고 다른 값이나 변수가 할당되어야 했을 수 있습니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\npublic void setName(String name) {\n  name = name;\n}\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre>\npublic void setName(String name) {\n  this.name = name;\n}\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": "<ul>\n  <li> <a href=\"https://wiki.sei.cmu.edu/confluence/x/5dUxBQ\">CERT, MSC12-C.</a> - 효과가 없거나 실행되지 않는 코드를 탐지하고 제거하세요 </li>\n</ul>"
  },
  {
    "id": "S1206",
    "key": "java:S1206",
    "name": "\"equals(Object obj)\" and \"hashCode()\" should be overridden in pairs",
    "type": "bug",
    "severity": "minor",
    "tags": [
      "cwe",
      "cert"
    ],
    "why": "<p>According to the Java Language Specification, there is a contract between <code>equals(Object)</code> and <code>hashCode()</code>:</p>\n<blockquote>\n  <p>If two objects are equal according to the <code>equals(Object)</code> method, then calling the <code>hashCode</code> method on each of the two\n  objects must produce the same integer result.</p>\n  <p>It is not required that if two objects are unequal according to the <code>equals(java.lang.Object)</code> method, then calling the\n  <code>hashCode</code> method on each of the two objects must produce distinct integer results.</p>\n  <p>However, the programmer should be aware that producing distinct integer results for unequal objects may improve the performance of\n  hashtables.</p>\n</blockquote>\n<p>In order to comply with this contract, those methods should be either both inherited, or both overridden.</p>",
    "howToFix": "<h4>Noncompliant code example</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\nclass MyClass {    // Noncompliant - should also override \"hashCode()\"\n\n  @Override\n  public boolean equals(Object obj) {\n    /* ... */\n  }\n\n}\n</pre>\n<h4>Compliant solution</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\nclass MyClass {    // Compliant\n\n  @Override\n  public boolean equals(Object obj) {\n    /* ... */\n  }\n\n  @Override\n  public int hashCode() {\n    /* ... */\n  }\n\n}\n</pre>",
    "moreInfo": "<ul>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/581\">CWE-581 - Object Model Violation: Just One of Equals and Hashcode Defined</a> </li>\n  <li> <a href=\"https://wiki.sei.cmu.edu/confluence/x/7DVGBQ\">CERT, MET09-J.</a> - Classes that define an equals() method must also define a\n  hashCode() method </li>\n</ul>",
    "status": "READY",
    "name_ko": "\"equals(Object obj)\"와 \"hashCode()\"는 함께 오버라이드해야 합니다",
    "why_ko": "<p>Java 언어 명세에 따르면, <code>equals(Object)</code>와 <code>hashCode()</code> 사이에는 계약이 있습니다:</p>\n<blockquote>\n  <p><code>equals(Object)</code> 메서드에 따라 두 객체가 동등하면, 두 객체 각각에 대해 <code>hashCode</code> 메서드를 호출하면 동일한 정수 결과를 생성해야 합니다.</p>\n  <p><code>equals(java.lang.Object)</code> 메서드에 따라 두 객체가 동등하지 않으면, 두 객체 각각에 대해 <code>hashCode</code> 메서드를 호출하면 서로 다른 정수 결과를 생성해야 하는 것은 아닙니다.</p>\n  <p>그러나 프로그래머는 동등하지 않은 객체에 대해 서로 다른 정수 결과를 생성하면 해시테이블의 성능이 향상될 수 있다는 것을 알아야 합니다.</p>\n</blockquote>\n<p>이 계약을 준수하려면 이러한 메서드는 둘 다 상속되거나 둘 다 오버라이드되어야 합니다.</p>",
    "howToFix_ko": "<h4>규칙을 준수하지 않는 코드 예시</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\nclass MyClass {    // 규칙 위반 - \"hashCode()\"도 오버라이드해야 함\n\n  @Override\n  public boolean equals(Object obj) {\n    /* ... */\n  }\n\n}\n</pre>\n<h4>규칙을 준수하는 해결책</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\nclass MyClass {    // 규칙 준수\n\n  @Override\n  public boolean equals(Object obj) {\n    /* ... */\n  }\n\n  @Override\n  public int hashCode() {\n    /* ... */\n  }\n\n}\n</pre>",
    "moreInfo_ko": "<ul>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/581\">CWE-581 - 객체 모델 위반: Equals와 Hashcode 중 하나만 정의됨</a> </li>\n  <li> <a href=\"https://wiki.sei.cmu.edu/confluence/x/7DVGBQ\">CERT, MET09-J.</a> - equals() 메서드를 정의하는 클래스는 hashCode() 메서드도 정의해야 합니다 </li>\n</ul>"
  },
  {
    "id": "S2095",
    "key": "java:S2095",
    "name": "Resources should be closed",
    "type": "bug",
    "severity": "blocker",
    "tags": [
      "symbolic-execution",
      "cwe",
      "leak",
      "denial-of-service",
      "cert"
    ],
    "why": "<p>Connections, streams, files, and other classes that implement the <code>Closeable</code> interface or its super-interface,\n<code>AutoCloseable</code>, needs to be closed after use. Further, that <code>close</code> call must be made in a <code>finally</code> block otherwise\nan exception could keep the call from being made. Preferably, when class implements <code>AutoCloseable</code>, resource should be created using\n\"try-with-resources\" pattern and will be closed automatically.</p>\n<p>Failure to properly close resources will result in a resource leak which could bring first the application and then perhaps the box the application\nis on to their knees.</p>\n<h3>Noncompliant code example</h3>\n<pre>\nprivate void readTheFile() throws IOException {\n  Path path = Paths.get(this.fileName);\n  BufferedReader reader = Files.newBufferedReader(path, this.charset);\n  // ...\n  reader.close();  // Noncompliant\n  // ...\n  Files.lines(\"input.txt\").forEach(System.out::println); // Noncompliant: The stream needs to be closed\n}\n\nprivate void doSomething() {\n  OutputStream stream = null;\n  try {\n    for (String property : propertyList) {\n      stream = new FileOutputStream(\"myfile.txt\");  // Noncompliant\n      // ...\n    }\n  } catch (Exception e) {\n    // ...\n  } finally {\n    stream.close();  // Multiple streams were opened. Only the last is closed.\n  }\n}\n</pre>\n<h3>Compliant solution</h3>\n<pre>\nprivate void readTheFile(String fileName) throws IOException {\n    Path path = Paths.get(fileName);\n    try (BufferedReader reader = Files.newBufferedReader(path, StandardCharsets.UTF_8)) {\n      reader.readLine();\n      // ...\n    }\n    // ..\n    try (Stream&lt;String&gt; input = Files.lines(\"input.txt\"))  {\n      input.forEach(System.out::println);\n    }\n}\n\nprivate void doSomething() {\n  OutputStream stream = null;\n  try {\n    stream = new FileOutputStream(\"myfile.txt\");\n    for (String property : propertyList) {\n      // ...\n    }\n  } catch (Exception e) {\n    // ...\n  } finally {\n    stream.close();\n  }\n}\n</pre>\n<h3>Exceptions</h3>\n<p>Instances of the following classes are ignored by this rule because <code>close</code> has no effect:</p>\n<ul>\n  <li> <code>java.io.ByteArrayOutputStream</code> </li>\n  <li> <code>java.io.ByteArrayInputStream</code> </li>\n  <li> <code>java.io.CharArrayReader</code> </li>\n  <li> <code>java.io.CharArrayWriter</code> </li>\n  <li> <code>java.io.StringReader</code> </li>\n  <li> <code>java.io.StringWriter</code> </li>\n</ul>\n<p>Java 7 introduced the try-with-resources statement, which implicitly closes <code>Closeables</code>. All resources opened in a try-with-resources\nstatement are ignored by this rule.</p>\n<pre>\ntry (BufferedReader br = new BufferedReader(new FileReader(fileName))) {\n  //...\n}\ncatch ( ... ) {\n  //...\n}\n</pre>",
    "howToFix": "",
    "moreInfo": "<ul>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/459\">CWE-459 - Incomplete Cleanup</a> </li>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/772\">CWE-772 - Missing Release of Resource after Effective Lifetime</a> </li>\n  <li> <a href=\"https://wiki.sei.cmu.edu/confluence/x/vjdGBQ\">CERT, FIO04-J.</a> - Release resources when they are no longer needed </li>\n  <li> <a href=\"https://wiki.sei.cmu.edu/confluence/x/QtUxBQ\">CERT, FIO42-C.</a> - Close files when they are no longer needed </li>\n  <li> <a href=\"https://docs.oracle.com/javase/tutorial/essential/exceptions/tryResourceClose.html\">Try With Resources</a> </li>\n</ul>",
    "status": "READY",
    "name_ko": "리소스는 닫아야 합니다",
    "why_ko": "<p><code>Closeable</code> 인터페이스 또는 그 상위 인터페이스인 <code>AutoCloseable</code>을 구현하는 연결, 스트림, 파일 및 기타 클래스는 사용 후 닫아야 합니다. 또한 그 <code>close</code> 호출은 <code>finally</code> 블록에서 이루어져야 합니다. 그렇지 않으면 예외로 인해 호출이 이루어지지 않을 수 있습니다. 클래스가 <code>AutoCloseable</code>을 구현할 때 리소스는 \"try-with-resources\" 패턴을 사용하여 생성되고 자동으로 닫히는 것이 바람직합니다.</p>\n<p>리소스를 제대로 닫지 못하면 리소스 누수가 발생하여 먼저 애플리케이션을 그리고 아마도 애플리케이션이 실행 중인 시스템을 다운시킬 수 있습니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\nprivate void readTheFile() throws IOException {\n  Path path = Paths.get(this.fileName);\n  BufferedReader reader = Files.newBufferedReader(path, this.charset);\n  // ...\n  reader.close();  // 규칙 위반\n  // ...\n  Files.lines(\"input.txt\").forEach(System.out::println); // 규칙 위반: 스트림을 닫아야 합니다\n}\n\nprivate void doSomething() {\n  OutputStream stream = null;\n  try {\n    for (String property : propertyList) {\n      stream = new FileOutputStream(\"myfile.txt\");  // 규칙 위반\n      // ...\n    }\n  } catch (Exception e) {\n    // ...\n  } finally {\n    stream.close();  // 여러 스트림이 열렸습니다. 마지막 것만 닫힙니다.\n  }\n}\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre>\nprivate void readTheFile(String fileName) throws IOException {\n    Path path = Paths.get(fileName);\n    try (BufferedReader reader = Files.newBufferedReader(path, StandardCharsets.UTF_8)) {\n      reader.readLine();\n      // ...\n    }\n    // ..\n    try (Stream&lt;String&gt; input = Files.lines(\"input.txt\"))  {\n      input.forEach(System.out::println);\n    }\n}\n\nprivate void doSomething() {\n  OutputStream stream = null;\n  try {\n    stream = new FileOutputStream(\"myfile.txt\");\n    for (String property : propertyList) {\n      // ...\n    }\n  } catch (Exception e) {\n    // ...\n  } finally {\n    stream.close();\n  }\n}\n</pre>\n<h3>예외</h3>\n<p>다음 클래스의 인스턴스는 <code>close</code>가 효과가 없으므로 이 규칙에서 무시됩니다:</p>\n<ul>\n  <li> <code>java.io.ByteArrayOutputStream</code> </li>\n  <li> <code>java.io.ByteArrayInputStream</code> </li>\n  <li> <code>java.io.CharArrayReader</code> </li>\n  <li> <code>java.io.CharArrayWriter</code> </li>\n  <li> <code>java.io.StringReader</code> </li>\n  <li> <code>java.io.StringWriter</code> </li>\n</ul>\n<p>Java 7에서는 <code>Closeables</code>를 암시적으로 닫는 try-with-resources 문을 도입했습니다. try-with-resources 문에서 열린 모든 리소스는 이 규칙에서 무시됩니다.</p>\n<pre>\ntry (BufferedReader br = new BufferedReader(new FileReader(fileName))) {\n  //...\n}\ncatch ( ... ) {\n  //...\n}\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": "<ul>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/459\">CWE-459 - Incomplete Cleanup</a> </li>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/772\">CWE-772 - Missing Release of Resource after Effective Lifetime</a> </li>\n  <li> <a href=\"https://wiki.sei.cmu.edu/confluence/x/vjdGBQ\">CERT, FIO04-J.</a> - Release resources when they are no longer needed </li>\n  <li> <a href=\"https://wiki.sei.cmu.edu/confluence/x/QtUxBQ\">CERT, FIO42-C.</a> - Close files when they are no longer needed </li>\n  <li> <a href=\"https://docs.oracle.com/javase/tutorial/essential/exceptions/tryResourceClose.html\">Try With Resources</a> </li>\n</ul>"
  },
  {
    "id": "S4792",
    "key": "java:S4792",
    "name": "Configuring loggers is security-sensitive",
    "type": "security-hotspot",
    "severity": "critical",
    "tags": [],
    "why": "<p>This rule is deprecated, and will eventually be removed.</p>\n<p>Configuring loggers is security-sensitive. It has led in the past to the following vulnerabilities:</p>\n<ul>\n  <li> <a href=\"https://www.cve.org/CVERecord?id=CVE-2018-0285\">CVE-2018-0285</a> </li>\n  <li> <a href=\"https://www.cve.org/CVERecord?id=CVE-2000-1127\">CVE-2000-1127</a> </li>\n  <li> <a href=\"https://www.cve.org/CVERecord?id=CVE-2017-15113\">CVE-2017-15113</a> </li>\n  <li> <a href=\"https://www.cve.org/CVERecord?id=CVE-2015-5742\">CVE-2015-5742</a> </li>\n</ul>\n<p>Logs are useful before, during and after a security incident.</p>\n<ul>\n  <li> Attackers will most of the time start their nefarious work by probing the system for vulnerabilities. Monitoring this activity and stopping it\n  is the first step to prevent an attack from ever happening. </li>\n  <li> In case of a successful attack, logs should contain enough information to understand what damage an attacker may have inflicted. </li>\n</ul>\n<p>Logs are also a target for attackers because they might contain sensitive information. Configuring loggers has an impact on the type of information\nlogged and how they are logged.</p>\n<p>This rule flags for review code that initiates loggers configuration. The goal is to guide security code reviews.</p>\n<h2>Exceptions</h2>\n<p>Log4J 1.x is not covered as it has reached <a href=\"https://blogs.apache.org/foundation/entry/apache_logging_services_project_announces\">end of\nlife</a>.</p>\n",
    "howToFix": "<h2>Recommended Secure Coding Practices</h2>\n<ul>\n  <li> Check that your production deployment doesn't have its loggers in \"debug\" mode as it might write sensitive information in logs. </li>\n  <li> Production logs should be stored in a secure location which is only accessible to system administrators. </li>\n  <li> Configure the loggers to display all warnings, info and error messages. Write relevant information such as the precise time of events and the\n  hostname. </li>\n  <li> Choose log format which is easy to parse and process automatically. It is important to process logs rapidly in case of an attack so that the\n  impact is known and limited. </li>\n  <li> Check that the permissions of the log files are correct. If you index the logs in some other service, make sure that the transfer and the\n  service are secure too. </li>\n  <li> Add limits to the size of the logs and make sure that no user can fill the disk with logs. This can happen even when the user does not control\n  the logged information. An attacker could just repeat a logged action many times. </li>\n</ul>\n<p>Remember that configuring loggers properly doesn't make them bullet-proof. Here is a list of recommendations explaining on how to use your\nlogs:</p>\n<ul>\n  <li> Don't log any sensitive information. This obviously includes passwords and credit card numbers but also any personal information such as user\n  names, locations, etc…​ Usually any information which is protected by law is good candidate for removal. </li>\n  <li> Sanitize all user inputs before writing them in the logs. This includes checking its size, content, encoding, syntax, etc…​ As for any user\n  input, validate using whitelists whenever possible. Enabling users to write what they want in your logs can have many impacts. It could for example\n  use all your storage space or compromise your log indexing service. </li>\n  <li> Log enough information to monitor suspicious activities and evaluate the impact an attacker might have on your systems. Register events such as\n  failed logins, successful logins, server side input validation failures, access denials and any important transaction. </li>\n  <li> Monitor the logs for any suspicious activity. </li>\n</ul>\n<h2>See</h2>\n<ul>\n  <li> OWASP - <a href=\"https://owasp.org/Top10/A09_2021-Security_Logging_and_Monitoring_Failures/\">Top 10 2021 Category A9 - Security Logging and\n  Monitoring Failures</a> </li>\n  <li> OWASP - <a href=\"https://owasp.org/www-project-top-ten/2017/A3_2017-Sensitive_Data_Exposure\">Top 10 2017 Category A3 - Sensitive Data\n  Exposure</a> </li>\n  <li> OWASP - <a href=\"https://owasp.org/www-project-top-ten/2017/A10_2017-Insufficient_Logging%2526Monitoring\">Top 10 2017 Category A10 -\n  Insufficient Logging &amp; Monitoring</a> </li>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/117\">CWE-117 - Improper Output Neutralization for Logs</a> </li>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/532\">CWE-532 - Information Exposure Through Log Files</a> </li>\n</ul>",
    "moreInfo": "",
    "status": "DEPRECATED",
    "name_ko": "로거 설정은 보안에 민감합니다",
    "why_ko": "<p>이 규칙은 더 이상 사용되지 않으며 결국 제거될 예정입니다.</p>\n<p>로거 설정은 보안에 민감합니다. 이것은 과거에 다음과 같은 취약점으로 이어졌습니다:</p>\n<ul>\n  <li> <a href=\"https://www.cve.org/CVERecord?id=CVE-2018-0285\">CVE-2018-0285</a> </li>\n  <li> <a href=\"https://www.cve.org/CVERecord?id=CVE-2000-1127\">CVE-2000-1127</a> </li>\n  <li> <a href=\"https://www.cve.org/CVERecord?id=CVE-2017-15113\">CVE-2017-15113</a> </li>\n  <li> <a href=\"https://www.cve.org/CVERecord?id=CVE-2015-5742\">CVE-2015-5742</a> </li>\n</ul>\n<p>로그는 보안 사고 전, 중, 후에 유용합니다.</p>\n<ul>\n  <li> 공격자는 대부분의 경우 취약점을 찾기 위해 시스템을 탐색하면서 악의적인 작업을 시작합니다. 이 활동을 모니터링하고 중지하는 것이 공격을 방지하는 첫 번째 단계입니다. </li>\n  <li> 성공적인 공격의 경우 로그에는 공격자가 어떤 피해를 입혔는지 이해하기에 충분한 정보가 포함되어야 합니다. </li>\n</ul>\n<p>로그는 민감한 정보를 포함할 수 있으므로 공격자의 대상이기도 합니다. 로거를 설정하면 기록되는 정보의 유형과 기록 방법에 영향을 미칩니다.</p>\n<p>이 규칙은 로거 설정을 시작하는 코드를 검토 대상으로 표시합니다. 목표는 보안 코드 검토를 안내하는 것입니다.</p>\n<h2>예외</h2>\n<p>Log4J 1.x는 <a href=\"https://blogs.apache.org/foundation/entry/apache_logging_services_project_announces\">수명 종료</a>에 도달했으므로 적용되지 않습니다.</p>\n",
    "howToFix_ko": "<h2>권장되는 보안 코딩 관행</h2>\n<ul>\n  <li> 프로덕션 배포에서 로거가 \"debug\" 모드가 아닌지 확인하세요. 민감한 정보가 로그에 기록될 수 있습니다. </li>\n  <li> 프로덕션 로그는 시스템 관리자만 접근할 수 있는 안전한 위치에 저장해야 합니다. </li>\n  <li> 모든 경고, 정보 및 오류 메시지를 표시하도록 로거를 설정하세요. 이벤트의 정확한 시간 및 호스트 이름과 같은 관련 정보를 작성하세요. </li>\n  <li> 자동으로 파싱하고 처리하기 쉬운 로그 형식을 선택하세요. 공격 시 영향이 알려지고 제한되도록 로그를 신속하게 처리하는 것이 중요합니다. </li>\n  <li> 로그 파일의 권한이 올바른지 확인하세요. 다른 서비스에서 로그를 인덱싱하는 경우 전송 및 서비스도 안전한지 확인하세요. </li>\n  <li> 로그 크기에 제한을 추가하고 사용자가 로그로 디스크를 채울 수 없도록 하세요. 이것은 사용자가 기록된 정보를 제어하지 않더라도 발생할 수 있습니다. 공격자가 기록된 작업을 여러 번 반복할 수 있습니다. </li>\n</ul>\n<p>로거를 적절하게 구성한다고 해서 완벽하게 보호되는 것은 아닙니다. 다음은 로그 사용 방법을 설명하는 권장 사항 목록입니다:</p>\n<ul>\n  <li> 민감한 정보를 로깅하지 마세요. 여기에는 비밀번호와 신용카드 번호는 물론 사용자 이름, 위치 등과 같은 개인 정보도 포함됩니다. 일반적으로 법으로 보호되는 정보는 제거 대상으로 적합합니다. </li>\n  <li> 로그에 쓰기 전에 모든 사용자 입력을 삭제하세요. 여기에는 크기, 내용, 인코딩, 구문 등을 확인하는 것이 포함됩니다. 다른 사용자 입력과 마찬가지로 가능하면 화이트리스트를 사용하여 검증하세요. 사용자가 로그에 원하는 것을 쓸 수 있게 하면 많은 영향을 미칠 수 있습니다. 예를 들어 모든 저장 공간을 사용하거나 로그 인덱싱 서비스를 손상시킬 수 있습니다. </li>\n  <li> 의심스러운 활동을 모니터링하고 공격자가 시스템에 미칠 수 있는 영향을 평가하기에 충분한 정보를 기록하세요. 실패한 로그인, 성공한 로그인, 서버 측 입력 유효성 검사 실패, 접근 거부 및 중요한 트랜잭션과 같은 이벤트를 등록하세요. </li>\n  <li> 의심스러운 활동에 대해 로그를 모니터링하세요. </li>\n</ul>\n<h2>참고</h2>\n<ul>\n  <li> OWASP - <a href=\"https://owasp.org/Top10/A09_2021-Security_Logging_and_Monitoring_Failures/\">Top 10 2021 카테고리 A9 - 보안 로깅 및 모니터링 실패</a> </li>\n  <li> OWASP - <a href=\"https://owasp.org/www-project-top-ten/2017/A3_2017-Sensitive_Data_Exposure\">Top 10 2017 카테고리 A3 - 민감한 데이터 노출</a> </li>\n  <li> OWASP - <a href=\"https://owasp.org/www-project-top-ten/2017/A10_2017-Insufficient_Logging%2526Monitoring\">Top 10 2017 카테고리 A10 - 불충분한 로깅 및 모니터링</a> </li>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/117\">CWE-117 - 로그에 대한 부적절한 출력 무력화</a> </li>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/532\">CWE-532 - 로그 파일을 통한 정보 노출</a> </li>\n</ul>",
    "moreInfo_ko": ""
  },
  {
    "id": "S3305",
    "key": "java:S3305",
    "name": "Factory method injection should be used in \"@Configuration\" classes",
    "type": "code-smell",
    "severity": "critical",
    "tags": [
      "spring",
      "performance"
    ],
    "why": "<p>When <code>@Autowired</code> is used, dependencies need to be resolved when the class is instantiated, which may cause early initialization of\nbeans or lead the context to look in places it shouldn't to find the bean. To avoid this tricky issue and optimize the way the context loads,\ndependencies should be requested as late as possible. That means using parameter injection instead of field injection for dependencies that are only\nused in a single <code>@Bean</code> method.</p>\n<h3>Noncompliant code example</h3>\n<pre>\n@Configuration\npublic class ​FooConfiguration {\n\n  @Autowired private ​DataSource dataSource​;  // Noncompliant\n\n  @Bean\n  public ​MyService myService() {\n    return new ​MyService(this​.dataSource​);\n  }\n}\n</pre>\n<h3>Compliant solution</h3>\n<pre>\n@Configuration\npublic class ​FooConfiguration {\n\n @Bean\n  public ​MyService myService(DataSource dataSource) {\n    return new ​MyService(dataSource);\n  }\n}\n</pre>\n<h3>Exceptions</h3>\n<p>Fields used in methods that are called directly by other methods in the application (as opposed to being invoked automatically by the Spring\nframework) are ignored by this rule so that direct callers don't have to provide the dependencies themselves.</p>",
    "howToFix": "",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "\"@Configuration\" 클래스에서는 팩토리 메서드 주입을 사용해야 합니다",
    "why_ko": "<p><code>@Autowired</code>를 사용하면 클래스가 인스턴스화될 때 의존성이 해결되어야 하므로, 빈의 조기 초기화가 발생하거나 컨텍스트가 빈을 찾기 위해 적절하지 않은 곳을 탐색하게 될 수 있습니다. 이 까다로운 문제를 피하고 컨텍스트가 로드되는 방식을 최적화하려면 의존성을 가능한 한 늦게 요청해야 합니다. 즉, 단일 <code>@Bean</code> 메서드에서만 사용되는 의존성에 대해서는 필드 주입 대신 매개변수 주입을 사용해야 합니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\n@Configuration\npublic class ​FooConfiguration {\n\n  @Autowired private ​DataSource dataSource​;  // 규칙 위반\n\n  @Bean\n  public ​MyService myService() {\n    return new ​MyService(this​.dataSource​);\n  }\n}\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre>\n@Configuration\npublic class ​FooConfiguration {\n\n @Bean\n  public ​MyService myService(DataSource dataSource) {\n    return new ​MyService(dataSource);\n  }\n}\n</pre>\n<h3>예외</h3>\n<p>Spring 프레임워크에 의해 자동으로 호출되는 것이 아니라 애플리케이션의 다른 메서드에 의해 직접 호출되는 메서드에서 사용되는 필드는 이 규칙에서 무시됩니다. 이렇게 하면 직접 호출자가 의존성을 직접 제공할 필요가 없습니다.</p>",
    "howToFix_ko": "",
    "moreInfo_ko": ""
  },
  {
    "id": "S6804",
    "key": "java:S6804",
    "name": "\"@Value\" annotation should inject property or SpEL expression",
    "type": "code-smell",
    "severity": "major",
    "tags": [
      "spring"
    ],
    "why": "<p>The purpose of the <code>@Value</code> annotation in <code>org.springframework.beans.factory.annotation</code> is to inject a value into a field or\nmethod based on the Spring context after it has been established.</p>\n<p>If the annotation does not include an expression (either Spring Expression Language or a property injection), the injected value is a simple\nconstant that does not depend on the Spring context, making the annotation replaceable with a standard field initialization statement.</p>\n<p>This not only implies the redundant use of <code>@Value</code>, but could also indicate an error where the expression indicators (<code>#</code>,\n<code>$</code>) were omitted by mistake.</p>\n<h3>Exceptions</h3>\n<p>This rule does not raise an issue if <code>@Value</code> is applied to a method or method argument, because the annotation has the side effect that\nthe method is called.</p>",
    "howToFix": "<ul>\n  <li> If a property is to be injected, use <code>${propertyName}</code> instead of <code>propertyName</code>. </li>\n  <li> If a SpEL expression is to be evaluated, use <code>#{expression}</code> instead of <code>expression</code>. </li>\n  <li> If you intend to initialize a field with a simple value or with an expression that does not depend on the Spring context, use a standard field\n  initialization statement. </li>\n</ul>\n\n<h4>Noncompliant code example</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\n@Value(\"catalog.name\") // Noncompliant, this will not inject the property\nString catalog;\n</pre>\n<h4>Compliant solution</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\n@Value(\"${catalog.name}\") // Compliant\nString catalog;\n</pre>\n<h4>Noncompliant code example</h4>\n<pre data-diff-id=\"2\" data-diff-type=\"noncompliant\">\n@Value(\"book.topics[0]\") // Noncompliant, this will not evaluate the expression\nTopic topic;\n</pre>\n<h4>Compliant solution</h4>\n<pre data-diff-id=\"2\" data-diff-type=\"compliant\">\n@Value(\"#{book.topics[0]}\") // Compliant\nTopic topic;\n</pre>\n<h4>Noncompliant code example</h4>\n<pre data-diff-id=\"3\" data-diff-type=\"noncompliant\">\n@Value(\"Hello, world!\") // Noncompliant, this use of @Value is redundant\nString greeting;\n</pre>\n<h4>Compliant solution</h4>\n<pre data-diff-id=\"3\" data-diff-type=\"compliant\">\nString greeting = \"Hello, world!\"; // Compliant\n</pre>",
    "moreInfo": "<h3>Documentation</h3>\n<ul>\n  <li> <a href=\"https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/beans/factory/annotation/Value.html\">Spring\n  Framework API - Annotation Interface Value</a> </li>\n</ul>\n<h3>Articles &amp; blog posts</h3>\n<ul>\n  <li> <a href=\"https://www.baeldung.com/spring-value-annotation\">Baeldung - A Quick Guide to Spring @Value</a> </li>\n  <li> <a href=\"https://www.digitalocean.com/community/tutorials/spring-value-annotation\">DigitalOcean - Spring @Value Annotation</a> </li>\n</ul>",
    "status": "READY",
    "name_ko": "\"@Value\" 어노테이션은 프로퍼티 또는 SpEL 표현식을 주입해야 합니다",
    "why_ko": "<p><code>org.springframework.beans.factory.annotation</code>의 <code>@Value</code> 어노테이션의 목적은 Spring 컨텍스트가 설정된 후 필드나 메서드에 값을 주입하는 것입니다.</p>\n<p>어노테이션에 표현식(Spring Expression Language 또는 프로퍼티 주입)이 포함되어 있지 않으면 주입된 값은 Spring 컨텍스트에 의존하지 않는 단순한 상수이므로 어노테이션을 표준 필드 초기화 문으로 대체할 수 있습니다.</p>\n<p>이는 <code>@Value</code>의 중복 사용을 의미할 뿐만 아니라 표현식 지시자(<code>#</code>, <code>$</code>)가 실수로 생략된 오류를 나타낼 수도 있습니다.</p>\n<h3>예외</h3>\n<p>이 규칙은 <code>@Value</code>가 메서드나 메서드 인수에 적용된 경우 문제를 발생시키지 않습니다. 어노테이션에는 메서드가 호출되는 부작용이 있기 때문입니다.</p>",
    "howToFix_ko": "<ul>\n  <li> 프로퍼티를 주입하려면 <code>propertyName</code> 대신 <code>${propertyName}</code>을 사용하세요. </li>\n  <li> SpEL 표현식을 평가하려면 <code>expression</code> 대신 <code>#{expression}</code>을 사용하세요. </li>\n  <li> 단순 값이나 Spring 컨텍스트에 의존하지 않는 표현식으로 필드를 초기화하려면 표준 필드 초기화 문을 사용하세요. </li>\n</ul>\n\n<h4>규칙을 준수하지 않는 코드 예시</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\n@Value(\"catalog.name\") // 규칙 위반, 프로퍼티가 주입되지 않습니다\nString catalog;\n</pre>\n<h4>규칙을 준수하는 해결책</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\n@Value(\"${catalog.name}\") // 규칙 준수\nString catalog;\n</pre>\n<h4>규칙을 준수하지 않는 코드 예시</h4>\n<pre data-diff-id=\"2\" data-diff-type=\"noncompliant\">\n@Value(\"book.topics[0]\") // 규칙 위반, 표현식이 평가되지 않습니다\nTopic topic;\n</pre>\n<h4>규칙을 준수하는 해결책</h4>\n<pre data-diff-id=\"2\" data-diff-type=\"compliant\">\n@Value(\"#{book.topics[0]}\") // 규칙 준수\nTopic topic;\n</pre>\n<h4>규칙을 준수하지 않는 코드 예시</h4>\n<pre data-diff-id=\"3\" data-diff-type=\"noncompliant\">\n@Value(\"Hello, world!\") // 규칙 위반, @Value 사용이 중복됩니다\nString greeting;\n</pre>\n<h4>규칙을 준수하는 해결책</h4>\n<pre data-diff-id=\"3\" data-diff-type=\"compliant\">\nString greeting = \"Hello, world!\"; // 규칙 준수\n</pre>",
    "moreInfo_ko": "<h3>문서</h3>\n<ul>\n  <li> <a href=\"https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/beans/factory/annotation/Value.html\">Spring Framework API - 어노테이션 인터페이스 Value</a> </li>\n</ul>\n<h3>기사 및 블로그 게시물</h3>\n<ul>\n  <li> <a href=\"https://www.baeldung.com/spring-value-annotation\">Baeldung - Spring @Value 빠른 가이드</a> </li>\n  <li> <a href=\"https://www.digitalocean.com/community/tutorials/spring-value-annotation\">DigitalOcean - Spring @Value 어노테이션</a> </li>\n</ul>"
  },
  {
    "id": "S5547",
    "key": "java:S5547",
    "name": "Cipher algorithms should be robust",
    "type": "vulnerability",
    "severity": "critical",
    "tags": [
      "cwe",
      "privacy"
    ],
    "why": "<p>Encryption algorithms are essential for protecting sensitive information and ensuring secure communication in various domains. They are used for\nseveral important reasons:</p>\n<ul>\n  <li> Confidentiality, privacy, and intellectual property protection </li>\n  <li> Security during transmission or on storage devices </li>\n  <li> Data integrity, general trust, and authentication </li>\n</ul>\n<p>When selecting encryption algorithms, tools, or combinations, you should also consider two things:</p>\n<ol>\n  <li> No encryption is unbreakable. </li>\n  <li> The strength of an encryption algorithm is usually measured by the effort required to crack it within a reasonable time frame. </li>\n</ol>\n<p>For these reasons, as soon as cryptography is included in a project, it is important to choose encryption algorithms that are considered strong and\nsecure by the cryptography community.</p>\n<h3>What is the potential impact?</h3>\n<p>The cleartext of an encrypted message might be recoverable. Additionally, it might be possible to modify the cleartext of an encrypted message.</p>\n<p>Below are some real-world scenarios that illustrate some impacts of an attacker exploiting the vulnerability.</p>\n<h4>Theft of sensitive data</h4>\n<p>The encrypted message might contain data that is considered sensitive and should not be known to third parties.</p>\n<p>By using a weak algorithm the likelihood that an attacker might be able to recover the cleartext drastically increases.</p>\n<h4>Additional attack surface</h4>\n<p>By modifying the cleartext of the encrypted message it might be possible for an attacker to trigger other vulnerabilities in the code. Encrypted\nvalues are often considered trusted, since under normal circumstances it would not be possible for a third party to modify them.</p>",
    "howToFix": "<p>The following code contains examples of algorithms that are not considered highly resistant to cryptanalysis and thus should be avoided.</p>\n<h4>Noncompliant code example</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\nimport javax.crypto.Cipher;\nimport java.security.NoSuchAlgorithmException;\nimport javax.crypto.NoSuchPaddingException;\n\npublic static void main(String[] args) {\n    try {\n        Cipher des = Cipher.getInstance(\"DES\"); // Noncompliant\n    } catch(NoSuchAlgorithmException|NoSuchPaddingException e) {\n        // ...\n    }\n}\n</pre>\n<h4>Compliant solution</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\nimport javax.crypto.Cipher;\nimport java.security.NoSuchAlgorithmException;\nimport javax.crypto.NoSuchPaddingException;\n\npublic static void main(String[] args) {\n    try {\n        Cipher aes = Cipher.getInstance(\"AES/GCM/NoPadding\");\n    } catch(NoSuchAlgorithmException|NoSuchPaddingException e) {\n        // ...\n    }\n}\n</pre>\n<h3>How does this work?</h3>\n<h4>Use a secure algorithm</h4>\n<p>It is highly recommended to use an algorithm that is currently considered secure by the cryptographic community. A common choice for such an\nalgorithm is the Advanced Encryption Standard (AES).</p>\n<p>For block ciphers, it is not recommended to use algorithms with a block size that is smaller than 128 bits.</p>",
    "moreInfo": "<h3>Standards</h3>\n<ul>\n  <li> OWASP - <a href=\"https://owasp.org/Top10/A02_2021-Cryptographic_Failures/\">Top 10 2021 Category A2 - Cryptographic Failures</a> </li>\n  <li> OWASP - <a href=\"https://owasp.org/www-project-top-ten/2017/A3_2017-Sensitive_Data_Exposure\">Top 10 2017 Category A3 - Sensitive Data\n  Exposure</a> </li>\n  <li> OWASP - <a href=\"https://owasp.org/www-project-top-ten/2017/A6_2017-Security_Misconfiguration\">Top 10 2017 Category A6 - Security\n  Misconfiguration</a> </li>\n  <li> OWASP - <a href=\"https://mas.owasp.org/checklists/MASVS-CRYPTO/\">Mobile AppSec Verification Standard - Cryptography Requirements</a> </li>\n  <li> OWASP - <a href=\"https://owasp.org/www-project-mobile-top-10/2016-risks/m5-insufficient-cryptography\">Mobile Top 10 2016 Category M5 -\n  Insufficient Cryptography</a> </li>\n  <li> OWASP - <a href=\"https://owasp.org/www-project-mobile-top-10/2023-risks/m10-insufficient-cryptography\">Mobile Top 10 2024 Category M10 -\n  Insufficient Cryptography</a> </li>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/327\">CWE-327 - Use of a Broken or Risky Cryptographic Algorithm</a> </li>\n  <li> STIG Viewer - <a href=\"https://stigviewer.com/stigs/application_security_and_development/2024-12-06/finding/V-222396\">Application Security and\n  Development: V-222396</a> - The application must implement DoD-approved encryption to protect the confidentiality of remote access sessions. </li>\n</ul>",
    "status": "READY",
    "name_ko": "암호 알고리즘은 충분히 강력해야 합니다",
    "why_ko": "<p>암호화 알고리즘은 다양한 도메인에서 민감한 정보를 보호하고 안전한 통신을 보장하는 데 필수적입니다. 여러 가지 중요한 이유로 사용됩니다:</p>\n<ul>\n  <li> 기밀성, 개인정보 보호 및 지적 재산권 보호 </li>\n  <li> 전송 중 또는 저장 장치에서의 보안 </li>\n  <li> 데이터 무결성, 일반적인 신뢰 및 인증 </li>\n</ul>\n<p>암호화 알고리즘, 도구 또는 조합을 선택할 때 두 가지를 고려해야 합니다:</p>\n<ol>\n  <li> 어떤 암호화도 깨지지 않는 것은 없습니다. </li>\n  <li> 암호화 알고리즘의 강도는 일반적으로 합리적인 시간 내에 해독하는 데 필요한 노력으로 측정됩니다. </li>\n</ol>\n<p>이러한 이유로 프로젝트에 암호화가 포함되면 암호학 커뮤니티에서 강력하고 안전하다고 여기는 암호화 알고리즘을 선택하는 것이 중요합니다.</p>\n<h3>잠재적 영향은 무엇입니까?</h3>\n<p>암호화된 메시지의 평문이 복구될 수 있습니다. 또한 암호화된 메시지의 평문을 수정할 수 있을 수 있습니다.</p>\n<p>아래는 공격자가 취약점을 악용할 때 일부 영향을 설명하는 실제 시나리오입니다.</p>\n<h4>민감한 데이터 도난</h4>\n<p>암호화된 메시지에는 민감하고 제3자에게 알려지면 안 되는 데이터가 포함될 수 있습니다.</p>\n<p>약한 알고리즘을 사용하면 공격자가 평문을 복구할 수 있는 가능성이 크게 증가합니다.</p>\n<h4>추가 공격 표면</h4>\n<p>암호화된 메시지의 평문을 수정하면 공격자가 코드의 다른 취약점을 트리거할 수 있을 수 있습니다. 암호화된 값은 정상적인 상황에서는 제3자가 수정할 수 없으므로 종종 신뢰할 수 있는 것으로 간주됩니다.</p>",
    "howToFix_ko": "<p>다음 코드는 암호 해석에 높은 저항성이 없어 피해야 하는 알고리즘의 예시를 포함합니다.</p>\n<h4>규칙을 준수하지 않는 코드 예시</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\nimport javax.crypto.Cipher;\nimport java.security.NoSuchAlgorithmException;\nimport javax.crypto.NoSuchPaddingException;\n\npublic static void main(String[] args) {\n    try {\n        Cipher des = Cipher.getInstance(\"DES\"); // 규칙 위반\n    } catch(NoSuchAlgorithmException|NoSuchPaddingException e) {\n        // ...\n    }\n}\n</pre>\n<h4>규칙을 준수하는 해결책</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\nimport javax.crypto.Cipher;\nimport java.security.NoSuchAlgorithmException;\nimport javax.crypto.NoSuchPaddingException;\n\npublic static void main(String[] args) {\n    try {\n        Cipher aes = Cipher.getInstance(\"AES/GCM/NoPadding\");\n    } catch(NoSuchAlgorithmException|NoSuchPaddingException e) {\n        // ...\n    }\n}\n</pre>\n<h3>어떻게 작동합니까?</h3>\n<h4>안전한 알고리즘 사용</h4>\n<p>암호학 커뮤니티에서 현재 안전하다고 여기는 알고리즘을 사용하는 것이 강력히 권장됩니다. 이러한 알고리즘의 일반적인 선택은 고급 암호화 표준(AES)입니다.</p>\n<p>블록 암호의 경우 128비트보다 작은 블록 크기를 가진 알고리즘은 사용하지 않는 것이 좋습니다.</p>",
    "moreInfo_ko": "<h3>표준</h3>\n<ul>\n  <li> OWASP - <a href=\"https://owasp.org/Top10/A02_2021-Cryptographic_Failures/\">Top 10 2021 Category A2 - Cryptographic Failures</a> </li>\n  <li> OWASP - <a href=\"https://owasp.org/www-project-top-ten/2017/A3_2017-Sensitive_Data_Exposure\">Top 10 2017 Category A3 - Sensitive Data Exposure</a> </li>\n  <li> OWASP - <a href=\"https://owasp.org/www-project-top-ten/2017/A6_2017-Security_Misconfiguration\">Top 10 2017 Category A6 - Security Misconfiguration</a> </li>\n  <li> OWASP - <a href=\"https://mas.owasp.org/checklists/MASVS-CRYPTO/\">Mobile AppSec Verification Standard - Cryptography Requirements</a> </li>\n  <li> OWASP - <a href=\"https://owasp.org/www-project-mobile-top-10/2016-risks/m5-insufficient-cryptography\">Mobile Top 10 2016 Category M5 - Insufficient Cryptography</a> </li>\n  <li> OWASP - <a href=\"https://owasp.org/www-project-mobile-top-10/2023-risks/m10-insufficient-cryptography\">Mobile Top 10 2024 Category M10 - Insufficient Cryptography</a> </li>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/327\">CWE-327 - 손상되거나 위험한 암호화 알고리즘 사용</a> </li>\n  <li> STIG Viewer - <a href=\"https://stigviewer.com/stigs/application_security_and_development/2024-12-06/finding/V-222396\">Application Security and Development: V-222396</a> - 애플리케이션은 원격 접근 세션의 기밀성을 보호하기 위해 DoD 승인 암호화를 구현해야 합니다. </li>\n</ul>"
  },
  {
    "id": "S1695",
    "key": "java:S1695",
    "name": "\"NullPointerException\" should not be explicitly thrown",
    "type": "code-smell",
    "severity": "major",
    "tags": [
      "error-handling",
      "pitfall"
    ],
    "why": "<p>A <code>NullPointerException</code> should indicate that a <code>null</code> value was unexpectedly encountered. Good programming practice dictates\nthat code is structured to avoid NPE's.</p>\n<p>Explicitly throwing <code>NullPointerException</code> forces a method's callers to explicitly catch it, rather than coding to avoid it. Further, it\nmakes it difficult to distinguish between the unexpectedly-encountered <code>null</code> value and the condition which causes the method to purposely\nthrow an NPE.</p>\n<p>If an NPE is being thrown to indicate that a parameter to the method should not have been null, use the <code>@NotNull</code> annotation\ninstead.</p>\n<h3>Noncompliant code example</h3>\n<pre>\npublic void doSomething (String aString) throws NullPointerException {\n     throw new NullPointerException();\n}\n</pre>\n<h3>Compliant solution</h3>\n<pre>\npublic void doSomething (@NotNull String aString) {\n}\n</pre>",
    "howToFix": "",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "\"NullPointerException\"을 명시적으로 던지면 안 됩니다",
    "why_ko": "<p><code>NullPointerException</code>은 <code>null</code> 값이 예기치 않게 발견되었음을 나타내야 합니다. 좋은 프로그래밍 관행은 NPE를 피하도록 코드를 구성하는 것입니다.</p>\n<p>명시적으로 <code>NullPointerException</code>을 던지면 메서드 호출자가 이를 피하는 코드를 작성하는 대신 명시적으로 catch해야 합니다. 또한 예기치 않게 발견된 <code>null</code> 값과 메서드가 의도적으로 NPE를 던지게 하는 조건을 구별하기 어렵게 만듭니다.</p>\n<p>메서드의 매개변수가 null이 아니어야 함을 나타내기 위해 NPE를 던지는 경우 대신 <code>@NotNull</code> 어노테이션을 사용하세요.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\npublic void doSomething (String aString) throws NullPointerException {\n     throw new NullPointerException();\n}\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre>\npublic void doSomething (@NotNull String aString) {\n}\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": ""
  },
  {
    "id": "S6916",
    "key": "java:S6916",
    "name": "Use when instead of a single if inside a pattern match body",
    "type": "code-smell",
    "severity": "major",
    "tags": [
      "java21"
    ],
    "why": "<p>Java 21 has introduced enhancements to switch statements and expressions, allowing them to operate on any type, not just specific ones, as in\nprevious versions. Furthermore, case labels have been upgraded to support patterns, providing an alternative to the previous restriction of only\naccepting constants.</p>\n<pre>\n// As of Java 21\nString patternMatchSwitch(Object obj) {\n    return switch (obj) {\n        case String s  -&gt; String.format(\"String %s\", s);\n        case Integer i -&gt; String.format(\"int %d\", i);\n        default        -&gt; obj.toString();\n    };\n}\n</pre>\n<p>This allows to use the <code>when</code> keyword to specify a condition for a case label, also called a guarded case label.</p>\n<pre>\nString guardedCaseSwitch(Object obj) {\n    return switch (obj) {\n        case String s when s.length() &gt; 0 -&gt; String.format(\"String %s\", s);\n        case Integer i when i &gt; 0 -&gt; String.format(\"int %d\", i);\n        default        -&gt; obj.toString();\n    };\n}\n</pre>\n<p>This syntax is more readable and less error-prone than using an if statement inside the case block and should be preferred.</p>\n<p>This rule reports an issue when a single <code>if</code> statement is used inside a case block.</p>",
    "howToFix": "<p>Replace the <code>if</code> statement with a guarded case label.</p>\n\n<h4>Noncompliant code example</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\nvoid testObject(Object response) {\n    switch (response) {\n        case String s -&gt; {\n            if(s.length() &gt; 80) { // Noncompliant; use the \"when\" keyword\n                System.out.println(\"This string is too long\");\n            }\n        }\n        case Integer i -&gt; {\n            if(i &gt; 80) { // Noncompliant; use the \"when\" keyword\n                System.out.println(\"This integer is too big\");\n            }\n        }\n        default -&gt; System.out.println(\"Unknown type\");\n    }\n}\n</pre>\n<h4>Compliant solution</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\nvoid testObject(Object response) {\n    switch (response) {\n        case String s when s.length() &gt; 80 -&gt; {\n            System.out.println(\"This string is too long\");\n        }\n        case Integer i when i &gt; 80 -&gt; {\n            System.out.println(\"This integer is too big\");\n        }\n        default -&gt; System.out.println(\"Unknown type\");\n    }\n}\n</pre>",
    "moreInfo": "<h3>Documentation</h3>\n<ul>\n  <li> Java Documentation - <a href=\"https://openjdk.org/jeps/441\">Pattern Matching for switch</a> </li>\n</ul>",
    "status": "READY",
    "name_ko": "패턴 매치 본문 내에서 단일 if 대신 when을 사용해야 합니다",
    "why_ko": "<p>Java 21에서는 switch 문과 표현식이 이전 버전처럼 특정 타입만이 아닌 모든 타입에서 작동할 수 있도록 향상되었습니다. 또한 case 레이블이 패턴을 지원하도록 업그레이드되어 상수만 허용하던 이전 제한에 대한 대안을 제공합니다.</p>\n<pre>\n// Java 21 기준\nString patternMatchSwitch(Object obj) {\n    return switch (obj) {\n        case String s  -&gt; String.format(\"String %s\", s);\n        case Integer i -&gt; String.format(\"int %d\", i);\n        default        -&gt; obj.toString();\n    };\n}\n</pre>\n<p>이를 통해 가드된 case 레이블이라고도 하는 case 레이블에 조건을 지정하기 위해 <code>when</code> 키워드를 사용할 수 있습니다.</p>\n<pre>\nString guardedCaseSwitch(Object obj) {\n    return switch (obj) {\n        case String s when s.length() &gt; 0 -&gt; String.format(\"String %s\", s);\n        case Integer i when i &gt; 0 -&gt; String.format(\"int %d\", i);\n        default        -&gt; obj.toString();\n    };\n}\n</pre>\n<p>이 구문은 case 블록 내에서 if 문을 사용하는 것보다 더 읽기 쉽고 오류가 적으므로 선호해야 합니다.</p>\n<p>이 규칙은 case 블록 내에서 단일 <code>if</code> 문이 사용될 때 문제를 보고합니다.</p>",
    "howToFix_ko": "<p><code>if</code> 문을 가드된 case 레이블로 교체하세요.</p>\n\n<h4>규칙을 준수하지 않는 코드 예시</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\nvoid testObject(Object response) {\n    switch (response) {\n        case String s -&gt; {\n            if(s.length() &gt; 80) { // 규칙 위반; \"when\" 키워드를 사용하세요\n                System.out.println(\"This string is too long\");\n            }\n        }\n        case Integer i -&gt; {\n            if(i &gt; 80) { // 규칙 위반; \"when\" 키워드를 사용하세요\n                System.out.println(\"This integer is too big\");\n            }\n        }\n        default -&gt; System.out.println(\"Unknown type\");\n    }\n}\n</pre>\n<h4>규칙을 준수하는 해결책</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\nvoid testObject(Object response) {\n    switch (response) {\n        case String s when s.length() &gt; 80 -&gt; {\n            System.out.println(\"This string is too long\");\n        }\n        case Integer i when i &gt; 80 -&gt; {\n            System.out.println(\"This integer is too big\");\n        }\n        default -&gt; System.out.println(\"Unknown type\");\n    }\n}\n</pre>",
    "moreInfo_ko": "<h3>문서</h3>\n<ul>\n  <li> Java 문서 - <a href=\"https://openjdk.org/jeps/441\">switch를 위한 패턴 매칭</a> </li>\n</ul>"
  },
  {
    "id": "S5793",
    "key": "java:S5793",
    "name": "Migrate your tests from JUnit4 to the new JUnit5 annotations",
    "type": "code-smell",
    "severity": "info",
    "tags": [
      "junit",
      "tests"
    ],
    "why": "<p>As mentioned in JUnit5 documentation, it is possible to integrate JUnit4 with JUnit5:</p>\n<blockquote>\n  <p>JUnit provides a gentle migration path via a JUnit Vintage test engine which allows existing tests based on JUnit 3 and JUnit 4 to be executed\n  using the JUnit Platform infrastructure. Since all classes and annotations specific to JUnit Jupiter reside under a new org.junit.jupiter base\n  package, having both JUnit 4 and JUnit Jupiter in the classpath does not lead to any conflicts.</p>\n</blockquote>\n<p>However, maintaining both systems is a temporary solution. This rule flags all the annotations from JUnit4 which would need to be migrated to\nJUnit5, hence helping migration of a project.</p>\n<p>Here is the list of JUnit4 annotations tracked by the rule, with their corresponding annotations in JUnit5:</p>\n<table>\n  <colgroup>\n    <col style=\"width: 50%;\">\n    <col style=\"width: 50%;\">\n  </colgroup>\n  <thead>\n    <tr>\n      <th>JUnit4</th>\n      <th>JUnit5</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td><p><code>org.junit.Test</code></p></td>\n      <td><p><code>org.junit.jupiter.api.Test</code></p></td>\n    </tr>\n    <tr>\n      <td><p><code>org.junit.Before</code></p></td>\n      <td><p><code>org.junit.jupiter.api.BeforeEach</code></p></td>\n    </tr>\n    <tr>\n      <td><p><code>org.junit.After</code></p></td>\n      <td><p><code>org.junit.jupiter.api.AfterEach</code></p></td>\n    </tr>\n    <tr>\n      <td><p><code>org.junit.BeforeClass</code></p></td>\n      <td><p><code>org.junit.jupiter.api.BeforeAll</code></p></td>\n    </tr>\n    <tr>\n      <td><p><code>org.junit.AfterClass</code></p></td>\n      <td><p><code>org.junit.jupiter.api.AfterAll</code></p></td>\n    </tr>\n    <tr>\n      <td><p><code>org.junit.Ignore</code></p></td>\n      <td><p><code>org.junit.jupiter.api.Disabled</code></p></td>\n    </tr>\n  </tbody>\n</table>\n<p>Note that the following annotations might requires some rework of the tests to have JUnit5 equivalent behavior. A simple replacement of the\nannotation won't work immediately:</p>\n<table>\n  <colgroup>\n    <col style=\"width: 50%;\">\n    <col style=\"width: 50%;\">\n  </colgroup>\n  <thead>\n    <tr>\n      <th>JUnit4</th>\n      <th>JUnit5</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td><p><code>org.junit.experimental.categories.Category</code></p></td>\n      <td><p><code>org.junit.jupiter.api.Tag</code></p></td>\n    </tr>\n    <tr>\n      <td><p><code>org.junit.Rule</code></p></td>\n      <td><p><code>org.junit.jupiter.api.extension.ExtendWith</code></p></td>\n    </tr>\n    <tr>\n      <td><p><code>org.junit.ClassRule</code></p></td>\n      <td><p><code>org.junit.jupiter.api.extension.RegisterExtension</code></p></td>\n    </tr>\n    <tr>\n      <td><p><code>org.junit.runner.RunWith</code></p></td>\n      <td><p><code>org.junit.jupiter.api.extension.ExtendWith</code></p></td>\n    </tr>\n  </tbody>\n</table>\n<h3>Noncompliant code example</h3>\n<pre>\npackage org.foo;\n\nimport org.junit.After;\nimport org.junit.AfterClass;\nimport org.junit.Before;\nimport org.junit.BeforeClass;\nimport org.junit.Ignore;\nimport org.junit.Test;\nimport org.junit.experimental.categories.Category;\nimport org.junit.runner.RunWith;\n\n@RunWith(MyJUnit4Runner.class)\npublic class MyJUnit4Test {\n\n  @BeforeClass\n  public static void beforeAll() {\n    System.out.println(\"beforeAll\");\n  }\n\n  @AfterClass\n  public static void afterAll() {\n    System.out.println(\"AfterAll\");\n  }\n\n  @Before\n  public void beforeEach() {\n    System.out.println(\"beforeEach\");\n  }\n\n  @After\n  public void afterEach() {\n    System.out.println(\"afterEach\");\n  }\n\n  @Test\n  public void test1() throws Exception {\n    System.out.println(\"test1\");\n  }\n\n  public interface SomeTests { /* category marker */ }\n\n  @Test\n  @Category(SomeTests.class)\n  public void test2() throws Exception {\n    System.out.println(\"test2\");\n  }\n\n  @Test\n  @Ignore(\"Requires fix of #42\")\n  public void ignored() throws Exception {\n    System.out.println(\"ignored\");\n  }\n}\n</pre>\n<h3>Compliant solution</h3>\n<pre>\npackage org.foo;\n\nimport org.junit.jupiter.api.AfterAll;\nimport org.junit.jupiter.api.AfterEach;\nimport org.junit.jupiter.api.BeforeAll;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Disabled;\nimport org.junit.jupiter.api.Tag;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.api.extension.ExtendWith;\n\n@ExtendWith(MyJUnit5Extension.class)\nclass MyJUnit5Test {\n\n  @BeforeAll\n  static void beforeAll() {\n    System.out.println(\"beforeAll\");\n  }\n\n  @AfterAll\n  static void afterAll() {\n    System.out.println(\"afterAll\");\n  }\n\n  @BeforeEach\n  void beforeEach() {\n    System.out.println(\"beforeEach\");\n  }\n\n  @AfterEach\n  void afterEach() {\n    System.out.println(\"afterEach\");\n  }\n\n  @Test\n  void test1() {\n    System.out.println(\"test1\");\n  }\n\n  @Test\n  @Tag(\"SomeTests\")\n  void test2() {\n    System.out.println(\"test2\");\n  }\n\n  @Test\n  @Disabled(\"Requires fix of #42\")\n  void disabled() {\n    System.out.println(\"ignored\");\n  }\n}\n</pre>",
    "howToFix": "",
    "moreInfo": "<ul>\n  <li> <a href=\"https://junit.org/junit5/docs/current/user-guide/#migrating-from-junit4\">JUnit 5: Migrating from JUnit4</a> </li>\n</ul>",
    "status": "READY",
    "name_ko": "테스트를 JUnit4에서 새로운 JUnit5 어노테이션으로 마이그레이션하세요",
    "why_ko": "<p>JUnit5 문서에 언급된 대로 JUnit4를 JUnit5와 통합하는 것이 가능합니다:</p>\n<blockquote>\n  <p>JUnit은 JUnit 3 및 JUnit 4를 기반으로 하는 기존 테스트를 JUnit 플랫폼 인프라를 사용하여 실행할 수 있는 JUnit Vintage 테스트 엔진을 통해 부드러운 마이그레이션 경로를 제공합니다. JUnit Jupiter에 특정한 모든 클래스와 어노테이션은 새로운 org.junit.jupiter 기본 패키지 아래에 있으므로 JUnit 4와 JUnit Jupiter가 모두 클래스 경로에 있어도 충돌이 발생하지 않습니다.</p>\n</blockquote>\n<p>그러나 두 시스템을 모두 유지하는 것은 임시 솔루션입니다. 이 규칙은 JUnit5로 마이그레이션해야 하는 JUnit4의 모든 어노테이션을 표시하여 프로젝트 마이그레이션을 돕습니다.</p>\n<p>다음은 규칙에서 추적하는 JUnit4 어노테이션 목록과 JUnit5의 해당 어노테이션입니다:</p>\n<table>\n  <colgroup>\n    <col style=\"width: 50%;\">\n    <col style=\"width: 50%;\">\n  </colgroup>\n  <thead>\n    <tr>\n      <th>JUnit4</th>\n      <th>JUnit5</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td><p><code>org.junit.Test</code></p></td>\n      <td><p><code>org.junit.jupiter.api.Test</code></p></td>\n    </tr>\n    <tr>\n      <td><p><code>org.junit.Before</code></p></td>\n      <td><p><code>org.junit.jupiter.api.BeforeEach</code></p></td>\n    </tr>\n    <tr>\n      <td><p><code>org.junit.After</code></p></td>\n      <td><p><code>org.junit.jupiter.api.AfterEach</code></p></td>\n    </tr>\n    <tr>\n      <td><p><code>org.junit.BeforeClass</code></p></td>\n      <td><p><code>org.junit.jupiter.api.BeforeAll</code></p></td>\n    </tr>\n    <tr>\n      <td><p><code>org.junit.AfterClass</code></p></td>\n      <td><p><code>org.junit.jupiter.api.AfterAll</code></p></td>\n    </tr>\n    <tr>\n      <td><p><code>org.junit.Ignore</code></p></td>\n      <td><p><code>org.junit.jupiter.api.Disabled</code></p></td>\n    </tr>\n  </tbody>\n</table>\n<p>다음 어노테이션은 JUnit5 동등한 동작을 가지려면 테스트를 다시 작업해야 할 수 있습니다. 어노테이션을 단순히 교체하는 것만으로는 즉시 작동하지 않습니다:</p>\n<table>\n  <colgroup>\n    <col style=\"width: 50%;\">\n    <col style=\"width: 50%;\">\n  </colgroup>\n  <thead>\n    <tr>\n      <th>JUnit4</th>\n      <th>JUnit5</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td><p><code>org.junit.experimental.categories.Category</code></p></td>\n      <td><p><code>org.junit.jupiter.api.Tag</code></p></td>\n    </tr>\n    <tr>\n      <td><p><code>org.junit.Rule</code></p></td>\n      <td><p><code>org.junit.jupiter.api.extension.ExtendWith</code></p></td>\n    </tr>\n    <tr>\n      <td><p><code>org.junit.ClassRule</code></p></td>\n      <td><p><code>org.junit.jupiter.api.extension.RegisterExtension</code></p></td>\n    </tr>\n    <tr>\n      <td><p><code>org.junit.runner.RunWith</code></p></td>\n      <td><p><code>org.junit.jupiter.api.extension.ExtendWith</code></p></td>\n    </tr>\n  </tbody>\n</table>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\npackage org.foo;\n\nimport org.junit.After;\nimport org.junit.AfterClass;\nimport org.junit.Before;\nimport org.junit.BeforeClass;\nimport org.junit.Ignore;\nimport org.junit.Test;\nimport org.junit.experimental.categories.Category;\nimport org.junit.runner.RunWith;\n\n@RunWith(MyJUnit4Runner.class)\npublic class MyJUnit4Test {\n\n  @BeforeClass\n  public static void beforeAll() {\n    System.out.println(\"beforeAll\");\n  }\n\n  @AfterClass\n  public static void afterAll() {\n    System.out.println(\"AfterAll\");\n  }\n\n  @Before\n  public void beforeEach() {\n    System.out.println(\"beforeEach\");\n  }\n\n  @After\n  public void afterEach() {\n    System.out.println(\"afterEach\");\n  }\n\n  @Test\n  public void test1() throws Exception {\n    System.out.println(\"test1\");\n  }\n\n  public interface SomeTests { /* 카테고리 마커 */ }\n\n  @Test\n  @Category(SomeTests.class)\n  public void test2() throws Exception {\n    System.out.println(\"test2\");\n  }\n\n  @Test\n  @Ignore(\"#42 수정 필요\")\n  public void ignored() throws Exception {\n    System.out.println(\"ignored\");\n  }\n}\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre>\npackage org.foo;\n\nimport org.junit.jupiter.api.AfterAll;\nimport org.junit.jupiter.api.AfterEach;\nimport org.junit.jupiter.api.BeforeAll;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Disabled;\nimport org.junit.jupiter.api.Tag;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.api.extension.ExtendWith;\n\n@ExtendWith(MyJUnit5Extension.class)\nclass MyJUnit5Test {\n\n  @BeforeAll\n  static void beforeAll() {\n    System.out.println(\"beforeAll\");\n  }\n\n  @AfterAll\n  static void afterAll() {\n    System.out.println(\"afterAll\");\n  }\n\n  @BeforeEach\n  void beforeEach() {\n    System.out.println(\"beforeEach\");\n  }\n\n  @AfterEach\n  void afterEach() {\n    System.out.println(\"afterEach\");\n  }\n\n  @Test\n  void test1() {\n    System.out.println(\"test1\");\n  }\n\n  @Test\n  @Tag(\"SomeTests\")\n  void test2() {\n    System.out.println(\"test2\");\n  }\n\n  @Test\n  @Disabled(\"#42 수정 필요\")\n  void disabled() {\n    System.out.println(\"ignored\");\n  }\n}\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": "<ul>\n  <li> <a href=\"https://junit.org/junit5/docs/current/user-guide/#migrating-from-junit4\">JUnit 5: JUnit4에서 마이그레이션</a> </li>\n</ul>"
  },
  {
    "id": "S5843",
    "key": "java:S5843",
    "name": "Regular expressions should not be too complicated",
    "type": "code-smell",
    "severity": "major",
    "tags": [
      "regex"
    ],
    "why": "<p>Overly complicated regular expressions are hard to read and to maintain and can easily cause hard-to-find bugs. If a regex is too complicated, you\nshould consider replacing it or parts of it with regular code or splitting it apart into multiple patterns at least.</p>\n<p>The complexity of a regular expression is determined as follows:</p>\n<p>Each of the following operators increases the complexity by an amount equal to the current nesting level and also increases the current nesting\nlevel by one for its arguments:</p>\n<ul>\n  <li> <code>|</code> - when multiple <code>|</code> operators are used together, the subsequent ones only increase the complexity by 1 </li>\n  <li> <code>&amp;&amp;</code> (inside character classes) - when multiple <code>&amp;&amp;</code> operators are used together, the subsequent ones\n  only increase the complexity by 1 </li>\n  <li> Quantifiers (<code>*</code>, <code>+</code>, <code>?</code>, <code>{n,m}</code>, <code>{n,}</code> or <code>{n}</code>) </li>\n  <li> Non-capturing groups that set flags (such as <code>(?i:some_pattern)</code> or <code>(?i)some_pattern</code>) </li>\n  <li> Lookahead and lookbehind assertions </li>\n</ul>\n<p>Additionally, each use of the following features increase the complexity by 1 regardless of nesting:</p>\n<ul>\n  <li> character classes </li>\n  <li> back references </li>\n</ul>\n<p>If a regular expression is split among multiple variables, the complexity is calculated for each variable individually, not for the whole regular\nexpression. If a regular expression is split over multiple lines, each line is treated individually if it is accompanied by a comment (either a Java\ncomment or a comment within the regular expression), otherwise the regular expression is analyzed as a whole.</p>\n<h3>Noncompliant code example</h3>\n<pre>\nif (dateString.matches(\"^(?:(?:31(\\\\/|-|\\\\.)(?:0?[13578]|1[02]))\\\\1|(?:(?:29|30)(\\\\/|-|\\\\.)(?:0?[13-9]|1[0-2])\\\\2))(?:(?:1[6-9]|[2-9]\\\\d)?\\\\d{2})$|^(?:29(\\\\/|-|\\\\.)0?2\\\\3(?:(?:(?:1[6-9]|[2-9]\\\\d)?(?:0[48]|[2468][048]|[13579][26])|(?:(?:16|[2468][048]|[3579][26])00))))$|^(?:0?[1-9]|1\\\\d|2[0-8])(\\\\/|-|\\\\.)(?:(?:0?[1-9])|(?:1[0-2]))\\\\4(?:(?:1[6-9]|[2-9]\\\\d)?\\\\d{2})$\")) {\n    handleDate(dateString);\n}\n</pre>\n<h3>Compliant solution</h3>\n<pre>\nif (dateString.matches(\"^\\\\d{1,2}([-/.])\\\\d{1,2}\\\\1\\\\d{1,4}$\")) {\n    String dateParts[] = dateString.split(\"[-/.]\");\n    int day = Integer.parseInt(dateParts[0]);\n    int month = Integer.parseInt(dateParts[1]);\n    int year = Integer.parseInt(dateParts[2]);\n    // Put logic to validate and process the date based on its integer parts here\n}\n</pre>\n<h3>Exceptions</h3>\n<p>Regular expressions are only analyzed if all parts of the regular expression are either string literals, effectively final local variables or\n<code>static final</code> fields, all of which can be combined using the '<code>+</code>' operator.</p>\n<p>When a regular expression is split among multiple variables or commented lines, each part is only analyzed if it is syntactically valid by\nitself.</p>",
    "howToFix": "",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "정규식은 너무 복잡하면 안 됩니다",
    "why_ko": "<p>지나치게 복잡한 정규식은 읽기 어렵고 유지 관리하기 어려우며 찾기 어려운 버그를 쉽게 유발할 수 있습니다. 정규식이 너무 복잡하면 일반 코드로 대체하거나 최소한 여러 패턴으로 분할하는 것을 고려해야 합니다.</p>\n<p>정규식의 복잡성은 다음과 같이 결정됩니다:</p>\n<p>다음 연산자 각각은 현재 중첩 수준과 같은 양만큼 복잡성을 증가시키고 인수에 대해 현재 중첩 수준도 1 증가시킵니다:</p>\n<ul>\n  <li> <code>|</code> - 여러 <code>|</code> 연산자가 함께 사용되면 후속 연산자는 복잡성을 1만 증가시킵니다 </li>\n  <li> <code>&amp;&amp;</code> (문자 클래스 내부) - 여러 <code>&amp;&amp;</code> 연산자가 함께 사용되면 후속 연산자는 복잡성을 1만 증가시킵니다 </li>\n  <li> 수량자 (<code>*</code>, <code>+</code>, <code>?</code>, <code>{n,m}</code>, <code>{n,}</code> 또는 <code>{n}</code>) </li>\n  <li> 플래그를 설정하는 비캡처 그룹 (<code>(?i:some_pattern)</code> 또는 <code>(?i)some_pattern</code> 등) </li>\n  <li> 전방 탐색 및 후방 탐색 assertion </li>\n</ul>\n<p>또한 다음 기능의 각 사용은 중첩에 관계없이 복잡성을 1 증가시킵니다:</p>\n<ul>\n  <li> 문자 클래스 </li>\n  <li> 역참조 </li>\n</ul>\n<p>정규식이 여러 변수로 분할된 경우 복잡성은 전체 정규식이 아닌 각 변수에 대해 개별적으로 계산됩니다. 정규식이 여러 줄에 걸쳐 분할된 경우 주석(Java 주석 또는 정규식 내 주석)이 있으면 각 줄이 개별적으로 처리되고, 그렇지 않으면 정규식이 전체로 분석됩니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\nif (dateString.matches(\"^(?:(?:31(\\\\/|-|\\\\.)(?:0?[13578]|1[02]))\\\\1|(?:(?:29|30)(\\\\/|-|\\\\.)(?:0?[13-9]|1[0-2])\\\\2))(?:(?:1[6-9]|[2-9]\\\\d)?\\\\d{2})$|^(?:29(\\\\/|-|\\\\.)0?2\\\\3(?:(?:(?:1[6-9]|[2-9]\\\\d)?(?:0[48]|[2468][048]|[13579][26])|(?:(?:16|[2468][048]|[3579][26])00))))$|^(?:0?[1-9]|1\\\\d|2[0-8])(\\\\/|-|\\\\.)(?:(?:0?[1-9])|(?:1[0-2]))\\\\4(?:(?:1[6-9]|[2-9]\\\\d)?\\\\d{2})$\")) {\n    handleDate(dateString);\n}\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre>\nif (dateString.matches(\"^\\\\d{1,2}([-/.])\\\\d{1,2}\\\\1\\\\d{1,4}$\")) {\n    String dateParts[] = dateString.split(\"[-/.]\");\n    int day = Integer.parseInt(dateParts[0]);\n    int month = Integer.parseInt(dateParts[1]);\n    int year = Integer.parseInt(dateParts[2]);\n    // 정수 부분을 기반으로 날짜를 검증하고 처리하는 로직을 여기에 넣습니다\n}\n</pre>\n<h3>예외</h3>\n<p>정규식은 정규식의 모든 부분이 문자열 리터럴, 사실상 final인 지역 변수 또는 <code>static final</code> 필드인 경우에만 분석되며, 이 모두는 '<code>+</code>' 연산자를 사용하여 결합할 수 있습니다.</p>\n<p>정규식이 여러 변수 또는 주석이 달린 줄로 분할된 경우 각 부분은 그 자체로 구문적으로 유효한 경우에만 분석됩니다.</p>",
    "howToFix_ko": "",
    "moreInfo_ko": ""
  },
  {
    "id": "S105",
    "key": "java:S105",
    "name": "Tabulation characters should not be used",
    "type": "code-smell",
    "severity": "minor",
    "tags": [
      "convention"
    ],
    "why": "<p>The tab width can differ from one development environment to another. Using tabs may require other developers to configure their environment (text\neditor, preferences, etc.) to read source code.</p>\n<p>That is why using spaces is preferable.</p>",
    "howToFix": "",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "탭 문자를 사용하면 안 됩니다",
    "why_ko": "<p>탭 너비는 개발 환경마다 다를 수 있습니다. 탭을 사용하면 다른 개발자들이 소스 코드를 읽기 위해 환경(텍스트 편집기, 설정 등)을 구성해야 할 수 있습니다.</p>\n<p>그래서 공백을 사용하는 것이 바람직합니다.</p>",
    "howToFix_ko": "",
    "moreInfo_ko": ""
  },
  {
    "id": "S2390",
    "key": "java:S2390",
    "name": "Classes should not access their own subclasses during class initialization",
    "type": "bug",
    "severity": "critical",
    "tags": [
      "cert"
    ],
    "why": "<p>Referencing a static member of a subclass from its parent during class initialization, makes the code more fragile and prone to future bugs. The\nexecution of the program will rely heavily on the order of initialization of classes and their static members.</p>\n<h3>What is the potential impact?</h3>\n<p>This could create what is known as an \"initialization cycle\", or even a deadlock in some extreme cases. Additionally, if the order of the static\nclass members is changed, the behavior of the program might change. These issues can be very hard to diagnose so it is highly recommended to avoid\ncreating this kind of dependencies.</p>\n<h3>Noncompliant code example</h3>\n<pre>\nclass Parent {\n  static int field1 = Child.method(); // Noncompliant\n  static int field2 = 42;\n\n  public static void main(String[] args) {\n    System.out.println(Parent.field1); // will display \"0\" instead of \"42\"\n  }\n}\n\nclass Child extends Parent {\n  static int method() {\n    return Parent.field2;\n  }\n}\n</pre>",
    "howToFix": "",
    "moreInfo": "<ul>\n  <li> CERT - <a href=\"https://wiki.sei.cmu.edu/confluence/display/java/DCL00-J.+Prevent+class+initialization+cycles\">DCL00-J. Prevent class\n  initialization cycles</a> </li>\n  <li> <a href=\"https://docs.oracle.com/javase/specs/jls/se17/html/jls-12.html#jls-12.4\">Section 12.4: Initialization of Classes and Interfaces</a> -\n  Java Language Specification </li>\n</ul>",
    "status": "READY",
    "name_ko": "클래스 초기화 중에 자신의 하위 클래스에 접근하면 안 됩니다",
    "why_ko": "<p>클래스 초기화 중에 부모에서 하위 클래스의 정적 멤버를 참조하면 코드가 더 취약해지고 향후 버그가 발생하기 쉬워집니다. 프로그램의 실행은 클래스와 정적 멤버의 초기화 순서에 크게 의존하게 됩니다.</p>\n<h3>잠재적 영향은 무엇입니까?</h3>\n<p>이는 \"초기화 순환\"이라고 알려진 것을 만들 수 있으며, 극단적인 경우에는 데드락까지 발생할 수 있습니다. 또한 정적 클래스 멤버의 순서가 변경되면 프로그램의 동작이 변경될 수 있습니다. 이러한 문제는 진단하기 매우 어려울 수 있으므로 이러한 종류의 의존성을 만들지 않는 것이 좋습니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\nclass Parent {\n  static int field1 = Child.method(); // 규칙 위반\n  static int field2 = 42;\n\n  public static void main(String[] args) {\n    System.out.println(Parent.field1); // \"42\" 대신 \"0\"이 표시됨\n  }\n}\n\nclass Child extends Parent {\n  static int method() {\n    return Parent.field2;\n  }\n}\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": "<ul>\n  <li> CERT - <a href=\"https://wiki.sei.cmu.edu/confluence/display/java/DCL00-J.+Prevent+class+initialization+cycles\">DCL00-J. 클래스 초기화 순환 방지</a> </li>\n  <li> <a href=\"https://docs.oracle.com/javase/specs/jls/se17/html/jls-12.html#jls-12.4\">Section 12.4: 클래스와 인터페이스의 초기화</a> - Java Language Specification </li>\n</ul>"
  },
  {
    "id": "S5785",
    "key": "java:S5785",
    "name": "JUnit assertTrue/assertFalse should be simplified to the corresponding dedicated assertion",
    "type": "code-smell",
    "severity": "major",
    "tags": [
      "junit",
      "tests"
    ],
    "why": "<p>Testing equality or nullness with JUnit's <code>assertTrue()</code> or <code>assertFalse()</code> should be simplified to the corresponding\ndedicated assertion.</p>\n<h3>Noncompliant code example</h3>\n<pre>\nAssert.assertTrue(a.equals(b));\nAssert.assertTrue(a == b);\nAssert.assertTrue(a == null);\nAssert.assertTrue(a != null);\nAssert.assertFalse(a.equals(b));\n</pre>\n<h3>Compliant solution</h3>\n<pre>\nAssert.assertEquals(a, b);\nAssert.assertSame(a, b);\nAssert.assertNull(a);\nAssert.assertNotNull(a);\nAssert.assertNotEquals(a, b);\n</pre>",
    "howToFix": "",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "JUnit assertTrue/assertFalse는 해당하는 전용 assertion으로 단순화해야 합니다",
    "why_ko": "<p>JUnit의 <code>assertTrue()</code> 또는 <code>assertFalse()</code>로 동등성이나 null 여부를 테스트하는 것은 해당하는 전용 assertion으로 단순화해야 합니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\nAssert.assertTrue(a.equals(b));\nAssert.assertTrue(a == b);\nAssert.assertTrue(a == null);\nAssert.assertTrue(a != null);\nAssert.assertFalse(a.equals(b));\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre>\nAssert.assertEquals(a, b);\nAssert.assertSame(a, b);\nAssert.assertNull(a);\nAssert.assertNotNull(a);\nAssert.assertNotEquals(a, b);\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": ""
  },
  {
    "id": "S2693",
    "key": "java:S2693",
    "name": "Threads should not be started in constructors",
    "type": "code-smell",
    "severity": "blocker",
    "tags": [
      "multi-threading",
      "cert",
      "pitfall"
    ],
    "why": "<p>The problem with invoking <code>Thread.start()</code> in a constructor is that you'll have a confusing mess on your hands if the class is ever\nextended because the superclass' constructor will start the thread before the child class has truly been initialized.</p>\n<p>This rule raises an issue any time <code>start</code> is invoked in the constructor of a non-<code>final</code> class.</p>\n<h3>Noncompliant code example</h3>\n<pre>\npublic class MyClass {\n\n  Thread thread = null;\n\n  public MyClass(Runnable runnable) {\n    thread = new Thread(runnable);\n    thread.start(); // Noncompliant\n  }\n}\n</pre>",
    "howToFix": "",
    "moreInfo": "<ul>\n  <li> <a href=\"https://wiki.sei.cmu.edu/confluence/x/FDdGBQ\">CERT, TSM02-J.</a> - Do not use background threads during class initialization </li>\n</ul>",
    "status": "READY",
    "name_ko": "생성자에서 Thread를 시작하면 안 됩니다",
    "why_ko": "<p>생성자에서 <code>Thread.start()</code>를 호출하는 문제는 클래스가 확장될 경우 혼란스러운 상황이 발생한다는 것입니다. 상위 클래스의 생성자가 하위 클래스가 실제로 초기화되기 전에 스레드를 시작하기 때문입니다.</p>\n<p>이 규칙은 non-<code>final</code> 클래스의 생성자에서 <code>start</code>가 호출될 때마다 문제를 제기합니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\npublic class MyClass {\n\n  Thread thread = null;\n\n  public MyClass(Runnable runnable) {\n    thread = new Thread(runnable);\n    thread.start(); // 규칙 위반\n  }\n}\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": "<ul>\n  <li> <a href=\"https://wiki.sei.cmu.edu/confluence/x/FDdGBQ\">CERT, TSM02-J.</a> - 클래스 초기화 중에 백그라운드 스레드를 사용하지 마십시오 </li>\n</ul>"
  },
  {
    "id": "S3981",
    "key": "java:S3981",
    "name": "Collection sizes and array length comparisons should make sense",
    "type": "bug",
    "severity": "major",
    "tags": [
      "confusing"
    ],
    "why": "<p>The size of a collection and the length of an array are always greater than or equal to zero. Testing it doesn't make sense, since the result is\nalways <code>true</code>.</p>\n<pre>\nif (myList.size() &gt;= 0) {...} // Noncompliant: always true\n\nboolean result = myArray.length &gt;= 0; // Noncompliant: true\n</pre>\n<p>Similarly testing that it is less than zero will always return <code>false</code>.</p>\n<pre>\nif (myList.size() &lt; 0) {...} // Noncompliant: always false\n</pre>\n<p>Fix the code to properly check for emptiness if it was the intent, or remove the redundant code to keep the current behavior.</p>",
    "howToFix": "",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "Collection 크기와 배열 길이 비교는 논리적이어야 합니다",
    "why_ko": "<p>컬렉션의 크기와 배열의 길이는 항상 0보다 크거나 같습니다. 결과가 항상 <code>true</code>이므로 테스트하는 것은 의미가 없습니다.</p>\n<pre>\nif (myList.size() &gt;= 0) {...} // 규칙 위반: 항상 true\n\nboolean result = myArray.length &gt;= 0; // 규칙 위반: true\n</pre>\n<p>마찬가지로 0보다 작은지 테스트하면 항상 <code>false</code>를 반환합니다.</p>\n<pre>\nif (myList.size() &lt; 0) {...} // 규칙 위반: 항상 false\n</pre>\n<p>의도한 바였다면 비어 있는지 올바르게 확인하도록 코드를 수정하거나, 현재 동작을 유지하려면 중복 코드를 제거하세요.</p>",
    "howToFix_ko": "",
    "moreInfo_ko": ""
  },
  {
    "id": "S5855",
    "key": "java:S5855",
    "name": "Regex alternatives should not be redundant",
    "type": "bug",
    "severity": "major",
    "tags": [
      "regex"
    ],
    "why": "<p>If an alternative in a regular expression only matches things that are already matched by another alternative, that alternative is redundant and\nserves no purpose.</p>\n<p>In the best case this means that the offending subpattern is merely redundant and should be removed. In the worst case it's a sign that this regex\ndoes not match what it was intended to match and should be reworked.</p>\n\n<h4>Noncompliant code example</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\n\"[ab]|a\"   // Noncompliant: the \"|a\" is redundant because \"[ab]\" already matches \"a\"\n\".*|a\"     // Noncompliant: .* matches everything, so any other alternative is redundant\n</pre>\n<h4>Compliant solution</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\n\"[ab]\"\n\".*\"\n</pre>",
    "howToFix": "",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "정규식 대안은 중복되면 안 됩니다",
    "why_ko": "<p>정규 표현식의 대안이 이미 다른 대안에 의해 일치되는 것만 일치시키면 해당 대안은 중복되며 아무런 목적도 없습니다.</p>\n<p>가장 좋은 경우 이는 문제의 하위 패턴이 단순히 중복되어 제거해야 함을 의미합니다. 최악의 경우 이 정규식이 의도한 것과 일치하지 않아 재작업해야 함을 나타내는 신호입니다.</p>\n\n<h4>규칙을 준수하지 않는 코드 예시</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\n\"[ab]|a\"   // 규칙 위반: \"[ab]\"가 이미 \"a\"와 일치하므로 \"|a\"는 중복\n\".*|a\"     // 규칙 위반: .*는 모든 것과 일치하므로 다른 대안은 중복\n</pre>\n<h4>규칙을 준수하는 해결책</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\n\"[ab]\"\n\".*\"\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": ""
  },
  {
    "id": "S3578",
    "key": "java:S3578",
    "name": "Test methods should comply with a naming convention",
    "type": "code-smell",
    "severity": "minor",
    "tags": [
      "convention",
      "tests"
    ],
    "why": "<p>Shared naming conventions allow teams to collaborate efficiently. This rule raises an issue when a test method name does not match the provided\nregular expression.</p>\n<h3>Noncompliant code example</h3>\n<p>With the default value: <code>^test[A-Z][a-zA-Z0-9]*$</code></p>\n<pre>\n@Test\npublic void foo() {  // Noncompliant\n  //...\n}\n</pre>\n<h3>Compliant solution</h3>\n<pre>\n@Test\npublic void testFoo() {\n  // ...\n}\n</pre>",
    "howToFix": "",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "테스트 메서드는 명명 규칙을 준수해야 합니다",
    "why_ko": "<p>공유된 명명 규칙을 통해 팀이 효율적으로 협업할 수 있습니다. 이 규칙은 테스트 메서드 이름이 제공된 정규 표현식과 일치하지 않을 때 문제를 제기합니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<p>기본값: <code>^test[A-Z][a-zA-Z0-9]*$</code></p>\n<pre>\n@Test\npublic void foo() {  // 규칙 위반\n  //...\n}\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre>\n@Test\npublic void testFoo() {\n  // ...\n}\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": ""
  },
  {
    "id": "S4602",
    "key": "java:S4602",
    "name": "\"@SpringBootApplication\" and \"@ComponentScan\" should not be used in the default package",
    "type": "bug",
    "severity": "blocker",
    "tags": [
      "spring"
    ],
    "why": "<p><code>@ComponentScan</code> is used to determine which Spring Beans are available in the application context. The packages to scan can be\nconfigured thanks to the <code>basePackageClasses</code> or <code>basePackages</code> (or its alias <code>value</code>) parameters. If neither\nparameter is configured, <code>@ComponentScan</code> will consider only the package of the class annotated with it. When <code>@ComponentScan</code>\nis used on a class belonging to the default package, the entire classpath will be scanned.</p>\n<p>This will slow-down the start-up of the application and it is likely the application will fail to start with an\n<code>BeanDefinitionStoreException</code> because you ended up scanning the Spring Framework package itself.</p>\n<p>This rule raises an issue when:</p>\n<ul>\n  <li> <code>@ComponentScan</code>, <code>@SpringBootApplication</code> and <code>@ServletComponentScan</code> are used on a class belonging to the\n  default package </li>\n  <li> <code>@ComponentScan</code> is explicitly configured with the default package </li>\n</ul>\n<h3>Noncompliant code example</h3>\n<pre>\nimport org.springframework.boot.SpringApplication;\n\n@SpringBootApplication // Noncompliant; RootBootApp is declared in the default package\npublic class RootBootApp {\n...\n}\n</pre>\n<pre>\n@ComponentScan(\"\")\npublic class Application {\n...\n}\n</pre>\n<h3>Compliant solution</h3>\n<pre>\npackage hello;\n\nimport org.springframework.boot.SpringApplication;\n\n@SpringBootApplication // Compliant; RootBootApp belongs to the \"hello\" package\npublic class RootBootApp {\n...\n}\n</pre>",
    "howToFix": "",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "@SpringBootApplication과 @ComponentScan은 기본 패키지에서 사용하면 안 됩니다",
    "why_ko": "<p><code>@ComponentScan</code>은 애플리케이션 컨텍스트에서 사용 가능한 Spring Bean을 결정하는 데 사용됩니다. 스캔할 패키지는 <code>basePackageClasses</code> 또는 <code>basePackages</code>(또는 별칭 <code>value</code>) 매개변수 덕분에 구성할 수 있습니다. 두 매개변수 모두 구성되지 않으면 <code>@ComponentScan</code>은 어노테이션이 달린 클래스의 패키지만 고려합니다. <code>@ComponentScan</code>이 기본 패키지에 속하는 클래스에서 사용되면 전체 클래스패스가 스캔됩니다.</p>\n<p>이로 인해 애플리케이션 시작이 느려지고 Spring Framework 패키지 자체를 스캔하게 되어 <code>BeanDefinitionStoreException</code>과 함께 애플리케이션 시작에 실패할 가능성이 높습니다.</p>\n<p>이 규칙은 다음과 같은 경우 문제를 제기합니다:</p>\n<ul>\n  <li> <code>@ComponentScan</code>, <code>@SpringBootApplication</code> 및 <code>@ServletComponentScan</code>이 기본 패키지에 속하는 클래스에서 사용되는 경우 </li>\n  <li> <code>@ComponentScan</code>이 명시적으로 기본 패키지로 구성된 경우 </li>\n</ul>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\nimport org.springframework.boot.SpringApplication;\n\n@SpringBootApplication // 규칙 위반; RootBootApp이 기본 패키지에 선언됨\npublic class RootBootApp {\n...\n}\n</pre>\n<pre>\n@ComponentScan(\"\")\npublic class Application {\n...\n}\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre>\npackage hello;\n\nimport org.springframework.boot.SpringApplication;\n\n@SpringBootApplication // 규칙 준수; RootBootApp이 \"hello\" 패키지에 속함\npublic class RootBootApp {\n...\n}\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": ""
  },
  {
    "id": "S7184",
    "key": "java:S7184",
    "name": "\"@Scheduled\" annotation should only be applied to no-arg methods",
    "type": "bug",
    "severity": "critical",
    "tags": [
      "spring"
    ],
    "why": "<p>According to Spring documentation, the <code>@Scheduled</code> annotation can only be applied to methods without arguments. Applying @Scheduled to\na method with arguments will result in a runtime error.</p>",
    "howToFix": "<p>Transform method annotated with <code>@Scheduled</code> into a no-arg method.</p>\n\n<h4>Noncompliant code example</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\npublic class ExampleService {\n\n    @Scheduled(fixedRate = 5000)\n    public void scheduledTask(String param) { // non compliant, method has an argument. It will raise a runtime error.\n        // Task implementation\n    }\n}\n</pre>\n<h4>Compliant solution</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\npublic class ExampleService {\n\n    @Scheduled(fixedRate = 5000)\n    public void scheduledTask() { // compliant, no-arg method\n        // Task implementation\n    }\n}\n</pre>",
    "moreInfo": "<h3>Documentation</h3>\n<ul>\n  <li> Spring - <a\n  href=\"https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/scheduling/annotation/Scheduled.html\">scheduled</a> </li>\n</ul>",
    "status": "READY",
    "name_ko": "\"@Scheduled\" 어노테이션은 매개변수가 없는 메서드에만 적용해야 합니다",
    "why_ko": "<p>Spring 문서에 따르면 <code>@Scheduled</code> 어노테이션은 인수가 없는 메서드에만 적용할 수 있습니다. 인수가 있는 메서드에 @Scheduled를 적용하면 런타임 오류가 발생합니다.</p>",
    "howToFix_ko": "<p><code>@Scheduled</code>로 어노테이션된 메서드를 인수가 없는 메서드로 변환하세요.</p>\n\n<h4>규칙을 준수하지 않는 코드 예시</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\npublic class ExampleService {\n\n    @Scheduled(fixedRate = 5000)\n    public void scheduledTask(String param) { // 규칙 위반, 메서드에 인수가 있습니다. 런타임 오류가 발생합니다.\n        // 작업 구현\n    }\n}\n</pre>\n<h4>규칙을 준수하는 해결책</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\npublic class ExampleService {\n\n    @Scheduled(fixedRate = 5000)\n    public void scheduledTask() { // 규칙 준수, 인수가 없는 메서드\n        // 작업 구현\n    }\n}\n</pre>",
    "moreInfo_ko": "<h3>문서</h3>\n<ul>\n  <li> Spring - <a href=\"https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/scheduling/annotation/Scheduled.html\">Scheduled</a> </li>\n</ul>"
  },
  {
    "id": "S5443",
    "key": "java:S5443",
    "name": "Using publicly writable directories is security-sensitive",
    "type": "security-hotspot",
    "severity": "critical",
    "tags": [
      "cwe"
    ],
    "why": "<p>Operating systems have global directories where any user has write access. Those folders are mostly used as temporary storage areas like\n<code>/tmp</code> in Linux based systems. An application manipulating files from these folders is exposed to race conditions on filenames: a malicious\nuser can try to create a file with a predictable name before the application does. A successful attack can result in other files being accessed,\nmodified, corrupted or deleted. This risk is even higher if the application runs with elevated permissions.</p>\n<p>In the past, it has led to the following vulnerabilities:</p>\n<ul>\n  <li> <a href=\"https://nvd.nist.gov/vuln/detail/CVE-2012-2451\">CVE-2012-2451</a> </li>\n  <li> <a href=\"https://nvd.nist.gov/vuln/detail/CVE-2015-1838\">CVE-2015-1838</a> </li>\n</ul>\n<p>This rule raises an issue whenever it detects a hard-coded path to a publicly writable directory like <code>/tmp</code> (see examples below). It\nalso detects access to environment variables that point to publicly writable directories, e.g., <code>TMP</code> and <code>TMPDIR</code>.</p>\n<ul>\n  <li> <code>/tmp</code> </li>\n  <li> <code>/var/tmp</code> </li>\n  <li> <code>/usr/tmp</code> </li>\n  <li> <code>/dev/shm</code> </li>\n  <li> <code>/dev/mqueue</code> </li>\n  <li> <code>/run/lock</code> </li>\n  <li> <code>/var/run/lock</code> </li>\n  <li> <code>/Library/Caches</code> </li>\n  <li> <code>/Users/Shared</code> </li>\n  <li> <code>/private/tmp</code> </li>\n  <li> <code>/private/var/tmp</code> </li>\n  <li> <code>\\Windows\\Temp</code> </li>\n  <li> <code>\\Temp</code> </li>\n  <li> <code>\\TMP</code> </li>\n</ul>\n",
    "howToFix": "<h2>Recommended Secure Coding Practices</h2>\n<ul>\n  <li> Use a dedicated sub-folder with tightly controlled permissions </li>\n  <li> Use secure-by-design APIs to create temporary files. Such API will make sure:\n    <ul>\n      <li> The generated filename is unpredictable </li>\n      <li> The file is readable and writable only by the creating user ID </li>\n      <li> The file descriptor is not inherited by child processes </li>\n      <li> The file will be destroyed as soon as it is closed </li>\n    </ul>  </li>\n</ul>\n<h2>Compliant Solution</h2>\n<pre>\nnew File(\"/myDirectory/myfile.txt\");  // Compliant\n\nFile.createTempFile(\"prefix\", \"suffix\", new File(\"/mySecureDirectory\"));  // Compliant\n\nif(SystemUtils.IS_OS_UNIX) {\n  FileAttribute<Set<PosixFilePermission>> attr = PosixFilePermissions.asFileAttribute(PosixFilePermissions.fromString(\"rwx------\"));\n  Files.createTempFile(\"prefix\", \"suffix\", attr); // Compliant\n}\nelse {\n  File f = Files.createTempFile(\"prefix\", \"suffix\").toFile();  // Compliant\n  f.setReadable(true, true);\n  f.setWritable(true, true);\n  f.setExecutable(true, true);\n}\n</pre>\n<h2>See</h2>\n<ul>\n  <li> OWASP - <a href=\"https://owasp.org/Top10/A01_2021-Broken_Access_Control/\">Top 10 2021 Category A1 - Broken Access Control</a> </li>\n  <li> OWASP - <a href=\"https://owasp.org/www-project-top-ten/2017/A5_2017-Broken_Access_Control\">Top 10 2017 Category A5 - Broken Access Control</a>\n  </li>\n  <li> OWASP - <a href=\"https://owasp.org/www-project-top-ten/2017/A3_2017-Sensitive_Data_Exposure\">Top 10 2017 Category A3 - Sensitive Data\n  Exposure</a> </li>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/377\">CWE-377 - Insecure Temporary File</a> </li>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/379\">CWE-379 - Creation of Temporary File in Directory with Incorrect Permissions</a>\n  </li>\n  <li> <a href=\"https://owasp.org/www-community/vulnerabilities/Insecure_Temporary_File\">OWASP, Insecure Temporary File</a> </li>\n  <li> STIG Viewer - <a href=\"https://stigviewer.com/stigs/application_security_and_development/2024-12-06/finding/V-222567\">Application Security and\n  Development: V-222567</a> - The application must not be vulnerable to race conditions. </li>\n</ul>",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "공개 쓰기 가능한 디렉토리 사용은 보안에 민감합니다",
    "why_ko": "<p>운영 체제에는 모든 사용자가 쓰기 권한을 가진 전역 디렉토리가 있습니다. 이러한 폴더는 Linux 기반 시스템의 <code>/tmp</code>처럼 주로 임시 저장 영역으로 사용됩니다. 이러한 폴더에서 파일을 조작하는 애플리케이션은 파일 이름에 대한 경쟁 조건에 노출됩니다: 악의적인 사용자가 애플리케이션보다 먼저 예측 가능한 이름으로 파일을 생성하려 할 수 있습니다. 성공적인 공격은 다른 파일에 접근하거나 수정, 손상 또는 삭제될 수 있습니다. 애플리케이션이 상승된 권한으로 실행되는 경우 이 위험은 더욱 높아집니다.</p>\n<p>과거에 다음과 같은 취약점이 발생했습니다:</p>\n<ul>\n  <li> <a href=\"https://nvd.nist.gov/vuln/detail/CVE-2012-2451\">CVE-2012-2451</a> </li>\n  <li> <a href=\"https://nvd.nist.gov/vuln/detail/CVE-2015-1838\">CVE-2015-1838</a> </li>\n</ul>\n<p>이 규칙은 <code>/tmp</code>와 같은 공개 쓰기 가능한 디렉토리에 대한 하드코딩된 경로를 감지할 때마다 문제를 제기합니다(아래 예시 참조). 또한 <code>TMP</code> 및 <code>TMPDIR</code>과 같이 공개 쓰기 가능한 디렉토리를 가리키는 환경 변수에 대한 접근도 감지합니다.</p>\n<ul>\n  <li> <code>/tmp</code> </li>\n  <li> <code>/var/tmp</code> </li>\n  <li> <code>/usr/tmp</code> </li>\n  <li> <code>/dev/shm</code> </li>\n  <li> <code>/dev/mqueue</code> </li>\n  <li> <code>/run/lock</code> </li>\n  <li> <code>/var/run/lock</code> </li>\n  <li> <code>/Library/Caches</code> </li>\n  <li> <code>/Users/Shared</code> </li>\n  <li> <code>/private/tmp</code> </li>\n  <li> <code>/private/var/tmp</code> </li>\n  <li> <code>\\Windows\\Temp</code> </li>\n  <li> <code>\\Temp</code> </li>\n  <li> <code>\\TMP</code> </li>\n</ul>\n",
    "howToFix_ko": "<h2>권장 보안 코딩 관행</h2>\n<ul>\n  <li> 엄격하게 제어되는 권한을 가진 전용 하위 폴더를 사용하세요 </li>\n  <li> 임시 파일을 생성하기 위해 설계상 안전한 API를 사용하세요. 이러한 API는 다음을 보장합니다:\n    <ul>\n      <li> 생성된 파일 이름이 예측 불가능함 </li>\n      <li> 파일을 생성한 사용자 ID만 읽고 쓸 수 있음 </li>\n      <li> 파일 디스크립터가 자식 프로세스에 상속되지 않음 </li>\n      <li> 파일이 닫히자마자 파괴됨 </li>\n    </ul>  </li>\n</ul>\n<h2>규칙을 준수하는 해결책</h2>\n<pre>\nnew File(\"/myDirectory/myfile.txt\");  // 규칙 준수\n\nFile.createTempFile(\"prefix\", \"suffix\", new File(\"/mySecureDirectory\"));  // 규칙 준수\n\nif(SystemUtils.IS_OS_UNIX) {\n  FileAttribute<Set<PosixFilePermission>> attr = PosixFilePermissions.asFileAttribute(PosixFilePermissions.fromString(\"rwx------\"));\n  Files.createTempFile(\"prefix\", \"suffix\", attr); // 규칙 준수\n}\nelse {\n  File f = Files.createTempFile(\"prefix\", \"suffix\").toFile();  // 규칙 준수\n  f.setReadable(true, true);\n  f.setWritable(true, true);\n  f.setExecutable(true, true);\n}\n</pre>\n<h2>참고</h2>\n<ul>\n  <li> OWASP - <a href=\"https://owasp.org/Top10/A01_2021-Broken_Access_Control/\">Top 10 2021 Category A1 - Broken Access Control</a> </li>\n  <li> OWASP - <a href=\"https://owasp.org/www-project-top-ten/2017/A5_2017-Broken_Access_Control\">Top 10 2017 Category A5 - Broken Access Control</a> </li>\n  <li> OWASP - <a href=\"https://owasp.org/www-project-top-ten/2017/A3_2017-Sensitive_Data_Exposure\">Top 10 2017 Category A3 - Sensitive Data Exposure</a> </li>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/377\">CWE-377 - 안전하지 않은 임시 파일</a> </li>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/379\">CWE-379 - 잘못된 권한을 가진 디렉토리에서 임시 파일 생성</a> </li>\n  <li> <a href=\"https://owasp.org/www-community/vulnerabilities/Insecure_Temporary_File\">OWASP, 안전하지 않은 임시 파일</a> </li>\n  <li> STIG Viewer - <a href=\"https://stigviewer.com/stigs/application_security_and_development/2024-12-06/finding/V-222567\">Application Security and Development: V-222567</a> - 애플리케이션은 경쟁 조건에 취약하지 않아야 합니다. </li>\n</ul>",
    "moreInfo_ko": ""
  },
  {
    "id": "S2386",
    "key": "java:S2386",
    "name": "Mutable fields should not be \"public static\"",
    "type": "code-smell",
    "severity": "minor",
    "tags": [
      "cwe",
      "unpredictable",
      "cert"
    ],
    "why": "<p>There is no good reason to have a mutable object as the <code>public</code> (by default), <code>static</code> member of an <code>interface</code>.\nSuch variables should be moved into classes and their visibility lowered.</p>\n<p>Similarly, mutable <code>static</code> members of classes and enumerations which are accessed directly, rather than through getters and setters,\nshould be protected to the degree possible. That can be done by reducing visibility or making the field <code>final</code> if appropriate.</p>\n<p>Note that making a mutable field, such as an array, <code>final</code> will keep the variable from being reassigned, but doing so has no effect on\nthe mutability of the internal state of the array (i.e. it doesn't accomplish the goal).</p>\n<p>This rule raises issues for <code>public static</code> array, <code>Collection</code>, <code>Date</code>, and <code>awt.Point</code> members.</p>\n<h3>Noncompliant code example</h3>\n<pre>\npublic interface MyInterface {\n  public static String [] strings; // Noncompliant\n}\n\npublic class A {\n  public static String [] strings1 = {\"first\",\"second\"};  // Noncompliant\n  public static String [] strings2 = {\"first\",\"second\"};  // Noncompliant\n  public static List&lt;String&gt; strings3 = new ArrayList&lt;&gt;();  // Noncompliant\n  // ...\n}\n</pre>",
    "howToFix": "",
    "moreInfo": "<ul>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/582\">CWE-582 - Array Declared Public, Final, and Static</a> </li>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/607\">CWE-607 - Public Static Final Field References Mutable Object</a> </li>\n  <li> <a href=\"https://wiki.sei.cmu.edu/confluence/x/LjdGBQ\">CERT, OBJ01-J.</a> - Limit accessibility of fields </li>\n  <li> <a href=\"https://wiki.sei.cmu.edu/confluence/x/VzZGBQ\">CERT, OBJ13-J.</a> - Ensure that references to mutable objects are not exposed </li>\n</ul>",
    "status": "READY",
    "name_ko": "가변 필드는 \"public static\"이면 안 됩니다",
    "why_ko": "<p><code>interface</code>의 <code>public</code>(기본값), <code>static</code> 멤버로 가변 객체를 갖는 좋은 이유가 없습니다. 이러한 변수는 클래스로 이동하고 가시성을 낮춰야 합니다.</p>\n<p>마찬가지로 getter와 setter를 통하지 않고 직접 접근하는 클래스와 열거형의 가변 <code>static</code> 멤버는 가능한 한 보호해야 합니다. 이는 가시성을 줄이거나 적절한 경우 필드를 <code>final</code>로 만들어 수행할 수 있습니다.</p>\n<p>배열과 같은 가변 필드를 <code>final</code>로 만들면 변수가 재할당되는 것을 방지하지만 배열의 내부 상태의 가변성에는 영향을 미치지 않습니다(즉, 목표를 달성하지 못합니다).</p>\n<p>이 규칙은 <code>public static</code> 배열, <code>Collection</code>, <code>Date</code> 및 <code>awt.Point</code> 멤버에 대해 이슈를 발생시킵니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\npublic interface MyInterface {\n  public static String [] strings; // 규칙 위반\n}\n\npublic class A {\n  public static String [] strings1 = {\"first\",\"second\"};  // 규칙 위반\n  public static String [] strings2 = {\"first\",\"second\"};  // 규칙 위반\n  public static List&lt;String&gt; strings3 = new ArrayList&lt;&gt;();  // 규칙 위반\n  // ...\n}\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": "<ul>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/582\">CWE-582 - Public, Final, Static으로 선언된 배열</a> </li>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/607\">CWE-607 - Public Static Final 필드가 가변 객체를 참조</a> </li>\n  <li> <a href=\"https://wiki.sei.cmu.edu/confluence/x/LjdGBQ\">CERT, OBJ01-J.</a> - 필드의 접근성을 제한하세요 </li>\n  <li> <a href=\"https://wiki.sei.cmu.edu/confluence/x/VzZGBQ\">CERT, OBJ13-J.</a> - 가변 객체에 대한 참조가 노출되지 않도록 하세요 </li>\n</ul>"
  },
  {
    "id": "S113",
    "key": "java:S113",
    "name": "Files should end with a newline",
    "type": "code-smell",
    "severity": "minor",
    "tags": [
      "convention"
    ],
    "why": "<p>Some tools work better when files end with a newline.</p>\n<p>This rule simply generates an issue if it is missing.</p>\n<p>For example, a Git diff looks like this if the empty line is missing at the end of the file:</p>\n<pre>\n+class Test {\n+}\n\\ No newline at end of file\n</pre>",
    "howToFix": "",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "파일은 개행 문자로 끝나야 합니다",
    "why_ko": "<p>일부 도구는 파일이 개행 문자로 끝날 때 더 잘 작동합니다.</p>\n<p>이 규칙은 개행 문자가 없는 경우 단순히 이슈를 생성합니다.</p>\n<p>예를 들어 파일 끝에 빈 줄이 없으면 Git diff가 다음과 같이 보입니다:</p>\n<pre>\n+class Test {\n+}\n\\ No newline at end of file\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": ""
  },
  {
    "id": "S6541",
    "key": "java:S6541",
    "name": "Methods should not perform too many tasks (aka Brain method)",
    "type": "code-smell",
    "severity": "info",
    "tags": [
      "design"
    ],
    "why": "<p>This issue is raised when Sonar considers that a method is a 'Brain Method'. <br> A Brain Method is a method that tends to centralize its owner's\nclass logic and generally performs too many operations. This can include checking too many conditions, using lots of variables, and ultimately making\nit difficult to understand, maintain and reuse.<br> It is characterized by high LOC number, high cyclomatic and cognitive complexity, and a large\nnumber of variables being used.</p>\n<h3>What is the potential impact?</h3>\n<p>Brain Methods are often hard to cover with tests, because of their deep nesting, and they are error-prone, because of the many local variables they\nusually introduce. Such methods will be very hard to read and understand for anyone outside who created them, and therefore hard to maintain and fix\nif bugs get spotted.<br> They also enable code duplication since the method itself can hardly be reused anywhere else.</p>",
    "howToFix": "<p>The common approach is to identify fragments of the method's code that deal with a specific responsibility and extract them to a new method. This\nwill make each method more readable, easy to understand and maintain, easier to test, and more prone to be reused.<br> In this paper, the authors\ndescribe a systematic procedure to refactor this type of code smell: <a href=\"https://dl.acm.org/doi/10.1145/3191314\">\"Assessing the Refactoring of\nBrain Methods\"</a>.</p>\n\n<h4>Noncompliant code example</h4>\n<pre>\nvoid farmDailyRoutine() {\n    Crops southEastCrops = getCrops(1, -1);\n    Crops eastCrops = getCrops(1, 0);\n    WaterContainer waterContainer = new WaterContainer();\n    List&lt;Bottle&gt; bottles = new ArrayList&lt;&gt;();\n    for(int i = 0; i &lt; 10; i++) {\n        var bottle = new Bottle();\n        bottle.addWater(10L);\n        bottle.putCap();\n        bottle.shake(2);\n        bottles.add(bottle);\n    }\n    waterContainer.store(bottles);\n\n    Truck t1 = new Truck(Truck.Type.TRANSPORT);\n    t1.load(waterContainer);\n    if(Weather.current != Weather.RAINY) {\n        WaterContainer extraWaterContainer = new WaterContainer();\n        List&lt;Bottle&gt; extraBottles = new ArrayList&lt;&gt;();\n        if(southEastCrops.isDry()) {\n            for(LandSlot ls : southEastCrops.lands()) {\n                Bottle b = new Bottle();\n                b.addWater(10L);\n                b.putCap();\n                extraBottles.add(b);\n            }\n        } else {\n            extraBottles.add(new Bottle());\n        }\n        if(eastCrops.isDry()) {\n            for(LandSlot ls : southEastCrops.lands()) {\n                Bottle b = new Bottle();\n                b.addWater(10L);\n                b.putCap();\n                extraBottles.add(b);\n            }\n        } else {\n            extraBottles.add(new Bottle());\n        }\n        extraWaterContainer.store(extraBottles);\n        t1.load(extraWaterContainer);\n    } else {\n        WaterContainer extraWaterContainer = WaterSource.clone(waterContainer);\n        t1.load(extraWaterContainer)\n    }\n}\n</pre>\n<h4>Compliant solution</h4>\n<pre>\nvoid farmDailyRoutine() { // Compliant: Simpler method, making use of extracted and distributed logic\n    Crops southEastCrops = getCrops(1, -1);\n    Crops eastCrops = getCrops(1, 0);\n    WaterContainer waterContainer = new WaterContainer();\n    List&lt;Bottle&gt; bottles = getWaterBottles(10, 10L, true);\n    waterContainer.store(bottles);\n\n    Truck t1 = new Truck(Truck.Type.TRANSPORT);\n    t1.load(waterContainer);\n    if(Weather.current != Weather.RAINY) {\n        WaterContainer extraWaterContainer = new WaterContainer();\n        fillContainerForCrops(extraWaterContainer, southEastCrops);\n        fillContainerForCrops(extraWaterContainer, eastCrops);\n        t1.load(extraWaterContainer);\n    } else {\n        WaterContainer extraWaterContainer = WaterSource.clone(waterContainer);\n        t1.load(extraWaterContainer)\n    }\n}\n\nprivate fillContainerForCrops(WaterContainer wc, Crops crops) { // Compliant: extracted readable and reusable method\n    if(crops.isDry()) {\n        wc.store(getWaterBottles(crops.lands().size(), 10L, false));\n    } else {\n        wc.store(Collections.singleton(new Bottle()));\n    }\n}\n\nprivate List&lt;Bottle&gt; getWaterBottles(int qt, long liquid, boolean shake){ // Compliant: extracted readable and reusable method\n    List&lt;Bottle&gt; bottles = new ArrayList&lt;&gt;();\n    for(int i = 0; i &lt; qt; i++) {\n        Bottle b = new Bottle();\n        b.addWater(liquid);\n        b.putCap();\n        if(shake) {\n            b.shake();\n        }\n        bottles.add(b);\n    }\n    return bottles;\n}\n</pre>\n<h3>How does this work?</h3>\n<p>In this case, the method <code>farmDailyRoutine</code> was taking care of performing many different tasks, with nested conditions and loops, it was\nlong and had plenty of local variables. By separating its logic into multiple single-responsibility methods, it is reusing parts of its original\nduplicated code and each of the new methods is now readable and easy to understand. They are now also easier to cover with tests, and many other parts\nof the owner class could benefit from using these methods.</p>",
    "moreInfo": "<h3>Articles &amp; blog posts</h3>\n<ul>\n  <li> <a href=\"https://link.springer.com/book/10.1007/3-540-39538-5\">\"Object-Oriented Metrics in Practice: Using Software Metrics to Characterize,\n  Evaluate, and Improve the Design of Object-Oriented Systems\"</a> by M. Lanza, R. Marinescu <br> </li>\n  <li> <a href=\"https://dl.acm.org/doi/10.1145/3191314\">\"Assessing the Refactoring of Brain Methods\"</a> by S. Vidal, I. Berra, S. Zulliani, C.\n  Marcos, J. A. Diaz Pace <br> </li>\n</ul>",
    "status": "BETA",
    "name_ko": "메서드는 너무 많은 작업을 수행하면 안 됩니다 (일명 Brain method)",
    "why_ko": "<p>이 문제는 Sonar가 메서드를 'Brain Method'로 간주할 때 발생합니다. <br> Brain Method는 소유 클래스의 로직을 중앙 집중화하는 경향이 있고 일반적으로 너무 많은 작업을 수행하는 메서드입니다. 여기에는 너무 많은 조건 확인, 많은 변수 사용, 궁극적으로 이해, 유지 관리 및 재사용을 어렵게 만드는 것이 포함될 수 있습니다.<br> 높은 LOC 수, 높은 순환 및 인지 복잡성, 그리고 사용되는 많은 변수 수로 특징지어집니다.</p>\n<h3>잠재적 영향은 무엇인가요?</h3>\n<p>Brain Method는 깊은 중첩으로 인해 테스트로 커버하기 어려운 경우가 많고, 일반적으로 도입하는 많은 지역 변수로 인해 오류가 발생하기 쉽습니다. 이러한 메서드는 생성한 사람 외에는 읽고 이해하기 매우 어려우므로 버그가 발견되면 유지 관리하고 수정하기 어렵습니다.<br> 또한 메서드 자체를 다른 곳에서 거의 재사용할 수 없으므로 코드 중복이 가능해집니다.</p>",
    "howToFix_ko": "<p>일반적인 접근 방식은 특정 책임을 다루는 메서드 코드의 조각을 식별하고 새 메서드로 추출하는 것입니다. 이렇게 하면 각 메서드가 더 읽기 쉽고, 이해 및 유지 관리하기 쉬우며, 테스트하기 쉽고, 재사용되기 더 쉽습니다.<br> 이 논문에서 저자들은 이러한 유형의 코드 스멜을 리팩토링하는 체계적인 절차를 설명합니다: <a href=\"https://dl.acm.org/doi/10.1145/3191314\">\"Brain Method 리팩토링 평가\"</a>.</p>\n\n<h4>규칙을 준수하지 않는 코드 예시</h4>\n<pre>\nvoid farmDailyRoutine() {\n    Crops southEastCrops = getCrops(1, -1);\n    Crops eastCrops = getCrops(1, 0);\n    WaterContainer waterContainer = new WaterContainer();\n    List&lt;Bottle&gt; bottles = new ArrayList&lt;&gt;();\n    for(int i = 0; i &lt; 10; i++) {\n        var bottle = new Bottle();\n        bottle.addWater(10L);\n        bottle.putCap();\n        bottle.shake(2);\n        bottles.add(bottle);\n    }\n    waterContainer.store(bottles);\n\n    Truck t1 = new Truck(Truck.Type.TRANSPORT);\n    t1.load(waterContainer);\n    if(Weather.current != Weather.RAINY) {\n        WaterContainer extraWaterContainer = new WaterContainer();\n        List&lt;Bottle&gt; extraBottles = new ArrayList&lt;&gt;();\n        if(southEastCrops.isDry()) {\n            for(LandSlot ls : southEastCrops.lands()) {\n                Bottle b = new Bottle();\n                b.addWater(10L);\n                b.putCap();\n                extraBottles.add(b);\n            }\n        } else {\n            extraBottles.add(new Bottle());\n        }\n        if(eastCrops.isDry()) {\n            for(LandSlot ls : southEastCrops.lands()) {\n                Bottle b = new Bottle();\n                b.addWater(10L);\n                b.putCap();\n                extraBottles.add(b);\n            }\n        } else {\n            extraBottles.add(new Bottle());\n        }\n        extraWaterContainer.store(extraBottles);\n        t1.load(extraWaterContainer);\n    } else {\n        WaterContainer extraWaterContainer = WaterSource.clone(waterContainer);\n        t1.load(extraWaterContainer)\n    }\n}\n</pre>\n<h4>규칙을 준수하는 해결책</h4>\n<pre>\nvoid farmDailyRoutine() { // 규칙 준수: 추출되고 분산된 로직을 사용하는 더 간단한 메서드\n    Crops southEastCrops = getCrops(1, -1);\n    Crops eastCrops = getCrops(1, 0);\n    WaterContainer waterContainer = new WaterContainer();\n    List&lt;Bottle&gt; bottles = getWaterBottles(10, 10L, true);\n    waterContainer.store(bottles);\n\n    Truck t1 = new Truck(Truck.Type.TRANSPORT);\n    t1.load(waterContainer);\n    if(Weather.current != Weather.RAINY) {\n        WaterContainer extraWaterContainer = new WaterContainer();\n        fillContainerForCrops(extraWaterContainer, southEastCrops);\n        fillContainerForCrops(extraWaterContainer, eastCrops);\n        t1.load(extraWaterContainer);\n    } else {\n        WaterContainer extraWaterContainer = WaterSource.clone(waterContainer);\n        t1.load(extraWaterContainer)\n    }\n}\n\nprivate fillContainerForCrops(WaterContainer wc, Crops crops) { // 규칙 준수: 추출된 읽기 쉽고 재사용 가능한 메서드\n    if(crops.isDry()) {\n        wc.store(getWaterBottles(crops.lands().size(), 10L, false));\n    } else {\n        wc.store(Collections.singleton(new Bottle()));\n    }\n}\n\nprivate List&lt;Bottle&gt; getWaterBottles(int qt, long liquid, boolean shake){ // 규칙 준수: 추출된 읽기 쉽고 재사용 가능한 메서드\n    List&lt;Bottle&gt; bottles = new ArrayList&lt;&gt;();\n    for(int i = 0; i &lt; qt; i++) {\n        Bottle b = new Bottle();\n        b.addWater(liquid);\n        b.putCap();\n        if(shake) {\n            b.shake();\n        }\n        bottles.add(b);\n    }\n    return bottles;\n}\n</pre>\n<h3>작동 방식</h3>\n<p>이 경우 <code>farmDailyRoutine</code> 메서드는 중첩된 조건과 루프로 많은 다른 작업을 수행하고 있었으며, 길었고 많은 지역 변수가 있었습니다. 로직을 여러 단일 책임 메서드로 분리함으로써 원래 중복된 코드의 일부를 재사용하고 있으며 각각의 새 메서드는 이제 읽기 쉽고 이해하기 쉽습니다. 또한 테스트로 커버하기 더 쉬워졌으며 소유 클래스의 다른 많은 부분이 이러한 메서드를 사용하여 이점을 얻을 수 있습니다.</p>",
    "moreInfo_ko": "<h3>기사 및 블로그 게시물</h3>\n<ul>\n  <li> <a href=\"https://link.springer.com/book/10.1007/3-540-39538-5\">\"Object-Oriented Metrics in Practice: 객체 지향 시스템의 설계를 특성화, 평가 및 개선하기 위한 소프트웨어 메트릭 사용\"</a> M. Lanza, R. Marinescu 저 <br> </li>\n  <li> <a href=\"https://dl.acm.org/doi/10.1145/3191314\">\"Brain Method 리팩토링 평가\"</a> S. Vidal, I. Berra, S. Zulliani, C. Marcos, J. A. Diaz Pace 저 <br> </li>\n</ul>"
  },
  {
    "id": "S2447",
    "key": "java:S2447",
    "name": "\"null\" should not be returned from a \"Boolean\" method",
    "type": "code-smell",
    "severity": "critical",
    "tags": [
      "cwe",
      "cert",
      "pitfall"
    ],
    "why": "<p>Callers of a <code>Boolean</code> method may be expecting to receive <code>true</code> or <code>false</code> in response. But <code>Boolean</code>\nobjects can take <code>null</code> as a possible value. <code>Boolean</code> methods should not return <code>null</code> unless the code is annotated\nappropriately. With the proper annotation, the caller is aware that the returned value could be null.</p>\n<h3>Noncompliant code example</h3>\n<pre>\npublic Boolean isUsable() {\n  // ...\n  return null;  // Noncompliant\n}\n\npublic void caller() {\n  if (isUsable()) { // A NullPointerException might occur here\n    // ...\n  }\n}\n</pre>\n<h3>Compliant solution</h3>\n<pre>\n@javax.annotation.Nullable\npublic Boolean isUsable() {\n  // ...\n  return null;\n}\n\n@javax.annotation.CheckForNull\npublic Boolean isUsable() {\n  // ...\n  return null;\n}\n\npublic void caller() {\n  if (Boolean.True.equals(isUsable())) { // This caller knows to check and avoid ambiguity\n    // ...\n  }\n}\n</pre>",
    "howToFix": "",
    "moreInfo": "<ul>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/476\">CWE-476 - NULL Pointer Dereference</a> </li>\n  <li> <a href=\"https://wiki.sei.cmu.edu/confluence/x/aDdGBQ\">CERT, EXP01-J.</a> - Do not use a null in a case where an object is required </li>\n</ul>",
    "status": "READY",
    "name_ko": "\"Boolean\" 메서드에서 \"null\"을 반환하면 안 됩니다",
    "why_ko": "<p><code>Boolean</code> 메서드의 호출자는 응답으로 <code>true</code> 또는 <code>false</code>를 받을 것으로 기대할 수 있습니다. 그러나 <code>Boolean</code> 객체는 가능한 값으로 <code>null</code>을 가질 수 있습니다. <code>Boolean</code> 메서드는 코드에 적절한 어노테이션이 없으면 <code>null</code>을 반환해서는 안 됩니다. 적절한 어노테이션이 있으면 호출자는 반환 값이 null일 수 있음을 알게 됩니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\npublic Boolean isUsable() {\n  // ...\n  return null;  // 규칙 위반\n}\n\npublic void caller() {\n  if (isUsable()) { // 여기서 NullPointerException이 발생할 수 있음\n    // ...\n  }\n}\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre>\n@javax.annotation.Nullable\npublic Boolean isUsable() {\n  // ...\n  return null;\n}\n\n@javax.annotation.CheckForNull\npublic Boolean isUsable() {\n  // ...\n  return null;\n}\n\npublic void caller() {\n  if (Boolean.True.equals(isUsable())) { // 이 호출자는 모호성을 확인하고 피하는 방법을 알고 있음\n    // ...\n  }\n}\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": "<ul>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/476\">CWE-476 - NULL 포인터 역참조</a> </li>\n  <li> <a href=\"https://wiki.sei.cmu.edu/confluence/x/aDdGBQ\">CERT, EXP01-J.</a> - 객체가 필요한 경우 null을 사용하지 마십시오 </li>\n</ul>"
  },
  {
    "id": "S1142",
    "key": "java:S1142",
    "name": "Methods should not have too many return statements",
    "type": "code-smell",
    "severity": "major",
    "tags": [
      "brain-overload"
    ],
    "why": "<p>Having too many return statements in a method increases the method's essential complexity because the flow of execution is broken each time a\nreturn statement is encountered. This makes it harder to read and understand the logic of the method.</p>\n<h3>Noncompliant code example</h3>\n<p>With the default threshold of 3:</p>\n<pre>\npublic boolean myMethod() { // Noncompliant; there are 4 return statements\n  if (condition1) {\n    return true;\n  } else {\n    if (condition2) {\n      return false;\n    } else {\n      return true;\n    }\n  }\n  return false;\n}\n</pre>",
    "howToFix": "",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "메서드는 너무 많은 return 문을 가지면 안 됩니다",
    "why_ko": "<p>메서드에 너무 많은 return 문이 있으면 return 문을 만날 때마다 실행 흐름이 끊기기 때문에 메서드의 본질적인 복잡성이 증가합니다. 이로 인해 메서드의 로직을 읽고 이해하기가 더 어려워집니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<p>기본 임계값 3을 사용할 경우:</p>\n<pre>\npublic boolean myMethod() { // 규칙 위반; return 문이 4개 있음\n  if (condition1) {\n    return true;\n  } else {\n    if (condition2) {\n      return false;\n    } else {\n      return true;\n    }\n  }\n  return false;\n}\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": ""
  },
  {
    "id": "S1135",
    "key": "java:S1135",
    "name": "Track uses of \"TODO\" tags",
    "type": "code-smell",
    "severity": "info",
    "tags": [
      "cwe"
    ],
    "why": "<p>Developers often use <code>TODO</code> tags to mark areas in the code where additional work or improvements are needed but are not implemented\nimmediately. However, these <code>TODO</code> tags sometimes get overlooked or forgotten, leading to incomplete or unfinished code. This rule aims to\nidentify and address unattended <code>TODO</code> tags to ensure a clean and maintainable codebase. This description explores why this is a problem\nand how it can be fixed to improve the overall code quality.</p>\n<h3>What is the potential impact?</h3>\n<p>Unattended <code>TODO</code> tags in code can have significant implications for the development process and the overall codebase.</p>\n<p>Incomplete Functionality: When developers leave <code>TODO</code> tags without implementing the corresponding code, it results in incomplete\nfunctionality within the software. This can lead to unexpected behavior or missing features, adversely affecting the end-user experience.</p>\n<p>Missed Bug Fixes: If developers do not promptly address <code>TODO</code> tags, they might overlook critical bug fixes and security updates.\nDelayed bug fixes can result in more severe issues and increase the effort required to resolve them later.</p>\n<p>Impact on Collaboration: In team-based development environments, unattended <code>TODO</code> tags can hinder collaboration. Other team members\nmight not be aware of the intended changes, leading to conflicts or redundant efforts in the codebase.</p>\n<p>Codebase Bloat: The accumulation of unattended <code>TODO</code> tags over time can clutter the codebase and make it difficult to distinguish\nbetween work in progress and completed code. This bloat can make it challenging to maintain an organized and efficient codebase.</p>\n<p>Addressing this code smell is essential to ensure a maintainable, readable, reliable codebase and promote effective collaboration among\ndevelopers.</p>\n<h3>Noncompliant code example</h3>\n<pre>\nvoid doSomething() {\n  // TODO\n}\n</pre>",
    "howToFix": "",
    "moreInfo": "<ul>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/546\">CWE-546 - Suspicious Comment</a> </li>\n</ul>",
    "status": "READY",
    "name_ko": "\"TODO\" 태그 사용을 추적합니다",
    "why_ko": "<p>개발자들은 추가 작업이나 개선이 필요하지만 즉시 구현되지 않은 코드 영역을 표시하기 위해 <code>TODO</code> 태그를 자주 사용합니다. 그러나 이러한 <code>TODO</code> 태그는 때때로 간과되거나 잊혀져 불완전하거나 미완성된 코드로 이어질 수 있습니다. 이 규칙은 방치된 <code>TODO</code> 태그를 식별하고 처리하여 깨끗하고 유지보수 가능한 코드베이스를 보장하는 것을 목표로 합니다. 이 설명은 왜 이것이 문제인지와 전반적인 코드 품질을 개선하기 위해 어떻게 수정할 수 있는지를 설명합니다.</p>\n<h3>잠재적인 영향은 무엇인가요?</h3>\n<p>코드에서 방치된 <code>TODO</code> 태그는 개발 프로세스와 전체 코드베이스에 상당한 영향을 미칠 수 있습니다.</p>\n<p>불완전한 기능: 개발자가 해당 코드를 구현하지 않고 <code>TODO</code> 태그를 남겨두면 소프트웨어 내에서 불완전한 기능이 발생합니다. 이는 예상치 못한 동작이나 누락된 기능으로 이어져 최종 사용자 경험에 부정적인 영향을 미칠 수 있습니다.</p>\n<p>버그 수정 누락: 개발자가 <code>TODO</code> 태그를 신속하게 처리하지 않으면 중요한 버그 수정 및 보안 업데이트를 간과할 수 있습니다. 지연된 버그 수정은 더 심각한 문제를 초래하고 나중에 해결하는 데 필요한 노력을 증가시킬 수 있습니다.</p>\n<p>협업에 대한 영향: 팀 기반 개발 환경에서 방치된 <code>TODO</code> 태그는 협업을 방해할 수 있습니다. 다른 팀원들이 의도된 변경 사항을 인식하지 못해 코드베이스에서 충돌이나 중복 작업이 발생할 수 있습니다.</p>\n<p>코드베이스 비대화: 시간이 지남에 따라 방치된 <code>TODO</code> 태그가 축적되면 코드베이스가 복잡해지고 진행 중인 작업과 완료된 코드를 구분하기 어려워질 수 있습니다. 이러한 비대화는 체계적이고 효율적인 코드베이스를 유지하는 것을 어렵게 만들 수 있습니다.</p>\n<p>이 코드 스멜을 해결하는 것은 유지보수 가능하고 읽기 쉽고 신뢰할 수 있는 코드베이스를 보장하고 개발자 간의 효과적인 협업을 촉진하는 데 필수적입니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\nvoid doSomething() {\n  // TODO\n}\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": "<ul>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/546\">CWE-546 - 의심스러운 주석</a> </li>\n</ul>"
  },
  {
    "id": "S2060",
    "key": "java:S2060",
    "name": "\"Externalizable\" classes should have no-arguments constructors",
    "type": "bug",
    "severity": "major",
    "tags": [],
    "why": "<p>A class that implements <code>java.io.Externalizable</code> is a class that provides a way to customize the serialization and deserialization,\nallowing greater control over how the object's state is written or read.</p>\n<p>The first step of the deserialization process is to call the class' no-argument constructor before the <code>readExternal(ObjectInput in)</code>\nmethod.</p>\n<p>An implicit default no-argument constructor exists on a class when no constructor is explicitly defined within the class. But this implicit\nconstructor does not exist when any constructor is explicitly defined, and in this case, we should always ensure that one of the constructors has\nno-argument.</p>\n<p>It is an issue if the implicit or explicit no-argument constructor is missing or not public, because the deserialization will fail and throw an\n<code>InvalidClassException: no valid constructor.</code>.</p>",
    "howToFix": "<p>This issue can be fixed by:</p>\n<ul>\n  <li> Adding an explicit public no-argument constructor. </li>\n  <li> Or if all constructors can be removed, remove all constructors to benefit of the default implicit no-argument constructor. </li>\n</ul>\n\n<h4>Noncompliant code example</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\npublic class Tomato implements Externalizable {\n\n  public Color color;\n\n  // Noncompliant; because of this constructor there is no implicit no-argument constructor,\n  // deserialization will fail\n  public Tomato(Color color) {\n    this.color = color;\n  }\n\n  @Override\n  public void writeExternal(ObjectOutput out) throws IOException {\n    out.writeUTF(color.name());\n  }\n\n  @Override\n  public void readExternal(ObjectInput in) throws IOException {\n    color = Color.valueOf(in.readUTF());\n  }\n}\n</pre>\n<h4>Compliant solution</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\npublic class Tomato implements Externalizable {\n\n  public Color color;\n\n  // Compliant; deserialization will invoke this public no-argument constructor\n  public Tomato() {\n    this.color = Color.UNKNOWN;\n  }\n\n  public Tomato(Color color) {\n    this.color = color;\n  }\n\n  @Override\n  public void writeExternal(ObjectOutput out) throws IOException {\n    out.writeUTF(color.name());\n  }\n\n  @Override\n  public void readExternal(ObjectInput in) throws IOException {\n    color = Color.valueOf(in.readUTF());\n  }\n}\n</pre>",
    "moreInfo": "<h3>Documentation</h3>\n<ul>\n  <li> <a href=\"https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/io/Externalizable.html\">Oracle SDK - java.io.Externalizable</a>\n  </li>\n</ul>",
    "status": "READY",
    "name_ko": "\"Externalizable\" 클래스는 인자 없는 생성자를 가져야 합니다",
    "why_ko": "<p><code>java.io.Externalizable</code>을 구현하는 클래스는 직렬화와 역직렬화를 사용자 정의할 수 있는 방법을 제공하여 객체의 상태가 쓰이거나 읽히는 방식에 대한 더 큰 제어를 허용합니다.</p>\n<p>역직렬화 프로세스의 첫 번째 단계는 <code>readExternal(ObjectInput in)</code> 메서드 전에 클래스의 인자 없는 생성자를 호출하는 것입니다.</p>\n<p>클래스 내에 명시적으로 정의된 생성자가 없을 때 암시적 기본 인자 없는 생성자가 클래스에 존재합니다. 그러나 이 암시적 생성자는 생성자가 명시적으로 정의되면 존재하지 않으며, 이 경우 생성자 중 하나가 인자 없는 생성자임을 항상 확인해야 합니다.</p>\n<p>암시적 또는 명시적 인자 없는 생성자가 누락되었거나 public이 아닌 경우 역직렬화가 실패하고 <code>InvalidClassException: no valid constructor.</code>를 던지기 때문에 문제가 됩니다.</p>",
    "howToFix_ko": "<p>이 문제는 다음과 같이 수정할 수 있습니다:</p>\n<ul>\n  <li> 명시적 public 인자 없는 생성자를 추가합니다. </li>\n  <li> 또는 모든 생성자를 제거할 수 있다면 기본 암시적 인자 없는 생성자의 이점을 얻기 위해 모든 생성자를 제거합니다. </li>\n</ul>\n\n<h4>규칙을 준수하지 않는 코드 예시</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\npublic class Tomato implements Externalizable {\n\n  public Color color;\n\n  // 규칙 위반; 이 생성자 때문에 암시적 인자 없는 생성자가 없으며,\n  // 역직렬화가 실패합니다\n  public Tomato(Color color) {\n    this.color = color;\n  }\n\n  @Override\n  public void writeExternal(ObjectOutput out) throws IOException {\n    out.writeUTF(color.name());\n  }\n\n  @Override\n  public void readExternal(ObjectInput in) throws IOException {\n    color = Color.valueOf(in.readUTF());\n  }\n}\n</pre>\n<h4>규칙을 준수하는 해결책</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\npublic class Tomato implements Externalizable {\n\n  public Color color;\n\n  // 규칙 준수; 역직렬화가 이 public 인자 없는 생성자를 호출합니다\n  public Tomato() {\n    this.color = Color.UNKNOWN;\n  }\n\n  public Tomato(Color color) {\n    this.color = color;\n  }\n\n  @Override\n  public void writeExternal(ObjectOutput out) throws IOException {\n    out.writeUTF(color.name());\n  }\n\n  @Override\n  public void readExternal(ObjectInput in) throws IOException {\n    color = Color.valueOf(in.readUTF());\n  }\n}\n</pre>",
    "moreInfo_ko": "<h3>문서</h3>\n<ul>\n  <li> <a href=\"https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/io/Externalizable.html\">Oracle SDK - java.io.Externalizable</a> </li>\n</ul>"
  },
  {
    "id": "S7409",
    "key": "java:S7409",
    "name": "Exposing native code through JavaScript interfaces is security-sensitive",
    "type": "security-hotspot",
    "severity": "major",
    "tags": [
      "cwe",
      "android"
    ],
    "why": "<p>Using JavaScript interfaces in WebViews to expose Java objects is unsafe. Doing so allows JavaScript to invoke Java methods, potentially giving\nattackers access to data or sensitive app functionality. WebViews might include untrusted sources such as third-party iframes, making this\nfunctionality particularly risky. As JavaScript interfaces are passed to every frame in the WebView, those iframes are also able to access the exposed\nJava object.</p>\n",
    "howToFix": "<h2>Recommended Secure Coding Practices</h2>\n<h3>Disable JavaScript</h3>\n<p>If it is possible to disable JavaScript in the WebView, this is the most secure option. By default, JavaScript is disabled in a WebView, so\n<code>webSettings.setJavaScriptEnabled(false)</code> does not need to be explicitly called. Of course, sometimes it is necessary to enable JavaScript,\nin which case the following recommendations should be considered.</p>\n<h3>Remove JavaScript interface when loading untrusted content</h3>\n<p>JavaScript interfaces can be removed at a later point. It is recommended to remove the JavaScript interface when it is no longer needed. If it is\nneeded for a longer time, consider removing it before loading untrusted content. This can be done by calling\n<code>webView.removeJavascriptInterface(\"interfaceName\")</code>.</p>\n<p>A good place to do this is inside the <code>shouldInterceptRequest</code> method of a <code>WebViewClient</code>, where you can check the URL or\nresource being loaded and remove the interface if the content is untrusted.</p>\n<h3>Alternative methods to implement native bridges</h3>\n<p>If a native bridge has to be added to the WebView, and it is impossible to remove it at a later point, consider using an alternative method that\noffers more control over the communication flow. <code>WebViewCompat.postWebMessage</code>/<code>WebViewCompat.addWebMessageListener</code> and\n<code>WebMessagePort.postMessage</code> offer more ways to validate incoming and outgoing messages, such as by being able to restrict the origins that\ncan send messages to the JavaScript bridge.</p>\n<h2>Compliant Solution</h2>\n<p>The most secure option is to disable JavaScript entirely. <a href='/coding_rules#rule_key=java%3AS6362'>S6362</a> further explains why it should not be enabled unless absolutely\nnecessary.</p>\n<pre>\npublic class ExampleActivity extends AppCompatActivity {\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n\n        WebView webView = new WebView(this);\n        webView.getSettings().setJavaScriptEnabled(false);\n    }\n}\n</pre>\n<p>If possible, remove the JavaScript interface after it is no longer needed, or before loading any untrusted content.</p>\n<pre>\npublic class ExampleActivity extends AppCompatActivity {\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n\n        WebView webView = new WebView(this);\n        webView.getSettings().setJavaScriptEnabled(true);\n\n        webView.addJavascriptInterface(new JavaScriptBridge(), \"androidBridge\");\n\n        // Sometime later, before unsafe content is loaded, remove the JavaScript interface\n        webView.removeJavascriptInterface(\"androidBridge\");\n    }\n}\n</pre>\n<p>If a JavaScript bridge must be used, consider using <code>WebViewCompat.addWebMessageListener</code> instead. This allows you to restrict the\norigins that can send messages to the JavaScript bridge.</p>\n<pre>\npublic class ExampleActivity extends AppCompatActivity {\n    private static final Set&lt;String&gt; ALLOWED_ORIGINS = Collections.singleton(\"https://example.com\");\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n\n        WebView webView = new WebView(this);\n        webView.getSettings().setJavaScriptEnabled(true);\n\n        WebViewCompat.addWebMessageListener(\n            webView,\n            \"androidBridge\",\n            ALLOWED_ORIGINS, // Only allow messages from these origins\n            new WebMessageListener() {\n                @Override\n                public void onPostMessage(\n                    WebView view,\n                    WebMessageCompat message,\n                    Uri sourceOrigin,\n                    boolean isMainFrame,\n                    JavaScriptReplyProxy replyProxy\n                ) {\n                    // Handle the message\n                }\n            }\n        );\n    }\n}\n</pre>\n<h2>See</h2>\n<ul>\n  <li> Android Documentation - <a href=\"https://developer.android.com/privacy-and-security/risks/insecure-webview-native-bridges\">Insecure WebView\n  native bridges</a> </li>\n  <li> Android Documentation - <a href=\"https://developer.android.com/reference/androidx/webkit/WebViewCompat\">WebViewCompat API reference</a> </li>\n  <li> OWASP - <a href=\"https://owasp.org/Top10/A05_2021-Security_Misconfiguration/\">Top 10 2021 Category A5 - Security Misconfiguration</a> </li>\n  <li> OWASP - <a href=\"https://owasp.org/www-project-mobile-top-10/2023-risks/m4-insufficient-input-output-validation.html\">Mobile Top 10 2024\n  Category M4 - Insufficient Input/Output Validation</a> </li>\n  <li> OWASP - <a href=\"https://owasp.org/www-project-mobile-top-10/2023-risks/m8-security-misconfiguration.html\">Mobile Top 10 2024 Category M8 -\n  Security Misconfiguration</a> </li>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/79\">CWE-79 - Improper Neutralization of Input During Web Page Generation</a> </li>\n</ul>\n<h3>Related rules</h3>\n<ul>\n  <li> <a href='/coding_rules#rule_key=java%3AS6362'>S6362</a> - Enabling JavaScript support for WebViews is security-sensitive </li>\n</ul>",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "JavaScript 인터페이스를 통한 네이티브 코드 노출은 보안에 민감합니다",
    "why_ko": "<p>WebView에서 JavaScript 인터페이스를 사용하여 Java 객체를 노출하는 것은 안전하지 않습니다. 이렇게 하면 JavaScript가 Java 메서드를 호출할 수 있어 공격자가 데이터나 민감한 앱 기능에 접근할 수 있게 됩니다. WebView에는 타사 iframe과 같은 신뢰할 수 없는 소스가 포함될 수 있어 이 기능이 특히 위험합니다. JavaScript 인터페이스가 WebView의 모든 프레임에 전달되므로 해당 iframe도 노출된 Java 객체에 접근할 수 있습니다.</p>\n",
    "howToFix_ko": "<h2>권장 보안 코딩 관행</h2>\n<h3>JavaScript 비활성화</h3>\n<p>WebView에서 JavaScript를 비활성화할 수 있다면 이것이 가장 안전한 옵션입니다. 기본적으로 WebView에서 JavaScript는 비활성화되어 있으므로 <code>webSettings.setJavaScriptEnabled(false)</code>를 명시적으로 호출할 필요가 없습니다. 물론 JavaScript를 활성화해야 하는 경우도 있으며, 이 경우 다음 권장 사항을 고려해야 합니다.</p>\n<h3>신뢰할 수 없는 콘텐츠 로드 시 JavaScript 인터페이스 제거</h3>\n<p>JavaScript 인터페이스는 나중에 제거할 수 있습니다. 더 이상 필요하지 않으면 JavaScript 인터페이스를 제거하는 것이 좋습니다. 더 오래 필요한 경우 신뢰할 수 없는 콘텐츠를 로드하기 전에 제거하는 것을 고려하세요. 이것은 <code>webView.removeJavascriptInterface(\"interfaceName\")</code>를 호출하여 수행할 수 있습니다.</p>\n<p>이를 수행하기 좋은 위치는 <code>WebViewClient</code>의 <code>shouldInterceptRequest</code> 메서드 내부로, 로드되는 URL이나 리소스를 확인하고 콘텐츠가 신뢰할 수 없는 경우 인터페이스를 제거할 수 있습니다.</p>\n<h3>네이티브 브리지를 구현하는 대체 방법</h3>\n<p>WebView에 네이티브 브리지를 추가해야 하고 나중에 제거할 수 없는 경우 통신 흐름에 대한 더 많은 제어를 제공하는 대체 방법을 사용하는 것을 고려하세요. <code>WebViewCompat.postWebMessage</code>/<code>WebViewCompat.addWebMessageListener</code> 및 <code>WebMessagePort.postMessage</code>는 JavaScript 브리지에 메시지를 보낼 수 있는 출처를 제한하는 것과 같이 수신 및 발신 메시지를 검증하는 더 많은 방법을 제공합니다.</p>\n<h2>규칙을 준수하는 해결책</h2>\n<p>가장 안전한 옵션은 JavaScript를 완전히 비활성화하는 것입니다. <a href='/coding_rules#rule_key=java%3AS6362'>S6362</a>는 절대적으로 필요한 경우가 아니면 활성화해서는 안 되는 이유를 추가로 설명합니다.</p>\n<pre>\npublic class ExampleActivity extends AppCompatActivity {\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n\n        WebView webView = new WebView(this);\n        webView.getSettings().setJavaScriptEnabled(false);\n    }\n}\n</pre>\n<p>가능하면 더 이상 필요하지 않거나 신뢰할 수 없는 콘텐츠를 로드하기 전에 JavaScript 인터페이스를 제거하세요.</p>\n<pre>\npublic class ExampleActivity extends AppCompatActivity {\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n\n        WebView webView = new WebView(this);\n        webView.getSettings().setJavaScriptEnabled(true);\n\n        webView.addJavascriptInterface(new JavaScriptBridge(), \"androidBridge\");\n\n        // 나중에 안전하지 않은 콘텐츠가 로드되기 전에 JavaScript 인터페이스를 제거\n        webView.removeJavascriptInterface(\"androidBridge\");\n    }\n}\n</pre>\n<p>JavaScript 브리지를 사용해야 하는 경우 대신 <code>WebViewCompat.addWebMessageListener</code>를 사용하는 것을 고려하세요. 이를 통해 JavaScript 브리지에 메시지를 보낼 수 있는 출처를 제한할 수 있습니다.</p>\n<pre>\npublic class ExampleActivity extends AppCompatActivity {\n    private static final Set&lt;String&gt; ALLOWED_ORIGINS = Collections.singleton(\"https://example.com\");\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n\n        WebView webView = new WebView(this);\n        webView.getSettings().setJavaScriptEnabled(true);\n\n        WebViewCompat.addWebMessageListener(\n            webView,\n            \"androidBridge\",\n            ALLOWED_ORIGINS, // 이 출처에서만 메시지 허용\n            new WebMessageListener() {\n                @Override\n                public void onPostMessage(\n                    WebView view,\n                    WebMessageCompat message,\n                    Uri sourceOrigin,\n                    boolean isMainFrame,\n                    JavaScriptReplyProxy replyProxy\n                ) {\n                    // 메시지 처리\n                }\n            }\n        );\n    }\n}\n</pre>\n<h2>참고</h2>\n<ul>\n  <li> Android 문서 - <a href=\"https://developer.android.com/privacy-and-security/risks/insecure-webview-native-bridges\">안전하지 않은 WebView 네이티브 브리지</a> </li>\n  <li> Android 문서 - <a href=\"https://developer.android.com/reference/androidx/webkit/WebViewCompat\">WebViewCompat API 참조</a> </li>\n  <li> OWASP - <a href=\"https://owasp.org/Top10/A05_2021-Security_Misconfiguration/\">Top 10 2021 카테고리 A5 - 보안 구성 오류</a> </li>\n  <li> OWASP - <a href=\"https://owasp.org/www-project-mobile-top-10/2023-risks/m4-insufficient-input-output-validation.html\">Mobile Top 10 2024 카테고리 M4 - 불충분한 입력/출력 검증</a> </li>\n  <li> OWASP - <a href=\"https://owasp.org/www-project-mobile-top-10/2023-risks/m8-security-misconfiguration.html\">Mobile Top 10 2024 카테고리 M8 - 보안 구성 오류</a> </li>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/79\">CWE-79 - 웹 페이지 생성 중 입력의 부적절한 중화</a> </li>\n</ul>\n<h3>관련 규칙</h3>\n<ul>\n  <li> <a href='/coding_rules#rule_key=java%3AS6362'>S6362</a> - WebView에 대한 JavaScript 지원 활성화는 보안에 민감합니다 </li>\n</ul>",
    "moreInfo_ko": ""
  },
  {
    "id": "S5967",
    "key": "java:S5967",
    "name": "Tests method should not be annotated with competing annotations",
    "type": "bug",
    "severity": "major",
    "tags": [
      "tests"
    ],
    "why": "<p>Annotating unit tests with more than one test-related annotation is not only useless but could also result in unexpected behavior like failing\ntests or unwanted side-effects.</p>\n<p>This rule reports an issue when a test method is annotated with more than one of the following competing annotation:</p>\n<ul>\n  <li> @Test </li>\n  <li> @RepeatedTest </li>\n  <li> @ParameterizedTest </li>\n  <li> @TestFactory </li>\n  <li> @TestTemplate </li>\n</ul>\n<h3>Noncompliant code example</h3>\n<pre>\n@Test\n@RepeatedTest(2) // Noncompliant, this test will be repeated 3 times\nvoid test() { }\n\n@ParameterizedTest\n@Test\n@MethodSource(\"methodSource\")\nvoid test2(int argument) { } // Noncompliant, this test will fail with ParameterResolutionException\n</pre>\n<h3>Compliant solution</h3>\n<pre>\n@RepeatedTest(2)\nvoid test() { }\n\n@ParameterizedTest\n@MethodSource(\"methodSource\")\nvoid test2(int argument) { }\n</pre>",
    "howToFix": "",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "테스트 메서드에 상충하는 어노테이션을 지정하면 안 됩니다",
    "why_ko": "<p>둘 이상의 테스트 관련 어노테이션으로 단위 테스트에 주석을 다는 것은 쓸모없을 뿐만 아니라 실패하는 테스트나 원치 않는 부작용과 같은 예상치 못한 동작을 초래할 수 있습니다.</p>\n<p>이 규칙은 테스트 메서드에 다음 상충하는 어노테이션 중 둘 이상이 지정된 경우 문제를 보고합니다:</p>\n<ul>\n  <li> @Test </li>\n  <li> @RepeatedTest </li>\n  <li> @ParameterizedTest </li>\n  <li> @TestFactory </li>\n  <li> @TestTemplate </li>\n</ul>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\n@Test\n@RepeatedTest(2) // 규칙 위반, 이 테스트는 3번 반복됩니다\nvoid test() { }\n\n@ParameterizedTest\n@Test\n@MethodSource(\"methodSource\")\nvoid test2(int argument) { } // 규칙 위반, 이 테스트는 ParameterResolutionException으로 실패합니다\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre>\n@RepeatedTest(2)\nvoid test() { }\n\n@ParameterizedTest\n@MethodSource(\"methodSource\")\nvoid test2(int argument) { }\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": ""
  },
  {
    "id": "S6218",
    "key": "java:S6218",
    "name": "Equals method should be overridden in records containing array fields",
    "type": "bug",
    "severity": "major",
    "tags": [
      "java16"
    ],
    "why": "<p>In records, the default behavior of the <code>equals()</code> method is to check the equality by field values. This works well for primitive fields\nor fields, whose type overrides <code>equals()</code>, but this behavior doesn't work as expected for array fields.</p>\n<p>By default, array fields are compared by their reference, and overriding <code>equals()</code> is highly appreciated to achieve the deep equality\ncheck. The same strategy applies to <code>hashCode()</code> and <code>toString()</code> methods.</p>\n<p>This rule reports an issue if a record class has an array field and is not overriding <code>equals()</code>, <code>hashCode()</code> or\n<code>toString()</code> methods.</p>\n<h3>Noncompliant code example</h3>\n<pre>\nrecord Person(String[] names, int age) {} // Noncompliant\n</pre>\n<h3>Compliant solution</h3>\n<pre>\nrecord Person(String[] names, int age) {\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (o == null || getClass() != o.getClass()) return false;\n        Person person = (Person) o;\n        return age == person.age &amp;&amp; Arrays.equals(names, person.names);\n    }\n\n    @Override\n    public int hashCode() {\n        int result = Objects.hash(age);\n        result = 31 * result + Arrays.hashCode(names);\n        return result;\n    }\n\n    @Override\n    public String toString() {\n        return \"Person{\" +\n                \"names=\" + Arrays.toString(names) +\n                \", age=\" + age +\n                '}';\n    }\n}\n</pre>",
    "howToFix": "",
    "moreInfo": "<ul>\n  <li> <a href=\"https://docs.oracle.com/javase/specs/jls/se16/html/jls-8.html#jls-8.10\">Records specification</a> </li>\n</ul>",
    "status": "READY",
    "name_ko": "배열 필드를 포함하는 Record에서 equals 메서드를 오버라이드해야 합니다",
    "why_ko": "<p>Record에서 <code>equals()</code> 메서드의 기본 동작은 필드 값으로 동등성을 확인하는 것입니다. 이것은 기본 필드나 <code>equals()</code>를 오버라이드하는 타입의 필드에 대해서는 잘 작동하지만, 배열 필드에 대해서는 예상대로 작동하지 않습니다.</p>\n<p>기본적으로 배열 필드는 참조로 비교되며, 깊은 동등성 검사를 위해 <code>equals()</code>를 오버라이드하는 것이 매우 권장됩니다. 동일한 전략이 <code>hashCode()</code>와 <code>toString()</code> 메서드에도 적용됩니다.</p>\n<p>이 규칙은 record 클래스가 배열 필드를 가지고 있고 <code>equals()</code>, <code>hashCode()</code> 또는 <code>toString()</code> 메서드를 오버라이드하지 않을 때 문제를 보고합니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\nrecord Person(String[] names, int age) {} // 규칙 위반\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre>\nrecord Person(String[] names, int age) {\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (o == null || getClass() != o.getClass()) return false;\n        Person person = (Person) o;\n        return age == person.age &amp;&amp; Arrays.equals(names, person.names);\n    }\n\n    @Override\n    public int hashCode() {\n        int result = Objects.hash(age);\n        result = 31 * result + Arrays.hashCode(names);\n        return result;\n    }\n\n    @Override\n    public String toString() {\n        return \"Person{\" +\n                \"names=\" + Arrays.toString(names) +\n                \", age=\" + age +\n                '}';\n    }\n}\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": "<ul>\n  <li> <a href=\"https://docs.oracle.com/javase/specs/jls/se16/html/jls-8.html#jls-8.10\">Record 명세</a> </li>\n</ul>"
  },
  {
    "id": "S1162",
    "key": "java:S1162",
    "name": "Checked exceptions should not be thrown",
    "type": "code-smell",
    "severity": "major",
    "tags": [
      "error-handling"
    ],
    "why": "<p>The purpose of checked exceptions is to ensure that errors will be dealt with, either by propagating them or by handling them, but some believe\nthat checked exceptions negatively impact the readability of source code, by spreading this error handling/propagation logic everywhere.</p>\n<p>This rule verifies that no method throws a new checked exception.</p>\n<h3>Noncompliant code example</h3>\n<pre>\npublic void myMethod1() throws CheckedException {\n  ...\n  throw new CheckedException(message);   // Noncompliant\n  ...\n  throw new IllegalArgumentException(message); // Compliant; IllegalArgumentException is unchecked\n}\n\npublic void myMethod2() throws CheckedException {  // Compliant; propagation allowed\n  myMethod1();\n}\n</pre>",
    "howToFix": "",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "Checked exception을 던지면 안 됩니다",
    "why_ko": "<p>checked exception의 목적은 예외를 전파하거나 처리하여 오류가 처리되도록 보장하는 것이지만, 일부에서는 checked exception이 오류 처리/전파 로직을 모든 곳에 퍼뜨려 소스 코드의 가독성에 부정적인 영향을 미친다고 생각합니다.</p>\n<p>이 규칙은 어떤 메서드도 새로운 checked exception을 던지지 않는지 확인합니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\npublic void myMethod1() throws CheckedException {\n  ...\n  throw new CheckedException(message);   // 규칙 위반\n  ...\n  throw new IllegalArgumentException(message); // 규칙 준수; IllegalArgumentException은 unchecked\n}\n\npublic void myMethod2() throws CheckedException {  // 규칙 준수; 전파 허용\n  myMethod1();\n}\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": ""
  },
  {
    "id": "S888",
    "key": "java:S888",
    "name": "Equality operators should not be used in \"for\" loop termination conditions",
    "type": "code-smell",
    "severity": "critical",
    "tags": [
      "cwe",
      "cert",
      "suspicious"
    ],
    "why": "<p>Testing <code>for</code> loop termination using an equality operator (<code>==</code> and <code>!=</code>) is dangerous, because it could set up an\ninfinite loop. Using a broader relational operator instead casts a wider net, and makes it harder (but not impossible) to accidentally write an\ninfinite loop.</p>\n<h3>Noncompliant code example</h3>\n<pre>\nfor (int i = 1; i != 10; i += 2)  // Noncompliant. Infinite; i goes from 9 straight to 11.\n{\n  //...\n}\n</pre>\n<h3>Compliant solution</h3>\n<pre>\nfor (int i = 1; i &lt;= 10; i += 2)  // Compliant\n{\n  //...\n}\n</pre>\n<h3>Exceptions</h3>\n<p>Equality operators are ignored if the loop counter is not modified within the body of the loop and either:</p>\n<ul>\n  <li> starts below the ending value and is incremented by 1 on each iteration. </li>\n  <li> starts above the ending value and is decremented by 1 on each iteration. </li>\n</ul>\n<p>Equality operators are also ignored when the test is against <code>null</code>.</p>\n<pre>\nfor (int i = 0; arr[i] != null; i++) {\n  // ...\n}\n\nfor (int i = 0; (item = arr[i]) != null; i++) {\n  // ...\n}\n</pre>",
    "howToFix": "",
    "moreInfo": "<ul>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/835\">CWE-835 - Loop with Unreachable Exit Condition ('Infinite Loop')</a> </li>\n  <li> <a href=\"https://wiki.sei.cmu.edu/confluence/x/x9YxBQ\">CERT, MSC21-C.</a> - Use robust loop termination conditions </li>\n</ul>",
    "status": "READY",
    "name_ko": "\"for\" 반복문 종료 조건에 동등 연산자를 사용하면 안 됩니다",
    "why_ko": "<p>동등 연산자(<code>==</code> 및 <code>!=</code>)를 사용하여 <code>for</code> 반복문 종료를 테스트하는 것은 무한 루프를 설정할 수 있으므로 위험합니다. 대신 더 넓은 관계 연산자를 사용하면 더 넓은 범위를 포괄하고 실수로 무한 루프를 작성하기 더 어렵게(불가능하지는 않지만) 만듭니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\nfor (int i = 1; i != 10; i += 2)  // 규칙 위반. 무한 루프; i가 9에서 바로 11로 감.\n{\n  //...\n}\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre>\nfor (int i = 1; i &lt;= 10; i += 2)  // 규칙 준수\n{\n  //...\n}\n</pre>\n<h3>예외</h3>\n<p>루프 카운터가 루프 본문 내에서 수정되지 않고 다음 중 하나에 해당하면 동등 연산자는 무시됩니다:</p>\n<ul>\n  <li> 종료 값보다 낮게 시작하고 각 반복에서 1씩 증가합니다. </li>\n  <li> 종료 값보다 높게 시작하고 각 반복에서 1씩 감소합니다. </li>\n</ul>\n<p>테스트가 <code>null</code>에 대한 것일 때도 동등 연산자는 무시됩니다.</p>\n<pre>\nfor (int i = 0; arr[i] != null; i++) {\n  // ...\n}\n\nfor (int i = 0; (item = arr[i]) != null; i++) {\n  // ...\n}\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": "<ul>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/835\">CWE-835 - 도달할 수 없는 종료 조건이 있는 루프('무한 루프')</a> </li>\n  <li> <a href=\"https://wiki.sei.cmu.edu/confluence/x/x9YxBQ\">CERT, MSC21-C.</a> - 견고한 루프 종료 조건을 사용하세요 </li>\n</ul>"
  },
  {
    "id": "S3626",
    "key": "java:S3626",
    "name": "Jump statements should not be redundant",
    "type": "code-smell",
    "severity": "minor",
    "tags": [
      "redundant",
      "clumsy"
    ],
    "why": "<p>Jump statements such as <code>return</code> and <code>continue</code> let you change the default flow of program execution, but jump statements\nthat direct the control flow to the original direction are just a waste of keystrokes.</p>\n<h3>Noncompliant code example</h3>\n<pre>\npublic void foo() {\n  while (condition1) {\n    if (condition2) {\n      continue; // Noncompliant\n    } else {\n      doTheThing();\n    }\n  }\n  return; // Noncompliant; this is a void method\n}\n</pre>\n<h3>Compliant solution</h3>\n<pre>\npublic void foo() {\n  while (condition1) {\n    if (!condition2) {\n      doTheThing();\n    }\n  }\n}\n</pre>",
    "howToFix": "",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "불필요한 점프 문이 있으면 안 됩니다",
    "why_ko": "<p><code>return</code> 및 <code>continue</code>와 같은 점프 문을 사용하면 프로그램 실행의 기본 흐름을 변경할 수 있지만, 제어 흐름을 원래 방향으로 향하게 하는 점프 문은 키 입력 낭비일 뿐입니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\npublic void foo() {\n  while (condition1) {\n    if (condition2) {\n      continue; // 규칙 위반\n    } else {\n      doTheThing();\n    }\n  }\n  return; // 규칙 위반; void 메서드입니다\n}\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre>\npublic void foo() {\n  while (condition1) {\n    if (!condition2) {\n      doTheThing();\n    }\n  }\n}\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": ""
  },
  {
    "id": "S6832",
    "key": "java:S6832",
    "name": "Non-singleton Spring beans should not be injected into singleton beans",
    "type": "code-smell",
    "severity": "major",
    "tags": [
      "spring"
    ],
    "why": "<p>In Spring, singleton beans and their dependencies are initialized when the application context is created.</p>\n<p>If a <code>Singleton</code> bean depends on a bean with a shorter-lived scope (like <code>Request</code> or <code>Session</code> beans), it retains\nthe same instance of that bean, even when new instances are created for each Request or Session. This mismatch can cause unexpected behavior and bugs,\nas the Singleton bean doesn't interact correctly with the new instances of the shorter-lived bean.</p>\n<p>This rule raises an issue when non-singleton beans are injected into a singleton bean.</p>\n<h3>What is the potential impact?</h3>\n<p>When a <code>Singleton</code> bean has a dependency on a bean with a shorter-lived scope, it can lead to the following issues:</p>\n<ul>\n  <li> <strong>Data inconsistency</strong>: any state change in the shorter-lived bean will not be reflected in the Singleton bean. </li>\n  <li> <strong>Incorrect behavior</strong>: using the same instance of the shorter-lived bean, when a new instance is supposed to be created for each\n  new request or session. </li>\n  <li> <strong>Memory leaks</strong>: preventing garbage collection of a shorter-lived bean that allocates a significant amount of data over time.\n  </li>\n</ul>",
    "howToFix": "<p>Inject a shorter-lived bean into a <code>Singleton</code> bean using <strong>ApplicationContext</strong>, <strong>Factories</strong> or\n<strong>Providers</strong>.</p>\n\n<h4>Noncompliant code example</h4>\n<p>When a <code>Singleton</code> bean auto-wires a <code>Request</code> bean, the dependency is resolved at instantiation time and thus the same\ninstance is used for each HTTP request.</p>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\n@Component\n@Scope(value = WebApplicationContext.SCOPE_REQUEST, proxyMode = ScopedProxyMode.TARGET_CLASS)\npublic class RequestBean {\n    //...\n}\n\npublic class SingletonBean {\n    @Autowired\n    private final RequestBean requestBean; // Noncompliant, the same instance of RequestBean is used for each HTTP request.\n\n    public RequestBean getRequestBean() {\n        return requestBean;\n    }\n}\n</pre>\n<h4>Compliant solution</h4>\n<p>Instead, use a <code>ObjectFactory&lt;RequestBean&gt;</code>, <code>ObjectProvider&lt;RequestBean&gt;</code>, or\n<code>Provider&lt;RequestBean&gt;</code> as injection point (as for <a\nhref=\"https://docs.spring.io/spring-framework/reference/core/beans/standard-annotations.html#beans-inject-named\">JSR-330</a>).</p>\n<p>Such a dependency is resolved at runtime, allowing for actual injection of a new instance of the shorter-lived bean on each HTTP request.</p>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\n@Component\n@Scope(value = WebApplicationContext.SCOPE_REQUEST, proxyMode = ScopedProxyMode.TARGET_CLASS)\npublic class RequestBean {\n    //...\n}\n\npublic class SingletonBean {\n    private final ObjectFactory&lt;RequestBean&gt; requestBeanFactory;\n\n    @Autowired\n    public SingletonBean(ObjectFactory&lt;RequestBean&gt; requestBeanFactory) {\n        this.requestBeanFactory = requestBeanFactory;\n    }\n\n    public RequestBean getRequestBean() {\n        return requestBeanFactory.getObject();\n    }\n}\n</pre>\n<h4>Noncompliant code example</h4>\n<p>When a <code>Singleton</code> bean auto-wires a <code>Prototype</code> bean, the dependency is resolved at instantiation time and thus the same\ninstance is used for each bean request.</p>\n<pre data-diff-id=\"2\" data-diff-type=\"noncompliant\">\n@Component\n@Scope(\"prototype\")\npublic class PrototypeBean {\n    public Object execute() {\n      //...\n    }\n}\n\npublic class SingletonBean {\n    private PrototypeBean prototypeBean;\n\n    @Autowired\n    public SingletonBean(PrototypeBean prototypeBean) { // Noncompliant, the same instance of PrototypeBean is used for each bean request.\n      this.prototypeBean = prototypeBean;\n    }\n\n    public Object process() {\n        return prototypeBean.execute();\n    }\n}\n</pre>\n<h4>Compliant solution</h4>\n<p>Using the <code>ApplicationContext</code> to retrieve a new instance of a <code>Prototype</code> bean on each bean request.</p>\n<pre data-diff-id=\"2\" data-diff-type=\"compliant\">\n@Component\n@Scope(\"prototype\")\npublic class PrototypeBean {\n    public Object execute() {\n      //...\n    }\n}\n\npublic class SingletonBean implements ApplicationContextAware {\n    private ApplicationContext applicationContext;\n\n    @Autowired\n    public SingletonBean(ApplicationContext applicationContext) {\n      this.applicationContext = applicationContext;\n    }\n\n    public Object process() {\n        PrototypeBean prototypeBean = createPrototypeBean();\n        return prototypeBean.execute();\n    }\n\n    protected PrototypeBean createPrototypeBean() {\n        return this.applicationContext.getBean(\"prototypeBean\", PrototypeBean.class);\n    }\n}\n</pre>",
    "moreInfo": "<h3>Documentation</h3>\n<ul>\n  <li> Spring Framework - <a href=\"https://docs.spring.io/spring-framework/reference/core/beans/factory-scopes.html\">Factory Scopes</a> </li>\n  <li> Spring Framework - <a href=\"https://docs.spring.io/spring-framework/reference/core/beans/standard-annotations.html#beans-inject-named\">Beans\n  Inject Named</a> </li>\n  <li> Spring Framework - <a href=\"https://docs.spring.io/spring-framework/reference/core/beans/dependencies/factory-method-injection.html\">Method\n  Injection</a> </li>\n</ul>\n<h3>Articles &amp; blog posts</h3>\n<ul>\n  <li> Baeldung - <a href=\"https://www.baeldung.com/spring-bean-scopes\">Spring Bean Scopes</a> </li>\n</ul>",
    "status": "READY",
    "name_ko": "Non-singleton Spring Bean은 singleton Bean에 주입하면 안 됩니다",
    "why_ko": "<p>Spring에서 singleton 빈과 그 의존성은 애플리케이션 컨텍스트가 생성될 때 초기화됩니다.</p>\n<p><code>Singleton</code> 빈이 더 짧은 생명주기 범위를 가진 빈(예: <code>Request</code> 또는 <code>Session</code> 빈)에 의존하는 경우 각 Request 또는 Session에 대해 새 인스턴스가 생성되더라도 동일한 빈 인스턴스를 유지합니다. 이 불일치로 인해 Singleton 빈이 더 짧은 생명주기 빈의 새 인스턴스와 올바르게 상호 작용하지 않아 예상치 못한 동작과 버그가 발생할 수 있습니다.</p>\n<p>이 규칙은 non-singleton 빈이 singleton 빈에 주입될 때 문제를 발생시킵니다.</p>\n<h3>잠재적 영향은 무엇인가요?</h3>\n<p><code>Singleton</code> 빈이 더 짧은 생명주기 범위의 빈에 의존하면 다음 문제가 발생할 수 있습니다:</p>\n<ul>\n  <li> <strong>데이터 불일치</strong>: 더 짧은 생명주기 빈의 상태 변경이 Singleton 빈에 반영되지 않습니다. </li>\n  <li> <strong>잘못된 동작</strong>: 각 새 요청이나 세션에 대해 새 인스턴스가 생성되어야 할 때 더 짧은 생명주기 빈의 동일한 인스턴스를 사용합니다. </li>\n  <li> <strong>메모리 누수</strong>: 시간이 지남에 따라 상당한 양의 데이터를 할당하는 더 짧은 생명주기 빈의 가비지 컬렉션이 방지됩니다. </li>\n</ul>",
    "howToFix_ko": "<p><strong>ApplicationContext</strong>, <strong>Factories</strong> 또는 <strong>Providers</strong>를 사용하여 더 짧은 생명주기 빈을 <code>Singleton</code> 빈에 주입하세요.</p>\n\n<h4>규칙을 준수하지 않는 코드 예시</h4>\n<p><code>Singleton</code> 빈이 <code>Request</code> 빈을 자동 연결하면 의존성이 인스턴스화 시점에 해결되므로 각 HTTP 요청에 동일한 인스턴스가 사용됩니다.</p>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\n@Component\n@Scope(value = WebApplicationContext.SCOPE_REQUEST, proxyMode = ScopedProxyMode.TARGET_CLASS)\npublic class RequestBean {\n    //...\n}\n\npublic class SingletonBean {\n    @Autowired\n    private final RequestBean requestBean; // 규칙 위반, 각 HTTP 요청에 동일한 RequestBean 인스턴스가 사용됩니다.\n\n    public RequestBean getRequestBean() {\n        return requestBean;\n    }\n}\n</pre>\n<h4>규칙을 준수하는 해결책</h4>\n<p>대신 <code>ObjectFactory&lt;RequestBean&gt;</code>, <code>ObjectProvider&lt;RequestBean&gt;</code> 또는 <code>Provider&lt;RequestBean&gt;</code>을 주입 지점으로 사용하세요(<a href=\"https://docs.spring.io/spring-framework/reference/core/beans/standard-annotations.html#beans-inject-named\">JSR-330</a> 참조).</p>\n<p>이러한 의존성은 런타임에 해결되어 각 HTTP 요청에 더 짧은 생명주기 빈의 새 인스턴스를 실제로 주입할 수 있습니다.</p>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\n@Component\n@Scope(value = WebApplicationContext.SCOPE_REQUEST, proxyMode = ScopedProxyMode.TARGET_CLASS)\npublic class RequestBean {\n    //...\n}\n\npublic class SingletonBean {\n    private final ObjectFactory&lt;RequestBean&gt; requestBeanFactory;\n\n    @Autowired\n    public SingletonBean(ObjectFactory&lt;RequestBean&gt; requestBeanFactory) {\n        this.requestBeanFactory = requestBeanFactory;\n    }\n\n    public RequestBean getRequestBean() {\n        return requestBeanFactory.getObject();\n    }\n}\n</pre>\n<h4>규칙을 준수하지 않는 코드 예시</h4>\n<p><code>Singleton</code> 빈이 <code>Prototype</code> 빈을 자동 연결하면 의존성이 인스턴스화 시점에 해결되므로 각 빈 요청에 동일한 인스턴스가 사용됩니다.</p>\n<pre data-diff-id=\"2\" data-diff-type=\"noncompliant\">\n@Component\n@Scope(\"prototype\")\npublic class PrototypeBean {\n    public Object execute() {\n      //...\n    }\n}\n\npublic class SingletonBean {\n    private PrototypeBean prototypeBean;\n\n    @Autowired\n    public SingletonBean(PrototypeBean prototypeBean) { // 규칙 위반, 각 빈 요청에 동일한 PrototypeBean 인스턴스가 사용됩니다.\n      this.prototypeBean = prototypeBean;\n    }\n\n    public Object process() {\n        return prototypeBean.execute();\n    }\n}\n</pre>\n<h4>규칙을 준수하는 해결책</h4>\n<p><code>ApplicationContext</code>를 사용하여 각 빈 요청에 <code>Prototype</code> 빈의 새 인스턴스를 검색합니다.</p>\n<pre data-diff-id=\"2\" data-diff-type=\"compliant\">\n@Component\n@Scope(\"prototype\")\npublic class PrototypeBean {\n    public Object execute() {\n      //...\n    }\n}\n\npublic class SingletonBean implements ApplicationContextAware {\n    private ApplicationContext applicationContext;\n\n    @Autowired\n    public SingletonBean(ApplicationContext applicationContext) {\n      this.applicationContext = applicationContext;\n    }\n\n    public Object process() {\n        PrototypeBean prototypeBean = createPrototypeBean();\n        return prototypeBean.execute();\n    }\n\n    protected PrototypeBean createPrototypeBean() {\n        return this.applicationContext.getBean(\"prototypeBean\", PrototypeBean.class);\n    }\n}\n</pre>",
    "moreInfo_ko": "<h3>문서</h3>\n<ul>\n  <li> Spring Framework - <a href=\"https://docs.spring.io/spring-framework/reference/core/beans/factory-scopes.html\">Factory 스코프</a> </li>\n  <li> Spring Framework - <a href=\"https://docs.spring.io/spring-framework/reference/core/beans/standard-annotations.html#beans-inject-named\">Bean 주입 Named</a> </li>\n  <li> Spring Framework - <a href=\"https://docs.spring.io/spring-framework/reference/core/beans/dependencies/factory-method-injection.html\">메서드 주입</a> </li>\n</ul>\n<h3>기사 및 블로그 게시물</h3>\n<ul>\n  <li> Baeldung - <a href=\"https://www.baeldung.com/spring-bean-scopes\">Spring Bean 스코프</a> </li>\n</ul>"
  },
  {
    "id": "S2308",
    "key": "java:S2308",
    "name": "\"deleteOnExit\" should not be used",
    "type": "code-smell",
    "severity": "major",
    "tags": [
      "performance"
    ],
    "why": "<p>Use of <code>File.deleteOnExit()</code> is not recommended for the following reasons:</p>\n<ul>\n  <li> The deletion occurs only in the case of a normal JVM shutdown but not when the JVM crashes or is killed. </li>\n  <li> For each file handler, the memory associated with the handler is released only at the end of the process. </li>\n</ul>\n<h3>Noncompliant code example</h3>\n<pre>\nFile file = new File(\"file.txt\");\nfile.deleteOnExit();  // Noncompliant\n</pre>",
    "howToFix": "",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "deleteOnExit를 사용하면 안 됩니다",
    "why_ko": "<p><code>File.deleteOnExit()</code> 사용은 다음과 같은 이유로 권장되지 않습니다:</p>\n<ul>\n  <li> 삭제는 정상적인 JVM 종료의 경우에만 발생하며 JVM이 충돌하거나 종료될 때는 발생하지 않습니다. </li>\n  <li> 각 파일 핸들러에 대해 핸들러와 관련된 메모리는 프로세스가 끝날 때만 해제됩니다. </li>\n</ul>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\nFile file = new File(\"file.txt\");\nfile.deleteOnExit();  // 규칙 위반\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": ""
  },
  {
    "id": "NoSonar",
    "key": "java:NoSonar",
    "name": "Track uses of \"NOSONAR\" comments",
    "type": "code-smell",
    "severity": "major",
    "tags": [
      "bad-practice"
    ],
    "why": "<p>Any issue to quality rule can be deactivated with the <code>NOSONAR</code> marker. This marker is pretty useful to exclude false-positive results\nbut it can also be used abusively to hide real quality flaws.</p>\n<p>This rule raises an issue when <code>NOSONAR</code> is used.</p>",
    "howToFix": "",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "\"NOSONAR\" 주석 사용을 추적합니다",
    "why_ko": "<p>품질 규칙에 대한 모든 이슈는 <code>NOSONAR</code> 마커로 비활성화할 수 있습니다. 이 마커는 거짓 양성 결과를 제외하는 데 매우 유용하지만 실제 품질 결함을 숨기기 위해 남용될 수도 있습니다.</p>\n<p>이 규칙은 <code>NOSONAR</code>가 사용될 때 문제를 제기합니다.</p>",
    "howToFix_ko": "",
    "moreInfo_ko": ""
  },
  {
    "id": "S1174",
    "key": "java:S1174",
    "name": "\"Object.finalize()\" should remain protected (versus public) when overriding",
    "type": "code-smell",
    "severity": "critical",
    "tags": [
      "cwe",
      "cert"
    ],
    "why": "<p>The contract of the <code>Object.finalize()</code> method is clear: only the Garbage Collector is supposed to call this method.</p>\n<p>Making this method public is misleading, because it implies that any caller can use it.</p>\n<h3>Noncompliant code example</h3>\n<pre>\npublic class MyClass {\n\n  @Override\n  public void finalize() {    // Noncompliant\n    /* ... */\n  }\n}\n</pre>",
    "howToFix": "",
    "moreInfo": "<ul>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/583\">CWE-583 - finalize() Method Declared Public</a> </li>\n  <li> <a href=\"https://wiki.sei.cmu.edu/confluence/x/4jZGBQ\">CERT, MET12-J.</a> - Do not use finalizers </li>\n</ul>",
    "status": "READY",
    "name_ko": "\"Object.finalize()\"를 오버라이드할 때 public이 아닌 protected로 유지해야 합니다",
    "why_ko": "<p><code>Object.finalize()</code> 메서드의 계약은 명확합니다: 오직 가비지 컬렉터만 이 메서드를 호출해야 합니다.</p>\n<p>이 메서드를 public으로 만드는 것은 모든 호출자가 사용할 수 있다는 것을 암시하므로 오해를 불러일으킵니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\npublic class MyClass {\n\n  @Override\n  public void finalize() {    // 규칙 위반\n    /* ... */\n  }\n}\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": "<ul>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/583\">CWE-583 - public으로 선언된 finalize() 메서드</a> </li>\n  <li> <a href=\"https://wiki.sei.cmu.edu/confluence/x/4jZGBQ\">CERT, MET12-J.</a> - finalizer를 사용하지 마세요 </li>\n</ul>"
  },
  {
    "id": "S6432",
    "key": "java:S6432",
    "name": "Counter Mode initialization vectors should not be reused",
    "type": "vulnerability",
    "severity": "critical",
    "tags": [
      "cwe"
    ],
    "why": "<p>When encrypting data using a counter (CTR) derived block cipher mode of operation, it is essential not to reuse the same initialization vector (IV)\nfor a given key. An IV that complies with this requirement is called a \"nonce\" (<strong>n</strong>umber used <strong>once</strong>). Galois/Counter\n(GCM) and Counter with Cipher Block Chaining-Message Authentication Code (CCM) are both derived from counter mode.</p>\n<p>When using AES-GCM or AES-CCM, a given key and IV pair will create a \"keystream\" that is used to encrypt a plaintext (original content) into a\nciphertext (encrypted content.) For any key and IV pair, this keystream is always deterministic. Because of this property, encrypting several\nplaintexts with one key and IV pair can be catastrophic. If an attacker has access to one plaintext and its associated ciphertext, they are able to\ndecrypt everything that was created using the same pair.</p>\n<p>Additionally, IV reuse also drastically decreases the key recovery computational complexity by downgrading it to a simpler polynomial root-finding\nproblem. This means that even without access to a plaintext/ciphertext pair, an attacker may still be able to decrypt all the sensitive data.</p>\n<h3>What is the potential impact?</h3>\n<p>If the encryption that is being used is flawed, attackers might be able to exploit it in several ways. They might be able to decrypt existing\nsensitive data or bypass key protections.</p>\n<p>Below are some real-world scenarios that illustrate some impacts of an attacker exploiting the vulnerability.</p>\n<h4>Theft of sensitive data</h4>\n<p>The encrypted message might contain data that is considered sensitive and should not be known to third parties.</p>\n<p>By not using the encryption algorithm correctly, the likelihood that an attacker might be able to recover the original sensitive data drastically\nincreases.</p>\n<h4>Additional attack surface</h4>\n<p>Encrypted values are often considered trusted, since under normal circumstances it would not be possible for a third party to modify them. If an\nattacker is able to modify the cleartext of the encrypted message, it might be possible to trigger other vulnerabilities in the code.</p>",
    "howToFix": "<p>The example uses a hardcoded IV as a nonce, which causes AES-CCM to be insecure. To fix it, a nonce is randomly generated instead.</p>\n<h4>Noncompliant code example</h4>\n<pre data-diff-id=\"101\" data-diff-type=\"noncompliant\">\npublic void encrypt(byte[] key, byte[] ptxt) {\n    byte[] nonce = \"7cVgr5cbdCZV\".getBytes(\"UTF-8\");\n\n    Cipher cipher = Cipher.getInstance(\"AES/GCM/NoPadding\");\n    SecretKeySpec keySpec = new SecretKeySpec(key, \"AES\");\n    GCMParameterSpec gcmSpec = new GCMParameterSpec(128, nonce);\n\n    cipher.init(Cipher.ENCRYPT_MODE, keySpec, gcmSpec); // Noncompliant\n}\n</pre>\n<h4>Compliant solution</h4>\n<pre data-diff-id=\"101\" data-diff-type=\"compliant\">\npublic void encrypt(byte[] key, byte[] ptxt) {\n    SecureRandom random = new SecureRandom();\n    byte[] nonce = new byte[12];\n    random.nextBytes(nonce);\n\n    Cipher cipher = Cipher.getInstance(\"AES/GCM/NoPadding\");\n    SecretKeySpec keySpec = new SecretKeySpec(key, \"AES\");\n    GCMParameterSpec gcmSpec = new GCMParameterSpec(128, nonce);\n\n    cipher.init(Cipher.ENCRYPT_MODE, keySpec, gcmSpec);\n}\n</pre>\n<h3>How does this work?</h3>\n<p>For AES-GCM and AES-CCM, NIST recommends generating a nonce using either a deterministic approach or using a 'Random Bit Generator (RBG)'.</p>\n<h4>Generating nonces using random number generation</h4>\n<p>When using a randomized approach, NIST recommends a nonce of at least 96 bits using a cryptographically secure pseudorandom number generator\n(CSPRNG.) Such a generator can create output with a sufficiently low probability of the same number being output twice (also called a\n<em>collision</em>) for a long time. However, after 2<sup>32</sup> generated numbers for the same key, NIST recommends rotating this key for a new\none. After that amount of generated numbers, the probability of a collision is high enough to be considered insecure.</p>\n<p>The code example above demonstrates how CSPRNGs can be used to generate nonces.</p>\n<p>Be careful to use a random number generator that is sufficiently secure. Default (non-cryptographically secure) RNGs might be more prone to\ncollisions in their output, which is catastrophic for counter-based encryption modes.</p>\n<h4>Deterministically generating nonces</h4>\n<p>One method to prevent the same IV from being used multiple times for the same key is to update the IV in a deterministic way after each encryption.\nThe most straightforward deterministic method for this is a counter.</p>\n<p>The way this works is simple: for any key, the first IV is the number zero. After this IV is used to encrypt something with a key, it is\nincremented for that key (and is now equal to 1). Although this requires additional bookkeeping, it should guarantee that for each encryption key, an\nIV is never repeated.</p>\n<p>For a secure implementation, NIST suggests generating these nonces in two parts: a fixed field and an invocation field. The fixed field should be\nused to identify the device executing the encryption (for example, it could contain a device ID), such that for one key, no two devices can generate\nthe same nonce. The invocation field contains the counter as described above. For a 96-bit nonce, NIST recommends (but does not require) using a\n32-bit fixed field and a 64-bit invocation field. Additional details can be found in the <a\nhref=\"https://nvlpubs.nist.gov/nistpubs/Legacy/SP/nistspecialpublication800-38d.pdf\">NIST Special Publication 800-38D</a>.</p>",
    "moreInfo": "<h3>Standards</h3>\n<ul>\n  <li> OWASP - <a href=\"https://owasp.org/Top10/A02_2021-Cryptographic_Failures/\">Top 10 2021 Category A2 - Cryptographic Failures</a> </li>\n  <li> OWASP - <a href=\"https://owasp.org/www-project-top-ten/2017/A3_2017-Sensitive_Data_Exposure\">Top 10 2017 Category A3 - Sensitive Data\n  Exposure</a> </li>\n  <li> OWASP - <a href=\"https://mas.owasp.org/checklists/MASVS-CRYPTO/\">Mobile AppSec Verification Standard - Cryptography Requirements</a> </li>\n  <li> OWASP - <a href=\"https://owasp.org/www-project-mobile-top-10/2016-risks/m5-insufficient-cryptography\">Mobile Top 10 2016 Category M5 -\n  Insufficient Cryptography</a> </li>\n  <li> OWASP - <a href=\"https://owasp.org/www-project-mobile-top-10/2023-risks/m10-insufficient-cryptography\">Mobile Top 10 2024 Category M10 -\n  Insufficient Cryptography</a> </li>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/323\">CWE-323 - Reusing a Nonce, Key Pair in Encryption</a> </li>\n  <li> <a href=\"https://nvlpubs.nist.gov/nistpubs/Legacy/SP/nistspecialpublication800-38a.pdf\">NIST, SP-800-38A</a> - Recommendation for Block Cipher\n  Modes of Operation </li>\n  <li> <a href=\"https://nvlpubs.nist.gov/nistpubs/Legacy/SP/nistspecialpublication800-38c.pdf\">NIST, SP-800-38C</a> - Recommendation for Block Cipher\n  Modes of Operation: The CCM Mode for Authentication and Confidentiality </li>\n  <li> <a href=\"https://nvlpubs.nist.gov/nistpubs/Legacy/SP/nistspecialpublication800-38d.pdf\">NIST, SP-800-38D</a> - Recommendation for Block Cipher\n  Modes of Operation: Galois/Counter Mode (GCM) and GMAC </li>\n</ul>",
    "status": "READY",
    "name_ko": "Counter Mode 초기화 벡터는 재사용하면 안 됩니다",
    "why_ko": "<p>카운터(CTR) 파생 블록 암호 운영 모드를 사용하여 데이터를 암호화할 때 주어진 키에 대해 동일한 초기화 벡터(IV)를 재사용하지 않는 것이 필수적입니다. 이 요구 사항을 준수하는 IV를 \"nonce\"(<strong>한 번만</strong> 사용되는 <strong>숫자</strong>)라고 합니다. Galois/Counter(GCM)와 Counter with Cipher Block Chaining-Message Authentication Code(CCM)는 모두 카운터 모드에서 파생됩니다.</p>\n<p>AES-GCM 또는 AES-CCM을 사용할 때 주어진 키와 IV 쌍은 평문(원본 콘텐츠)을 암호문(암호화된 콘텐츠)으로 암호화하는 데 사용되는 \"키스트림\"을 생성합니다. 모든 키와 IV 쌍에 대해 이 키스트림은 항상 결정적입니다. 이 속성 때문에 하나의 키와 IV 쌍으로 여러 평문을 암호화하면 치명적일 수 있습니다. 공격자가 하나의 평문과 그에 연결된 암호문에 접근할 수 있다면 동일한 쌍을 사용하여 생성된 모든 것을 복호화할 수 있습니다.</p>\n<p>또한 IV 재사용은 키 복구 계산 복잡도를 더 단순한 다항식 근 찾기 문제로 다운그레이드하여 크게 감소시킵니다. 이는 평문/암호문 쌍에 접근하지 않아도 공격자가 모든 민감한 데이터를 복호화할 수 있다는 것을 의미합니다.</p>\n<h3>잠재적 영향은 무엇인가요?</h3>\n<p>사용 중인 암호화에 결함이 있으면 공격자가 여러 방식으로 이를 악용할 수 있습니다. 기존의 민감한 데이터를 복호화하거나 키 보호를 우회할 수 있습니다.</p>\n<p>다음은 공격자가 취약점을 악용할 때의 일부 영향을 보여주는 실제 시나리오입니다.</p>\n<h4>민감한 데이터 도난</h4>\n<p>암호화된 메시지에는 민감하다고 간주되고 제3자에게 알려지면 안 되는 데이터가 포함될 수 있습니다.</p>\n<p>암호화 알고리즘을 올바르게 사용하지 않으면 공격자가 원래의 민감한 데이터를 복구할 수 있는 가능성이 크게 증가합니다.</p>\n<h4>추가 공격 표면</h4>\n<p>암호화된 값은 일반적으로 정상적인 상황에서는 제3자가 수정할 수 없기 때문에 신뢰할 수 있는 것으로 간주됩니다. 공격자가 암호화된 메시지의 평문을 수정할 수 있다면 코드의 다른 취약점을 트리거할 수 있습니다.</p>",
    "howToFix_ko": "<p>예제에서는 하드코딩된 IV를 nonce로 사용하여 AES-CCM이 안전하지 않게 됩니다. 이를 수정하려면 대신 nonce를 무작위로 생성합니다.</p>\n<h4>규칙을 준수하지 않는 코드 예시</h4>\n<pre data-diff-id=\"101\" data-diff-type=\"noncompliant\">\npublic void encrypt(byte[] key, byte[] ptxt) {\n    byte[] nonce = \"7cVgr5cbdCZV\".getBytes(\"UTF-8\");\n\n    Cipher cipher = Cipher.getInstance(\"AES/GCM/NoPadding\");\n    SecretKeySpec keySpec = new SecretKeySpec(key, \"AES\");\n    GCMParameterSpec gcmSpec = new GCMParameterSpec(128, nonce);\n\n    cipher.init(Cipher.ENCRYPT_MODE, keySpec, gcmSpec); // 규칙 위반\n}\n</pre>\n<h4>규칙을 준수하는 해결책</h4>\n<pre data-diff-id=\"101\" data-diff-type=\"compliant\">\npublic void encrypt(byte[] key, byte[] ptxt) {\n    SecureRandom random = new SecureRandom();\n    byte[] nonce = new byte[12];\n    random.nextBytes(nonce);\n\n    Cipher cipher = Cipher.getInstance(\"AES/GCM/NoPadding\");\n    SecretKeySpec keySpec = new SecretKeySpec(key, \"AES\");\n    GCMParameterSpec gcmSpec = new GCMParameterSpec(128, nonce);\n\n    cipher.init(Cipher.ENCRYPT_MODE, keySpec, gcmSpec);\n}\n</pre>\n<h3>어떻게 작동하나요?</h3>\n<p>AES-GCM 및 AES-CCM의 경우 NIST는 결정적 접근 방식이나 'Random Bit Generator(RBG)'를 사용하여 nonce를 생성할 것을 권장합니다.</p>\n<h4>난수 생성을 사용한 nonce 생성</h4>\n<p>무작위 접근 방식을 사용할 때 NIST는 암호학적으로 안전한 의사 난수 생성기(CSPRNG)를 사용하여 최소 96비트의 nonce를 권장합니다. 이러한 생성기는 오랜 시간 동안 동일한 숫자가 두 번 출력될 확률(<em>충돌</em>이라고도 함)이 충분히 낮은 출력을 생성할 수 있습니다. 그러나 동일한 키에 대해 2<sup>32</sup>개의 숫자가 생성된 후 NIST는 이 키를 새 키로 교체할 것을 권장합니다. 그 양의 생성된 숫자 이후에는 충돌 확률이 안전하지 않다고 간주될 만큼 높습니다.</p>\n<p>위의 코드 예제는 CSPRNG를 사용하여 nonce를 생성하는 방법을 보여줍니다.</p>\n<p>충분히 안전한 난수 생성기를 사용하도록 주의하세요. 기본(암호학적으로 안전하지 않은) RNG는 출력에서 충돌이 발생하기 쉬우며, 이는 카운터 기반 암호화 모드에 치명적입니다.</p>\n<h4>결정적으로 nonce 생성</h4>\n<p>동일한 키에 대해 동일한 IV가 여러 번 사용되는 것을 방지하는 한 가지 방법은 각 암호화 후 결정적 방식으로 IV를 업데이트하는 것입니다. 이를 위한 가장 간단한 결정적 방법은 카운터입니다.</p>\n<p>이것이 작동하는 방식은 간단합니다: 모든 키에 대해 첫 번째 IV는 숫자 0입니다. 이 IV가 키로 무언가를 암호화하는 데 사용된 후 해당 키에 대해 증가합니다(이제 1과 같습니다). 이것은 추가 기록 관리가 필요하지만 각 암호화 키에 대해 IV가 반복되지 않도록 보장해야 합니다.</p>\n<p>안전한 구현을 위해 NIST는 이러한 nonce를 두 부분으로 생성할 것을 제안합니다: 고정 필드와 호출 필드. 고정 필드는 암호화를 실행하는 장치를 식별하는 데 사용해야 합니다(예: 장치 ID를 포함할 수 있음). 이렇게 하면 하나의 키에 대해 두 장치가 동일한 nonce를 생성할 수 없습니다. 호출 필드에는 위에서 설명한 카운터가 포함됩니다. 96비트 nonce의 경우 NIST는 32비트 고정 필드와 64비트 호출 필드를 사용할 것을 권장합니다(필수는 아님). 추가 세부 정보는 <a href=\"https://nvlpubs.nist.gov/nistpubs/Legacy/SP/nistspecialpublication800-38d.pdf\">NIST Special Publication 800-38D</a>에서 찾을 수 있습니다.</p>",
    "moreInfo_ko": "<h3>표준</h3>\n<ul>\n  <li> OWASP - <a href=\"https://owasp.org/Top10/A02_2021-Cryptographic_Failures/\">Top 10 2021 Category A2 - 암호화 실패</a> </li>\n  <li> OWASP - <a href=\"https://owasp.org/www-project-top-ten/2017/A3_2017-Sensitive_Data_Exposure\">Top 10 2017 Category A3 - 민감한 데이터 노출</a> </li>\n  <li> OWASP - <a href=\"https://mas.owasp.org/checklists/MASVS-CRYPTO/\">Mobile AppSec Verification Standard - 암호화 요구사항</a> </li>\n  <li> OWASP - <a href=\"https://owasp.org/www-project-mobile-top-10/2016-risks/m5-insufficient-cryptography\">Mobile Top 10 2016 Category M5 - 불충분한 암호화</a> </li>\n  <li> OWASP - <a href=\"https://owasp.org/www-project-mobile-top-10/2023-risks/m10-insufficient-cryptography\">Mobile Top 10 2024 Category M10 - 불충분한 암호화</a> </li>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/323\">CWE-323 - 암호화에서 Nonce, 키 쌍 재사용</a> </li>\n  <li> <a href=\"https://nvlpubs.nist.gov/nistpubs/Legacy/SP/nistspecialpublication800-38a.pdf\">NIST, SP-800-38A</a> - 블록 암호 운영 모드 권장 사항 </li>\n  <li> <a href=\"https://nvlpubs.nist.gov/nistpubs/Legacy/SP/nistspecialpublication800-38c.pdf\">NIST, SP-800-38C</a> - 블록 암호 운영 모드 권장 사항: 인증 및 기밀성을 위한 CCM 모드 </li>\n  <li> <a href=\"https://nvlpubs.nist.gov/nistpubs/Legacy/SP/nistspecialpublication800-38d.pdf\">NIST, SP-800-38D</a> - 블록 암호 운영 모드 권장 사항: Galois/Counter Mode(GCM) 및 GMAC </li>\n</ul>"
  },
  {
    "id": "S2164",
    "key": "java:S2164",
    "name": "Math should not be performed on floats",
    "type": "bug",
    "severity": "minor",
    "tags": [
      "cert"
    ],
    "why": "<p>For small numbers, <code>float</code> math has enough precision to yield the expected value, but for larger numbers, it does not.\n<code>BigDecimal</code> is the best alternative, but if a primitive is required, use a <code>double</code>.</p>\n<h3>Noncompliant code example</h3>\n<pre>\nfloat a = 16777216.0f;\nfloat b = 1.0f;\nfloat c = a + b; // Noncompliant; yields 1.6777216E7 not 1.6777217E7\n\ndouble d = a + b; // Noncompliant; addition is still between 2 floats\n</pre>\n<h3>Compliant solution</h3>\n<pre>\nfloat a = 16777216.0f;\nfloat b = 1.0f;\nBigDecimal c = BigDecimal.valueOf(a).add(BigDecimal.valueOf(b));\n\ndouble d = (double)a + (double)b;\n</pre>\n<h3>Exceptions</h3>\n<p>This rule doesn't raise an issue when the mathematical expression is only used to build a string.</p>\n<pre>\nSystem.out.println(\"[\"+getName()+\"] \" +\n           \"\\n\\tMax time to retrieve connection:\"+(max/1000f/1000f)+\" ms.\");\n</pre>",
    "howToFix": "",
    "moreInfo": "<ul>\n  <li> <a href=\"https://wiki.sei.cmu.edu/confluence/x/CtcxBQ\">CERT, FLP02-C.</a> - Avoid using floating-point numbers when precise computation is\n  needed </li>\n</ul>",
    "status": "READY",
    "name_ko": "float에 대한 수학 연산은 수행하면 안 됩니다",
    "why_ko": "<p>작은 숫자의 경우 <code>float</code> 수학 연산은 예상 값을 산출하기에 충분한 정밀도를 갖지만, 큰 숫자의 경우에는 그렇지 않습니다. <code>BigDecimal</code>이 최선의 대안이지만, 기본형이 필요한 경우 <code>double</code>을 사용하세요.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\nfloat a = 16777216.0f;\nfloat b = 1.0f;\nfloat c = a + b; // 규칙 위반; 1.6777217E7이 아닌 1.6777216E7을 산출\n\ndouble d = a + b; // 규칙 위반; 여전히 두 float 간의 덧셈\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre>\nfloat a = 16777216.0f;\nfloat b = 1.0f;\nBigDecimal c = BigDecimal.valueOf(a).add(BigDecimal.valueOf(b));\n\ndouble d = (double)a + (double)b;\n</pre>\n<h3>예외</h3>\n<p>이 규칙은 수학 표현식이 문자열을 구성하는 데만 사용될 때 문제를 제기하지 않습니다.</p>\n<pre>\nSystem.out.println(\"[\"+getName()+\"] \" +\n           \"\\n\\tMax time to retrieve connection:\"+(max/1000f/1000f)+\" ms.\");\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": "<ul>\n  <li> <a href=\"https://wiki.sei.cmu.edu/confluence/x/CtcxBQ\">CERT, FLP02-C.</a> - 정확한 계산이 필요할 때 부동 소수점 숫자 사용을 피하세요 </li>\n</ul>"
  },
  {
    "id": "S125",
    "key": "java:S125",
    "name": "Sections of code should not be commented out",
    "type": "code-smell",
    "severity": "major",
    "tags": [
      "unused"
    ],
    "why": "<p>Commented-out code distracts the focus from the actual executed code. It creates a noise that increases maintenance code. And because it is never\nexecuted, it quickly becomes out of date and invalid.</p>\n<p>Commented-out code should be deleted and can be retrieved from source control history if required.</p>",
    "howToFix": "",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "코드를 주석 처리하면 안 됩니다",
    "why_ko": "<p>주석 처리된 코드는 실제로 실행되는 코드에 대한 집중을 방해합니다. 유지 관리 코드를 증가시키는 노이즈를 만듭니다. 그리고 절대 실행되지 않기 때문에 빠르게 오래되고 유효하지 않게 됩니다.</p>\n<p>주석 처리된 코드는 삭제해야 하며 필요한 경우 소스 제어 기록에서 검색할 수 있습니다.</p>",
    "howToFix_ko": "",
    "moreInfo_ko": ""
  },
  {
    "id": "S3958",
    "key": "java:S3958",
    "name": "Intermediate Stream methods should not be left unused",
    "type": "bug",
    "severity": "major",
    "tags": [
      "symbolic-execution",
      "java8"
    ],
    "why": "<p>There are two types of stream operations: intermediate operations, which return another stream, and terminal operations, which return something\nother than a stream. Intermediate operations are lazy, meaning they aren't actually executed until and unless a terminal stream operation is performed\non their results. Consequently, if the result of an intermediate stream operation is not fed to a terminal operation, it serves no purpose, which is\nalmost certainly an error.</p>\n<h3>Noncompliant code example</h3>\n<pre>\nwidgets.stream().filter(b -&gt; b.getColor() == RED); // Noncompliant\n</pre>\n<h3>Compliant solution</h3>\n<pre>\nint sum = widgets.stream()\n                      .filter(b -&gt; b.getColor() == RED)\n                      .mapToInt(b -&gt; b.getWeight())\n                      .sum();\nStream&lt;Widget&gt; pipeline = widgets.stream()\n                                 .filter(b -&gt; b.getColor() == GREEN)\n                                 .mapToInt(b -&gt; b.getWeight());\nsum = pipeline.sum();\n</pre>",
    "howToFix": "",
    "moreInfo": "<ul>\n  <li> <a href=\"https://docs.oracle.com/javase/8/docs/api/java/util/stream/package-summary.html#StreamOps\">Stream Operations</a> </li>\n</ul>",
    "status": "READY",
    "name_ko": "중간 Stream 메서드를 사용하지 않고 남겨두면 안 됩니다",
    "why_ko": "<p>스트림 연산에는 두 가지 유형이 있습니다: 다른 스트림을 반환하는 중간 연산과 스트림 이외의 것을 반환하는 종단 연산입니다. 중간 연산은 지연(lazy)됩니다. 즉, 결과에 대해 종단 스트림 연산이 수행될 때까지 실제로 실행되지 않습니다. 따라서 중간 스트림 연산의 결과가 종단 연산에 전달되지 않으면 아무 목적도 없으며, 이는 거의 확실히 오류입니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\nwidgets.stream().filter(b -&gt; b.getColor() == RED); // 규칙 위반\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre>\nint sum = widgets.stream()\n                      .filter(b -&gt; b.getColor() == RED)\n                      .mapToInt(b -&gt; b.getWeight())\n                      .sum();\nStream&lt;Widget&gt; pipeline = widgets.stream()\n                                 .filter(b -&gt; b.getColor() == GREEN)\n                                 .mapToInt(b -&gt; b.getWeight());\nsum = pipeline.sum();\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": "<ul>\n  <li> <a href=\"https://docs.oracle.com/javase/8/docs/api/java/util/stream/package-summary.html#StreamOps\">Stream 연산</a> </li>\n</ul>"
  },
  {
    "id": "S1066",
    "key": "java:S1066",
    "name": "Mergeable \"if\" statements should be combined",
    "type": "code-smell",
    "severity": "major",
    "tags": [
      "clumsy"
    ],
    "why": "<p>Nested code - blocks of code inside blocks of code - is eventually necessary, but increases complexity. This is why keeping the code as flat as\npossible, by avoiding unnecessary nesting, is considered a good practice.</p>\n<p>Merging <code>if</code> statements when possible will decrease the nesting of the code and improve its readability.</p>\n<p>Code like</p>\n<pre>\nif (condition1) {\n  if (condition2) {             // Noncompliant\n    /* ... */\n  }\n}\n</pre>\n<p>Will be more readable as</p>\n<pre>\nif (condition1 &amp;&amp; condition2) { // Compliant\n  /* ... */\n}\n</pre>",
    "howToFix": "<p>If merging the conditions seems to result in a more complex code, extracting the condition or part of it in a named function or variable is a\nbetter approach to fix readability.</p>\n\n<h4>Noncompliant code example</h4>\n<pre>\nif (file != null) {\n  if (file.isFile() || file.isDirectory()) {  // Noncompliant\n    /* ... */\n  }\n}\n</pre>\n<h4>Compliant solution</h4>\n<pre>\nif (file != null &amp;&amp; isFileOrDirectory(file)) { // Compliant\n  /* ... */\n}\n\nprivate static boolean isFileOrDirectory(File file) {\n  return file.isFile() || file.isDirectory();\n}\n</pre>",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "병합 가능한 \"if\" 문은 결합해야 합니다",
    "why_ko": "<p>중첩된 코드 - 코드 블록 안의 코드 블록 - 는 결국 필요하지만 복잡성을 증가시킵니다. 그래서 불필요한 중첩을 피해 코드를 최대한 평탄하게 유지하는 것이 좋은 관행으로 여겨집니다.</p>\n<p>가능할 때 <code>if</code> 문을 병합하면 코드의 중첩이 줄어들고 가독성이 향상됩니다.</p>\n<p>다음과 같은 코드는</p>\n<pre>\nif (condition1) {\n  if (condition2) {             // 규칙 위반\n    /* ... */\n  }\n}\n</pre>\n<p>다음과 같이 작성하면 더 읽기 쉽습니다</p>\n<pre>\nif (condition1 &amp;&amp; condition2) { // 규칙 준수\n  /* ... */\n}\n</pre>",
    "howToFix_ko": "<p>조건을 병합하면 더 복잡한 코드가 될 것 같다면, 조건이나 조건의 일부를 이름 있는 함수나 변수로 추출하는 것이 가독성을 개선하는 더 나은 접근법입니다.</p>\n\n<h4>규칙을 준수하지 않는 코드 예시</h4>\n<pre>\nif (file != null) {\n  if (file.isFile() || file.isDirectory()) {  // 규칙 위반\n    /* ... */\n  }\n}\n</pre>\n<h4>규칙을 준수하는 해결책</h4>\n<pre>\nif (file != null &amp;&amp; isFileOrDirectory(file)) { // 규칙 준수\n  /* ... */\n}\n\nprivate static boolean isFileOrDirectory(File file) {\n  return file.isFile() || file.isDirectory();\n}\n</pre>",
    "moreInfo_ko": ""
  },
  {
    "id": "S5863",
    "key": "java:S5863",
    "name": "Assertions should not compare an object to itself",
    "type": "bug",
    "severity": "major",
    "tags": [
      "tests"
    ],
    "why": "<p>Assertions comparing an object to itself are more likely to be bugs due to developer's carelessness.</p>\n<p>This rule raises an issue when the actual expression matches the expected expression.</p>\n<h3>Noncompliant code example</h3>\n<pre>\nassertThat(actual).isEqualTo(actual); // Noncompliant\n</pre>\n<h3>Compliant solution</h3>\n<pre>\nassertThat(actual).isEqualTo(expected);\n</pre>\n<h3>Exceptions</h3>\n<p>In a unit test validating the <code>equals(...)</code> and <code>hashCode()</code> methods, it's legitimate to compare an object to itself. This\nrule does not raise an issue for <code>isEqualTo</code>, <code>assertEquals</code> or <code>hasSameHashCodeAs</code> when the unit test name contains\n(case insensitive): <code>equal</code>, <code>hash_?code</code>, <code>object_?method</code>. For example, in tests with the following names:\n<code>test_equals</code>, <code>testEqual</code>, <code>test_hashCode</code>, <code>test_hash_code</code>, <code>test_object_methods</code>.</p>\n<pre>\nclass MyClassTest {\n  @Test\n  void test_equals_and_hash_code() {\n    MyClass obj = new MyClass();\n    assertThat(obj).isEqualTo(obj); // Compliant\n    assertThat(obj).hasSameHashCodeAs(obj); // Compliant\n  }\n}\n</pre>",
    "howToFix": "",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "assertion은 객체를 자기 자신과 비교하면 안 됩니다",
    "why_ko": "<p>객체를 자기 자신과 비교하는 assertion은 개발자의 부주의로 인한 버그일 가능성이 높습니다.</p>\n<p>이 규칙은 실제 표현식이 예상 표현식과 일치할 때 문제를 제기합니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\nassertThat(actual).isEqualTo(actual); // 규칙 위반\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre>\nassertThat(actual).isEqualTo(expected);\n</pre>\n<h3>예외</h3>\n<p><code>equals(...)</code>와 <code>hashCode()</code> 메서드를 검증하는 단위 테스트에서는 객체를 자기 자신과 비교하는 것이 합법적입니다. 단위 테스트 이름에 (대소문자 무관) <code>equal</code>, <code>hash_?code</code>, <code>object_?method</code>가 포함된 경우 이 규칙은 <code>isEqualTo</code>, <code>assertEquals</code> 또는 <code>hasSameHashCodeAs</code>에 대해 문제를 제기하지 않습니다. 예를 들어, <code>test_equals</code>, <code>testEqual</code>, <code>test_hashCode</code>, <code>test_hash_code</code>, <code>test_object_methods</code>와 같은 이름의 테스트에서:</p>\n<pre>\nclass MyClassTest {\n  @Test\n  void test_equals_and_hash_code() {\n    MyClass obj = new MyClass();\n    assertThat(obj).isEqualTo(obj); // 규칙 준수\n    assertThat(obj).hasSameHashCodeAs(obj); // 규칙 준수\n  }\n}\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": ""
  },
  {
    "id": "S1123",
    "key": "java:S1123",
    "name": "Deprecated elements should have both the annotation and the Javadoc tag",
    "type": "code-smell",
    "severity": "major",
    "tags": [
      "obsolete",
      "bad-practice"
    ],
    "why": "<p>Deprecation should be marked with both the <code>@Deprecated</code> annotation and @deprecated Javadoc tag. The annotation enables tools such as\nIDEs to warn about referencing deprecated elements, and the tag can be used to explain when it was deprecated, why, and how references should be\nrefactored.</p>\n<h3>Noncompliant code example</h3>\n<pre>\nclass MyClass {\n\n  @Deprecated\n  public void foo1() {    // Noncompliant: Add the missing @deprecated Javadoc tag.\n  }\n\n  /**\n    * @deprecated\n    */\n  public void foo2() {    // Noncompliant: Add the missing @Deprecated annotation.\n  }\n\n}\n</pre>\n<h3>Compliant solution</h3>\n<pre>\nclass MyClass {\n\n  /**\n    * @deprecated (when, why, refactoring advice...)\n    */\n  @Deprecated\n  public void foo1() {\n  }\n\n}\n</pre>\n<h3>Exceptions</h3>\n<p>The members and methods of a deprecated class or interface are ignored by this rule. The classes and interfaces themselves are still subject to\nit.</p>\n<pre>\n/**\n * @deprecated (when, why, etc...)\n */\n@Deprecated\nclass Qix  {\n\n  public void foo() {} // Compliant; class is deprecated\n\n}\n\n/**\n * @deprecated (when, why, etc...)\n */\n@Deprecated\ninterface Plop {\n\n  void bar();\n\n}\n</pre>",
    "howToFix": "",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "Deprecated 요소는 어노테이션과 Javadoc 태그를 모두 가져야 합니다",
    "why_ko": "<p>Deprecation은 <code>@Deprecated</code> 어노테이션과 @deprecated Javadoc 태그 모두로 표시해야 합니다. 어노테이션은 IDE와 같은 도구가 deprecated 요소를 참조할 때 경고를 할 수 있게 하고, 태그는 언제 deprecated 되었는지, 왜 그런지, 참조를 어떻게 리팩토링해야 하는지 설명하는 데 사용할 수 있습니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\nclass MyClass {\n\n  @Deprecated\n  public void foo1() {    // 규칙 위반: 누락된 @deprecated Javadoc 태그를 추가하세요.\n  }\n\n  /**\n    * @deprecated\n    */\n  public void foo2() {    // 규칙 위반: 누락된 @Deprecated 어노테이션을 추가하세요.\n  }\n\n}\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre>\nclass MyClass {\n\n  /**\n    * @deprecated (언제, 왜, 리팩토링 조언...)\n    */\n  @Deprecated\n  public void foo1() {\n  }\n\n}\n</pre>\n<h3>예외 사항</h3>\n<p>deprecated 클래스나 인터페이스의 멤버와 메서드는 이 규칙에서 무시됩니다. 클래스와 인터페이스 자체는 여전히 이 규칙의 적용을 받습니다.</p>\n<pre>\n/**\n * @deprecated (언제, 왜 등...)\n */\n@Deprecated\nclass Qix  {\n\n  public void foo() {} // 규칙 준수; 클래스가 deprecated됨\n\n}\n\n/**\n * @deprecated (언제, 왜 등...)\n */\n@Deprecated\ninterface Plop {\n\n  void bar();\n\n}\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": ""
  },
  {
    "id": "S1820",
    "key": "java:S1820",
    "name": "Classes should not have too many fields",
    "type": "code-smell",
    "severity": "major",
    "tags": [
      "brain-overload"
    ],
    "why": "<p>A class that grows too much tends to aggregate too many responsibilities and inevitably becomes harder to understand and therefore to maintain, and\nhaving a lot of fields is an indication that a class has grown too large.</p>\n<p>Above a specific threshold, it is strongly advised to refactor the class into smaller ones which focus on well defined topics.</p>",
    "howToFix": "",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "클래스에 너무 많은 필드가 있으면 안 됩니다",
    "why_ko": "<p>너무 커진 클래스는 너무 많은 책임을 모으는 경향이 있으며, 필연적으로 이해하기 어려워지고 따라서 유지보수하기도 어려워집니다. 많은 필드를 가지고 있다는 것은 클래스가 너무 커졌다는 것을 나타냅니다.</p>\n<p>특정 임계값을 초과하면, 잘 정의된 주제에 집중하는 더 작은 클래스로 리팩토링하는 것이 강력히 권장됩니다.</p>",
    "howToFix_ko": "",
    "moreInfo_ko": ""
  },
  {
    "id": "S6035",
    "key": "java:S6035",
    "name": "Single-character alternations in regular expressions should be replaced with character classes",
    "type": "code-smell",
    "severity": "major",
    "tags": [
      "regex"
    ],
    "why": "<p>When an alternation contains multiple alternatives that consist of a single character, it can be rewritten as a character class. This should be\npreferred because it is more efficient and can even help prevent stack overflows when used inside a repetition (see rule <a href='/coding_rules#rule_key=java%3AS5998'>S5998</a>).</p>\n<h3>Noncompliant code example</h3>\n<pre>\nPattern.compile(\"a|b|c\"); // Noncompliant\n</pre>\n<h3>Compliant solution</h3>\n<pre>\nPattern.compile(\"[abc]\");\n// or\nPattern.compile(\"[a-c]\");\n</pre>",
    "howToFix": "",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "정규 표현식의 단일 문자 대안은 문자 클래스로 대체해야 합니다",
    "why_ko": "<p>대안에 단일 문자로 구성된 여러 대안이 포함된 경우 문자 클래스로 다시 작성할 수 있습니다. 더 효율적이고 반복 내에서 사용할 때 스택 오버플로우를 방지하는 데 도움이 될 수도 있으므로 이것이 선호됩니다(규칙 <a href='/coding_rules#rule_key=java%3AS5998'>S5998</a> 참조).</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\nPattern.compile(\"a|b|c\"); // 규칙 위반\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre>\nPattern.compile(\"[abc]\");\n// 또는\nPattern.compile(\"[a-c]\");\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": ""
  },
  {
    "id": "S2975",
    "key": "java:S2975",
    "name": "\"clone\" should not be overridden",
    "type": "code-smell",
    "severity": "blocker",
    "tags": [
      "suspicious"
    ],
    "why": "<p>The <code>Object.clone</code> / <code>java.lang.Cloneable</code> mechanism in Java should be considered broken for the following reasons and\nshould, consequently, not be used:</p>\n<ul>\n  <li> <code>Cloneable</code> is a <em>marker interface</em> without API but with a contract about class behavior that the compiler cannot enforce.\n  This is a bad practice. </li>\n  <li> Classes are instantiated without calling their constructor, so possible preconditions cannot be enforced. </li>\n  <li> There are implementation flaws by design when overriding <code>Object.clone</code>, like type casts or the handling of\n  <code>CloneNotSupportedException</code> exceptions. </li>\n</ul>",
    "howToFix": "<p>A copy constructor, copy factory or a custom copy function are suitable alternatives to the <code>Object.clone</code> /\n<code>java.lang.Cloneable</code> mechanism.</p>\n<p>Consider the following example:</p>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\nclass Entity implements Cloneable { // Noncompliant, using `Cloneable`\n\n  public int value;\n  public List&lt;Entity&gt; children; // deep copy wanted\n\n  Entity() {\n    EntityManager.register(this); // invariant\n  }\n\n  @Override\n  public Entity clone() {\n    try {\n      Entity copy = (Entity) super.clone(); // invariant not enforced, because no constructor is caled\n      copy.children = children.stream().map(Entity::clone).toList();\n      return copy;\n    } catch (CloneNotSupportedException e) { // this will not happen due to behavioral contract\n      throw new AssertionError();\n    }\n  }\n}\n</pre>\n<p>The <code>Cloneable</code> / <code>Object.clone</code> mechanism could easily be replaced by copy constructor:</p>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\nclass Entity { // Compliant\n\n  public int value;\n  public List&lt;Entity&gt; children; // deep copy wanted\n\n  Entity() {\n    EntityManager.register(this); // invariant\n  }\n\n  Entity(Entity template) {\n    value = template.value;\n    children = template.children.stream().map(Entity::new).toList();\n  }\n}\n</pre>\n<p>Or by a factory method:</p>\n<pre>\nclass Entity { // Compliant\n\n  public int value;\n  public List&lt;Entity&gt; children; // deep copy wanted\n\n  Entity() {\n    EntityManager.register(this); // invariant\n  }\n\n  public static Entity create(Entity template) {\n    Entity entity = new Entity();\n    entity.value = template.value;\n    entity.children = template.children.stream().map(Entity::new).toList();\n    return Entity;\n  }\n}\n</pre>\n<p>Or by a custom <code>copy</code> function:</p>\n<pre>\nclass Entity { // Compliant\n\n  public int value;\n  public List&lt;Entity&gt; children; // deep copy wanted\n\n  Entity() {\n    EntityManager.register(this); // invariant\n  }\n\n  public Entity copy() {\n    Entity entity = new Entity();\n    entity.value = value;\n    entity.children = children.stream().map(Entity::new).toList();\n    return Entity;\n  }\n}\n</pre>",
    "moreInfo": "<h3>Documentation</h3>\n<ul>\n  <li> <a href=\"https://www.artima.com/intv/bloch13.html\">Joshua Bloch - Copy Constructor versus Cloning</a> </li>\n  <li> <a href=\"https://docs.oracle.com/javase/8/docs/api/java/lang/Cloneable.html\">Interface Cloneable - Java™ Platform, Standard Edition 8 API\n  Specification</a> </li>\n  <li> <a href=\"https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html#clone--\">Object.clone - Java™ Platform, Standard Edition 8 API\n  Specification</a> </li>\n</ul>\n<h3>Related rules</h3>\n<ul>\n  <li> <a href='/coding_rules#rule_key=java%3AS2157'>S2157</a> - \"Cloneables\" should implement \"clone\" </li>\n  <li> <a href='/coding_rules#rule_key=java%3AS1182'>S1182</a> - Classes that override \"clone\" should be \"Cloneable\" and call \"super.clone()\" </li>\n</ul>",
    "status": "READY",
    "name_ko": "clone을 오버라이드하면 안 됩니다",
    "why_ko": "<p>Java의 <code>Object.clone</code> / <code>java.lang.Cloneable</code> 메커니즘은 다음과 같은 이유로 문제가 있으므로 사용하면 안 됩니다:</p>\n<ul>\n  <li> <code>Cloneable</code>은 API가 없지만 컴파일러가 강제할 수 없는 클래스 동작에 대한 계약이 있는 <em>마커 인터페이스</em>입니다. 이것은 나쁜 관행입니다. </li>\n  <li> 생성자를 호출하지 않고 클래스가 인스턴스화되므로 가능한 전제 조건을 강제할 수 없습니다. </li>\n  <li> <code>Object.clone</code>을 오버라이드할 때 타입 캐스트나 <code>CloneNotSupportedException</code> 예외 처리와 같은 설계상의 구현 결함이 있습니다. </li>\n</ul>",
    "howToFix_ko": "<p>복사 생성자, 복사 팩토리 또는 사용자 정의 복사 함수가 <code>Object.clone</code> / <code>java.lang.Cloneable</code> 메커니즘의 적합한 대안입니다.</p>\n<p>다음 예시를 고려하세요:</p>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\nclass Entity implements Cloneable { // 규칙 위반, `Cloneable` 사용\n\n  public int value;\n  public List&lt;Entity&gt; children; // 깊은 복사 필요\n\n  Entity() {\n    EntityManager.register(this); // 불변 조건\n  }\n\n  @Override\n  public Entity clone() {\n    try {\n      Entity copy = (Entity) super.clone(); // 생성자가 호출되지 않으므로 불변 조건이 강제되지 않음\n      copy.children = children.stream().map(Entity::clone).toList();\n      return copy;\n    } catch (CloneNotSupportedException e) { // 동작 계약으로 인해 발생하지 않음\n      throw new AssertionError();\n    }\n  }\n}\n</pre>\n<p><code>Cloneable</code> / <code>Object.clone</code> 메커니즘은 복사 생성자로 쉽게 대체할 수 있습니다:</p>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\nclass Entity { // 규칙 준수\n\n  public int value;\n  public List&lt;Entity&gt; children; // 깊은 복사 필요\n\n  Entity() {\n    EntityManager.register(this); // 불변 조건\n  }\n\n  Entity(Entity template) {\n    value = template.value;\n    children = template.children.stream().map(Entity::new).toList();\n  }\n}\n</pre>\n<p>또는 팩토리 메서드로:</p>\n<pre>\nclass Entity { // 규칙 준수\n\n  public int value;\n  public List&lt;Entity&gt; children; // 깊은 복사 필요\n\n  Entity() {\n    EntityManager.register(this); // 불변 조건\n  }\n\n  public static Entity create(Entity template) {\n    Entity entity = new Entity();\n    entity.value = template.value;\n    entity.children = template.children.stream().map(Entity::new).toList();\n    return Entity;\n  }\n}\n</pre>\n<p>또는 사용자 정의 <code>copy</code> 함수로:</p>\n<pre>\nclass Entity { // 규칙 준수\n\n  public int value;\n  public List&lt;Entity&gt; children; // 깊은 복사 필요\n\n  Entity() {\n    EntityManager.register(this); // 불변 조건\n  }\n\n  public Entity copy() {\n    Entity entity = new Entity();\n    entity.value = value;\n    entity.children = children.stream().map(Entity::new).toList();\n    return Entity;\n  }\n}\n</pre>",
    "moreInfo_ko": "<h3>문서</h3>\n<ul>\n  <li> <a href=\"https://www.artima.com/intv/bloch13.html\">Joshua Bloch - Copy Constructor versus Cloning</a> </li>\n  <li> <a href=\"https://docs.oracle.com/javase/8/docs/api/java/lang/Cloneable.html\">Interface Cloneable - Java™ Platform, Standard Edition 8 API Specification</a> </li>\n  <li> <a href=\"https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html#clone--\">Object.clone - Java™ Platform, Standard Edition 8 API Specification</a> </li>\n</ul>\n<h3>관련 규칙</h3>\n<ul>\n  <li> <a href='/coding_rules#rule_key=java%3AS2157'>S2157</a> - \"Cloneable\"은 \"clone\"을 구현해야 합니다 </li>\n  <li> <a href='/coding_rules#rule_key=java%3AS1182'>S1182</a> - \"clone\"을 오버라이드하는 클래스는 \"Cloneable\"이어야 하고 \"super.clone()\"을 호출해야 합니다 </li>\n</ul>"
  },
  {
    "id": "S2133",
    "key": "java:S2133",
    "name": "Objects should not be created only to invoke \"getClass\"",
    "type": "code-smell",
    "severity": "major",
    "tags": [
      "performance"
    ],
    "why": "<p>Creating an object for the sole purpose of calling <code>getClass</code> on it is a waste of memory and cycles. Instead, simply use the class's\n<code>.class</code> property.</p>\n<h3>Noncompliant code example</h3>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\nMyObject myOb = new MyObject();  // Noncompliant\nClass c = myOb.getClass();\n</pre>\n<h3>Compliant solution</h3>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\nClass c = MyObject.class;\n</pre>",
    "howToFix": "",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "getClass 호출만을 위해 객체를 생성하면 안 됩니다",
    "why_ko": "<p><code>getClass</code>를 호출하기 위한 유일한 목적으로 객체를 생성하는 것은 메모리와 사이클의 낭비입니다. 대신 클래스의 <code>.class</code> 속성을 사용하세요.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\nMyObject myOb = new MyObject();  // 규칙 위반\nClass c = myOb.getClass();\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\nClass c = MyObject.class;\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": ""
  },
  {
    "id": "S3688",
    "key": "java:S3688",
    "name": "Track uses of disallowed classes",
    "type": "code-smell",
    "severity": "info",
    "tags": [],
    "why": "<p>This rule allows banning certain classes.</p>\n<h3>Noncompliant code example</h3>\n<p>Given parameters:</p>\n<ul>\n  <li> className:java.lang.String </li>\n</ul>\n<pre>\nString name;  // Noncompliant\n</pre>",
    "howToFix": "",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "허용되지 않은 클래스 사용을 추적합니다",
    "why_ko": "<p>이 규칙을 사용하면 특정 클래스를 금지할 수 있습니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<p>매개변수:</p>\n<ul>\n  <li> className:java.lang.String </li>\n</ul>\n<pre>\nString name;  // 규칙 위반\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": ""
  },
  {
    "id": "S1158",
    "key": "java:S1158",
    "name": "Primitive wrappers should not be instantiated only for \"toString\" or \"compareTo\" calls",
    "type": "code-smell",
    "severity": "minor",
    "tags": [
      "performance",
      "clumsy"
    ],
    "why": "<p>Creating temporary primitive wrapper objects only for <code>String</code> conversion or the use of the <code>compareTo()</code> method is\ninefficient.</p>\n<p>Instead, the static <code>toString()</code> or <code>compare()</code> method of the primitive wrapper class should be used.</p>\n<h3>Noncompliant code example</h3>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\nprivate int isZero(int value){\n    return Integer.valueOf(value).compareTo(0); // Noncompliant\n}\nprivate String convert(int value){\n    return Integer.valueOf(value).toString(); // Noncompliant\n}\n</pre>\n<h3>Compliant solution</h3>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\nprivate int isZero(int value){\n    return Integer.compare(value, 0); // Compliant\n}\nprivate String convert(int value){\n    return Integer.toString(value); // Compliant\n}\n</pre>",
    "howToFix": "",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "기본 타입 래퍼는 \"toString\"이나 \"compareTo\" 호출만을 위해 인스턴스화하면 안 됩니다",
    "why_ko": "<p><code>String</code> 변환이나 <code>compareTo()</code> 메서드 사용만을 위해 임시 기본 타입 래퍼 객체를 생성하는 것은 비효율적입니다.</p>\n<p>대신 기본 타입 래퍼 클래스의 static <code>toString()</code> 또는 <code>compare()</code> 메서드를 사용해야 합니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\nprivate int isZero(int value){\n    return Integer.valueOf(value).compareTo(0); // 규칙 위반\n}\nprivate String convert(int value){\n    return Integer.valueOf(value).toString(); // 규칙 위반\n}\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\nprivate int isZero(int value){\n    return Integer.compare(value, 0); // 규칙 준수\n}\nprivate String convert(int value){\n    return Integer.toString(value); // 규칙 준수\n}\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": ""
  },
  {
    "id": "S3923",
    "key": "java:S3923",
    "name": "All branches in a conditional structure should not have exactly the same implementation",
    "type": "bug",
    "severity": "major",
    "tags": [],
    "why": "<p>Having all branches of a <code>switch</code> or <code>if</code> chain with the same implementation indicates a problem.</p>\n<p>In the following code:</p>\n<pre>\nif (b == 0) {  // Noncompliant\n  doOneMoreThing();\n} else {\n  doOneMoreThing();\n}\n\nint b = a &gt; 12 ? 4 : 4;  // Noncompliant\n\nswitch (i) {  // Noncompliant\n  case 1:\n    doSomething();\n    break;\n  case 2:\n    doSomething();\n    break;\n  case 3:\n    doSomething();\n    break;\n  default:\n    doSomething();\n}\n</pre>\n<p>Either there is a copy-paste error that needs fixing or an unnecessary <code>switch</code> or <code>if</code> chain that should be removed.</p>\n<h3>Exceptions</h3>\n<p>This rule does not apply to <code>if</code> chains without <code>else</code>, nor to <code>switch</code> without a <code>default</code> clause.</p>\n<pre>\nif(b == 0) {    //no issue, this could have been done on purpose to make the code more readable\n  doSomething();\n} else if(b == 1) {\n  doSomething();\n}\n</pre>",
    "howToFix": "",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "조건 구조의 모든 분기가 동일한 구현을 가지면 안 됩니다",
    "why_ko": "<p><code>switch</code> 또는 <code>if</code> 체인의 모든 분기가 동일한 구현을 가지면 문제가 있음을 나타냅니다.</p>\n<p>다음 코드에서:</p>\n<pre>\nif (b == 0) {  // 규칙 위반\n  doOneMoreThing();\n} else {\n  doOneMoreThing();\n}\n\nint b = a &gt; 12 ? 4 : 4;  // 규칙 위반\n\nswitch (i) {  // 규칙 위반\n  case 1:\n    doSomething();\n    break;\n  case 2:\n    doSomething();\n    break;\n  case 3:\n    doSomething();\n    break;\n  default:\n    doSomething();\n}\n</pre>\n<p>수정이 필요한 복사-붙여넣기 오류이거나 제거해야 하는 불필요한 <code>switch</code> 또는 <code>if</code> 체인입니다.</p>\n<h3>예외</h3>\n<p>이 규칙은 <code>else</code>가 없는 <code>if</code> 체인이나 <code>default</code> 절이 없는 <code>switch</code>에는 적용되지 않습니다.</p>\n<pre>\nif(b == 0) {    //문제 없음, 코드 가독성을 높이기 위해 의도적으로 이렇게 했을 수 있습니다\n  doSomething();\n} else if(b == 1) {\n  doSomething();\n}\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": ""
  },
  {
    "id": "S3020",
    "key": "java:S3020",
    "name": "\"Collection.toArray()\" should be passed an array of the proper type",
    "type": "bug",
    "severity": "minor",
    "tags": [],
    "why": "<p>The <code>Collection.toArray()</code> method returns an <code>Object[]</code> when no arguments are provided to it. This can lead to a\n<code>ClassCastException</code> at runtime if you try to cast the returned array to an array of a specific type. Instead, use this method by providing\nan array of the desired type as the argument.</p>\n<p>Note that passing a <code>new T[0]</code> array of length zero as the argument is more efficient than a pre-sized array <code>new\nT[size]</code>.</p>\n\n<h4>Noncompliant code example</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\npublic String [] getStringArray(List&lt;String&gt; strings) {\n  return (String []) strings.toArray();  // Noncompliant, a ClassCastException will be thrown here\n}\n</pre>\n<h4>Compliant solution</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\npublic String [] getStringArray(List&lt;String&gt; strings) {\n  return strings.toArray(new String[0]); // Compliant, the toArray method will return an array of the desired type, and we can remove the casting operation\n}\npublic String [] getPresizedStringArray(List&lt;String&gt; strings) {\n  return strings.toArray(new String[strings.size()]); // Compliant, but slightly less efficient than the previous example\n}\n</pre>",
    "howToFix": "",
    "moreInfo": "<ul>\n  <li> <a href=\"https://docs.oracle.com/javase/8/docs/api/java/util/Collection.html#toArray-T:A-\">docs.oracle</a> - Collection.toArray() </li>\n</ul>",
    "status": "READY",
    "name_ko": "\"Collection.toArray()\"에는 적절한 타입의 배열을 전달해야 합니다",
    "why_ko": "<p><code>Collection.toArray()</code> 메서드는 인자가 제공되지 않으면 <code>Object[]</code>를 반환합니다. 이로 인해 반환된 배열을 특정 타입의 배열로 캐스팅하려고 하면 런타임에 <code>ClassCastException</code>이 발생할 수 있습니다. 대신 원하는 타입의 배열을 인자로 제공하여 이 메서드를 사용하세요.</p>\n<p>길이가 0인 <code>new T[0]</code> 배열을 인자로 전달하는 것이 미리 크기가 지정된 <code>new T[size]</code> 배열보다 더 효율적입니다.</p>\n\n<h4>규칙을 준수하지 않는 코드 예시</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\npublic String [] getStringArray(List&lt;String&gt; strings) {\n  return (String []) strings.toArray();  // 규칙 위반, 여기서 ClassCastException이 발생합니다\n}\n</pre>\n<h4>규칙을 준수하는 해결책</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\npublic String [] getStringArray(List&lt;String&gt; strings) {\n  return strings.toArray(new String[0]); // 규칙 준수, toArray 메서드가 원하는 타입의 배열을 반환하고 캐스팅 연산을 제거할 수 있습니다\n}\npublic String [] getPresizedStringArray(List&lt;String&gt; strings) {\n  return strings.toArray(new String[strings.size()]); // 규칙 준수, 하지만 이전 예시보다 약간 덜 효율적입니다\n}\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": "<ul>\n  <li> <a href=\"https://docs.oracle.com/javase/8/docs/api/java/util/Collection.html#toArray-T:A-\">docs.oracle</a> - Collection.toArray() </li>\n</ul>"
  },
  {
    "id": "S2148",
    "key": "java:S2148",
    "name": "Underscores should be used to make large numbers readable",
    "type": "code-smell",
    "severity": "minor",
    "tags": [
      "convention"
    ],
    "why": "<p>Beginning with Java 7, it is possible to add underscores ('_') to numeric literals to enhance readability. The addition of underscores in this\nmanner has no semantic meaning, but makes it easier for maintainers to understand the code.</p>\n<p>The number of digits to the left of a decimal point needed to trigger this rule varies by base.</p>\n<table>\n  <colgroup>\n    <col style=\"width: 50%;\">\n    <col style=\"width: 50%;\">\n  </colgroup>\n  <thead>\n    <tr>\n      <th>Base</th>\n      <th>Minimum digits</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td><p>binary</p></td>\n      <td><p>9</p></td>\n    </tr>\n    <tr>\n      <td><p>octal</p></td>\n      <td><p>9</p></td>\n    </tr>\n    <tr>\n      <td><p>decimal</p></td>\n      <td><p>6</p></td>\n    </tr>\n    <tr>\n      <td><p>hexadecimal</p></td>\n      <td><p>9</p></td>\n    </tr>\n  </tbody>\n</table>\n<p>It is only the presence of underscores, not their spacing that is scrutinized by this rule.</p>\n<p><strong>Note</strong> that this rule is automatically disabled when the project's <code>sonar.java.source</code> is lower than <code>7</code>.</p>\n<h3>Noncompliant code example</h3>\n<pre>\nint i = 10000000;  // Noncompliant; is this 10 million or 100 million?\nint  j = 0b01101001010011011110010101011110;  // Noncompliant\nlong l = 0x7fffffffffffffffL;  // Noncompliant\n</pre>\n<h3>Compliant solution</h3>\n<pre>\nint i = 10_000_000;\nint  j = 0b01101001_01001101_11100101_01011110;\nlong l = 0x7fff_ffff_ffff_ffffL;\n</pre>",
    "howToFix": "",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "큰 숫자의 가독성을 위해 밑줄을 사용해야 합니다",
    "why_ko": "<p>Java 7부터 가독성을 높이기 위해 숫자 리터럴에 밑줄('_')을 추가할 수 있습니다. 이러한 방식의 밑줄 추가는 의미론적 의미가 없지만 유지보수자가 코드를 이해하기 쉽게 만듭니다.</p>\n<p>이 규칙을 트리거하는 데 필요한 소수점 왼쪽의 자릿수는 진법에 따라 다릅니다.</p>\n<table>\n  <colgroup>\n    <col style=\"width: 50%;\">\n    <col style=\"width: 50%;\">\n  </colgroup>\n  <thead>\n    <tr>\n      <th>진법</th>\n      <th>최소 자릿수</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td><p>이진법</p></td>\n      <td><p>9</p></td>\n    </tr>\n    <tr>\n      <td><p>팔진법</p></td>\n      <td><p>9</p></td>\n    </tr>\n    <tr>\n      <td><p>십진법</p></td>\n      <td><p>6</p></td>\n    </tr>\n    <tr>\n      <td><p>십육진법</p></td>\n      <td><p>9</p></td>\n    </tr>\n  </tbody>\n</table>\n<p>이 규칙은 밑줄의 존재 여부만 검사하며 간격은 검사하지 않습니다.</p>\n<p><strong>참고</strong>: 이 규칙은 프로젝트의 <code>sonar.java.source</code>가 <code>7</code> 미만일 때 자동으로 비활성화됩니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\nint i = 10000000;  // 규칙 위반; 이것이 1천만인가요 1억인가요?\nint  j = 0b01101001010011011110010101011110;  // 규칙 위반\nlong l = 0x7fffffffffffffffL;  // 규칙 위반\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre>\nint i = 10_000_000;\nint  j = 0b01101001_01001101_11100101_01011110;\nlong l = 0x7fff_ffff_ffff_ffffL;\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": ""
  },
  {
    "id": "S1764",
    "key": "java:S1764",
    "name": "Identical expressions should not be used on both sides of a binary operator",
    "type": "bug",
    "severity": "major",
    "tags": [
      "cert"
    ],
    "why": "<p>Using the same value on both sides of a binary operator is a code defect. In the case of logical operators, it is either a copy/paste error and,\ntherefore, a bug, or it is simply duplicated code and should be simplified. In the case of bitwise operators and most binary mathematical operators,\nhaving the same value on both sides of an operator yields predictable results and should be simplified as well.</p>\n<h3>Noncompliant code example</h3>\n<pre>\nif ( a == a ) { // always true\n  doZ();\n}\nif ( a != a ) { // always false\n  doY();\n}\nif ( a == b &amp;&amp; a == b ) { // if the first one is true, the second one is too\n  doX();\n}\nif ( a == b || a == b ) { // if the first one is true, the second one is too\n  doW();\n}\n\nint j = 5 / 5; //always 1\nint k = 5 - 5; //always 0\n\nc.equals(c); //always true\n</pre>\n<h3>Exceptions</h3>\n<ul>\n  <li> This rule ignores <code>*</code>, <code>+</code>, and <code>=</code>. </li>\n  <li> The specific case of testing a floating point value against itself is a valid test for <code>NaN</code> and is therefore ignored. </li>\n  <li> Similarly, left-shifting 1 onto 1 is common in the construction of bit masks, and is ignored. </li>\n</ul>\n<pre>\nfloat f;\nif(f != f) { //test for NaN value\n  System.out.println(\"f is NaN\");\n}\n\nint i = 1 &lt;&lt; 1; // Compliant\nint j = a &lt;&lt; a; // Noncompliant\n</pre>",
    "howToFix": "",
    "moreInfo": "<ul>\n  <li> <a href=\"https://wiki.sei.cmu.edu/confluence/x/5dUxBQ\">CERT, MSC12-C.</a> - Detect and remove code that has no effect or is never executed\n  </li>\n  <li> <a href='/coding_rules#rule_key=java%3AS1656'>S1656</a> - Implements a check on <code>=</code>. </li>\n</ul>",
    "status": "READY",
    "name_ko": "이항 연산자의 양쪽에 동일한 표현식을 사용하면 안 됩니다",
    "why_ko": "<p>이항 연산자의 양쪽에 동일한 값을 사용하는 것은 코드 결함입니다. 논리 연산자의 경우 복사/붙여넣기 오류이므로 버그이거나, 단순히 중복된 코드이므로 단순화해야 합니다. 비트 연산자와 대부분의 이항 수학 연산자의 경우, 연산자 양쪽에 동일한 값이 있으면 예측 가능한 결과가 나오므로 역시 단순화해야 합니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\nif ( a == a ) { // 항상 true\n  doZ();\n}\nif ( a != a ) { // 항상 false\n  doY();\n}\nif ( a == b &amp;&amp; a == b ) { // 첫 번째가 true이면 두 번째도 true\n  doX();\n}\nif ( a == b || a == b ) { // 첫 번째가 true이면 두 번째도 true\n  doW();\n}\n\nint j = 5 / 5; //항상 1\nint k = 5 - 5; //항상 0\n\nc.equals(c); //항상 true\n</pre>\n<h3>예외</h3>\n<ul>\n  <li> 이 규칙은 <code>*</code>, <code>+</code>, <code>=</code>는 무시합니다. </li>\n  <li> 부동 소수점 값을 자기 자신과 비교하는 특수한 경우는 <code>NaN</code> 테스트로 유효하므로 무시됩니다. </li>\n  <li> 마찬가지로, 1을 1만큼 왼쪽으로 시프트하는 것은 비트 마스크 구성에서 일반적이므로 무시됩니다. </li>\n</ul>\n<pre>\nfloat f;\nif(f != f) { //NaN 값 테스트\n  System.out.println(\"f is NaN\");\n}\n\nint i = 1 &lt;&lt; 1; // 규칙 준수\nint j = a &lt;&lt; a; // 규칙 위반\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": "<ul>\n  <li> <a href=\"https://wiki.sei.cmu.edu/confluence/x/5dUxBQ\">CERT, MSC12-C.</a> - 효과가 없거나 실행되지 않는 코드를 감지하고 제거하세요 </li>\n  <li> <a href='/coding_rules#rule_key=java%3AS1656'>S1656</a> - <code>=</code>에 대한 검사를 구현합니다. </li>\n</ul>"
  },
  {
    "id": "S4423",
    "key": "java:S4423",
    "name": "Weak SSL/TLS protocols should not be used",
    "type": "vulnerability",
    "severity": "critical",
    "tags": [
      "cwe",
      "privacy"
    ],
    "why": "<p>Encryption algorithms are essential for protecting sensitive information and ensuring secure communications in a variety of domains. They are used\nfor several important reasons:</p>\n<ul>\n  <li> Confidentiality, privacy, and intellectual property protection </li>\n  <li> Security during transmission or on storage devices </li>\n  <li> Data integrity, general trust, and authentication </li>\n</ul>\n<p>When selecting encryption algorithms, tools, or combinations, you should also consider two things:</p>\n<ol>\n  <li> No encryption is unbreakable. </li>\n  <li> The strength of an encryption algorithm is usually measured by the effort required to crack it within a reasonable time frame. </li>\n</ol>\n<p>For these reasons, as soon as cryptography is included in a project, it is important to choose encryption algorithms that are considered strong and\nsecure by the cryptography community.</p>\n<p>To provide communication security over a network, SSL and TLS are generally used. However, it is important to note that the following protocols are\nall considered weak by the cryptographic community, and are officially deprecated:</p>\n<ul>\n  <li> SSL versions 1.0, 2.0 and 3.0 </li>\n  <li> TLS versions 1.0 and 1.1 </li>\n</ul>\n<p>When these unsecured protocols are used, it is best practice to expect a breach: that a user or organization with malicious intent will perform\nmathematical attacks on this data after obtaining it by other means.</p>\n<h3>What is the potential impact?</h3>\n<p>After retrieving encrypted data and performing cryptographic attacks on it on a given timeframe, attackers can recover the plaintext that\nencryption was supposed to protect.</p>\n<p>Depending on the recovered data, the impact may vary.</p>\n<p>Below are some real-world scenarios that illustrate the potential impact of an attacker exploiting the vulnerability.</p>\n<h4>Additional attack surface</h4>\n<p>By modifying the plaintext of the encrypted message, an attacker may be able to trigger additional vulnerabilities in the code. An attacker can\nfurther exploit a system to obtain more information.<br> Encrypted values are often considered trustworthy because it would not be possible for a\nthird party to modify them under normal circumstances.</p>\n<h4>Breach of confidentiality and privacy</h4>\n<p>When encrypted data contains personal or sensitive information, its retrieval by an attacker can lead to privacy violations, identity theft,\nfinancial loss, reputational damage, or unauthorized access to confidential systems.</p>\n<p>In this scenario, the company, its employees, users, and partners could be seriously affected.</p>\n<p>The impact is twofold, as data breaches and exposure of encrypted data can undermine trust in the organization, as customers, clients and\nstakeholders may lose confidence in the organization's ability to protect their sensitive data.</p>\n<h4>Legal and compliance issues</h4>\n<p>In many industries and locations, there are legal and compliance requirements to protect sensitive data. If encrypted data is compromised and the\nplaintext can be recovered, companies face legal consequences, penalties, or violations of privacy laws.</p>",
    "howToFix": "<h4>Noncompliant code example</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\nimport javax.net.ssl.SSLContext;\nimport java.security.NoSuchAlgorithmException;\n\npublic static void main(String[] args) {\n    try {\n        SSLContext.getInstance(\"TLSv1.1\"); // Noncompliant\n    } catch (NoSuchAlgorithmException e) {\n        // ...\n    }\n}\n</pre>\n<h4>Compliant solution</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\nimport javax.net.ssl.SSLContext;\nimport java.security.NoSuchAlgorithmException;\n\npublic static void main(String[] args) {\n    try {\n        SSLContext.getInstance(\"TLSv1.2\");\n    } catch (NoSuchAlgorithmException e) {\n        // ...\n    }\n}\n</pre>\n<h3>How does this work?</h3>\n<p>As a rule of thumb, by default you should use the cryptographic algorithms and mechanisms that are considered strong by the cryptographic\ncommunity.</p>\n<p>The best choices at the moment are the following.</p>\n<h4>Use TLS v1.2 or TLS v1.3</h4>\n<p>Even though TLS V1.3 is available, using TLS v1.2 is still considered good and secure practice by the cryptography community.<br></p>\n<p>The use of TLS v1.2 ensures compatibility with a wide range of platforms and enables seamless communication between different systems that do not\nyet have TLS v1.3 support.</p>\n<p>The only drawback depends on whether the framework used is outdated: its TLS v1.2 settings may enable older and insecure cipher suites that are\ndeprecated as insecure.</p>\n<p>On the other hand, TLS v1.3 removes support for older and weaker cryptographic algorithms, eliminates known vulnerabilities from previous TLS\nversions, and improves performance.</p>",
    "moreInfo": "<h3>Articles &amp; blog posts</h3>\n<ul>\n  <li> <a href=\"https://en.wikipedia.org/wiki/Padding_oracle_attack\">Wikipedia, Padding Oracle Attack</a> </li>\n  <li> <a href=\"https://en.wikipedia.org/wiki/Chosen-ciphertext_attack\">Wikipedia, Chosen-Ciphertext Attack</a> </li>\n  <li> <a href=\"https://en.wikipedia.org/wiki/Chosen-plaintext_attack\">Wikipedia, Chosen-Plaintext Attack</a> </li>\n  <li> <a href=\"https://en.wikipedia.org/wiki/Semantic_security\">Wikipedia, Semantically Secure Cryptosystems</a> </li>\n  <li> <a href=\"https://en.wikipedia.org/wiki/Optimal_asymmetric_encryption_padding\">Wikipedia, OAEP</a> </li>\n  <li> <a href=\"https://en.wikipedia.org/wiki/Galois/Counter_Mode\">Wikipedia, Galois/Counter Mode</a> </li>\n</ul>\n<h3>Standards</h3>\n<ul>\n  <li> OWASP - <a href=\"https://owasp.org/Top10/A02_2021-Cryptographic_Failures/\">Top 10 2021 Category A2 - Cryptographic Failures</a> </li>\n  <li> OWASP - <a href=\"https://owasp.org/Top10/A07_2021-Identification_and_Authentication_Failures/\">Top 10 2021 Category A7 - Identification and\n  Authentication Failures</a> </li>\n  <li> OWASP - <a href=\"https://owasp.org/www-project-top-ten/2017/A3_2017-Sensitive_Data_Exposure\">Top 10 2017 Category A3 - Sensitive Data\n  Exposure</a> </li>\n  <li> OWASP - <a href=\"https://owasp.org/www-project-top-ten/2017/A6_2017-Security_Misconfiguration\">Top 10 2017 Category A6 - Security\n  Misconfiguration</a> </li>\n  <li> OWASP - <a href=\"https://mas.owasp.org/checklists/MASVS-CRYPTO/\">Mobile AppSec Verification Standard - Cryptography Requirements</a> </li>\n  <li> OWASP - <a href=\"https://owasp.org/www-project-mobile-top-10/2016-risks/m5-insufficient-cryptography\">Mobile Top 10 2016 Category M5 -\n  Insufficient Cryptography</a> </li>\n  <li> OWASP - <a href=\"https://owasp.org/www-project-mobile-top-10/2023-risks/m5-insecure-communication\">Mobile Top 10 2024 Category M5 - Insecure\n  Communication</a> </li>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/327\">CWE-327 - Use of a Broken or Risky Cryptographic Algorithm</a> </li>\n  <li> <a href=\"https://wiki.sei.cmu.edu/confluence/x/hDdGBQ\">CERT, MSC61-J.</a> - Do not use insecure or weak cryptographic algorithms </li>\n</ul>",
    "status": "READY",
    "name_ko": "취약한 SSL/TLS 프로토콜을 사용하면 안 됩니다",
    "why_ko": "<p>암호화 알고리즘은 다양한 도메인에서 민감한 정보를 보호하고 안전한 통신을 보장하는 데 필수적입니다. 여러 중요한 이유로 사용됩니다:</p>\n<ul>\n  <li> 기밀성, 개인정보 보호, 지적 재산 보호 </li>\n  <li> 전송 중 또는 저장 장치에서의 보안 </li>\n  <li> 데이터 무결성, 일반적인 신뢰, 인증 </li>\n</ul>\n<p>암호화 알고리즘, 도구 또는 조합을 선택할 때 두 가지를 고려해야 합니다:</p>\n<ol>\n  <li> 깨지지 않는 암호화는 없습니다. </li>\n  <li> 암호화 알고리즘의 강도는 일반적으로 합리적인 시간 내에 해독하는 데 필요한 노력으로 측정됩니다. </li>\n</ol>\n<p>이러한 이유로 프로젝트에 암호화가 포함되면 암호화 커뮤니티에서 강력하고 안전하다고 간주하는 암호화 알고리즘을 선택하는 것이 중요합니다.</p>\n<p>네트워크를 통한 통신 보안을 제공하기 위해 일반적으로 SSL과 TLS가 사용됩니다. 그러나 다음 프로토콜은 모두 암호화 커뮤니티에서 취약하다고 간주되며 공식적으로 더 이상 사용되지 않습니다:</p>\n<ul>\n  <li> SSL 버전 1.0, 2.0 및 3.0 </li>\n  <li> TLS 버전 1.0 및 1.1 </li>\n</ul>\n<p>이러한 보안되지 않은 프로토콜을 사용할 때는 침해를 예상하는 것이 가장 좋습니다: 악의적인 의도를 가진 사용자나 조직이 다른 수단으로 이 데이터를 획득한 후 수학적 공격을 수행할 것입니다.</p>\n<h3>잠재적 영향은 무엇인가요?</h3>\n<p>암호화된 데이터를 검색하고 주어진 시간 내에 암호화 공격을 수행한 후, 공격자는 암호화가 보호해야 했던 평문을 복구할 수 있습니다.</p>\n<p>복구된 데이터에 따라 영향은 다양할 수 있습니다.</p>\n<p>아래는 공격자가 취약점을 악용할 때의 잠재적 영향을 보여주는 실제 시나리오입니다.</p>\n<h4>추가적인 공격 표면</h4>\n<p>암호화된 메시지의 평문을 수정함으로써 공격자는 코드에서 추가적인 취약점을 유발할 수 있습니다. 공격자는 시스템을 더 악용하여 더 많은 정보를 얻을 수 있습니다.<br> 암호화된 값은 일반적인 상황에서 제3자가 수정할 수 없기 때문에 종종 신뢰할 수 있는 것으로 간주됩니다.</p>\n<h4>기밀성 및 개인정보 침해</h4>\n<p>암호화된 데이터에 개인 또는 민감한 정보가 포함되어 있는 경우, 공격자에 의한 검색은 개인정보 침해, 신원 도용, 재정적 손실, 평판 손상 또는 기밀 시스템에 대한 무단 액세스로 이어질 수 있습니다.</p>\n<p>이 시나리오에서 회사, 직원, 사용자 및 파트너가 심각하게 영향을 받을 수 있습니다.</p>\n<p>영향은 두 가지입니다. 데이터 유출 및 암호화된 데이터 노출은 조직에 대한 신뢰를 약화시킬 수 있으며, 고객 및 이해 관계자가 민감한 데이터를 보호하는 조직의 능력에 대한 신뢰를 잃을 수 있습니다.</p>\n<h4>법적 및 규정 준수 문제</h4>\n<p>많은 산업 및 지역에서 민감한 데이터를 보호하기 위한 법적 및 규정 준수 요구 사항이 있습니다. 암호화된 데이터가 손상되고 평문을 복구할 수 있는 경우 회사는 법적 결과, 처벌 또는 개인정보 보호법 위반에 직면합니다.</p>",
    "howToFix_ko": "<h4>규칙을 준수하지 않는 코드 예시</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\nimport javax.net.ssl.SSLContext;\nimport java.security.NoSuchAlgorithmException;\n\npublic static void main(String[] args) {\n    try {\n        SSLContext.getInstance(\"TLSv1.1\"); // 규칙 위반\n    } catch (NoSuchAlgorithmException e) {\n        // ...\n    }\n}\n</pre>\n<h4>규칙을 준수하는 해결책</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\nimport javax.net.ssl.SSLContext;\nimport java.security.NoSuchAlgorithmException;\n\npublic static void main(String[] args) {\n    try {\n        SSLContext.getInstance(\"TLSv1.2\");\n    } catch (NoSuchAlgorithmException e) {\n        // ...\n    }\n}\n</pre>\n<h3>어떻게 작동하나요?</h3>\n<p>경험상 기본적으로 암호화 커뮤니티에서 강력하다고 간주하는 암호화 알고리즘과 메커니즘을 사용해야 합니다.</p>\n<p>현재 최선의 선택은 다음과 같습니다.</p>\n<h4>TLS v1.2 또는 TLS v1.3 사용</h4>\n<p>TLS V1.3을 사용할 수 있지만, TLS v1.2 사용은 여전히 암호화 커뮤니티에서 좋고 안전한 관행으로 간주됩니다.<br></p>\n<p>TLS v1.2 사용은 다양한 플랫폼과의 호환성을 보장하고 아직 TLS v1.3을 지원하지 않는 다른 시스템 간의 원활한 통신을 가능하게 합니다.</p>\n<p>유일한 단점은 사용된 프레임워크가 구식인지에 따라 달라집니다: TLS v1.2 설정이 안전하지 않은 것으로 더 이상 사용되지 않는 이전 및 안전하지 않은 암호 모음을 활성화할 수 있습니다.</p>\n<p>반면 TLS v1.3은 이전 및 약한 암호화 알고리즘에 대한 지원을 제거하고, 이전 TLS 버전의 알려진 취약점을 제거하며, 성능을 향상시킵니다.</p>",
    "moreInfo_ko": "<h3>기사 및 블로그 게시물</h3>\n<ul>\n  <li> <a href=\"https://en.wikipedia.org/wiki/Padding_oracle_attack\">Wikipedia, Padding Oracle Attack</a> </li>\n  <li> <a href=\"https://en.wikipedia.org/wiki/Chosen-ciphertext_attack\">Wikipedia, Chosen-Ciphertext Attack</a> </li>\n  <li> <a href=\"https://en.wikipedia.org/wiki/Chosen-plaintext_attack\">Wikipedia, Chosen-Plaintext Attack</a> </li>\n  <li> <a href=\"https://en.wikipedia.org/wiki/Semantic_security\">Wikipedia, Semantically Secure Cryptosystems</a> </li>\n  <li> <a href=\"https://en.wikipedia.org/wiki/Optimal_asymmetric_encryption_padding\">Wikipedia, OAEP</a> </li>\n  <li> <a href=\"https://en.wikipedia.org/wiki/Galois/Counter_Mode\">Wikipedia, Galois/Counter Mode</a> </li>\n</ul>\n<h3>표준</h3>\n<ul>\n  <li> OWASP - <a href=\"https://owasp.org/Top10/A02_2021-Cryptographic_Failures/\">Top 10 2021 Category A2 - Cryptographic Failures</a> </li>\n  <li> OWASP - <a href=\"https://owasp.org/Top10/A07_2021-Identification_and_Authentication_Failures/\">Top 10 2021 Category A7 - Identification and Authentication Failures</a> </li>\n  <li> OWASP - <a href=\"https://owasp.org/www-project-top-ten/2017/A3_2017-Sensitive_Data_Exposure\">Top 10 2017 Category A3 - Sensitive Data Exposure</a> </li>\n  <li> OWASP - <a href=\"https://owasp.org/www-project-top-ten/2017/A6_2017-Security_Misconfiguration\">Top 10 2017 Category A6 - Security Misconfiguration</a> </li>\n  <li> OWASP - <a href=\"https://mas.owasp.org/checklists/MASVS-CRYPTO/\">Mobile AppSec Verification Standard - Cryptography Requirements</a> </li>\n  <li> OWASP - <a href=\"https://owasp.org/www-project-mobile-top-10/2016-risks/m5-insufficient-cryptography\">Mobile Top 10 2016 Category M5 - Insufficient Cryptography</a> </li>\n  <li> OWASP - <a href=\"https://owasp.org/www-project-mobile-top-10/2023-risks/m5-insecure-communication\">Mobile Top 10 2024 Category M5 - Insecure Communication</a> </li>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/327\">CWE-327 - Use of a Broken or Risky Cryptographic Algorithm</a> </li>\n  <li> <a href=\"https://wiki.sei.cmu.edu/confluence/x/hDdGBQ\">CERT, MSC61-J.</a> - Do not use insecure or weak cryptographic algorithms </li>\n</ul>"
  },
  {
    "id": "S4970",
    "key": "java:S4970",
    "name": "Derived exceptions should not hide their parents' catch blocks",
    "type": "code-smell",
    "severity": "critical",
    "tags": [],
    "why": "<p>The <code>catch</code> block of a checked exception \"E\" may be hidden because the corresponding <code>try</code> block only throws exceptions\nderived from E.</p>\n<p>These derived exceptions are handled in dedicated <code>catch</code> blocks prior to the <code>catch</code> block of the base exception E.</p>\n<p>The <code>catch</code> block of E is unreachable and should be considered dead code. It should be removed, or the entire try-catch structure should\nbe refactored.</p>\n<p>It is also possible that a single exception type in a multi-catch block may be hidden while the catch block itself is still reachable. In that case\nit is enough to only remove the hidden exception type or to replace it with another type.</p>\n<h3>Noncompliant code example</h3>\n<pre>\npublic class HiddenCatchBlock {\n\n  public static class CustomException extends Exception {\n  }\n\n  public static class CustomDerivedException extends CustomException {\n  }\n\n  public static void main(String[] args) {\n    try {\n      throwCustomDerivedException();\n    } catch(CustomDerivedException e) {\n      // ...\n    } catch(CustomException e) { // Noncompliant; this code is unreachable\n      // ...\n    }\n  }\n\n  private static void throwCustomDerivedException() throws CustomDerivedException {\n    throw new CustomDerivedException();\n  }\n}\n</pre>\n<h3>Compliant solution</h3>\n<pre>\npublic class HiddenCatchBlock {\n\n  public static class CustomException extends Exception {\n  }\n\n  public static class CustomDerivedException extends CustomException {\n  }\n\n  public static void main(String[] args) {\n    try {\n      throwCustomDerivedException();\n    } catch(CustomDerivedException e) { // Compliant; try-catch block is \"catching\" only the Exception that can be thrown in the \"try\"\n      //...\n    }\n  }\n}\n</pre>",
    "howToFix": "",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "파생 예외가 부모의 catch 블록을 숨기면 안 됩니다",
    "why_ko": "<p>체크된 예외 \"E\"의 <code>catch</code> 블록은 해당 <code>try</code> 블록이 E에서 파생된 예외만 던지기 때문에 숨겨질 수 있습니다.</p>\n<p>이러한 파생 예외는 기본 예외 E의 <code>catch</code> 블록 이전에 전용 <code>catch</code> 블록에서 처리됩니다.</p>\n<p>E의 <code>catch</code> 블록은 도달할 수 없으며 죽은 코드로 간주해야 합니다. 제거하거나 전체 try-catch 구조를 리팩토링해야 합니다.</p>\n<p>멀티 catch 블록에서 단일 예외 타입이 숨겨지면서 catch 블록 자체는 여전히 도달 가능한 경우도 있습니다. 이 경우 숨겨진 예외 타입만 제거하거나 다른 타입으로 교체하면 됩니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\npublic class HiddenCatchBlock {\n\n  public static class CustomException extends Exception {\n  }\n\n  public static class CustomDerivedException extends CustomException {\n  }\n\n  public static void main(String[] args) {\n    try {\n      throwCustomDerivedException();\n    } catch(CustomDerivedException e) {\n      // ...\n    } catch(CustomException e) { // 규칙 위반; 이 코드는 도달할 수 없음\n      // ...\n    }\n  }\n\n  private static void throwCustomDerivedException() throws CustomDerivedException {\n    throw new CustomDerivedException();\n  }\n}\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre>\npublic class HiddenCatchBlock {\n\n  public static class CustomException extends Exception {\n  }\n\n  public static class CustomDerivedException extends CustomException {\n  }\n\n  public static void main(String[] args) {\n    try {\n      throwCustomDerivedException();\n    } catch(CustomDerivedException e) { // 규칙 준수; try-catch 블록이 \"try\"에서 던질 수 있는 예외만 \"잡고\" 있음\n      //...\n    }\n  }\n}\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": ""
  },
  {
    "id": "S2689",
    "key": "java:S2689",
    "name": "Files opened in append mode should not be used with \"ObjectOutputStream\"",
    "type": "bug",
    "severity": "blocker",
    "tags": [
      "serialization",
      "symbolic-execution"
    ],
    "why": "<p>An <code>ObjectOutputStream</code> writes primitive data types and graphs of Java objects to an <code>OutputStream</code>. The objects can be read\n(reconstituted) using an <code>ObjectInputStream</code>.</p>\n<p>When <code>ObjectOutputStream</code> is used with files opened in append mode, it can cause data corruption and unexpected behavior. This is\nbecause when <code>ObjectOutputStream</code> is created, it writes metadata to the output stream, which can conflict with the existing metadata when\nthe file is opened in append mode. This can lead to errors and data loss.</p>\n<p>When used with serialization, an <code>ObjectOutputStream</code> first writes the serialization stream header. This header should appear once per\nfile at the beginning. When you're trying to read your object(s) back from the file, only the first one will be read successfully, and a\n<code>StreamCorruptedException</code> will be thrown after that.</p>",
    "howToFix": "<p>Open the file to use the default action (writes stream header).</p>\n\n<h4>Noncompliant code example</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\nFileOutputStream fos = new FileOutputStream(fileName , true);  // fos opened in append mode\nObjectOutputStream out = new ObjectOutputStream(fos);  // Noncompliant\n</pre>\n<h4>Compliant solution</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\nFileOutputStream fos = new FileOutputStream(fileName);\nObjectOutputStream out = new ObjectOutputStream(fos);\n</pre>",
    "moreInfo": "<h3>Articles &amp; blog posts</h3>\n<ul>\n  <li> <a href=\"https://docs.jboss.org/jbossas/javadoc/4.0.2/org/jboss/util/stream/AppendingObjectOutputStream.java.html\">JBoss -\n  AppendingObjectOutputStream</a> </li>\n</ul>\n<h3>Documentation</h3>\n<ul>\n  <li> <a href=\"https://docs.oracle.com/en/java/javase/20/docs/api/java.base/java/io/ObjectOutputStream.html\">Oracle SE 20 - ObjectOutputStream</a>\n  </li>\n</ul>",
    "status": "READY",
    "name_ko": "추가 모드로 열린 파일은 \"ObjectOutputStream\"과 함께 사용하면 안 됩니다",
    "why_ko": "<p><code>ObjectOutputStream</code>은 기본 데이터 타입과 Java 객체의 그래프를 <code>OutputStream</code>에 씁니다. 객체는 <code>ObjectInputStream</code>을 사용하여 읽을(재구성할) 수 있습니다.</p>\n<p><code>ObjectOutputStream</code>이 추가 모드로 열린 파일과 함께 사용되면 데이터 손상과 예기치 않은 동작을 유발할 수 있습니다. 이는 <code>ObjectOutputStream</code>이 생성될 때 출력 스트림에 메타데이터를 쓰는데, 파일이 추가 모드로 열릴 때 기존 메타데이터와 충돌할 수 있기 때문입니다. 이로 인해 오류와 데이터 손실이 발생할 수 있습니다.</p>\n<p>직렬화와 함께 사용될 때 <code>ObjectOutputStream</code>은 먼저 직렬화 스트림 헤더를 씁니다. 이 헤더는 파일의 시작 부분에 한 번만 나타나야 합니다. 파일에서 객체를 다시 읽으려고 할 때 첫 번째 객체만 성공적으로 읽히고 그 후에는 <code>StreamCorruptedException</code>이 발생합니다.</p>",
    "howToFix_ko": "<p>기본 동작(스트림 헤더 쓰기)을 사용하도록 파일을 엽니다.</p>\n\n<h4>규칙을 준수하지 않는 코드 예시</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\nFileOutputStream fos = new FileOutputStream(fileName , true);  // fos가 추가 모드로 열림\nObjectOutputStream out = new ObjectOutputStream(fos);  // 규칙 위반\n</pre>\n<h4>규칙을 준수하는 해결책</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\nFileOutputStream fos = new FileOutputStream(fileName);\nObjectOutputStream out = new ObjectOutputStream(fos);\n</pre>",
    "moreInfo_ko": "<h3>기사 및 블로그 포스트</h3>\n<ul>\n  <li> <a href=\"https://docs.jboss.org/jbossas/javadoc/4.0.2/org/jboss/util/stream/AppendingObjectOutputStream.java.html\">JBoss -\n  AppendingObjectOutputStream</a> </li>\n</ul>\n<h3>문서</h3>\n<ul>\n  <li> <a href=\"https://docs.oracle.com/en/java/javase/20/docs/api/java.base/java/io/ObjectOutputStream.html\">Oracle SE 20 - ObjectOutputStream</a>\n  </li>\n</ul>"
  },
  {
    "id": "S3077",
    "key": "java:S3077",
    "name": "Non-primitive fields should not be \"volatile\"",
    "type": "bug",
    "severity": "minor",
    "tags": [
      "multi-threading",
      "cert"
    ],
    "why": "<p>Marking an array <code>volatile</code> means that the array itself will always be read fresh and never thread cached, but the items <em>in</em> the\narray will not be. Similarly, marking a mutable object field <code>volatile</code> means the object <em>reference</em> is <code>volatile</code> but\nthe object itself is not, and other threads may not see updates to the object state.</p>\n<p>This can be salvaged with arrays by using the relevant AtomicArray class, such as <code>AtomicIntegerArray</code>, instead. For mutable objects,\nthe <code>volatile</code> should be removed, and some other method should be used to ensure thread-safety, such as synchronization, or ThreadLocal\nstorage.</p>\n<h3>Noncompliant code example</h3>\n<pre>\nprivate volatile int [] vInts;  // Noncompliant\nprivate volatile MyObj myObj;  // Noncompliant\n</pre>\n<h3>Compliant solution</h3>\n<pre>\nprivate AtomicIntegerArray vInts;\nprivate MyObj myObj;\n</pre>",
    "howToFix": "",
    "moreInfo": "<ul>\n  <li> <a href=\"https://wiki.sei.cmu.edu/confluence/x/UzdGBQ\">CERT, CON50-J.</a> - Do not assume that declaring a reference volatile guarantees safe\n  publication of the members of the referenced object </li>\n</ul>",
    "status": "READY",
    "name_ko": "비원시 타입 필드는 \"volatile\"이 되어서는 안 됩니다",
    "why_ko": "<p>배열을 <code>volatile</code>로 표시하면 배열 자체는 항상 새로 읽히고 스레드 캐시되지 않지만, 배열 <em>내의</em> 항목은 그렇지 않습니다. 마찬가지로, 가변 객체 필드를 <code>volatile</code>로 표시하면 객체 <em>참조</em>가 <code>volatile</code>이 되지만 객체 자체는 그렇지 않으며, 다른 스레드는 객체 상태에 대한 업데이트를 볼 수 없을 수 있습니다.</p>\n<p>배열의 경우 <code>AtomicIntegerArray</code>와 같은 관련 AtomicArray 클래스를 대신 사용하여 이를 해결할 수 있습니다. 가변 객체의 경우 <code>volatile</code>을 제거하고 동기화 또는 ThreadLocal 저장소와 같은 다른 방법을 사용하여 스레드 안전성을 보장해야 합니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\nprivate volatile int [] vInts;  // 규칙 위반\nprivate volatile MyObj myObj;  // 규칙 위반\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre>\nprivate AtomicIntegerArray vInts;\nprivate MyObj myObj;\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": "<ul>\n  <li> <a href=\"https://wiki.sei.cmu.edu/confluence/x/UzdGBQ\">CERT, CON50-J.</a> - 참조를 volatile로 선언하는 것이 참조된 객체의 멤버에 대한 안전한 게시를 보장한다고 가정하지 마세요 </li>\n</ul>"
  },
  {
    "id": "S4248",
    "key": "java:S4248",
    "name": "Regex patterns should not be created needlessly",
    "type": "code-smell",
    "severity": "major",
    "tags": [
      "regex",
      "performance"
    ],
    "why": "<p>The <code>java.util.regex.Pattern.compile()</code> methods have a significant performance cost, and therefore should be used sensibly.</p>\n<p>Moreover they are the only mechanism available to create instances of the Pattern class, which are necessary to do any pattern matching using\nregular expressions. Unfortunately that can be hidden behind convenience methods like <code>String.matches()</code> or\n<code>String.split()</code>.</p>\n<p>It is therefore somewhat easy to inadvertently repeatedly compile the same regular expression at great performance cost with no valid reason.</p>\n<p>This rule raises an issue when:</p>\n<ul>\n  <li> A <code>Pattern</code> is compiled from a <code>String</code> literal or constant and is not stored in a static final reference. </li>\n  <li> <code>String.matches</code>, <code>String.split</code>, <code>String.replaceAll</code> or <code>String.replaceFirst</code> are invoked with a\n  <code>String</code> literal or constant. In which case the code should be refactored to use a <code>java.util.regex.Pattern</code> while respecting\n  the previous rule. </li>\n</ul>\n<h3>Noncompliant code example</h3>\n<pre>\npublic void doingSomething(String stringToMatch) {\n  Pattern regex = Pattern.compile(\"myRegex\");  // Noncompliant\n  Matcher matcher = regex.matcher(\"s\");\n  // ...\n  if (stringToMatch.matches(\"myRegex2\")) {  // Noncompliant\n    // ...\n  }\n}\n</pre>\n<h3>Compliant solution</h3>\n<pre>\nprivate static final Pattern myRegex = Pattern.compile(\"myRegex\");\nprivate static final Pattern myRegex2 = Pattern.compile(\"myRegex2\");\n\npublic void doingSomething(String stringToMatch) {\n  Matcher matcher = myRegex.matcher(\"s\");\n  // ...\n  if (myRegex2.matcher(stringToMatch).matches()) {\n    // ...\n  }\n}\n</pre>\n<h3>Exceptions</h3>\n<p><code>String.split</code> doesn't create a regex when the string passed as argument meets either of these 2 conditions:</p>\n<ul>\n  <li> It is a one-char String and this character is not one of the RegEx's meta characters \".$|()[{^?*+\\\" </li>\n  <li> It is a two-char String and the first char is the backslash and the second is not the ascii digit or ascii letter. </li>\n</ul>\n<p>In which case no issue will be raised.</p>",
    "howToFix": "",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "Regex 패턴을 불필요하게 생성하면 안 됩니다",
    "why_ko": "<p><code>java.util.regex.Pattern.compile()</code> 메서드는 상당한 성능 비용이 들기 때문에 신중하게 사용해야 합니다.</p>\n<p>또한 정규식을 사용하여 패턴 매칭을 수행하는 데 필요한 Pattern 클래스의 인스턴스를 만드는 유일한 메커니즘입니다. 불행히도 이것은 <code>String.matches()</code>나 <code>String.split()</code>과 같은 편의 메서드 뒤에 숨겨져 있을 수 있습니다.</p>\n<p>따라서 타당한 이유 없이 큰 성능 비용을 들여 동일한 정규식을 반복적으로 컴파일하기 쉽습니다.</p>\n<p>이 규칙은 다음과 같은 경우 문제를 제기합니다:</p>\n<ul>\n  <li> <code>Pattern</code>이 <code>String</code> 리터럴 또는 상수에서 컴파일되었지만 static final 참조에 저장되지 않은 경우. </li>\n  <li> <code>String.matches</code>, <code>String.split</code>, <code>String.replaceAll</code> 또는 <code>String.replaceFirst</code>가 <code>String</code> 리터럴 또는 상수와 함께 호출된 경우. 이 경우 이전 규칙을 준수하면서 <code>java.util.regex.Pattern</code>을 사용하도록 코드를 리팩토링해야 합니다. </li>\n</ul>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\npublic void doingSomething(String stringToMatch) {\n  Pattern regex = Pattern.compile(\"myRegex\");  // 규칙 위반\n  Matcher matcher = regex.matcher(\"s\");\n  // ...\n  if (stringToMatch.matches(\"myRegex2\")) {  // 규칙 위반\n    // ...\n  }\n}\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre>\nprivate static final Pattern myRegex = Pattern.compile(\"myRegex\");\nprivate static final Pattern myRegex2 = Pattern.compile(\"myRegex2\");\n\npublic void doingSomething(String stringToMatch) {\n  Matcher matcher = myRegex.matcher(\"s\");\n  // ...\n  if (myRegex2.matcher(stringToMatch).matches()) {\n    // ...\n  }\n}\n</pre>\n<h3>예외</h3>\n<p><code>String.split</code>은 인수로 전달된 문자열이 다음 2가지 조건 중 하나를 충족할 때 정규식을 생성하지 않습니다:</p>\n<ul>\n  <li> 단일 문자 문자열이고 이 문자가 RegEx의 메타 문자 \".$|()[{^?*+\\\" 중 하나가 아닌 경우 </li>\n  <li> 두 문자 문자열이고 첫 번째 문자가 백슬래시이고 두 번째가 ASCII 숫자나 ASCII 문자가 아닌 경우. </li>\n</ul>\n<p>이 경우 문제가 제기되지 않습니다.</p>",
    "howToFix_ko": "",
    "moreInfo_ko": ""
  },
  {
    "id": "S2236",
    "key": "java:S2236",
    "name": "Methods \"wait(...)\", \"notify()\" and \"notifyAll()\" should not be called on Thread instances",
    "type": "bug",
    "severity": "blocker",
    "tags": [
      "multi-threading"
    ],
    "why": "<p>In Java, the <code>Thread</code> class represents a thread of execution. Synchronization between threads is typically achieved using objects or\nshared resources.</p>\n<p>The methods <code>wait(…​)</code>, <code>notify()</code>, and <code>notifyAll()</code> are related to the underlying object's monitor and are\ndesigned to be called on objects that act as locks or monitors for synchronization. These methods are available on Java <code>Object</code> and,\ntherefore, automatically inherited by all objects, including <code>Thread.</code></p>\n<p>Calling these methods on a <code>Thread</code> may corrupt the behavior of the JVM, which relies on them to change the state of the thread\n(<code>BLOCKED,</code> <code>WAITING,</code>…​).</p>\n<h3>Noncompliant code example</h3>\n<pre>\nThread myThread = new Thread(new RunnableJob());\n...\nmyThread.wait(); // Noncompliant\n</pre>",
    "howToFix": "",
    "moreInfo": "<ul>\n  <li> <a href=\"https://docs.oracle.com/en/java/javase/20/docs/api/java.base/java/lang/Thread.html\">Oracle Java SE - Thread</a> </li>\n  <li> <a href=\"https://docs.oracle.com/en/java/javase/20/docs/api/java.base/java/lang/Object.html\">Oracle Java SE - Object</a> </li>\n</ul>",
    "status": "READY",
    "name_ko": "\"wait(...)\", \"notify()\", \"notifyAll()\" 메서드는 Thread 인스턴스에서 호출하면 안 됩니다",
    "why_ko": "<p>Java에서 <code>Thread</code> 클래스는 실행 스레드를 나타냅니다. 스레드 간의 동기화는 일반적으로 객체나 공유 리소스를 사용하여 달성됩니다.</p>\n<p><code>wait(…​)</code>, <code>notify()</code>, <code>notifyAll()</code> 메서드는 기본 객체의 모니터와 관련되어 있으며 동기화를 위한 잠금 또는 모니터 역할을 하는 객체에서 호출되도록 설계되었습니다. 이러한 메서드는 Java <code>Object</code>에서 사용할 수 있으므로 <code>Thread</code>를 포함한 모든 객체에서 자동으로 상속됩니다.</p>\n<p><code>Thread</code>에서 이러한 메서드를 호출하면 스레드 상태(<code>BLOCKED,</code> <code>WAITING,</code>…​)를 변경하기 위해 이러한 메서드에 의존하는 JVM의 동작이 손상될 수 있습니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\nThread myThread = new Thread(new RunnableJob());\n...\nmyThread.wait(); // 규칙 위반\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": "<ul>\n  <li> <a href=\"https://docs.oracle.com/en/java/javase/20/docs/api/java.base/java/lang/Thread.html\">Oracle Java SE - Thread</a> </li>\n  <li> <a href=\"https://docs.oracle.com/en/java/javase/20/docs/api/java.base/java/lang/Object.html\">Oracle Java SE - Object</a> </li>\n</ul>"
  },
  {
    "id": "S109",
    "key": "java:S109",
    "name": "Magic numbers should not be used",
    "type": "code-smell",
    "severity": "major",
    "tags": [
      "brain-overload"
    ],
    "why": "<p>Magic numbers make the code more complex to understand as it requires the reader to have knowledge about the global context to understand the\nnumber itself. Their usage may seem obvious when writing the code, but it may not be the case for another developer or later once the context faded\naway. -1, 0, and 1 are not considered magic numbers.</p>\n<h3>Exceptions</h3>\n<p>This rule ignores <code>hashCode</code> methods.</p>",
    "howToFix": "<p>Replacing them with a constant allows us to provide a meaningful name associated with the value. Instead of adding complexity to the code, it\nbrings clarity and helps to understand the context and the global meaning.</p>\n\n<h4>Noncompliant code example</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\npublic static void doSomething() {\n  for (int i = 0; i &lt; 4; i++) {  // Noncompliant, 4 is a magic number\n    ...\n  }\n}\n</pre>\n<h4>Compliant solution</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\npublic static final int NUMBER_OF_CYCLES = 4;\npublic static void doSomething() {\n  for (int i = 0; i &lt; NUMBER_OF_CYCLES ; i++) { // Compliant\n    ...\n  }\n}\n</pre>",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "매직 넘버는 사용하면 안 됩니다",
    "why_ko": "<p>매직 넘버는 독자가 숫자 자체를 이해하기 위해 전역 컨텍스트에 대한 지식이 필요하므로 코드를 이해하기 더 복잡하게 만듭니다. 코드를 작성할 때 그 사용이 명백해 보일 수 있지만, 다른 개발자에게는 그렇지 않을 수 있고 나중에 컨텍스트가 사라지면 그렇지 않을 수 있습니다. -1, 0, 1은 매직 넘버로 간주되지 않습니다.</p>\n<h3>예외</h3>\n<p>이 규칙은 <code>hashCode</code> 메서드를 무시합니다.</p>",
    "howToFix_ko": "<p>상수로 교체하면 값과 연관된 의미 있는 이름을 제공할 수 있습니다. 코드에 복잡성을 추가하는 대신 명확성을 제공하고 컨텍스트와 전역적 의미를 이해하는 데 도움이 됩니다.</p>\n\n<h4>규칙을 준수하지 않는 코드 예시</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\npublic static void doSomething() {\n  for (int i = 0; i &lt; 4; i++) {  // 규칙 위반, 4는 매직 넘버입니다\n    ...\n  }\n}\n</pre>\n<h4>규칙을 준수하는 해결책</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\npublic static final int NUMBER_OF_CYCLES = 4;\npublic static void doSomething() {\n  for (int i = 0; i &lt; NUMBER_OF_CYCLES ; i++) { // 규칙 준수\n    ...\n  }\n}\n</pre>",
    "moreInfo_ko": ""
  },
  {
    "id": "S1699",
    "key": "java:S1699",
    "name": "Constructors should only call non-overridable methods",
    "type": "code-smell",
    "severity": "critical",
    "tags": [
      "cert",
      "pitfall"
    ],
    "why": "<p>Calling an overridable method from a constructor could result in failures or strange behaviors when instantiating a subclass which overrides the\nmethod.</p>\n<p>For example:</p>\n<ul>\n  <li> The subclass class constructor starts by contract by calling the parent class constructor. </li>\n  <li> The parent class constructor calls the method, which has been overridden in the child class. </li>\n  <li> If the behavior of the child class method depends on fields that are initialized in the child class constructor, unexpected behavior (like a\n  <code>NullPointerException</code>) can result, because the fields aren't initialized yet. </li>\n</ul>\n<h3>Noncompliant code example</h3>\n<pre>\npublic class Parent {\n\n  public Parent () {\n    doSomething();  // Noncompliant\n  }\n\n  public void doSomething () {  // not final; can be overridden\n    ...\n  }\n}\n\npublic class Child extends Parent {\n\n  private String foo;\n\n  public Child(String foo) {\n    super(); // leads to call doSomething() in Parent constructor which triggers a NullPointerException as foo has not yet been initialized\n    this.foo = foo;\n  }\n\n  public void doSomething () {\n    System.out.println(this.foo.length());\n  }\n\n}\n</pre>",
    "howToFix": "",
    "moreInfo": "<ul>\n  <li> <a href=\"https://wiki.sei.cmu.edu/confluence/x/8zZGBQ\">CERT, MET05-J.</a> - Ensure that constructors do not call overridable methods </li>\n  <li> <a href=\"https://wiki.sei.cmu.edu/confluence/x/6ns-BQ\">CERT, OOP50-CPP.</a> - Do not invoke virtual functions from constructors or destructors\n  </li>\n</ul>",
    "status": "READY",
    "name_ko": "생성자에서는 오버라이드할 수 없는 메서드만 호출해야 합니다",
    "why_ko": "<p>생성자에서 오버라이드 가능한 메서드를 호출하면 해당 메서드를 오버라이드하는 서브클래스를 인스턴스화할 때 실패하거나 이상한 동작이 발생할 수 있습니다.</p>\n<p>예를 들어:</p>\n<ul>\n  <li> 서브클래스 생성자는 계약에 의해 부모 클래스 생성자를 호출하는 것으로 시작합니다. </li>\n  <li> 부모 클래스 생성자는 자식 클래스에서 오버라이드된 메서드를 호출합니다. </li>\n  <li> 자식 클래스 메서드의 동작이 자식 클래스 생성자에서 초기화되는 필드에 의존하는 경우, 필드가 아직 초기화되지 않았기 때문에 예기치 않은 동작(예: <code>NullPointerException</code>)이 발생할 수 있습니다. </li>\n</ul>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\npublic class Parent {\n\n  public Parent () {\n    doSomething();  // 규칙 위반\n  }\n\n  public void doSomething () {  // final이 아님; 오버라이드 가능\n    ...\n  }\n}\n\npublic class Child extends Parent {\n\n  private String foo;\n\n  public Child(String foo) {\n    super(); // foo가 아직 초기화되지 않았기 때문에 Parent 생성자에서 doSomething()을 호출하여 NullPointerException이 발생\n    this.foo = foo;\n  }\n\n  public void doSomething () {\n    System.out.println(this.foo.length());\n  }\n\n}\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": "<ul>\n  <li> <a href=\"https://wiki.sei.cmu.edu/confluence/x/8zZGBQ\">CERT, MET05-J.</a> - 생성자에서 오버라이드 가능한 메서드를 호출하지 않도록 하세요 </li>\n  <li> <a href=\"https://wiki.sei.cmu.edu/confluence/x/6ns-BQ\">CERT, OOP50-CPP.</a> - 생성자나 소멸자에서 가상 함수를 호출하지 마세요 </li>\n</ul>"
  },
  {
    "id": "S5320",
    "key": "java:S5320",
    "name": "Broadcasting intents is security-sensitive",
    "type": "security-hotspot",
    "severity": "critical",
    "tags": [
      "cwe",
      "android"
    ],
    "why": "<p>In Android applications, broadcasting intents is security-sensitive. For example, it has led in the past to the following vulnerability:</p>\n<ul>\n  <li> <a href=\"https://www.cve.org/CVERecord?id=CVE-2018-9489\">CVE-2018-9489</a> </li>\n</ul>\n<p>By default, broadcasted intents are visible to every application, exposing all sensitive information they contain.</p>\n<p>This rule raises an issue when an intent is broadcasted without specifying any \"receiver permission\".</p>\n",
    "howToFix": "<h2>Recommended Secure Coding Practices</h2>\n<p>Restrict the access to broadcasted intents. See <a\nhref=\"https://developer.android.com/guide/components/broadcasts.html#restricting_broadcasts_with_permissions\">Android documentation</a> for more\ninformation.</p>\n<h2>Compliant Solution</h2>\n<pre>\nimport android.content.BroadcastReceiver;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.os.Build;\nimport android.os.Bundle;\nimport android.os.Handler;\nimport android.os.UserHandle;\nimport android.support.annotation.RequiresApi;\n\npublic class MyIntentBroadcast {\n    @RequiresApi(api = Build.VERSION_CODES.JELLY_BEAN_MR1)\n    public void broadcast(Intent intent, Context context, UserHandle user,\n                          BroadcastReceiver resultReceiver, Handler scheduler, int initialCode,\n                          String initialData, Bundle initialExtras,\n                          String broadcastPermission) {\n\n        context.sendBroadcast(intent, broadcastPermission);\n        context.sendBroadcastAsUser(intent, user, broadcastPermission);\n        context.sendOrderedBroadcast(intent, broadcastPermission);\n        context.sendOrderedBroadcastAsUser(intent, user,broadcastPermission, resultReceiver,\n                scheduler, initialCode, initialData, initialExtras);\n    }\n}\n</pre>\n<h2>See</h2>\n<ul>\n  <li> OWASP - <a href=\"https://owasp.org/Top10/A04_2021-Insecure_Design/\">Top 10 2021 Category A4 - Insecure Design</a> </li>\n  <li> OWASP - <a href=\"https://mas.owasp.org/checklists/MASVS-PLATFORM/\">Mobile AppSec Verification Standard - Platform Interaction Requirements</a>\n  </li>\n  <li> OWASP - <a href=\"https://owasp.org/www-project-mobile-top-10/2016-risks/m1-improper-platform-usage\">Mobile Top 10 2016 Category M1 - Improper\n  Platform Usage</a> </li>\n  <li> OWASP - <a href=\"https://owasp.org/www-project-mobile-top-10/2023-risks/m3-insecure-authentication-authorization\">Mobile Top 10 2024 Category\n  M3 - Insecure Authentication/Authorization</a> </li>\n  <li> OWASP - <a href=\"https://owasp.org/www-project-mobile-top-10/2023-risks/m8-security-misconfiguration\">Mobile Top 10 2024 Category M8 - Security\n  Misconfiguration</a> </li>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/927\">CWE-927 - Use of Implicit Intent for Sensitive Communication</a> </li>\n  <li> <a href=\"https://developer.android.com/guide/components/broadcasts.html#restricting_broadcasts_with_permissions\">Android documentation</a> -\n  Broadcast Overview - Security considerations and best practices </li>\n</ul>",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "Intent 브로드캐스팅은 보안에 민감합니다",
    "why_ko": "<p>Android 애플리케이션에서 Intent 브로드캐스팅은 보안에 민감합니다. 예를 들어, 이는 과거에 다음과 같은 취약점으로 이어졌습니다:</p>\n<ul>\n  <li> <a href=\"https://www.cve.org/CVERecord?id=CVE-2018-9489\">CVE-2018-9489</a> </li>\n</ul>\n<p>기본적으로 브로드캐스트된 Intent는 모든 애플리케이션에서 볼 수 있어 포함된 모든 민감한 정보가 노출됩니다.</p>\n<p>이 규칙은 \"수신자 권한\"을 지정하지 않고 Intent가 브로드캐스트될 때 문제를 제기합니다.</p>\n",
    "howToFix_ko": "<h2>권장 보안 코딩 방법</h2>\n<p>브로드캐스트된 Intent에 대한 접근을 제한하세요. 자세한 내용은 <a href=\"https://developer.android.com/guide/components/broadcasts.html#restricting_broadcasts_with_permissions\">Android 문서</a>를 참조하세요.</p>\n<h2>규칙을 준수하는 해결책</h2>\n<pre>\nimport android.content.BroadcastReceiver;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.os.Build;\nimport android.os.Bundle;\nimport android.os.Handler;\nimport android.os.UserHandle;\nimport android.support.annotation.RequiresApi;\n\npublic class MyIntentBroadcast {\n    @RequiresApi(api = Build.VERSION_CODES.JELLY_BEAN_MR1)\n    public void broadcast(Intent intent, Context context, UserHandle user,\n                          BroadcastReceiver resultReceiver, Handler scheduler, int initialCode,\n                          String initialData, Bundle initialExtras,\n                          String broadcastPermission) {\n\n        context.sendBroadcast(intent, broadcastPermission);\n        context.sendBroadcastAsUser(intent, user, broadcastPermission);\n        context.sendOrderedBroadcast(intent, broadcastPermission);\n        context.sendOrderedBroadcastAsUser(intent, user,broadcastPermission, resultReceiver,\n                scheduler, initialCode, initialData, initialExtras);\n    }\n}\n</pre>\n<h2>참고</h2>\n<ul>\n  <li> OWASP - <a href=\"https://owasp.org/Top10/A04_2021-Insecure_Design/\">상위 10가지 2021 카테고리 A4 - 안전하지 않은 설계</a> </li>\n  <li> OWASP - <a href=\"https://mas.owasp.org/checklists/MASVS-PLATFORM/\">모바일 AppSec 검증 표준 - 플랫폼 상호작용 요구 사항</a> </li>\n  <li> OWASP - <a href=\"https://owasp.org/www-project-mobile-top-10/2016-risks/m1-improper-platform-usage\">모바일 상위 10가지 2016 카테고리 M1 - 부적절한 플랫폼 사용</a> </li>\n  <li> OWASP - <a href=\"https://owasp.org/www-project-mobile-top-10/2023-risks/m3-insecure-authentication-authorization\">모바일 상위 10가지 2024 카테고리 M3 - 안전하지 않은 인증/권한 부여</a> </li>\n  <li> OWASP - <a href=\"https://owasp.org/www-project-mobile-top-10/2023-risks/m8-security-misconfiguration\">모바일 상위 10가지 2024 카테고리 M8 - 보안 구성 오류</a> </li>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/927\">CWE-927 - 민감한 통신에 암시적 Intent 사용</a> </li>\n  <li> <a href=\"https://developer.android.com/guide/components/broadcasts.html#restricting_broadcasts_with_permissions\">Android 문서</a> - 브로드캐스트 개요 - 보안 고려 사항 및 모범 사례 </li>\n</ul>",
    "moreInfo_ko": ""
  },
  {
    "id": "S2959",
    "key": "java:S2959",
    "name": "Unnecessary semicolons should be omitted",
    "type": "code-smell",
    "severity": "minor",
    "tags": [
      "convention"
    ],
    "why": "<p>Under the reasoning that cleaner code is better code, the semicolon at the end of a try-with-resources construct should be omitted because it can\nbe omitted.</p>\n<h3>Noncompliant code example</h3>\n<pre>\ntry (ByteArrayInputStream b = new ByteArrayInputStream(new byte[10]);  // ignored; this one's required\n      Reader r = new InputStreamReader(b);)   // Noncompliant\n{\n   //do stuff\n}\n</pre>\n<h3>Compliant solution</h3>\n<pre>\ntry (ByteArrayInputStream b = new ByteArrayInputStream(new byte[10]);\n      Reader r = new InputStreamReader(b))\n{\n   //do stuff\n}\n</pre>",
    "howToFix": "",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "불필요한 세미콜론은 생략해야 합니다",
    "why_ko": "<p>더 깔끔한 코드가 더 좋은 코드라는 논리에 따라, try-with-resources 구문 끝의 세미콜론은 생략할 수 있으므로 생략해야 합니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\ntry (ByteArrayInputStream b = new ByteArrayInputStream(new byte[10]);  // 무시됨; 이것은 필수입니다\n      Reader r = new InputStreamReader(b);)   // 규칙 위반\n{\n   //작업 수행\n}\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre>\ntry (ByteArrayInputStream b = new ByteArrayInputStream(new byte[10]);\n      Reader r = new InputStreamReader(b))\n{\n   //작업 수행\n}\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": ""
  },
  {
    "id": "S6019",
    "key": "java:S6019",
    "name": "Reluctant quantifiers in regular expressions should be followed by an expression that can't match the empty string",
    "type": "code-smell",
    "severity": "major",
    "tags": [
      "regex"
    ],
    "why": "<p>When a reluctant quantifier (such as <code>*?</code> or <code>+?</code>) is followed by a pattern that can match the empty string or directly by\nthe end of the regex, it will always match the empty string when used with methods that find partial matches (such as <code>find</code>,\n<code>replaceAll</code>, <code>split</code> etc.).</p>\n<p>Similarly, when used with methods that find full matches, a reluctant quantifier that's followed directly by the end of the regex (or a pattern\nthat always matches the empty string, such as <code>()</code>) behaves indistinguishably from a greedy quantifier while being less efficient.</p>\n<p>This is likely a sign that the regex does not work as intended.</p>\n<h3>Noncompliant code example</h3>\n<pre>\n\"start123endstart456\".replaceAll(\"start\\\\w*?(end)?\", \"x\"); // Noncompliant. In contrast to what one would expect, the result is not \"xx\".\nstr.matches(\"\\\\d*?\"); // Noncompliant. Matches the same as \"\\d*\", but will backtrack in every position.\n</pre>\n<h3>Compliant solution</h3>\n<pre>\n\"start123endstart456\".replaceAll(\"start\\\\w*?(end|$)\", \"x\"); // Result is \"xx\".\nstr.matches(\"\\\\d*\");\n</pre>",
    "howToFix": "",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "정규 표현식의 비탐욕적 수량자 뒤에는 빈 문자열과 매칭되지 않는 표현식이 와야 합니다",
    "why_ko": "<p>비탐욕적 수량자(예: <code>*?</code> 또는 <code>+?</code>) 뒤에 빈 문자열과 일치할 수 있는 패턴이 오거나 정규식의 끝이 바로 오면, 부분 일치를 찾는 메서드(<code>find</code>, <code>replaceAll</code>, <code>split</code> 등)와 함께 사용할 때 항상 빈 문자열과 일치합니다.</p>\n<p>마찬가지로 전체 일치를 찾는 메서드와 함께 사용할 때, 정규식의 끝이 바로 뒤에 오는 비탐욕적 수량자(또는 <code>()</code>처럼 항상 빈 문자열과 일치하는 패턴)는 덜 효율적이면서도 탐욕적 수량자와 구별할 수 없게 동작합니다.</p>\n<p>이것은 정규식이 의도한 대로 작동하지 않는다는 신호일 가능성이 높습니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\n\"start123endstart456\".replaceAll(\"start\\\\w*?(end)?\", \"x\"); // 규칙 위반. 예상과 달리 결과가 \"xx\"가 아님.\nstr.matches(\"\\\\d*?\"); // 규칙 위반. \"\\d*\"와 동일하게 일치하지만 모든 위치에서 역추적함.\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre>\n\"start123endstart456\".replaceAll(\"start\\\\w*?(end|$)\", \"x\"); // 결과는 \"xx\".\nstr.matches(\"\\\\d*\");\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": ""
  },
  {
    "id": "S1226",
    "key": "java:S1226",
    "name": "Method parameters, caught exceptions and foreach variables' initial values should not be ignored",
    "type": "bug",
    "severity": "minor",
    "tags": [],
    "why": "<p>While it is technically correct to assign to parameters from within method bodies, doing so before the parameter value is read is likely a bug.\nInstead, initial values of parameters, caught exceptions, and foreach parameters should be, if not treated as <code>final</code>, then at least read\nbefore reassignment.</p>\n<h3>Noncompliant code example</h3>\n<pre>\npublic void doTheThing(String str, int i, List&lt;String&gt; strings) {\n  str = Integer.toString(i); // Noncompliant\n\n  for (String s : strings) {\n    s = \"hello world\"; // Noncompliant\n  }\n}\n</pre>",
    "howToFix": "",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "메서드 파라미터, catch된 exception, foreach 변수의 초기값을 무시하면 안 됩니다",
    "why_ko": "<p>기술적으로 메서드 본문 내에서 파라미터에 값을 할당하는 것은 올바르지만, 파라미터 값을 읽기 전에 할당하는 것은 버그일 가능성이 높습니다.\n대신 파라미터, catch된 예외, foreach 파라미터의 초기값은 <code>final</code>로 처리하지 않더라도 최소한 재할당 전에 읽어야 합니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\npublic void doTheThing(String str, int i, List&lt;String&gt; strings) {\n  str = Integer.toString(i); // 규칙 위반\n\n  for (String s : strings) {\n    s = \"hello world\"; // 규칙 위반\n  }\n}\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": ""
  },
  {
    "id": "S1119",
    "key": "java:S1119",
    "name": "Labels should not be used",
    "type": "code-smell",
    "severity": "major",
    "tags": [
      "confusing"
    ],
    "why": "<p>Labels are not commonly used in Java, and many developers do not understand how they work. Moreover, their usage makes the control flow harder to\nfollow, which reduces the code's readability.</p>\n<h3>Noncompliant code example</h3>\n<pre>\nint matrix[][] = {\n  {1, 2, 3},\n  {4, 5, 6},\n  {7, 8, 9}\n};\n\nouter: for (int row = 0; row &lt; matrix.length; row++) {   // Non-Compliant\n  for (int col = 0; col &lt; matrix[row].length; col++) {\n    if (col == row) {\n      continue outer;\n    }\n    System.out.println(matrix[row][col]);                // Prints the elements under the diagonal, i.e. 4, 7 and 8\n  }\n}\n</pre>\n<h3>Compliant solution</h3>\n<pre>\nfor (int row = 1; row &lt; matrix.length; row++) {          // Compliant\n  for (int col = 0; col &lt; row; col++) {\n    System.out.println(matrix[row][col]);                // Also prints 4, 7 and 8\n  }\n}\n</pre>",
    "howToFix": "",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "Label은 사용하면 안 됩니다",
    "why_ko": "<p>Label은 Java에서 일반적으로 사용되지 않으며, 많은 개발자들이 어떻게 작동하는지 이해하지 못합니다. 게다가 사용하면 제어 흐름을 따라가기 어려워져 코드의 가독성이 떨어집니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\nint matrix[][] = {\n  {1, 2, 3},\n  {4, 5, 6},\n  {7, 8, 9}\n};\n\nouter: for (int row = 0; row &lt; matrix.length; row++) {   // 규칙 위반\n  for (int col = 0; col &lt; matrix[row].length; col++) {\n    if (col == row) {\n      continue outer;\n    }\n    System.out.println(matrix[row][col]);                // 대각선 아래 요소 출력, 즉 4, 7, 8\n  }\n}\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre>\nfor (int row = 1; row &lt; matrix.length; row++) {          // 규칙 준수\n  for (int col = 0; col &lt; row; col++) {\n    System.out.println(matrix[row][col]);                // 마찬가지로 4, 7, 8 출력\n  }\n}\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": ""
  },
  {
    "id": "S6326",
    "key": "java:S6326",
    "name": "Regular expressions should not contain multiple spaces",
    "type": "code-smell",
    "severity": "major",
    "tags": [
      "regex"
    ],
    "why": "<p>Multiple spaces in a regular expression can make it hard to tell how many spaces should be matched. It's more readable to use only one space and\nthen indicate with a quantifier how many spaces are expected.</p>\n<h3>Noncompliant code example</h3>\n<pre>\nPattern.compile(\"hello   world\");\n</pre>\n<h3>Compliant solution</h3>\n<pre>\nPattern.compile(\"hello {3}world\");\n</pre>\n<h3>Exceptions</h3>\n<p>In <a href=\"https://www.regular-expressions.info/freespacing.html\">free-spacing mode</a> (<code>Pattern.COMMENTS</code> flag, or with embedded flag\nexpression <code>(?x)</code>), whitespaces are ignored. In this case no issue should be triggered, because the whitespaces may be intended to improve\nreadability.</p>",
    "howToFix": "",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "정규 표현식에 여러 공백이 포함되면 안 됩니다",
    "why_ko": "<p>정규 표현식에서 여러 공백은 몇 개의 공백이 매칭되어야 하는지 파악하기 어렵게 만들 수 있습니다. 하나의 공백만 사용하고 수량자로 예상되는 공백 수를 표시하는 것이 더 읽기 쉽습니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\nPattern.compile(\"hello   world\");\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre>\nPattern.compile(\"hello {3}world\");\n</pre>\n<h3>예외</h3>\n<p><a href=\"https://www.regular-expressions.info/freespacing.html\">자유 공백 모드</a>(<code>Pattern.COMMENTS</code> 플래그 또는 내장 플래그 표현식 <code>(?x)</code>)에서는 공백이 무시됩니다. 이 경우 공백이 가독성 향상을 위한 것일 수 있으므로 문제가 발생하지 않아야 합니다.</p>","howToFix_ko": "",
    "moreInfo_ko": ""
  },
  {
    "id": "S6263",
    "key": "java:S6263",
    "name": "Using long-term access keys is security-sensitive",
    "type": "security-hotspot",
    "severity": "major",
    "tags": [
      "aws"
    ],
    "why": "<p>In AWS, long-term access keys will be valid until you manually revoke them. This makes them highly sensitive as any exposure can have serious\nconsequences and should be used with care.</p>\n<p>This rule will trigger when encountering an instantiation of <code>com.amazonaws.auth.BasicAWSCredentials</code>.</p>\n",
    "howToFix": "<h2>Recommended Secure Coding Practices</h2>\n<p>Consider using IAM roles or other features of the AWS Security Token Service that provide temporary credentials, limiting the risks.</p>\n<h2>Compliant Solution</h2>\n<p>Example for AWS STS (see <a href=\"https://docs.aws.amazon.com/sdk-for-java/v1/developer-guide/prog-services-sts.html\">Getting Temporary Credentials\nwith AWS STS</a>).</p>\n<pre>\nBasicSessionCredentials sessionCredentials = new BasicSessionCredentials(\n   session_creds.getAccessKeyId(),\n   session_creds.getSecretAccessKey(),\n   session_creds.getSessionToken());\n</pre>\n<h2>See</h2>\n<ul>\n  <li> <a href=\"https://docs.aws.amazon.com/general/latest/gr/aws-access-keys-best-practices.html\">Best practices for managing AWS access keys</a>\n  </li>\n  <li> <a href=\"https://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_access-keys.html\">Managing access keys for IAM users</a> </li>\n</ul>",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "장기 액세스 키 사용은 보안에 민감합니다",
    "why_ko": "<p>AWS에서 장기 액세스 키는 수동으로 취소할 때까지 유효합니다. 이로 인해 노출이 심각한 결과를 초래할 수 있으므로 매우 민감하며 주의해서 사용해야 합니다.</p>\n<p>이 규칙은 <code>com.amazonaws.auth.BasicAWSCredentials</code>의 인스턴스화를 만났을 때 트리거됩니다.</p>\n",
    "howToFix_ko": "<h2>권장 보안 코딩 관행</h2>\n<p>임시 자격 증명을 제공하는 IAM 역할 또는 AWS Security Token Service의 다른 기능을 사용하여 위험을 제한하는 것을 고려하세요.</p>\n<h2>규칙을 준수하는 해결책</h2>\n<p>AWS STS 예시 (<a href=\"https://docs.aws.amazon.com/sdk-for-java/v1/developer-guide/prog-services-sts.html\">AWS STS로 임시 자격 증명 얻기</a> 참조).</p>\n<pre>\nBasicSessionCredentials sessionCredentials = new BasicSessionCredentials(\n   session_creds.getAccessKeyId(),\n   session_creds.getSecretAccessKey(),\n   session_creds.getSessionToken());\n</pre>\n<h2>참고</h2>\n<ul>\n  <li> <a href=\"https://docs.aws.amazon.com/general/latest/gr/aws-access-keys-best-practices.html\">AWS 액세스 키 관리 모범 사례</a> </li>\n  <li> <a href=\"https://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_access-keys.html\">IAM 사용자 액세스 키 관리</a> </li>\n</ul>",
    "moreInfo_ko": ""
  },
  {
    "id": "S2109",
    "key": "java:S2109",
    "name": "Reflection should not be used to check non-runtime annotations",
    "type": "bug",
    "severity": "major",
    "tags": [],
    "why": "<p>Denoted by the \"@\" symbol, annotations are metadata that can be added to classes, methods, and variables for various purposes such as\ndocumentation, code analysis, and runtime processing.</p>\n<p>Annotations have retention policies that determine in which context they are retained and available for use. There are three retention policies for\nannotations:</p>\n<ul>\n  <li> <code>RetentionPolicy.SOURCE</code> - Annotations are only available during compilation and code analysis. They are not included in the\n  compiled class file and are not available at runtime. E.G. <code>@Override</code>, <code>@SuppressWarnings</code> </li>\n  <li> <code>RetentionPolicy.CLASS</code> - Annotations are included in the compiled class file providing information to the compiler, but they are\n  not retained by the JVM at runtime. This is the default retention policy. E.G. <code>@PreviewFeature</code> </li>\n  <li> <code>RetentionPolicy.RUNTIME</code> - Annotations are included in the compiled class file and available at runtime. They can be accessed and\n  used by the program through reflection. E.G. <code>@FunctionalInterface</code>, <code>@Deprecated</code> </li>\n</ul>\n<p>It is important to understand that only annotations having the <code>RUNTIME</code> retention policy can be accessed at runtime using reflection.\nFor example, the following if condition is true when the method argument is the <code>java.util.function.Function</code> class:</p>\n<pre>\nvoid execute(Class&lt;?&gt; cls) {\n  if (cls.isAnnotationPresent(FunctionalInterface.class)) {\n    // ...\n  }\n}\n</pre>\n<p>Therefore, it is an issue to use reflection in combination with annotations with the <code>SOURCE</code> or <code>CLASS</code> retention policy\nbecause they are not present at runtime. For example, in the JVM source code, the <code>hashCode()</code> method of the <code>Integer</code> class has\nthe <code>@Override</code> annotation. However, the following if condition will always be false even if the method argument is the\n<code>Integer#hashCode()</code> method because <code>@Override</code> has the <code>SOURCE</code> retention policy:</p>\n<pre>\nvoid execute(Method method) {\n  if (method.isAnnotationPresent(Override.class)) { // Noncompliant, if condition will always be false because\n                                                    // @Override is declared with @Retention(RetentionPolicy.SOURCE)\n    // ...\n  }\n}\n</pre>\n<p>This rule detects improper reflective access on annotations having the <code>SOURCE</code> or <code>CLASS</code> retention policy.</p>",
    "howToFix": "",
    "moreInfo": "<h3>Documentation</h3>\n<ul>\n  <li> <a href=\"https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/annotation/RetentionPolicy.html\">Oracle SDK -\n  java.lang.annotation.RetentionPolicy</a> </li>\n</ul>",
    "status": "READY",
    "name_ko": "Reflection은 런타임이 아닌 어노테이션을 검사하는 데 사용하면 안 됩니다",
    "why_ko": "<p>\"@\" 기호로 표시되는 어노테이션은 문서화, 코드 분석, 런타임 처리 등 다양한 목적으로 클래스, 메서드, 변수에 추가할 수 있는 메타데이터입니다.</p>\n<p>어노테이션은 어떤 컨텍스트에서 유지되고 사용할 수 있는지를 결정하는 보존 정책을 가지고 있습니다. 어노테이션에는 세 가지 보존 정책이 있습니다:</p>\n<ul>\n  <li> <code>RetentionPolicy.SOURCE</code> - 어노테이션은 컴파일과 코드 분석 중에만 사용할 수 있습니다. 컴파일된 클래스 파일에 포함되지 않으며 런타임에 사용할 수 없습니다. 예: <code>@Override</code>, <code>@SuppressWarnings</code> </li>\n  <li> <code>RetentionPolicy.CLASS</code> - 어노테이션은 컴파일된 클래스 파일에 포함되어 컴파일러에 정보를 제공하지만, 런타임에 JVM에 의해 유지되지 않습니다. 이것이 기본 보존 정책입니다. 예: <code>@PreviewFeature</code> </li>\n  <li> <code>RetentionPolicy.RUNTIME</code> - 어노테이션은 컴파일된 클래스 파일에 포함되고 런타임에 사용할 수 있습니다. 리플렉션을 통해 프로그램에서 접근하고 사용할 수 있습니다. 예: <code>@FunctionalInterface</code>, <code>@Deprecated</code> </li>\n</ul>\n<p><code>RUNTIME</code> 보존 정책을 가진 어노테이션만 리플렉션을 사용하여 런타임에 접근할 수 있다는 것을 이해하는 것이 중요합니다. 예를 들어, 다음 if 조건은 메서드 인수가 <code>java.util.function.Function</code> 클래스일 때 true입니다:</p>\n<pre>\nvoid execute(Class&lt;?&gt; cls) {\n  if (cls.isAnnotationPresent(FunctionalInterface.class)) {\n    // ...\n  }\n}\n</pre>\n<p>따라서 <code>SOURCE</code> 또는 <code>CLASS</code> 보존 정책을 가진 어노테이션과 함께 리플렉션을 사용하는 것은 문제입니다. 왜냐하면 런타임에 존재하지 않기 때문입니다. 예를 들어, JVM 소스 코드에서 <code>Integer</code> 클래스의 <code>hashCode()</code> 메서드는 <code>@Override</code> 어노테이션을 가지고 있습니다. 그러나 다음 if 조건은 메서드 인수가 <code>Integer#hashCode()</code> 메서드일지라도 항상 false입니다. 왜냐하면 <code>@Override</code>는 <code>SOURCE</code> 보존 정책을 가지고 있기 때문입니다:</p>\n<pre>\nvoid execute(Method method) {\n  if (method.isAnnotationPresent(Override.class)) { // 규칙 위반, @Override는 @Retention(RetentionPolicy.SOURCE)로 선언되어 있으므로\n                                                    // if 조건은 항상 false임\n    // ...\n  }\n}\n</pre>\n<p>이 규칙은 <code>SOURCE</code> 또는 <code>CLASS</code> 보존 정책을 가진 어노테이션에 대한 부적절한 리플렉션 접근을 감지합니다.</p>",
    "howToFix_ko": "",
    "moreInfo_ko": "<h3>문서</h3>\n<ul>\n  <li> <a href=\"https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/annotation/RetentionPolicy.html\">Oracle SDK -\n  java.lang.annotation.RetentionPolicy</a> </li>\n</ul>"
  },
  {
    "id": "S4032",
    "key": "java:S4032",
    "name": "Packages containing only \"package-info.java\" should be removed",
    "type": "code-smell",
    "severity": "minor",
    "tags": [
      "unused"
    ],
    "why": "<p>There is no reason to have a package that is empty except for \"package-info.java\". Such packages merely clutter a project, taking up space but\nadding no value.</p>",
    "howToFix": "",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "\"package-info.java\"만 포함된 패키지는 제거해야 합니다",
    "why_ko": "<p>\"package-info.java\"를 제외하고 비어 있는 패키지를 유지할 이유가 없습니다. 이러한 패키지는 단지 프로젝트를 어지럽히고, 공간만 차지하면서 가치를 추가하지 않습니다.</p>",
    "howToFix_ko": "",
    "moreInfo_ko": ""
  },
  {
    "id": "S5361",
    "key": "java:S5361",
    "name": "\"String#replace\" should be preferred to \"String#replaceAll\"",
    "type": "code-smell",
    "severity": "critical",
    "tags": [
      "regex",
      "performance"
    ],
    "why": "<p>The underlying implementation of <code>String::replaceAll</code> calls the <code>java.util.regex.Pattern.compile()</code> method each time it is\ncalled even if the first argument is not a regular expression. This has a significant performance cost and therefore should be used with care.</p>\n<p>When <code>String::replaceAll</code> is used, the first argument should be a real regular expression. If it's not the case,\n<code>String::replace</code> does exactly the same thing as <code>String::replaceAll</code> without the performance drawback of the regex.</p>\n<p>This rule raises an issue for each <code>String::replaceAll</code> used with a <code>String</code> as first parameter which doesn't contains\nspecial regex character or pattern.</p>\n<h3>Noncompliant code example</h3>\n<pre>\nString init = \"Bob is a Bird... Bob is a Plane... Bob is Superman!\";\nString changed = init.replaceAll(\"Bob is\", \"It's\"); // Noncompliant\nchanged = changed.replaceAll(\"\\\\.\\\\.\\\\.\", \";\"); // Noncompliant\n</pre>\n<h3>Compliant solution</h3>\n<pre>\nString init = \"Bob is a Bird... Bob is a Plane... Bob is Superman!\";\nString changed = init.replace(\"Bob is\", \"It's\");\nchanged = changed.replace(\"...\", \";\");\n</pre>\n<p>Or, with a regex:</p>\n<pre>\nString init = \"Bob is a Bird... Bob is a Plane... Bob is Superman!\";\nString changed = init.replaceAll(\"\\\\w*\\\\sis\", \"It's\");\nchanged = changed.replaceAll(\"\\\\.{3}\", \";\");\n</pre>",
    "howToFix": "",
    "moreInfo": "<ul>\n  <li> <a href='/coding_rules#rule_key=java%3AS4248'>S4248</a> - Regex patterns should not be created needlessly </li>\n</ul>",
    "status": "READY",
    "name_ko": "\"String#replaceAll\" 대신 \"String#replace\"를 사용하는 것이 좋습니다",
    "why_ko": "<p><code>String::replaceAll</code>의 기본 구현은 첫 번째 인수가 정규 표현식이 아니더라도 호출될 때마다 <code>java.util.regex.Pattern.compile()</code> 메서드를 호출합니다. 이는 상당한 성능 비용이 있으므로 주의해서 사용해야 합니다.</p>\n<p><code>String::replaceAll</code>을 사용할 때 첫 번째 인수는 실제 정규 표현식이어야 합니다. 그렇지 않은 경우 <code>String::replace</code>는 정규식의 성능 단점 없이 <code>String::replaceAll</code>과 정확히 같은 작업을 수행합니다.</p>\n<p>이 규칙은 특수 정규식 문자나 패턴을 포함하지 않는 <code>String</code>을 첫 번째 매개변수로 사용하는 각 <code>String::replaceAll</code>에 대해 문제를 제기합니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\nString init = \"Bob is a Bird... Bob is a Plane... Bob is Superman!\";\nString changed = init.replaceAll(\"Bob is\", \"It's\"); // 규칙 위반\nchanged = changed.replaceAll(\"\\\\.\\\\.\\\\.\", \";\"); // 규칙 위반\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre>\nString init = \"Bob is a Bird... Bob is a Plane... Bob is Superman!\";\nString changed = init.replace(\"Bob is\", \"It's\");\nchanged = changed.replace(\"...\", \";\");\n</pre>\n<p>또는 정규식을 사용하는 경우:</p>\n<pre>\nString init = \"Bob is a Bird... Bob is a Plane... Bob is Superman!\";\nString changed = init.replaceAll(\"\\\\w*\\\\sis\", \"It's\");\nchanged = changed.replaceAll(\"\\\\.{3}\", \";\");\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": "<ul>\n  <li> <a href='/coding_rules#rule_key=java%3AS4248'>S4248</a> - 정규식 패턴을 불필요하게 생성하면 안 됩니다 </li>\n</ul>"
  },
  {
    "id": "S4065",
    "key": "java:S4065",
    "name": "\"ThreadLocal.withInitial\" should be preferred",
    "type": "code-smell",
    "severity": "minor",
    "tags": [
      "java8"
    ],
    "why": "<p>Java 8 introduced <code>ThreadLocal.withInitial</code> which is a simpler alternative to creating an anonymous inner class to initialise a\n<code>ThreadLocal</code> instance.</p>\n<p>This rule raises an issue when a <code>ThreadLocal</code> anonymous inner class can be replaced by a call to\n<code>ThreadLocal.withInitial</code>.</p>\n<h3>Noncompliant code example</h3>\n<pre>\nThreadLocal&lt;List&lt;String&gt;&gt; myThreadLocal =\n    new ThreadLocal&lt;List&lt;String&gt;&gt;() { // Noncompliant\n        @Override\n        protected List&lt;String&gt; initialValue() {\n            return new ArrayList&lt;String&gt;();\n        }\n    };\n</pre>\n<h3>Compliant solution</h3>\n<pre>\nThreadLocal&lt;List&lt;String&gt;&gt; myThreadLocal = ThreadLocal.withInitial(ArrayList::new);\n</pre>",
    "howToFix": "",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "\"ThreadLocal.withInitial\"을 사용하는 것이 좋습니다",
    "why_ko": "<p>Java 8에서는 <code>ThreadLocal</code> 인스턴스를 초기화하기 위해 익명 내부 클래스를 만드는 것보다 더 간단한 대안인 <code>ThreadLocal.withInitial</code>을 도입했습니다.</p>\n<p>이 규칙은 <code>ThreadLocal</code> 익명 내부 클래스를 <code>ThreadLocal.withInitial</code> 호출로 대체할 수 있을 때 문제를 제기합니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\nThreadLocal&lt;List&lt;String&gt;&gt; myThreadLocal =\n    new ThreadLocal&lt;List&lt;String&gt;&gt;() { // 규칙 위반\n        @Override\n        protected List&lt;String&gt; initialValue() {\n            return new ArrayList&lt;String&gt;();\n        }\n    };\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre>\nThreadLocal&lt;List&lt;String&gt;&gt; myThreadLocal = ThreadLocal.withInitial(ArrayList::new);\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": ""
  },
  {
    "id": "S2293",
    "key": "java:S2293",
    "name": "The diamond operator (\"<>\") should be used",
    "type": "code-smell",
    "severity": "minor",
    "tags": [
      "clumsy"
    ],
    "why": "<p>Java uses angular brackets (<code>&lt;</code> and <code>&gt;</code>) to provide a specific type (the \"type argument\") to a generic type. For\ninstance, <code>List</code> is a generic type, so a list containing strings can be declared with <code>List&lt;String&gt;</code>.</p>\n<p>Prior to Java 7, the type argument had to be provided explicitly for every occurrence where generics were used. This often caused redundancy, as\nthe type argument would have to be provided both when a field is declared and initialized.</p>\n<p>Java 7 introduced the diamond operator (<code>&lt;&gt;</code>) to reduce the code's verbosity in some situations. The type argument between the\nangular brackets should be omitted if the compiler can infer it.</p>\n<p>Since the diamond operator was only introduced in Java 7, this rule is automatically disabled when the project's <code>sonar.java.source</code> is\nlower than <code>7</code>.</p>",
    "howToFix": "<p>The type argument should be omitted in the initialization if it is already present in the declaration of a field or variable.</p>\n<p>For instance, a field with type <code>List&lt;String&gt;</code> can be initialized with <code>ArrayList&lt;&gt;()</code>, as the compiler will\ninfer that <code>ArrayList&lt;String&gt;()</code> is the actually desired call.</p>\n\n<h4>Noncompliant code example</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\nList&lt;String&gt; strings = new ArrayList&lt;String&gt;();                       // Noncompliant, the compiler can infer the type argument of the constructor invocation\nMap&lt;String,List&lt;Integer&gt;&gt; map = new HashMap&lt;String,List&lt;Integer&gt;&gt;();  // Noncompliant, the compiler can also infer complex type arguments\n</pre>\n<h4>Compliant solution</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\nList&lt;String&gt; strings = new ArrayList&lt;&gt;();        // Compliant, the compiler will infer the type argument\nMap&lt;String,List&lt;Integer&gt;&gt; map = new HashMap&lt;&gt;(); // Compliant, the compiler will infer the type argument\n</pre>",
    "moreInfo": "<h3>Documentation</h3>\n<ul>\n  <li> <a href=\"https://docs.oracle.com/javase/tutorial/java/generics/genTypeInference.html\">The Java™ Tutorials</a> - Type Inference (Generics) </li>\n</ul>",
    "status": "READY",
    "name_ko": "다이아몬드 연산자 (\"<>\")를 사용해야 합니다",
    "why_ko": "<p>Java는 제네릭 타입에 특정 타입(\"타입 인자\")을 제공하기 위해 꺾쇠 괄호(<code>&lt;</code>와 <code>&gt;</code>)를 사용합니다. 예를 들어 <code>List</code>는 제네릭 타입이므로 문자열을 포함하는 리스트는 <code>List&lt;String&gt;</code>으로 선언할 수 있습니다.</p>\n<p>Java 7 이전에는 제네릭이 사용되는 모든 곳에서 타입 인자를 명시적으로 제공해야 했습니다. 이는 필드가 선언되고 초기화될 때 타입 인자를 모두 제공해야 했기 때문에 종종 중복을 유발했습니다.</p>\n<p>Java 7에서는 일부 상황에서 코드의 장황함을 줄이기 위해 다이아몬드 연산자(<code>&lt;&gt;</code>)를 도입했습니다. 컴파일러가 추론할 수 있는 경우 꺾쇠 괄호 사이의 타입 인자를 생략해야 합니다.</p>\n<p>다이아몬드 연산자는 Java 7에서만 도입되었으므로 프로젝트의 <code>sonar.java.source</code>가 <code>7</code>보다 낮으면 이 규칙이 자동으로 비활성화됩니다.</p>",
    "howToFix_ko": "<p>필드나 변수의 선언에 이미 있는 경우 초기화에서 타입 인자를 생략해야 합니다.</p>\n<p>예를 들어 <code>List&lt;String&gt;</code> 타입의 필드는 컴파일러가 <code>ArrayList&lt;String&gt;()</code>이 실제로 원하는 호출임을 추론하므로 <code>ArrayList&lt;&gt;()</code>로 초기화할 수 있습니다.</p>\n\n<h4>규칙을 준수하지 않는 코드 예시</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\nList&lt;String&gt; strings = new ArrayList&lt;String&gt;();                       // 규칙 위반, 컴파일러가 생성자 호출의 타입 인자를 추론할 수 있음\nMap&lt;String,List&lt;Integer&gt;&gt; map = new HashMap&lt;String,List&lt;Integer&gt;&gt;();  // 규칙 위반, 컴파일러가 복잡한 타입 인자도 추론할 수 있음\n</pre>\n<h4>규칙을 준수하는 해결책</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\nList&lt;String&gt; strings = new ArrayList&lt;&gt;();        // 규칙 준수, 컴파일러가 타입 인자를 추론함\nMap&lt;String,List&lt;Integer&gt;&gt; map = new HashMap&lt;&gt;(); // 규칙 준수, 컴파일러가 타입 인자를 추론함\n</pre>",
    "moreInfo_ko": "<h3>문서</h3>\n<ul>\n  <li> <a href=\"https://docs.oracle.com/javase/tutorial/java/generics/genTypeInference.html\">The Java™ Tutorials</a> - 타입 추론 (제네릭) </li>\n</ul>"
  },
  {
    "id": "S4347",
    "key": "java:S4347",
    "name": "Secure random number generators should not output predictable values",
    "type": "vulnerability",
    "severity": "critical",
    "tags": [
      "cwe",
      "cert",
      "pitfall"
    ],
    "why": "<p>Random number generators are often used to generate random values for cryptographic algorithms. When a random number generator is used for\ncryptographic purposes, the generated numbers must be as random and unpredictable as possible. When the random number generator is improperly seeded\nwith a constant or a predictable value, its output will also be predictable.</p>\n<p>This can have severe security implications for cryptographic operations that rely on the randomness of the generated numbers. By using a\npredictable seed, an attacker can potentially guess or deduce the generated numbers, compromising the security of whatever cryptographic algorithm\nrelies on the random number generator.</p>\n<h3>What is the potential impact?</h3>\n<p>It is crucial to understand that the strength of cryptographic algorithms heavily relies on the quality of the random numbers used. By improperly\nseeding a CSPRNG, we introduce a significant weakness that can be exploited by attackers.</p>\n<h4>Insecure cryptographic keys</h4>\n<p>One of the primary use cases for CSPRNGs is generating cryptographic keys. If an attacker can predict the seed used to initialize the random number\ngenerator, they may be able to derive the same keys. Depending on the use case, this can lead to multiple severe outcomes, such as:</p>\n<ul>\n  <li> Being able to decrypt sensitive documents, leading to privacy breaches or identity theft. </li>\n  <li> Gaining access to a private key used for signing, allowing an attacker to forge digital signatures and impersonate legitimate entities. </li>\n  <li> Bypassing authentication mechanisms that rely on public-key infrastructure (PKI), which can be abused to gain unauthorized access to systems or\n  networks. </li>\n</ul>\n<h4>Session hijacking and man-in-the-middle attack</h4>\n<p>Another scenario where this vulnerability can be exploited is in the generation of session tokens or nonces for secure communication protocols. If\nan attacker can predict the seed used to generate these tokens, they can impersonate legitimate users or intercept sensitive information.</p>",
    "howToFix": "<p>The following code uses a cryptographically strong random number generator to generate data that is not cryptographically strong.</p>\n<h4>Noncompliant code example</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\nSecureRandom sr = new SecureRandom();\nsr.setSeed(123456L); // Noncompliant\nint v = sr.next(32);\n</pre>\n<pre data-diff-id=\"2\" data-diff-type=\"noncompliant\">\nSecureRandom sr = new SecureRandom(\"abcdefghijklmnop\".getBytes(\"us-ascii\")); // Noncompliant\nint v = sr.next(32);\n</pre>\n<h4>Compliant solution</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\nSecureRandom sr = new SecureRandom();\nint v = sr.next(32);\n</pre>\n<p>This solution is available for JDK 1.8 and higher.</p>\n<pre data-diff-id=\"2\" data-diff-type=\"compliant\">\nSecureRandom sr = SecureRandom.getInstanceStrong();\nint v = sr.next(32);\n</pre>\n<h3>How does this work?</h3>\n<p>When the randomly generated data needs to be cryptographically strong, <code>SecureRandom</code> is the correct class to use. However, its\ndocumentation also cites that \"any seed material passed to a <code>SecureRandom</code> object must be unpredictable\". When no seed is passed by the\nuser to the object, the <code>SecureRandom</code> object chooses an unpredictable seed by default. Therefore, the easiest way to fix the issue is to\nuse the default constructor without any calls to <code>SecureObject.setSeed()</code>.</p>\n<p>To go the extra mile, <code>SecureObject.getInstanceStrong()</code> returns an instance of <code>SecureObject</code> that is guaranteed to use a\nstrong algorithm for its number generation.</p>\n<p>If the randomly generated data is not used for cryptographic purposes and is not business critical, it may be a better choice to use\n<code>java.util.Random</code> instead. In this case, setting a predictable seed may be acceptable depending on the situation.</p>",
    "moreInfo": "<h3>Documentation</h3>\n<ul>\n  <li> Java Documentation - <a href=\"https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/security/SecureRandom.html\">Class\n  <code>java.security.SecureRandom</code></a> </li>\n</ul>\n<h3>Standards</h3>\n<ul>\n  <li> OWASP - <a href=\"https://owasp.org/Top10/A02_2021-Cryptographic_Failures/\">Top 10 2021 Category A2 - Cryptographic Failures</a> </li>\n  <li> OWASP - <a href=\"https://owasp.org/www-project-top-ten/2017/A6_2017-Security_Misconfiguration\">Top 10 2017 Category A6 - Security\n  Misconfiguration</a> </li>\n  <li> OWASP - <a href=\"https://owasp.org/www-project-mobile-top-10/2023-risks/m10-insufficient-cryptography\">Mobile Top 10 2024 Category M10 -\n  Insufficient Cryptography</a> </li>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/330\">CWE-330 - Use of Insufficiently Random Values</a> </li>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/332\">CWE-332 - Insufficient Entropy in PRNG</a> </li>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/336\">CWE-336 - Same Seed in Pseudo-Random Number Generator (PRNG)</a> </li>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/337\">CWE-337 - Predictable Seed in Pseudo-Random Number Generator (PRNG)</a> </li>\n  <li> <a href=\"https://wiki.sei.cmu.edu/confluence/display/java/MSC63-J.+Ensure+that+SecureRandom+is+properly+seeded\">CERT, MSC63J.</a> - Ensure that\n  SecureRandom is properly seeded </li>\n</ul>",
    "status": "READY",
    "name_ko": "보안 난수 생성기는 예측 가능한 값을 출력하면 안 됩니다",
    "why_ko": "<p>난수 생성기는 암호화 알고리즘을 위한 임의의 값을 생성하는 데 자주 사용됩니다. 난수 생성기가 암호화 목적으로 사용될 때 생성된 숫자는 가능한 한 무작위적이고 예측 불가능해야 합니다. 난수 생성기가 상수 또는 예측 가능한 값으로 부적절하게 시드되면 출력도 예측 가능해집니다.</p>\n<p>이것은 생성된 숫자의 무작위성에 의존하는 암호화 작업에 심각한 보안 영향을 미칠 수 있습니다. 예측 가능한 시드를 사용하면 공격자가 생성된 숫자를 추측하거나 추론할 수 있어 난수 생성기에 의존하는 암호화 알고리즘의 보안이 손상될 수 있습니다.</p>\n<h3>잠재적 영향은 무엇인가요?</h3>\n<p>암호화 알고리즘의 강도가 사용된 난수의 품질에 크게 의존한다는 것을 이해하는 것이 중요합니다. CSPRNG를 부적절하게 시드하면 공격자가 악용할 수 있는 심각한 약점을 도입합니다.</p>\n<h4>안전하지 않은 암호화 키</h4>\n<p>CSPRNG의 주요 사용 사례 중 하나는 암호화 키 생성입니다. 공격자가 난수 생성기를 초기화하는 데 사용된 시드를 예측할 수 있으면 동일한 키를 유도할 수 있습니다. 사용 사례에 따라 다음과 같은 여러 심각한 결과가 발생할 수 있습니다:</p>\n<ul>\n  <li> 민감한 문서를 해독하여 개인 정보 침해 또는 신원 도용으로 이어질 수 있습니다. </li>\n  <li> 서명에 사용되는 개인 키에 대한 접근 권한을 얻어 공격자가 디지털 서명을 위조하고 합법적인 엔터티를 사칭할 수 있습니다. </li>\n  <li> 공개 키 인프라(PKI)에 의존하는 인증 메커니즘을 우회하여 시스템이나 네트워크에 무단으로 접근할 수 있습니다. </li>\n</ul>\n<h4>세션 하이재킹 및 중간자 공격</h4>\n<p>이 취약점이 악용될 수 있는 또 다른 시나리오는 보안 통신 프로토콜을 위한 세션 토큰 또는 논스(nonce) 생성입니다. 공격자가 이러한 토큰을 생성하는 데 사용된 시드를 예측할 수 있으면 합법적인 사용자를 사칭하거나 민감한 정보를 가로챌 수 있습니다.</p>",
    "howToFix_ko": "<p>다음 코드는 암호적으로 강력하지 않은 데이터를 생성하기 위해 암호적으로 강력한 난수 생성기를 사용합니다.</p>\n<h4>규칙을 준수하지 않는 코드 예시</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\nSecureRandom sr = new SecureRandom();\nsr.setSeed(123456L); // 규칙 위반\nint v = sr.next(32);\n</pre>\n<pre data-diff-id=\"2\" data-diff-type=\"noncompliant\">\nSecureRandom sr = new SecureRandom(\"abcdefghijklmnop\".getBytes(\"us-ascii\")); // 규칙 위반\nint v = sr.next(32);\n</pre>\n<h4>규칙을 준수하는 해결책</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\nSecureRandom sr = new SecureRandom();\nint v = sr.next(32);\n</pre>\n<p>이 해결책은 JDK 1.8 이상에서 사용할 수 있습니다.</p>\n<pre data-diff-id=\"2\" data-diff-type=\"compliant\">\nSecureRandom sr = SecureRandom.getInstanceStrong();\nint v = sr.next(32);\n</pre>\n<h3>어떻게 작동하나요?</h3>\n<p>무작위로 생성된 데이터가 암호적으로 강력해야 할 때 <code>SecureRandom</code>이 사용할 올바른 클래스입니다. 그러나 해당 문서에는 \"<code>SecureRandom</code> 객체에 전달되는 모든 시드 자료는 예측 불가능해야 합니다\"라고 명시되어 있습니다. 사용자가 객체에 시드를 전달하지 않으면 <code>SecureRandom</code> 객체는 기본적으로 예측 불가능한 시드를 선택합니다. 따라서 문제를 해결하는 가장 쉬운 방법은 <code>SecureObject.setSeed()</code>에 대한 호출 없이 기본 생성자를 사용하는 것입니다.</p>\n<p>더 나아가 <code>SecureObject.getInstanceStrong()</code>은 숫자 생성에 강력한 알고리즘을 사용하도록 보장된 <code>SecureObject</code> 인스턴스를 반환합니다.</p>\n<p>무작위로 생성된 데이터가 암호화 목적으로 사용되지 않고 비즈니스 크리티컬하지 않은 경우 대신 <code>java.util.Random</code>을 사용하는 것이 더 나은 선택일 수 있습니다. 이 경우 상황에 따라 예측 가능한 시드를 설정하는 것이 허용될 수 있습니다.</p>",
    "moreInfo_ko": "<h3>문서</h3>\n<ul>\n  <li> Java 문서 - <a href=\"https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/security/SecureRandom.html\">클래스 <code>java.security.SecureRandom</code></a> </li>\n</ul>\n<h3>표준</h3>\n<ul>\n  <li> OWASP - <a href=\"https://owasp.org/Top10/A02_2021-Cryptographic_Failures/\">Top 10 2021 카테고리 A2 - 암호화 실패</a> </li>\n  <li> OWASP - <a href=\"https://owasp.org/www-project-top-ten/2017/A6_2017-Security_Misconfiguration\">Top 10 2017 카테고리 A6 - 보안 구성 오류</a> </li>\n  <li> OWASP - <a href=\"https://owasp.org/www-project-mobile-top-10/2023-risks/m10-insufficient-cryptography\">Mobile Top 10 2024 카테고리 M10 - 불충분한 암호화</a> </li>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/330\">CWE-330 - 불충분하게 무작위인 값 사용</a> </li>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/332\">CWE-332 - PRNG의 불충분한 엔트로피</a> </li>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/336\">CWE-336 - 의사 난수 생성기(PRNG)의 동일한 시드</a> </li>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/337\">CWE-337 - 의사 난수 생성기(PRNG)의 예측 가능한 시드</a> </li>\n  <li> <a href=\"https://wiki.sei.cmu.edu/confluence/display/java/MSC63-J.+Ensure+that+SecureRandom+is+properly+seeded\">CERT, MSC63J.</a> - SecureRandom이 올바르게 시드되었는지 확인 </li>\n</ul>"
  },
  {
    "id": "S6395",
    "key": "java:S6395",
    "name": "Non-capturing groups without quantifier should not be used",
    "type": "code-smell",
    "severity": "major",
    "tags": [
      "regex"
    ],
    "why": "<p>Sub-patterns can be wrapped by parentheses to build a group. This enables to restrict alternations, back reference the group or apply quantifier to\nthe sub-pattern.</p>\n<p>If this group should not be part of the match result or if no reference to this group is required, a non-capturing group can be created by adding\n<code>?:</code> behind the opening parenthesis.</p>\n<p>However, if this non-capturing group does not have a quantifier, or does not wrap an alternation, then imaging this group is redundant.</p>\n<h3>Noncompliant code example</h3>\n<pre>\n\"(?:number)\\\\d{2}\"\n</pre>\n<h3>Compliant solution</h3>\n<pre>\n\"number\\\\d{2}\"      \t// it is anyway required\n\"(?:number)?\\\\d{2}\"  \t// it is in fact optional\n</pre>\n<h3>Exceptions</h3>\n<p>This rule does not report an issue if the non-capturing group is an alternation.</p>\n<pre>\n\"(?:number|string)\"\n</pre>",
    "howToFix": "",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "수량자 없는 비캡처 그룹은 사용하면 안 됩니다",
    "why_ko": "<p>서브 패턴은 그룹을 만들기 위해 괄호로 묶을 수 있습니다. 이를 통해 교체를 제한하거나 그룹을 역참조하거나 서브 패턴에 수량자를 적용할 수 있습니다.</p>\n<p>이 그룹이 매치 결과의 일부가 되어서는 안 되거나 이 그룹에 대한 참조가 필요하지 않은 경우 여는 괄호 뒤에 <code>?:</code>를 추가하여 비캡처 그룹을 만들 수 있습니다.</p>\n<p>그러나 이 비캡처 그룹에 수량자가 없거나 교체를 래핑하지 않는다면 이 그룹은 불필요합니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\n\"(?:number)\\\\d{2}\"\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre>\n\"number\\\\d{2}\"      \t// 어쨌든 필요함\n\"(?:number)?\\\\d{2}\"  \t// 실제로 선택적임\n</pre>\n<h3>예외</h3>\n<p>이 규칙은 비캡처 그룹이 교체인 경우 문제를 보고하지 않습니다.</p>\n<pre>\n\"(?:number|string)\"\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": ""
  },
  {
    "id": "S1450",
    "key": "java:S1450",
    "name": "Private fields only used as local variables in methods should become local variables",
    "type": "code-smell",
    "severity": "minor",
    "tags": [
      "pitfall"
    ],
    "why": "<p>When the value of a private field is always assigned to in a class' methods before being read, then it is not being used to store class\ninformation. Therefore, it should become a local variable in the relevant methods to prevent any misunderstanding.</p>\n<h3>Noncompliant code example</h3>\n<pre>\npublic class Foo {\n  private int a;\n  private int b;\n\n  public void doSomething(int y) {\n    a = y + 5;\n    ...\n    if(a == 0) {\n      ...\n    }\n    ...\n  }\n\n  public void doSomethingElse(int y) {\n    b = y + 3;\n    ...\n  }\n}\n</pre>\n<h3>Compliant solution</h3>\n<pre>\npublic class Foo {\n\n  public void doSomething(int y) {\n    int a = y + 5;\n    ...\n    if(a == 0) {\n      ...\n    }\n  }\n\n  public void doSomethingElse(int y) {\n    int b = y + 3;\n    ...\n  }\n}\n</pre>\n<h3>Exceptions</h3>\n<p>This rule doesn't raise any issue on annotated field.</p>",
    "howToFix": "",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "메서드에서 지역 변수로만 사용되는 private 필드는 지역 변수로 변경해야 합니다",
    "why_ko": "<p>private 필드의 값이 클래스의 메서드에서 읽기 전에 항상 할당되는 경우, 해당 필드는 클래스 정보를 저장하는 데 사용되지 않습니다. 따라서 오해를 방지하기 위해 해당 메서드의 지역 변수로 변경해야 합니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\npublic class Foo {\n  private int a;\n  private int b;\n\n  public void doSomething(int y) {\n    a = y + 5;\n    ...\n    if(a == 0) {\n      ...\n    }\n    ...\n  }\n\n  public void doSomethingElse(int y) {\n    b = y + 3;\n    ...\n  }\n}\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre>\npublic class Foo {\n\n  public void doSomething(int y) {\n    int a = y + 5;\n    ...\n    if(a == 0) {\n      ...\n    }\n  }\n\n  public void doSomethingElse(int y) {\n    int b = y + 3;\n    ...\n  }\n}\n</pre>\n<h3>예외</h3>\n<p>이 규칙은 어노테이션이 있는 필드에 대해서는 이슈를 발생시키지 않습니다.</p>",
    "howToFix_ko": "",
    "moreInfo_ko": ""
  },
  {
    "id": "S2786",
    "key": "java:S2786",
    "name": "Nested \"enum\"s should not be declared static",
    "type": "code-smell",
    "severity": "minor",
    "tags": [
      "redundant"
    ],
    "why": "<p>In Java, an enum is a special data type that allows you to define a set of constants. Nested enum types, also known as inner enum types, are enum\ntypes that are defined within another class or interface.</p>\n<p>Nested enum types are implicitly static, so there is no need to declare them <code>static</code> explicitly.</p>\n<h3>Noncompliant code example</h3>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\npublic class Flower {\n  static enum Color { // Noncompliant; static is redundant here\n    RED, YELLOW, BLUE, ORANGE\n  }\n  // ...\n}\n</pre>\n<h3>Compliant solution</h3>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\npublic class Flower {\n  enum Color { // Compliant\n    RED, YELLOW, BLUE, ORANGE\n  }\n  // ...\n}\n</pre>",
    "howToFix": "",
    "moreInfo": "<ul>\n  <li> <a href=\"https://docs.oracle.com/javase/specs/jls/se20/html/jls-8.html#jls-8.9\">Java Language Specification-8.9</a> </li>\n</ul>",
    "status": "READY",
    "name_ko": "중첩 enum을 static으로 선언하면 안 됩니다",
    "why_ko": "<p>Java에서 enum은 상수 집합을 정의할 수 있게 해주는 특별한 데이터 타입입니다. 내부 enum 타입이라고도 알려진 중첩 enum 타입은 다른 클래스나 인터페이스 내에 정의된 enum 타입입니다.</p>\n<p>중첩 enum 타입은 암묵적으로 static이므로 명시적으로 <code>static</code>으로 선언할 필요가 없습니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\npublic class Flower {\n  static enum Color { // 규칙 위반; 여기서 static은 중복입니다\n    RED, YELLOW, BLUE, ORANGE\n  }\n  // ...\n}\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\npublic class Flower {\n  enum Color { // 규칙 준수\n    RED, YELLOW, BLUE, ORANGE\n  }\n  // ...\n}\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": "<ul>\n  <li> <a href=\"https://docs.oracle.com/javase/specs/jls/se20/html/jls-8.html#jls-8.9\">Java Language Specification-8.9</a> </li>\n</ul>"
  },
  {
    "id": "S5413",
    "key": "java:S5413",
    "name": "'List.remove()' should not be used in ascending 'for' loops",
    "type": "code-smell",
    "severity": "major",
    "tags": [],
    "why": "<p>When <code>List.remove()</code> is called, the list shrinks, and the indices of all elements following the removed element are decremented by one.\nIf this operation is performed within a loop that iterates through the elements in ascending order, it will cause the loop to skip the element\nimmediately following the removed element.</p>",
    "howToFix": "<p>There are three ways how to fix this issue:</p>\n<ol>\n  <li> Replace the loop with a call to <code>Collection.removeIf()</code>. This is the preferred solution. </li>\n  <li> Replace the ascending loop with a descending loop. Use this approach if the preferred solution is not possible due to side effects of the loop.\n  </li>\n  <li> Adjust the loop counter within the loop body after the call to <code>Collection.remove()</code>. <strong>This approach is not\n  recommended</strong>, because it will raise an issue with rule <em><a href='/coding_rules#rule_key=java%3AS127'>S127</a> - \"for\" loop stop conditions should be invariant</em> </li>\n</ol>\n\n<h4>Noncompliant code example</h4>\n<p>If the loop can be replaced with Java 8's <code>Collection.removeIf</code> method, depending on the side effects of the loop and your Java target\nversion, then this is the preferred solution for this issue.</p>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\nvoid removeFrom(List&lt;String&gt; list) {\n  // expected: iterate over all list elements\n  for (int i = 0; i &lt; list.size(); i++) {\n    if (list.get(i).isEmpty()) {\n      list.remove(i); // Noncompliant, next element is skipped\n    }\n  }\n}\n</pre>\n<h4>Compliant solution</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\nvoid removeFrom(List&lt;String&gt; list) {\n  list.removeIf(String::isEmpty); // Compliant\n}\n</pre>\n<h4>Noncompliant code example</h4>\n<p>If this is not possible due to side effects of the loop, replace the ascending loop with a descending loop. Descending loops are not affected by\ndecrementing the element indices after the removed element, because they have already been iterated.</p>\n<pre data-diff-id=\"2\" data-diff-type=\"noncompliant\">\nvoid removeFrom(List&lt;String&gt; list) {\n  // expected: iterate over all list elements\n  for (int i = 0; i &lt; list.size(); i++) {\n    if (list.get(i).isEmpty()) {\n      list.remove(i); // Noncompliant, next element is skipped\n    }\n  }\n}\n</pre>\n<h4>Compliant solution</h4>\n<pre data-diff-id=\"2\" data-diff-type=\"compliant\">\nvoid removeFrom(List&lt;String&gt; list) {\n    // expected: iterate over all list elements\n    for (int i = list.size() - 1; i &gt;= 0; i--) {\n    if (list.get(i).isEmpty()) {\n      list.remove(i); // Compliant, elements after removed one have already been iterated\n    }\n  }\n}\n</pre>\n<h4>Noncompliant code example</h4>\n<p>Another way to solve this issue is to adjust the loop counter after the call to <code>Collection.remove</code> to account for the index\ndecrement.</p>\n<pre data-diff-id=\"3\" data-diff-type=\"noncompliant\">\nvoid removeFrom(List&lt;String&gt; list) {\n  // expected: iterate over all list elements\n  for (int i = 0; i &lt; list.size(); i++) {\n    if (list.get(i).isEmpty()) {\n      list.remove(i); // Noncompliant, next element is skipped\n    }\n  }\n}\n</pre>\n<h4>Compliant solution</h4>\n<p><strong>This is not recommanded</strong> because it raises an issue with rule <a href='/coding_rules#rule_key=java%3AS127'>S127</a>.</p>\n<pre data-diff-id=\"3\" data-diff-type=\"compliant\">\nvoid removeFrom(List&lt;String&gt; list) {\n  // expected: iterate over all list elements\n  for (int i = 0; i &lt; list.size(); i++) {\n    if (list.get(i).isEmpty()) {\n      list.remove(i); // Compliant due to counter adjust in next line\n      i--; // Noncompliant with S127!\n    }\n  }\n}\n</pre>",
    "moreInfo": "<h3>Documentation</h3>\n<ul>\n  <li> <a href=\"https://docs.oracle.com/javase/7/docs/api/java/util/Collection.html#remove(java.lang.Object)\">Java SE 7 API Specification:\n  Collection.remove</a> </li>\n  <li> <a href=\"https://docs.oracle.com/javase/8/docs/api/java/util/Collection.html#removeIf-java.util.function.Predicate-\">Java SE 8 API\n  Specification: Collection.removeIf</a> </li>\n  <li> <a href=\"https://sonarsource.github.io/rspec/#/rspec/<a href='/coding_rules#rule_key=java%3AS6068'>S6068</a>/java\"><a href='/coding_rules#rule_key=java%3AS127'>S127</a> - \"for\" loop stop conditions should be\n  invariant</a> </li>\n</ul>",
    "status": "READY",
    "name_ko": "오름차순 'for' 루프에서 'List.remove()'를 사용하면 안 됩니다",
    "why_ko": "<p><code>List.remove()</code>가 호출되면 리스트가 줄어들고 제거된 요소 이후의 모든 요소의 인덱스가 1씩 감소합니다. 이 작업이 오름차순으로 요소를 반복하는 루프 내에서 수행되면 루프가 제거된 요소 바로 다음 요소를 건너뛰게 됩니다.</p>",
    "howToFix_ko": "<p>이 문제를 해결하는 세 가지 방법이 있습니다:</p>\n<ol>\n  <li> 루프를 <code>Collection.removeIf()</code> 호출로 교체합니다. 이것이 권장되는 해결책입니다. </li>\n  <li> 오름차순 루프를 내림차순 루프로 교체합니다. 루프의 부작용으로 인해 권장 솔루션이 불가능한 경우 이 접근 방식을 사용하세요. </li>\n  <li> <code>Collection.remove()</code> 호출 후 루프 본문 내에서 루프 카운터를 조정합니다. <strong>이 접근 방식은 권장되지 않습니다</strong>. <em><a href='/coding_rules#rule_key=java%3AS127'>S127</a> - \"for\" 루프 중지 조건은 불변이어야 합니다</em> 규칙에 문제가 발생하기 때문입니다. </li>\n</ol>\n\n<h4>규칙을 준수하지 않는 코드 예시</h4>\n<p>루프의 부작용과 Java 대상 버전에 따라 루프를 Java 8의 <code>Collection.removeIf</code> 메서드로 교체할 수 있는 경우 이것이 이 문제에 대한 권장 솔루션입니다.</p>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\nvoid removeFrom(List&lt;String&gt; list) {\n  // 예상: 모든 리스트 요소 반복\n  for (int i = 0; i &lt; list.size(); i++) {\n    if (list.get(i).isEmpty()) {\n      list.remove(i); // 규칙 위반, 다음 요소가 건너뛰어짐\n    }\n  }\n}\n</pre>\n<h4>규칙을 준수하는 해결책</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\nvoid removeFrom(List&lt;String&gt; list) {\n  list.removeIf(String::isEmpty); // 규칙 준수\n}\n</pre>\n<h4>규칙을 준수하지 않는 코드 예시</h4>\n<p>루프의 부작용으로 인해 불가능한 경우 오름차순 루프를 내림차순 루프로 교체하세요. 내림차순 루프는 제거된 요소 이후의 요소 인덱스 감소의 영향을 받지 않습니다. 이미 반복되었기 때문입니다.</p>\n<pre data-diff-id=\"2\" data-diff-type=\"noncompliant\">\nvoid removeFrom(List&lt;String&gt; list) {\n  // 예상: 모든 리스트 요소 반복\n  for (int i = 0; i &lt; list.size(); i++) {\n    if (list.get(i).isEmpty()) {\n      list.remove(i); // 규칙 위반, 다음 요소가 건너뛰어짐\n    }\n  }\n}\n</pre>\n<h4>규칙을 준수하는 해결책</h4>\n<pre data-diff-id=\"2\" data-diff-type=\"compliant\">\nvoid removeFrom(List&lt;String&gt; list) {\n    // 예상: 모든 리스트 요소 반복\n    for (int i = list.size() - 1; i &gt;= 0; i--) {\n    if (list.get(i).isEmpty()) {\n      list.remove(i); // 규칙 준수, 제거된 것 이후의 요소는 이미 반복됨\n    }\n  }\n}\n</pre>\n<h4>규칙을 준수하지 않는 코드 예시</h4>\n<p>이 문제를 해결하는 또 다른 방법은 인덱스 감소를 설명하기 위해 <code>Collection.remove</code> 호출 후 루프 카운터를 조정하는 것입니다.</p>\n<pre data-diff-id=\"3\" data-diff-type=\"noncompliant\">\nvoid removeFrom(List&lt;String&gt; list) {\n  // 예상: 모든 리스트 요소 반복\n  for (int i = 0; i &lt; list.size(); i++) {\n    if (list.get(i).isEmpty()) {\n      list.remove(i); // 규칙 위반, 다음 요소가 건너뛰어짐\n    }\n  }\n}\n</pre>\n<h4>규칙을 준수하는 해결책</h4>\n<p><strong>이것은 권장되지 않습니다</strong>. <a href='/coding_rules#rule_key=java%3AS127'>S127</a> 규칙에 문제가 발생하기 때문입니다.</p>\n<pre data-diff-id=\"3\" data-diff-type=\"compliant\">\nvoid removeFrom(List&lt;String&gt; list) {\n  // 예상: 모든 리스트 요소 반복\n  for (int i = 0; i &lt; list.size(); i++) {\n    if (list.get(i).isEmpty()) {\n      list.remove(i); // 규칙 준수, 다음 줄의 카운터 조정으로 인해\n      i--; // S127에서 규칙 위반!\n    }\n  }\n}\n</pre>",
    "moreInfo_ko": "<h3>문서</h3>\n<ul>\n  <li> <a href=\"https://docs.oracle.com/javase/7/docs/api/java/util/Collection.html#remove(java.lang.Object)\">Java SE 7 API 명세: Collection.remove</a> </li>\n  <li> <a href=\"https://docs.oracle.com/javase/8/docs/api/java/util/Collection.html#removeIf-java.util.function.Predicate-\">Java SE 8 API 명세: Collection.removeIf</a> </li>\n  <li> <a href=\"https://sonarsource.github.io/rspec/#/rspec/S6068/java\"><a href='/coding_rules#rule_key=java%3AS127'>S127</a> - \"for\" 루프 중지 조건은 불변이어야 합니다</a> </li>\n</ul>"
  },
  {
    "id": "S2440",
    "key": "java:S2440",
    "name": "Classes with only \"static\" methods should not be instantiated",
    "type": "code-smell",
    "severity": "major",
    "tags": [
      "clumsy"
    ],
    "why": "<p><code>static</code> methods can be accessed without an instance of the enclosing class, so there's no reason to instantiate a class that has only\n<code>static</code> methods.</p>\n<h3>Noncompliant code example</h3>\n<pre>\npublic class TextUtils {\n  public static String stripHtml(String source) {\n    return source.replaceAll(\"&lt;[^&gt;]+&gt;\", \"\");\n  }\n}\n\npublic class TextManipulator {\n\n  // ...\n\n  public void cleanText(String source) {\n    TextUtils textUtils = new TextUtils(); // Noncompliant\n\n    String stripped = textUtils.stripHtml(source);\n\n    //...\n  }\n}\n</pre>\n<h3>Compliant solution</h3>\n<pre>\npublic class TextUtils {\n  public static String stripHtml(String source) {\n    return source.replaceAll(\"&lt;[^&gt;]+&gt;\", \"\");\n  }\n}\n\npublic class TextManipulator {\n\n  // ...\n\n  public void cleanText(String source) {\n    String stripped = TextUtils.stripHtml(source);\n\n    //...\n  }\n}\n</pre>",
    "howToFix": "",
    "moreInfo": "<h3>Related rules</h3>\n<ul>\n  <li> <a href='/coding_rules#rule_key=java%3AS1118'>S1118</a> - Utility classes should not have public constructors </li>\n</ul>",
    "status": "READY",
    "name_ko": "\"static\" 메서드만 있는 클래스는 인스턴스화하면 안 됩니다",
    "why_ko": "<p><code>static</code> 메서드는 해당 클래스의 인스턴스 없이 접근할 수 있으므로, <code>static</code> 메서드만 있는 클래스를 인스턴스화할 이유가 없습니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\npublic class TextUtils {\n  public static String stripHtml(String source) {\n    return source.replaceAll(\"&lt;[^&gt;]+&gt;\", \"\");\n  }\n}\n\npublic class TextManipulator {\n\n  // ...\n\n  public void cleanText(String source) {\n    TextUtils textUtils = new TextUtils(); // 규칙 위반\n\n    String stripped = textUtils.stripHtml(source);\n\n    //...\n  }\n}\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre>\npublic class TextUtils {\n  public static String stripHtml(String source) {\n    return source.replaceAll(\"&lt;[^&gt;]+&gt;\", \"\");\n  }\n}\n\npublic class TextManipulator {\n\n  // ...\n\n  public void cleanText(String source) {\n    String stripped = TextUtils.stripHtml(source);\n\n    //...\n  }\n}\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": "<h3>관련 규칙</h3>\n<ul>\n  <li> <a href='/coding_rules#rule_key=java%3AS1118'>S1118</a> - 유틸리티 클래스는 public 생성자를 가지면 안 됩니다 </li>\n</ul>"
  },
  {
    "id": "S5852",
    "key": "java:S5852",
    "name": "Using slow regular expressions is security-sensitive",
    "type": "security-hotspot",
    "severity": "critical",
    "tags": [
      "cwe",
      "regex"
    ],
    "why": "<p>Most of the regular expression engines use <code>backtracking</code> to try all possible execution paths of the regular expression when evaluating\nan input, in some cases it can cause performance issues, called <code>catastrophic backtracking</code> situations. In the worst case, the complexity\nof the regular expression is exponential in the size of the input, this means that a small carefully-crafted input (like 20 chars) can trigger\n<code>catastrophic backtracking</code> and cause a denial of service of the application. Super-linear regex complexity can lead to the same impact too\nwith, in this case, a large carefully-crafted input (thousands chars).</p>\n<p>This rule determines the runtime complexity of a regular expression and informs you of the complexity if it is not linear.</p>\n<p>Note that, due to improvements to the matching algorithm, some cases of exponential runtime complexity have become impossible when run using JDK 9\nor later. In such cases, an issue will only be reported if the project's target Java version is 8 or earlier.</p>\n",
    "howToFix": "<h2>Recommended Secure Coding Practices</h2>\n<p>To avoid <code>catastrophic backtracking</code> situations, make sure that none of the following conditions apply to your regular expression.</p>\n<p>In all of the following cases, catastrophic backtracking can only happen if the problematic part of the regex is followed by a pattern that can\nfail, causing the backtracking to actually happen. Note that when performing a full match (e.g. using <code>String.matches</code>), the end of the\nregex counts as a pattern that can fail because it will only succeed when the end of the string is reached.</p>\n<ul>\n  <li> If you have a non-possessive repetition <code>r*</code> or <code>r*?</code>, such that the regex <code>r</code> could produce different\n  possible matches (of possibly different lengths) on the same input, the worst case matching time can be exponential. This can be the case if\n  <code>r</code> contains optional parts, alternations or additional repetitions (but not if the repetition is written in such a way that there's only\n  one way to match it).\n    <ul>\n      <li> When using JDK 9 or later an optimization applies when the repetition is greedy and the entire regex does not contain any back references.\n      In that case the runtime will only be polynomial (in case of nested repetitions) or even linear (in case of alternations or optional parts).\n      </li>\n    </ul>  </li>\n  <li> If you have multiple non-possessive repetitions that can match the same contents and are consecutive or are only separated by an optional\n  separator or a separator that can be matched by both of the repetitions, the worst case matching time can be polynomial (O(n^c) where c is the\n  number of problematic repetitions). For example <code>a*b*</code> is not a problem because <code>a*</code> and <code>b*</code> match different\n  things and <code>a*_a*</code> is not a problem because the repetitions are separated by a <code>'_'</code> and can't match that <code>'_'</code>.\n  However, <code>a*a*</code> and <code>.*_.*</code> have quadratic runtime. </li>\n  <li> If you're performing a partial match (such as by using <code>Matcher.find</code>, <code>String.split</code>, <code>String.replaceAll</code>\n  etc.) and the regex is not anchored to the beginning of the string, quadratic runtime is especially hard to avoid because whenever a match fails,\n  the regex engine will try again starting at the next index. This means that any unbounded repetition (even a possessive one), if it's followed by a\n  pattern that can fail, can cause quadratic runtime on some inputs. For example <code>str.split(\"\\\\s*,\")</code> will run in quadratic time on strings\n  that consist entirely of spaces (or at least contain large sequences of spaces, not followed by a comma). </li>\n</ul>\n<p>In order to rewrite your regular expression without these patterns, consider the following strategies:</p>\n<ul>\n  <li> If applicable, define a maximum number of expected repetitions using the bounded quantifiers, like <code>{1,5}</code> instead of <code>+</code>\n  for instance. </li>\n  <li> Refactor <code>nested quantifiers</code> to limit the number of way the inner group can be matched by the outer quantifier, for instance this\n  nested quantifier situation <code>(ba+)+</code> doesn't cause performance issues, indeed, the inner group can be matched only if there exists\n  exactly one <code>b</code> char per repetition of the group. </li>\n  <li> Optimize regular expressions with <code>possessive quantifiers</code> and <code>atomic grouping</code>. </li>\n  <li> Use negated character classes instead of <code>.</code> to exclude separators where applicable. For example the quadratic regex\n  <code>.*_.*</code> can be made linear by changing it to <code>[^_]*_.*</code> </li>\n</ul>\n<p>Sometimes it's not possible to rewrite the regex to be linear while still matching what you want it to match. Especially when using partial\nmatches, for which it is quite hard to avoid quadratic runtimes. In those cases consider the following approaches:</p>\n<ul>\n  <li> Solve the problem without regular expressions </li>\n  <li> Use an alternative non-backtracking regex implementations such as Google's <a href=\"https://github.com/google/re2\">RE2</a> or <a\n  href=\"https://github.com/google/re2j\">RE2/J</a>. </li>\n  <li> Use multiple passes. This could mean pre- and/or post-processing the string manually before/after applying the regular expression to it or\n  using multiple regular expressions. One example of this would be to replace <code>str.split(\"\\\\s*,\\\\s*\")</code> with <code>str.split(\",\")</code> and\n  then trimming the spaces from the strings as a second step. </li>\n  <li> When using <code>Matcher.find()</code>, it is often possible to make the regex infallible by making all the parts that could fail optional,\n  which will prevent backtracking. Of course this means that you'll accept more strings than intended, but this can be handled by using capturing\n  groups to check whether the optional parts were matched or not and then ignoring the match if they weren't. For example the regex <code>x*y</code>\n  could be replaced with <code>x*(y)?</code> and then the call to <code>matcher.find()</code> could be replaced with <code>matcher.find() &amp;&amp;\n  matcher.group(1) != null</code>. </li>\n</ul>\n<h2>Compliant Solution</h2>\n<p>Possessive quantifiers do not keep backtracking positions, thus can be used, if possible, to avoid performance issues:</p>\n<pre>\njava.util.regex.Pattern.compile(\"(a+)++\").matcher(\n\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"+\n\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"+\n\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"+\n\"aaaaaaaaaaaaaaa!\").matches(); // Compliant\n\njava.util.regex.Pattern.compile(\"(h|h|ih(((i|a|c|c|a|i|i|j|b|a|i|b|a|a|j))+h)ahbfhba|c|i)*+\").matcher(\n\"hchcchicihcchciiicichhcichcihcchiihichiciiiihhcchi\"+\n\"cchhcihchcihiihciichhccciccichcichiihcchcihhicchcciicchcccihiiihhihihihi\"+\n\"chicihhcciccchihhhcchichchciihiicihciihcccciciccicciiiiiiiiicihhhiiiihchccch\"+\n\"chhhhiiihchihcccchhhiiiiiiiicicichicihcciciihichhhhchihciiihhiccccccciciihh\"+\n\"ichiccchhicchicihihccichicciihcichccihhiciccccccccichhhhihihhcchchihih\"+\n\"iihhihihihicichihiiiihhhhihhhchhichiicihhiiiiihchccccchichci\").matches(); // Compliant\n</pre>\n<h2>See</h2>\n<ul>\n  <li> OWASP - <a href=\"https://owasp.org/www-project-top-ten/2017/A1_2017-Injection\">Top 10 2017 Category A1 - Injection</a> </li>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/400\">CWE-400 - Uncontrolled Resource Consumption</a> </li>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/1333\">CWE-1333 - Inefficient Regular Expression Complexity</a> </li>\n  <li> <a href=\"https://owasp.org/www-community/attacks/Regular_expression_Denial_of_Service_-_ReDoS\">owasp.org</a> - OWASP Regular expression Denial\n  of Service - ReDoS </li>\n  <li> <a\n  href=\"https://web.archive.org/web/20220506215733/https://stackstatus.net/post/147710624694/outage-postmortem-july-20-2016\">stackstatus.net(archived)</a> - Outage Postmortem - July 20, 2016 </li>\n  <li> <a href=\"https://www.regular-expressions.info/catastrophic.html\">regular-expressions.info</a> - Runaway Regular Expressions: Catastrophic\n  Backtracking </li>\n  <li> <a\n  href=\"https://docs.microsoft.com/en-us/dotnet/standard/base-types/backtracking-in-regular-expressions#backtracking-with-nested-optional-quantifiers\">docs.microsoft.com</a> - Backtracking with Nested Optional Quantifiers </li>\n</ul>",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "느린 정규 표현식 사용은 보안에 민감합니다",
    "why_ko": "<p>대부분의 정규 표현식 엔진은 입력을 평가할 때 정규 표현식의 모든 가능한 실행 경로를 시도하기 위해 <code>역추적(backtracking)</code>을 사용합니다. 어떤 경우에는 <code>재앙적 역추적(catastrophic backtracking)</code>이라고 하는 성능 문제를 일으킬 수 있습니다. 최악의 경우 정규 표현식의 복잡성은 입력 크기에 대해 지수적이며, 이는 작은 신중하게 조작된 입력(20자 정도)이 <code>재앙적 역추적</code>을 트리거하고 애플리케이션의 서비스 거부를 일으킬 수 있음을 의미합니다. 초선형 정규식 복잡성은 이 경우 큰 신중하게 조작된 입력(수천 자)으로 동일한 영향을 줄 수 있습니다.</p>\n<p>이 규칙은 정규 표현식의 런타임 복잡성을 결정하고 선형이 아닌 경우 복잡성을 알려줍니다.</p>\n<p>매칭 알고리즘의 개선으로 인해 JDK 9 이상을 사용할 때 지수 런타임 복잡성의 일부 경우가 불가능해졌습니다. 이러한 경우 프로젝트의 대상 Java 버전이 8 이하인 경우에만 문제가 보고됩니다.</p>\n",
    "howToFix_ko": "<h2>권장 보안 코딩 관행</h2>\n<p><code>재앙적 역추적</code> 상황을 피하려면 다음 조건 중 어느 것도 정규 표현식에 적용되지 않도록 하세요.</p>\n<p>다음 모든 경우에서 재앙적 역추적은 정규식의 문제가 있는 부분 뒤에 실패할 수 있는 패턴이 있어 역추적이 실제로 발생하는 경우에만 발생할 수 있습니다. 전체 일치를 수행할 때(예: <code>String.matches</code> 사용) 정규식의 끝은 문자열의 끝에 도달할 때만 성공하므로 실패할 수 있는 패턴으로 간주됩니다.</p>\n<ul>\n  <li> 비소유 반복 <code>r*</code> 또는 <code>r*?</code>가 있고 정규식 <code>r</code>이 동일한 입력에서 (가능한 다른 길이의) 다른 가능한 일치를 생성할 수 있는 경우 최악의 일치 시간은 지수적일 수 있습니다. <code>r</code>에 선택적 부분, 대안 또는 추가 반복이 포함된 경우(반복이 일치하는 방법이 하나뿐인 방식으로 작성된 경우 제외) 이런 경우가 될 수 있습니다. </li>\n  <li> 동일한 내용과 일치할 수 있고 연속적이거나 선택적 구분자 또는 두 반복 모두와 일치할 수 있는 구분자로만 분리된 여러 비소유 반복이 있는 경우 최악의 일치 시간은 다항식(O(n^c), c는 문제가 있는 반복 수)일 수 있습니다. </li>\n  <li> 부분 일치를 수행하고(<code>Matcher.find</code>, <code>String.split</code>, <code>String.replaceAll</code> 등 사용) 정규식이 문자열의 시작에 앵커되지 않은 경우 일치가 실패할 때마다 정규식 엔진이 다음 인덱스에서 다시 시도하기 때문에 이차 런타임을 피하기가 특히 어렵습니다. </li>\n</ul>\n<h2>규칙을 준수하는 해결책</h2>\n<p>소유 수량자는 역추적 위치를 유지하지 않으므로 가능한 경우 성능 문제를 피하기 위해 사용할 수 있습니다:</p>\n<pre>\njava.util.regex.Pattern.compile(\"(a+)++\").matcher(\n\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"+\n\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"+\n\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"+\n\"aaaaaaaaaaaaaaa!\").matches(); // 규칙 준수\n</pre>\n<h2>참고</h2>\n<ul>\n  <li> OWASP - <a href=\"https://owasp.org/www-project-top-ten/2017/A1_2017-Injection\">Top 10 2017 카테고리 A1 - 인젝션</a> </li>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/400\">CWE-400 - 제어되지 않는 리소스 소비</a> </li>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/1333\">CWE-1333 - 비효율적인 정규 표현식 복잡성</a> </li>\n  <li> <a href=\"https://owasp.org/www-community/attacks/Regular_expression_Denial_of_Service_-_ReDoS\">owasp.org</a> - OWASP 정규 표현식 서비스 거부 - ReDoS </li>\n</ul>",
    "moreInfo_ko": ""
  },
  {
    "id": "S2694",
    "key": "java:S2694",
    "name": "Inner classes which do not reference their owning classes should be \"static\"",
    "type": "code-smell",
    "severity": "major",
    "tags": [
      "performance"
    ],
    "why": "<p>A non-static inner class has a reference to its outer class, and access to the outer class' fields and methods. That class reference makes the\ninner class larger and could cause the outer class instance to live in memory longer than necessary.</p>\n<p>If the reference to the outer class isn't used, it is more efficient to make the inner class <code>static</code> (also called nested). If the\nreference is used only in the class constructor, then explicitly pass a class reference to the constructor. If the inner class is anonymous, it will\nalso be necessary to name it.</p>\n<p>However, while a nested/<code>static</code> class would be more efficient, it's worth noting that there are semantic differences between an inner\nclass and a nested one:</p>\n<ul>\n  <li> an inner class can only be instantiated within the context of an instance of the outer class. </li>\n  <li> a nested (<code>static</code>) class can be instantiated independently of the outer class. </li>\n</ul>",
    "howToFix": "<p>There are two scenarios in which this rule will raise an issue:</p>\n<ol>\n  <li> On an <em>inner class</em>: make it <code>static</code>. </li>\n  <li> On a <em>local class</em>: extract it as a <code>static</code> <em>inner class</em>. </li>\n</ol>\n\n<h4>Noncompliant code example</h4>\n<p>Inner classes that don't use the outer class reference should be static.</p>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\npublic class Fruit {\n  // ...\n\n  public class Seed {  // Noncompliant; there's no use of the outer class reference so make it static\n    int germinationDays = 0;\n    public Seed(int germinationDays) {\n      this.germinationDays = germinationDays;\n    }\n    public int getGerminationDays() {\n      return germinationDays;\n    }\n  }\n}\n</pre>\n<h4>Compliant solution</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\npublic class Fruit {\n  // ...\n\n  public static class Seed {\n    int germinationDays = 0;\n    public Seed(int germinationDays) {\n      this.germinationDays = germinationDays;\n    }\n    public int getGerminationDays() {\n      return germinationDays;\n    }\n  }\n}\n</pre>\n<p>Local classes that don't use the outer class reference should be extracted as a static inner classes.</p>\n<h4>Noncompliant code example</h4>\n<pre data-diff-id=\"2\" data-diff-type=\"noncompliant\">\npublic class Foo {\n  public Foo() {\n    class Bar { // Noncompliant\n      void doSomething() {\n        // ...\n      }\n    }\n    new Bar().doSomething();\n  }\n\n  public void method() {\n    class Baz { // Noncompliant\n      void doSomething() {\n        // ...\n      }\n    }\n    new Baz().doSomething();\n  }\n}\n</pre>\n<h4>Compliant solution</h4>\n<pre data-diff-id=\"2\" data-diff-type=\"compliant\">\npublic class Foo {\n  public Foo() {\n    new Bar().doSomething();\n  }\n\n  public void method()  {\n    new Baz().doSomething();\n  }\n\n  private static class Bar { // Compliant\n    void doSomething() {\n      // ...\n    }\n  }\n\n  private static class Baz { // Compliant\n    void doSomething() {\n      // ...\n    }\n  }\n}\n</pre>",
    "moreInfo": "<h3>Documentation</h3>\n<ul>\n  <li> <a href=\"https://docs.oracle.com/javase/tutorial/java/javaOO/nested.html\">Oracle Java SE - Nested Classes</a> </li>\n  <li> <a href=\"https://docs.oracle.com/javase/tutorial/java/javaOO/localclasses.html\">Oracle Java SE - Local Classes</a> </li>\n</ul>\n<h3>Articles &amp; blog posts</h3>\n<ul>\n  <li> <a href=\"https://www.geeksforgeeks.org/difference-between-static-and-non-static-nested-class-in-java/\">GeeksforGeeks - Difference between\n  static and non-static nested class in Java</a> </li>\n</ul>",
    "status": "READY",
    "name_ko": "외부 클래스를 참조하지 않는 내부 클래스는 \"static\"이어야 합니다",
    "why_ko": "<p>비정적 내부 클래스는 외부 클래스에 대한 참조를 가지며 외부 클래스의 필드와 메서드에 접근할 수 있습니다. 이 클래스 참조는 내부 클래스를 더 크게 만들고 외부 클래스 인스턴스가 필요 이상으로 메모리에 오래 남아있게 할 수 있습니다.</p>\n<p>외부 클래스에 대한 참조가 사용되지 않으면 내부 클래스를 <code>static</code>(중첩이라고도 함)으로 만드는 것이 더 효율적입니다. 참조가 클래스 생성자에서만 사용된다면 생성자에 클래스 참조를 명시적으로 전달하세요. 내부 클래스가 익명이면 이름을 지정해야 합니다.</p>\n<p>그러나 중첩/<code>static</code> 클래스가 더 효율적이지만, 내부 클래스와 중첩 클래스 사이에는 의미론적 차이가 있음을 유의해야 합니다:</p>\n<ul>\n  <li> 내부 클래스는 외부 클래스 인스턴스의 컨텍스트 내에서만 인스턴스화할 수 있습니다. </li>\n  <li> 중첩(<code>static</code>) 클래스는 외부 클래스와 독립적으로 인스턴스화할 수 있습니다. </li>\n</ul>",
    "howToFix_ko": "<p>이 규칙이 문제를 제기하는 두 가지 시나리오가 있습니다:</p>\n<ol>\n  <li> <em>내부 클래스</em>에서: <code>static</code>으로 만드세요. </li>\n  <li> <em>지역 클래스</em>에서: <code>static</code> <em>내부 클래스</em>로 추출하세요. </li>\n</ol>\n\n<h4>규칙을 준수하지 않는 코드 예시</h4>\n<p>외부 클래스 참조를 사용하지 않는 내부 클래스는 static이어야 합니다.</p>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\npublic class Fruit {\n  // ...\n\n  public class Seed {  // 규칙 위반; 외부 클래스 참조를 사용하지 않으므로 static으로 만드세요\n    int germinationDays = 0;\n    public Seed(int germinationDays) {\n      this.germinationDays = germinationDays;\n    }\n    public int getGerminationDays() {\n      return germinationDays;\n    }\n  }\n}\n</pre>\n<h4>규칙을 준수하는 해결책</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\npublic class Fruit {\n  // ...\n\n  public static class Seed {\n    int germinationDays = 0;\n    public Seed(int germinationDays) {\n      this.germinationDays = germinationDays;\n    }\n    public int getGerminationDays() {\n      return germinationDays;\n    }\n  }\n}\n</pre>\n<p>외부 클래스 참조를 사용하지 않는 지역 클래스는 정적 내부 클래스로 추출해야 합니다.</p>\n<h4>규칙을 준수하지 않는 코드 예시</h4>\n<pre data-diff-id=\"2\" data-diff-type=\"noncompliant\">\npublic class Foo {\n  public Foo() {\n    class Bar { // 규칙 위반\n      void doSomething() {\n        // ...\n      }\n    }\n    new Bar().doSomething();\n  }\n\n  public void method() {\n    class Baz { // 규칙 위반\n      void doSomething() {\n        // ...\n      }\n    }\n    new Baz().doSomething();\n  }\n}\n</pre>\n<h4>규칙을 준수하는 해결책</h4>\n<pre data-diff-id=\"2\" data-diff-type=\"compliant\">\npublic class Foo {\n  public Foo() {\n    new Bar().doSomething();\n  }\n\n  public void method()  {\n    new Baz().doSomething();\n  }\n\n  private static class Bar { // 규칙 준수\n    void doSomething() {\n      // ...\n    }\n  }\n\n  private static class Baz { // 규칙 준수\n    void doSomething() {\n      // ...\n    }\n  }\n}\n</pre>",
    "moreInfo_ko": "<h3>문서</h3>\n<ul>\n  <li> <a href=\"https://docs.oracle.com/javase/tutorial/java/javaOO/nested.html\">Oracle Java SE - 중첩 클래스</a> </li>\n  <li> <a href=\"https://docs.oracle.com/javase/tutorial/java/javaOO/localclasses.html\">Oracle Java SE - 지역 클래스</a> </li>\n</ul>\n<h3>기사 및 블로그 포스트</h3>\n<ul>\n  <li> <a href=\"https://www.geeksforgeeks.org/difference-between-static-and-non-static-nested-class-in-java/\">GeeksforGeeks - Java에서 정적 및 비정적 중첩 클래스의 차이점</a> </li>\n</ul>"
  },
  {
    "id": "S3986",
    "key": "java:S3986",
    "name": "Week Year (\"YYYY\") should not be used for date formatting",
    "type": "bug",
    "severity": "major",
    "tags": [
      "suspicious"
    ],
    "why": "<p>Few developers are aware of the difference between <code>Y</code> for \"Week year\" and <code>y</code> for Year when formatting and parsing a date\nwith <code>SimpleDateFormat</code> or <code>DateTimeFormatter</code>. That's likely because for most dates, Week year and Year are the same, so\ntesting at any time other than the first or last week of the year will yield the same value for both <code>y</code> and <code>Y</code>. But in the\nlast week of December and the first week of January, you may get unexpected results.</p>\n<p>According to the <a href=\"http://docs.oracle.com/javase/8/docs/api/java/util/GregorianCalendar.html#week_year\">Javadoc</a>:</p>\n<blockquote>\n  <p>A week year is in sync with a WEEK_OF_YEAR cycle. All weeks between the first and last weeks (inclusive) have the same week year value.\n  Therefore, the first and last days of a week year may have different calendar year values.</p>\n  <p>For example, January 1, 1998 is a Thursday. If getFirstDayOfWeek() is MONDAY and getMinimalDaysInFirstWeek() is 4 (ISO 8601 standard compatible\n  setting), then week 1 of 1998 starts on December 29, 1997, and ends on January 4, 1998. The week year is 1998 for the last three days of calendar\n  year 1997. If, however, getFirstDayOfWeek() is SUNDAY, then week 1 of 1998 starts on January 4, 1998, and ends on January 10, 1998; the first three\n  days of 1998 then are part of week 53 of 1997 and their week year is 1997.</p>\n</blockquote>\n<h3>Noncompliant code example</h3>\n<pre>\nDate date = new SimpleDateFormat(\"yyyy/MM/dd\").parse(\"2015/12/31\");\nString result = new SimpleDateFormat(\"YYYY/MM/dd\").format(date);   //Noncompliant; yields '2016/12/31'\nresult = DateTimeFormatter.ofPattern(\"YYYY/MM/dd\").format(date); //Noncompliant; yields '2016/12/31'\n</pre>\n<h3>Compliant solution</h3>\n<pre>\nDate date = new SimpleDateFormat(\"yyyy/MM/dd\").parse(\"2015/12/31\");\nString result = new SimpleDateFormat(\"yyyy/MM/dd\").format(date);   //Yields '2015/12/31' as expected\nresult = DateTimeFormatter.ofPattern(\"yyyy/MM/dd\").format(date); //Yields '2015/12/31' as expected\n</pre>\n<h3>Exceptions</h3>\n<pre>\nDate date = new SimpleDateFormat(\"yyyy/MM/dd\").parse(\"2015/12/31\");\nString result = new SimpleDateFormat(\"YYYY-ww\").format(date);  //compliant, 'Week year' is used along with 'Week of year'. result = '2016-01'\nDateTimeFormatter.ofPattern(\"YYYY-ww\").format(date); //compliant; yields '2016-01' as expected\n</pre>",
    "howToFix": "",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "날짜 포맷팅에 Week Year (\"YYYY\")를 사용하면 안 됩니다",
    "why_ko": "<p><code>SimpleDateFormat</code> 또는 <code>DateTimeFormatter</code>로 날짜를 포맷하고 파싱할 때 \"Week year\"의 <code>Y</code>와 Year의 <code>y</code>의 차이를 아는 개발자는 거의 없습니다. 대부분의 날짜에서 Week year와 Year가 동일하기 때문일 것입니다. 따라서 연초나 연말 첫째 주가 아닌 시간에 테스트하면 <code>y</code>와 <code>Y</code> 모두 동일한 값을 산출합니다. 그러나 12월 마지막 주와 1월 첫째 주에는 예상치 못한 결과가 나올 수 있습니다.</p>\n<p><a href=\"http://docs.oracle.com/javase/8/docs/api/java/util/GregorianCalendar.html#week_year\">Javadoc</a>에 따르면:</p>\n<blockquote>\n  <p>Week year는 WEEK_OF_YEAR 주기와 동기화됩니다. 첫 번째 주와 마지막 주 사이의 모든 주(포함)는 동일한 week year 값을 갖습니다. 따라서 week year의 첫째 날과 마지막 날은 다른 달력 연도 값을 가질 수 있습니다.</p>\n  <p>예를 들어, 1998년 1월 1일은 목요일입니다. getFirstDayOfWeek()가 MONDAY이고 getMinimalDaysInFirstWeek()가 4(ISO 8601 표준 호환 설정)인 경우, 1998년 1주차는 1997년 12월 29일에 시작하여 1998년 1월 4일에 끝납니다. 1997년 달력 연도의 마지막 3일의 week year는 1998입니다. 그러나 getFirstDayOfWeek()가 SUNDAY인 경우, 1998년 1주차는 1998년 1월 4일에 시작하여 1998년 1월 10일에 끝납니다. 그러면 1998년의 처음 3일은 1997년 53주차의 일부이고 week year는 1997입니다.</p>\n</blockquote>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\nDate date = new SimpleDateFormat(\"yyyy/MM/dd\").parse(\"2015/12/31\");\nString result = new SimpleDateFormat(\"YYYY/MM/dd\").format(date);   //규칙 위반; '2016/12/31' 산출\nresult = DateTimeFormatter.ofPattern(\"YYYY/MM/dd\").format(date); //규칙 위반; '2016/12/31' 산출\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre>\nDate date = new SimpleDateFormat(\"yyyy/MM/dd\").parse(\"2015/12/31\");\nString result = new SimpleDateFormat(\"yyyy/MM/dd\").format(date);   //예상대로 '2015/12/31' 산출\nresult = DateTimeFormatter.ofPattern(\"yyyy/MM/dd\").format(date); //예상대로 '2015/12/31' 산출\n</pre>\n<h3>예외</h3>\n<pre>\nDate date = new SimpleDateFormat(\"yyyy/MM/dd\").parse(\"2015/12/31\");\nString result = new SimpleDateFormat(\"YYYY-ww\").format(date);  //규칙 준수, 'Week year'가 'Week of year'와 함께 사용됨. result = '2016-01'\nDateTimeFormatter.ofPattern(\"YYYY-ww\").format(date); //규칙 준수; 예상대로 '2016-01' 산출\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": ""
  },
  {
    "id": "S7479",
    "key": "java:S7479",
    "name": "\"ClassBuilder.withMethodBody\" should be preferred to \"ClassBuilder.withMethod\"",
    "type": "code-smell",
    "severity": "minor",
    "tags": [
      "java24"
    ],
    "why": "<p>The <code>ClassBuilder</code> API provides multiple ways to declare a method and its body, including <code>withMethod</code> and\n<code>withMethodBody</code>. While they can be used in very similar ways, <code>withMethodBody</code> reduces boilerplate code, lowers cognitive\ncomplexity and improves maintainability.</p>\n<h3>Exceptions</h3>\n<p>The rule will not raise on calls where the method under construction is abstract (eg: using the flag <code>ClassFile.ACC_ABSTRACT</code>).</p>",
    "howToFix": "<p>Replace the invocation of <code>withMethod</code> with <code>withMethodBody</code>.</p>\n\n<h4>Noncompliant code example</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\nClassBuilder addMethod(ClassBuilder builder) {\n    return builder\n        .withMethod(\"foo\", MTD_void, ACC_PUBLIC | ACC_STATIC, methodBuilder -&gt; { // Noncompliant\n            methodBuilder.withCode(codeBuilder -&gt;\n                codeBuilder.getstatic(ClassDesc.of(\"java.lang.System\"), \"out\", ClassDesc.of(\"java.io.PrintStream\"))\n                    .ldc(\"Hello World\")\n                    .invokevirtual(ClassDesc.of(\"java.io.PrintStream\"), \"println\", MTD_void)\n                    .return_()\n            );\n        });\n}\n</pre>\n<h4>Compliant solution</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\nClassBuilder addMethod(ClassBuilder builder) {\n    return builder\n        .withMethodBody(\"foo\", MTD_void, ACC_PUBLIC | ACC_STATIC, codeBuilder -&gt;\n            codeBuilder.getstatic(ClassDesc.of(\"java.lang.System\"), \"out\", ClassDesc.of(\"java.io.PrintStream\"))\n                .ldc(\"Hello World\")\n                .invokevirtual(ClassDesc.of(\"java.io.PrintStream\"), \"println\", MTD_void)\n                .return_()\n        );\n}\n</pre>",
    "moreInfo": "<h3>Documentation</h3>\n<ul>\n  <li> <a\n  href=\"https://docs.oracle.com/en/java/javase/24/docs/api/java.base/java/lang/classfile/package-summary.html#writing-classfiles-heading\">Writing\n  classfiles - classfile Javadoc</a> </li>\n  <li> <a\n  href=\"https://docs.oracle.com/en/java/javase/24/docs/api/java.base/java/lang/classfile/ClassBuilder.html#withMethod(java.lang.classfile.constantpool.Utf8Entry,java.lang.classfile.constantpool.Utf8Entry,int,java.util.function.Consumer)\">withMethod - ClassBuilder Javadoc</a> </li>\n  <li> <a\n  href=\"https://docs.oracle.com/en/java/javase/24/docs/api/java.base/java/lang/classfile/ClassBuilder.html#withMethodBody(java.lang.classfile.constantpool.Utf8Entry,java.lang.classfile.constantpool.Utf8Entry,int,java.util.function.Consumer)\">withMethodBody - ClassBuilder Javadoc</a> </li>\n  <li> <a href=\"https://openjdk.org/jeps/484\">JEP 484: Class-File API</a> </li>\n</ul>",
    "status": "READY",
    "name_ko": "\"ClassBuilder.withMethod\"보다 \"ClassBuilder.withMethodBody\"를 사용해야 합니다","why_ko": "<p><code>ClassBuilder</code> API는 <code>withMethod</code>와 <code>withMethodBody</code>를 포함하여 메서드와 본문을 선언하는 여러 방법을 제공합니다. 매우 유사한 방식으로 사용할 수 있지만 <code>withMethodBody</code>는 보일러플레이트 코드를 줄이고 인지 복잡성을 낮추며 유지 관리성을 향상시킵니다.</p>\n<h3>예외</h3>\n<p>이 규칙은 생성 중인 메서드가 추상 메서드인 경우(예: <code>ClassFile.ACC_ABSTRACT</code> 플래그 사용)에는 이슈를 발생시키지 않습니다.</p>",
    "howToFix_ko": "<p><code>withMethod</code> 호출을 <code>withMethodBody</code>로 교체하세요.</p>\n\n<h4>규칙을 준수하지 않는 코드 예시</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\nClassBuilder addMethod(ClassBuilder builder) {\n    return builder\n        .withMethod(\"foo\", MTD_void, ACC_PUBLIC | ACC_STATIC, methodBuilder -&gt; { // 규칙 위반\n            methodBuilder.withCode(codeBuilder -&gt;\n                codeBuilder.getstatic(ClassDesc.of(\"java.lang.System\"), \"out\", ClassDesc.of(\"java.io.PrintStream\"))\n                    .ldc(\"Hello World\")\n                    .invokevirtual(ClassDesc.of(\"java.io.PrintStream\"), \"println\", MTD_void)\n                    .return_()\n            );\n        });\n}\n</pre>\n<h4>규칙을 준수하는 해결책</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\nClassBuilder addMethod(ClassBuilder builder) {\n    return builder\n        .withMethodBody(\"foo\", MTD_void, ACC_PUBLIC | ACC_STATIC, codeBuilder -&gt;\n            codeBuilder.getstatic(ClassDesc.of(\"java.lang.System\"), \"out\", ClassDesc.of(\"java.io.PrintStream\"))\n                .ldc(\"Hello World\")\n                .invokevirtual(ClassDesc.of(\"java.io.PrintStream\"), \"println\", MTD_void)\n                .return_()\n        );\n}\n</pre>",
    "moreInfo_ko": "<h3>문서</h3>\n<ul>\n  <li> <a href=\"https://docs.oracle.com/en/java/javase/24/docs/api/java.base/java/lang/classfile/package-summary.html#writing-classfiles-heading\">classfile 작성 - classfile Javadoc</a> </li>\n  <li> <a href=\"https://docs.oracle.com/en/java/javase/24/docs/api/java.base/java/lang/classfile/ClassBuilder.html#withMethod(java.lang.classfile.constantpool.Utf8Entry,java.lang.classfile.constantpool.Utf8Entry,int,java.util.function.Consumer)\">withMethod - ClassBuilder Javadoc</a> </li>\n  <li> <a href=\"https://docs.oracle.com/en/java/javase/24/docs/api/java.base/java/lang/classfile/ClassBuilder.html#withMethodBody(java.lang.classfile.constantpool.Utf8Entry,java.lang.classfile.constantpool.Utf8Entry,int,java.util.function.Consumer)\">withMethodBody - ClassBuilder Javadoc</a> </li>\n  <li> <a href=\"https://openjdk.org/jeps/484\">JEP 484: Class-File API</a> </li>\n</ul>"
  },
  {
    "id": "S7183",
    "key": "java:S7183",
    "name": "@InitBinder methods should have void return type",
    "type": "code-smell",
    "severity": "major",
    "tags": [
      "spring"
    ],
    "why": "<p>Spring provides the <code>@InitBinder</code> annotation to initialize a <code>WebDataBinder</code> instance for controllers. This is useful to bind\nrequest parameters to a model object, and to plug converters and formatters into this process.</p>\n<p>Methods annotated with <code>@InitBinder</code> must not have a return value, otherwise the controller containing them will throw an exception when\ninvoked.</p>\n<p>This rule raises an issue when a method annotated with <code>@InitBinder</code> does not have a <code>void</code> return type</p>",
    "howToFix": "<h4>Noncompliant code example</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\n@Controller\npublic class MyController {\n\n\t@InitBinder\n\tpublic String initBinder(WebDataBinder binder) { // Non compliant, make the @InitBinder method return void\n\t\tSimpleDateFormat dateFormat = new SimpleDateFormat(\"yyyy-MM-dd\");\n\t\tdateFormat.setLenient(false);\n\t\tbinder.registerCustomEditor(Date.class, new CustomDateEditor(dateFormat, false));\n        return \"OK\";\n\t}\n\n\t// ...\n}\n</pre>\n<h4>Compliant solution</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\n@Controller\npublic class MyController {\n\n\t@InitBinder\n\tpublic void initBinder(WebDataBinder binder) {\n\t\tSimpleDateFormat dateFormat = new SimpleDateFormat(\"yyyy-MM-dd\");\n\t\tdateFormat.setLenient(false);\n\t\tbinder.registerCustomEditor(Date.class, new CustomDateEditor(dateFormat, false));\n\t}\n\n\t// ...\n}\n</pre>",
    "moreInfo": "<h3>Documentation</h3>\n<ul>\n  <li> Spring api - <a\n  href=\"https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/web/bind/annotation/InitBinder.html\">@InitBinder api</a>\n  </li>\n  <li> String documentation - <a href=\"https://docs.spring.io/spring-framework/reference/web/webmvc/mvc-controller/ann-initbinder.html\">@InitBinder\n  docs</a> </li>\n</ul>",
    "status": "READY",
    "name_ko": "@InitBinder 메서드는 void 반환 타입을 가져야 합니다",
    "why_ko": "<p>Spring은 컨트롤러에 대한 <code>WebDataBinder</code> 인스턴스를 초기화하기 위해 <code>@InitBinder</code> 어노테이션을 제공합니다. 이것은 요청 매개변수를 모델 객체에 바인딩하고 이 프로세스에 변환기와 포매터를 연결하는 데 유용합니다.</p>\n<p><code>@InitBinder</code>로 어노테이션된 메서드는 반환 값을 가져서는 안 됩니다. 그렇지 않으면 해당 메서드를 포함하는 컨트롤러가 호출될 때 예외를 발생시킵니다.</p>\n<p>이 규칙은 <code>@InitBinder</code>로 어노테이션된 메서드가 <code>void</code> 반환 타입을 갖지 않을 때 문제를 발생시킵니다.</p>",
    "howToFix_ko": "<h4>규칙을 준수하지 않는 코드 예시</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\n@Controller\npublic class MyController {\n\n\t@InitBinder\n\tpublic String initBinder(WebDataBinder binder) { // 규칙 위반, @InitBinder 메서드가 void를 반환하도록 하세요\n\t\tSimpleDateFormat dateFormat = new SimpleDateFormat(\"yyyy-MM-dd\");\n\t\tdateFormat.setLenient(false);\n\t\tbinder.registerCustomEditor(Date.class, new CustomDateEditor(dateFormat, false));\n        return \"OK\";\n\t}\n\n\t// ...\n}\n</pre>\n<h4>규칙을 준수하는 해결책</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\n@Controller\npublic class MyController {\n\n\t@InitBinder\n\tpublic void initBinder(WebDataBinder binder) {\n\t\tSimpleDateFormat dateFormat = new SimpleDateFormat(\"yyyy-MM-dd\");\n\t\tdateFormat.setLenient(false);\n\t\tbinder.registerCustomEditor(Date.class, new CustomDateEditor(dateFormat, false));\n\t}\n\n\t// ...\n}\n</pre>",
    "moreInfo_ko": "<h3>문서</h3>\n<ul>\n  <li> Spring API - <a href=\"https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/web/bind/annotation/InitBinder.html\">@InitBinder API</a> </li>\n  <li> Spring 문서 - <a href=\"https://docs.spring.io/spring-framework/reference/web/webmvc/mvc-controller/ann-initbinder.html\">@InitBinder 문서</a> </li>\n</ul>"
  },
  {
    "id": "S114",
    "key": "java:S114",
    "name": "Interface names should comply with a naming convention",
    "type": "code-smell",
    "severity": "minor",
    "tags": [
      "convention"
    ],
    "why": "<p>Sharing some naming conventions is a key point to make it possible for a team to efficiently collaborate. This rule allows to check that all\ninterface names match a provided regular expression.</p>\n<h3>Noncompliant code example</h3>\n<p>With the default regular expression <code>^[A-Z][a-zA-Z0-9]*$</code>:</p>\n<pre>\npublic interface myInterface {...} // Noncompliant\n</pre>\n<h3>Compliant solution</h3>\n<pre>\npublic interface MyInterface {...}\n</pre>",
    "howToFix": "",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "인터페이스 이름은 명명 규칙을 준수해야 합니다",
    "why_ko": "<p>일부 명명 규칙을 공유하는 것은 팀이 효율적으로 협업할 수 있도록 하는 핵심 포인트입니다. 이 규칙을 사용하면 모든 인터페이스 이름이 제공된 정규 표현식과 일치하는지 확인할 수 있습니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<p>기본 정규 표현식 <code>^[A-Z][a-zA-Z0-9]*$</code>의 경우:</p>\n<pre>\npublic interface myInterface {...} // 규칙 위반\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre>\npublic interface MyInterface {...}\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": ""
  },
  {
    "id": "S4605",
    "key": "java:S4605",
    "name": "Spring beans should be considered by \"@ComponentScan\"",
    "type": "code-smell",
    "severity": "critical",
    "tags": [
      "spring",
      "pitfall"
    ],
    "why": "<p>Spring beans belonging to packages that are not included in a <code>@ComponentScan</code> configuration will not be accessible in the Spring\nApplication Context. Therefore, it's likely to be a configuration mistake that will be detected by this rule.</p>\n<p><strong>Note:</strong> the <code>@ComponentScan</code> is implicit in the <code>@SpringBootApplication</code> annotation, case in which Spring Boot\nwill auto scan for components in the package containing the Spring Boot main class and its sub-packages.</p>\n<h3>Noncompliant code example</h3>\n<pre>\npackage com.mycompany.app;\n\n@Configuration\n@ComponentScan(\"com.mycompany.app.beans\")\npublic class Application {\n...\n}\n\npackage com.mycompany.app.web;\n\n@Controller\npublic class MyController { // Noncompliant; MyController belong to \"com.mycompany.app.web\" while the ComponentScan is looking for beans in \"com.mycompany.app.beans\" package\n...\n}\n</pre>\n<h3>Compliant solution</h3>\n<pre>\npackage com.mycompany.app;\n\n@Configuration\n@ComponentScan({\"com.mycompany.app.beans\",\"com.mycompany.app.web\"})\nor\n@ComponentScan(\"com.mycompany.app\")\nor\n@ComponentScan\npublic class Application {\n...\n}\n\npackage com.mycompany.app.web;\n\n@Controller\npublic class MyController { // \"com.mycompany.app.web\" is referenced by a @ComponentScan annotated class\n...\n}\n</pre>",
    "howToFix": "",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "Spring 빈은 @ComponentScan에 의해 인식되어야 합니다",
    "why_ko": "<p><code>@ComponentScan</code> 구성에 포함되지 않은 패키지에 속하는 Spring 빈은 Spring Application Context에서 접근할 수 없습니다. 따라서 이 규칙에 의해 감지되는 구성 실수일 가능성이 높습니다.</p>\n<p><strong>참고:</strong> <code>@ComponentScan</code>은 <code>@SpringBootApplication</code> 어노테이션에 암시적으로 포함되어 있으며, 이 경우 Spring Boot는 Spring Boot 메인 클래스가 포함된 패키지와 그 하위 패키지에서 컴포넌트를 자동으로 스캔합니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\npackage com.mycompany.app;\n\n@Configuration\n@ComponentScan(\"com.mycompany.app.beans\")\npublic class Application {\n...\n}\n\npackage com.mycompany.app.web;\n\n@Controller\npublic class MyController { // 규칙 위반; MyController는 \"com.mycompany.app.web\"에 속하지만 ComponentScan은 \"com.mycompany.app.beans\" 패키지에서 빈을 찾고 있음\n...\n}\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre>\npackage com.mycompany.app;\n\n@Configuration\n@ComponentScan({\"com.mycompany.app.beans\",\"com.mycompany.app.web\"})\nor\n@ComponentScan(\"com.mycompany.app\")\nor\n@ComponentScan\npublic class Application {\n...\n}\n\npackage com.mycompany.app.web;\n\n@Controller\npublic class MyController { // \"com.mycompany.app.web\"가 @ComponentScan 어노테이션이 달린 클래스에 의해 참조됨\n...\n}\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": ""
  },
  {
    "id": "S5917",
    "key": "java:S5917",
    "name": "DateTimeFormatters should not use mismatched year and week numbers",
    "type": "bug",
    "severity": "major",
    "tags": [],
    "why": "<p>When creating a <code>DateTimeFormatter</code> using the <code>WeekFields.weekBasedYear()</code> temporal field, the resulting year number may be\noff by 1 at the beginning of a new year (when the date to format is in a week that is shared by two consecutive years).</p>\n<p>Using this year number in combination with an incompatible week temporal field yields a result that may be confused with the first week of the\nprevious year.</p>\n<p>Instead, when paired with a week temporal field, the week-based year should only be used with the week of week-based year temporal field\n<code>WeekFields.weekOfWeekBasedYear()</code>.</p>\n<p>Alternatively the temporal field <code>ChronoField.ALIGNED_WEEK_OF_YEAR</code> can be used together with a regular year (but not the week based\nyear).</p>\n<h3>Noncompliant code example</h3>\n<pre>\nnew DateTimeFormatterBuilder()\n      .appendValue(ChronoField.YEAR, 4) // Noncompliant: using week of week-based year with regular year\n      .appendLiteral('-')\n      .appendValue(WeekFields.ISO.weekOfWeekBasedYear(), 2)\n      .toFormatter();\n\nnew DateTimeFormatterBuilder()\n      .appendValue(ChronoField.YEAR_OF_ERA, 4) // Noncompliant: using week of week-based year with regular year\n      .appendLiteral('-')\n      .appendValue(WeekFields.ISO.weekOfWeekBasedYear(), 2)\n      .toFormatter();\n\nnew DateTimeFormatterBuilder()\n      .appendValue(WeekFields.ISO.weekBasedYear(), 4) // Noncompliant: using aligned week of year with week-based year\n      .appendLiteral('-')\n      .appendValue(ChronoField.ALIGNED_WEEK_OF_YEAR, 2)\n      .toFormatter();\n</pre>\n<p>Here the first two formatters would wrongly format the 1st of January 2016 as \"2016-53\" while the last one would format it as \"2015-01\"</p>\n<h3>Compliant solution</h3>\n<pre>\nnew DateTimeFormatterBuilder()\n      .appendValue(WeekFields.ISO.weekBasedYear(), 4)\n      .appendLiteral('-')\n      .appendValue(WeekFields.ISO.weekOfWeekBasedYear(), 2)\n      .toFormatter();\n\nnew DateTimeFormatterBuilder()\n      .appendValue(ChronoField.YEAR, 4)\n      .appendLiteral('-')\n      .appendValue(ChronoField.ALIGNED_WEEK_OF_YEAR, 2)\n      .toFormatter();\n\nnew DateTimeFormatterBuilder()\n      .appendValue(ChronoField.YEAR_OF_ERA, 4)\n      .appendLiteral('-')\n      .appendValue(ChronoField.ALIGNED_WEEK_OF_YEAR, 2)\n      .toFormatter();\n</pre>\n<p>Here the first formatter would format the 1st of January 2016 as \"2015-53\" while the last two would produce \"2016-01\", both of which are correct\ndepending on how you count the weeks.</p>\n<h3>Exceptions</h3>\n<p>No issue is raised when week-based year is not used in combination with a week temporal field.</p>\n<p>Similarly, no issue is raised if week of week-based year is not used in combination with a year temporal field.</p>",
    "howToFix": "",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "DateTimeFormatter에서 일치하지 않는 연도와 주 번호를 사용하면 안 됩니다",
    "why_ko": "<p><code>WeekFields.weekBasedYear()</code> 시간 필드를 사용하여 <code>DateTimeFormatter</code>를 생성할 때, 결과 연도 숫자는 새해 초에 1만큼 차이가 날 수 있습니다(포맷할 날짜가 두 연속 연도에 걸쳐 있는 주에 있을 때).</p>\n<p>이 연도 숫자를 호환되지 않는 주 시간 필드와 함께 사용하면 이전 연도의 첫 주와 혼동될 수 있는 결과가 생성됩니다.</p>\n<p>대신, 주 시간 필드와 쌍으로 사용할 때 주 기반 연도는 주 기반 연도의 주 시간 필드 <code>WeekFields.weekOfWeekBasedYear()</code>와만 함께 사용해야 합니다.</p>\n<p>또는 시간 필드 <code>ChronoField.ALIGNED_WEEK_OF_YEAR</code>를 일반 연도와 함께 사용할 수 있습니다(주 기반 연도가 아님).</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\nnew DateTimeFormatterBuilder()\n      .appendValue(ChronoField.YEAR, 4) // 규칙 위반: 주 기반 연도의 주를 일반 연도와 함께 사용\n      .appendLiteral('-')\n      .appendValue(WeekFields.ISO.weekOfWeekBasedYear(), 2)\n      .toFormatter();\n\nnew DateTimeFormatterBuilder()\n      .appendValue(ChronoField.YEAR_OF_ERA, 4) // 규칙 위반: 주 기반 연도의 주를 일반 연도와 함께 사용\n      .appendLiteral('-')\n      .appendValue(WeekFields.ISO.weekOfWeekBasedYear(), 2)\n      .toFormatter();\n\nnew DateTimeFormatterBuilder()\n      .appendValue(WeekFields.ISO.weekBasedYear(), 4) // 규칙 위반: 정렬된 연도의 주를 주 기반 연도와 함께 사용\n      .appendLiteral('-')\n      .appendValue(ChronoField.ALIGNED_WEEK_OF_YEAR, 2)\n      .toFormatter();\n</pre>\n<p>여기서 처음 두 포매터는 2016년 1월 1일을 \"2016-53\"으로 잘못 포맷하고 마지막 포매터는 \"2015-01\"로 포맷합니다</p>\n<h3>규칙을 준수하는 해결책</h3>\n<pre>\nnew DateTimeFormatterBuilder()\n      .appendValue(WeekFields.ISO.weekBasedYear(), 4)\n      .appendLiteral('-')\n      .appendValue(WeekFields.ISO.weekOfWeekBasedYear(), 2)\n      .toFormatter();\n\nnew DateTimeFormatterBuilder()\n      .appendValue(ChronoField.YEAR, 4)\n      .appendLiteral('-')\n      .appendValue(ChronoField.ALIGNED_WEEK_OF_YEAR, 2)\n      .toFormatter();\n\nnew DateTimeFormatterBuilder()\n      .appendValue(ChronoField.YEAR_OF_ERA, 4)\n      .appendLiteral('-')\n      .appendValue(ChronoField.ALIGNED_WEEK_OF_YEAR, 2)\n      .toFormatter();\n</pre>\n<p>여기서 첫 번째 포매터는 2016년 1월 1일을 \"2015-53\"으로 포맷하고 마지막 두 개는 \"2016-01\"을 생성합니다. 주를 세는 방법에 따라 둘 다 올바릅니다.</p>\n<h3>예외</h3>\n<p>주 기반 연도가 주 시간 필드와 조합하여 사용되지 않는 경우 문제가 제기되지 않습니다.</p>\n<p>마찬가지로 주 기반 연도의 주가 연도 시간 필드와 조합하여 사용되지 않는 경우 문제가 제기되지 않습니다.</p>",
    "howToFix_ko": "",
    "moreInfo_ko": ""
  },
  {
    "id": "S2047",
    "key": "java:S2047",
    "name": "The names of methods with boolean return values should start with \"is\" or \"has\"",
    "type": "code-smell",
    "severity": "major",
    "tags": [
      "convention"
    ],
    "why": "<p>Well-named functions can allow the users of your code to understand at a glance what to expect from the function - even before reading the\ndocumentation. Toward that end, methods returning a boolean should have names that start with \"is\" or \"has\" rather than with \"get\".</p>\n<h3>Noncompliant code example</h3>\n<pre>\npublic boolean getFoo() { // Noncompliant\n  // ...\n}\n\npublic boolean getBar(Bar c) { // Noncompliant\n  // ...\n}\n\npublic boolean testForBar(Bar c) { // Compliant - The method does not start by 'get'.\n  // ...\n}\n</pre>\n<h3>Compliant solution</h3>\n<pre>\npublic boolean isFoo() {\n  // ...\n}\n\npublic boolean hasBar(Bar c) {\n  // ...\n}\n\npublic boolean testForBar(Bar c) {\n  // ...\n}\n</pre>\n<h3>Exceptions</h3>\n<p>Overriding methods are excluded.</p>\n<pre>\n@Override\npublic boolean getFoo(){\n  // ...\n}\n</pre>",
    "howToFix": "",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "boolean을 반환하는 메서드 이름은 \"is\" 또는 \"has\"로 시작해야 합니다",
    "why_ko": "<p>잘 명명된 함수는 코드 사용자가 문서를 읽기 전에도 함수에서 무엇을 기대해야 하는지 한눈에 이해할 수 있게 해줍니다. 이를 위해 boolean을 반환하는 메서드는 \"get\"이 아닌 \"is\" 또는 \"has\"로 시작하는 이름을 가져야 합니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\npublic boolean getFoo() { // 규칙 위반\n  // ...\n}\n\npublic boolean getBar(Bar c) { // 규칙 위반\n  // ...\n}\n\npublic boolean testForBar(Bar c) { // 규칙 준수 - 메서드가 'get'으로 시작하지 않음.\n  // ...\n}\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre>\npublic boolean isFoo() {\n  // ...\n}\n\npublic boolean hasBar(Bar c) {\n  // ...\n}\n\npublic boolean testForBar(Bar c) {\n  // ...\n}\n</pre>\n<h3>예외</h3>\n<p>오버라이딩 메서드는 제외됩니다.</p>\n<pre>\n@Override\npublic boolean getFoo(){\n  // ...\n}\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": ""
  },
  {
    "id": "S6291",
    "key": "java:S6291",
    "name": "Using unencrypted databases in mobile applications is security-sensitive",
    "type": "security-hotspot",
    "severity": "major",
    "tags": [],
    "why": "<p>This rule is deprecated, and will eventually be removed.</p>\n<p>Storing data locally is a common task for mobile applications. Such data includes preferences or authentication tokens for external services, among\nother things. There are many convenient solutions that allow storing data persistently, for example SQLiteDatabase, SharedPreferences, and Realm. By\ndefault these systems store the data unencrypted, thus an attacker with physical access to the device can read them out easily. Access to sensitive\ndata can be harmful for the user of the application, for example when the device gets stolen.</p>\n",
    "howToFix": "<h2>Recommended Secure Coding Practices</h2>\n<p>It's recommended to password-encrypt local databases that contain sensitive information. Most systems provide secure alternatives to plain-text\nstorage that should be used. If no secure alternative is available the data can also be encrypted manually before it is stored.</p>\n<p>The encryption password should not be hard-coded in the application. There are different approaches how the password can be provided to encrypt and\ndecrypt the database. In the case of <code>EncryptedSharedPreferences</code> the Android Keystore can be used to store the password. Other databases\ncan rely on <code>EncryptedSharedPreferences</code> to store passwords. The password can also be provided dynamically by the user of the application\nor it can be fetched from a remote server if the other methods are not feasible.</p>\n<h2>Compliant Solution</h2>\n<p>Instead of SQLiteDatabase you can use <a href=\"https://www.zetetic.net/sqlcipher/sqlcipher-for-android/\">SQLCipher</a>:</p>\n<pre>\nSQLiteDatabase db = SQLiteDatabase.openOrCreateDatabase(\"test.db\", getKey(), null);\n</pre>\n<p>Instead of SharedPreferences you can use <a\nhref=\"https://developer.android.com/reference/androidx/security/crypto/EncryptedSharedPreferences\">EncryptedSharedPreferences</a>:</p>\n<pre>\nString masterKeyAlias = new MasterKeys.getOrCreate(MasterKeys.AES256_GCM_SPEC);\nEncryptedSharedPreferences.create(\n    \"secret\",\n    masterKeyAlias,\n    context,\n    EncryptedSharedPreferences.PrefKeyEncryptionScheme.AES256_SIV,\n    EncryptedSharedPreferences.PrefValueEncryptionScheme.AES256_GCM\n);\n</pre>\n<p>For Realm an encryption key can be specified in the config:</p>\n<pre>\nRealmConfiguration config = new RealmConfiguration.Builder()\n    .encryptionKey(getKey())\n    .build();\nRealm realm = Realm.getInstance(config);\n</pre>\n<h2>See</h2>\n<ul>\n  <li> OWASP - <a href=\"https://owasp.org/www-project-top-ten/2017/A3_2017-Sensitive_Data_Exposure\">Top 10 2017 Category A3 - Sensitive Data\n  Exposure</a> </li>\n  <li> OWASP - <a href=\"https://owasp.org/www-project-top-ten/2017/A6_2017-Security_Misconfiguration\">Top 10 2017 Category A6 - Security\n  Misconfiguration</a> </li>\n  <li> OWASP - <a href=\"https://owasp.org/Top10/A02_2021-Cryptographic_Failures/\">Top 10 2021 Category A2 - Cryptographic Failures</a> </li>\n  <li> OWASP - <a href=\"https://owasp.org/Top10/A04_2021-Insecure_Design/\">Top 10 2021 Category A4 - Insecure Design</a> </li>\n  <li> OWASP - <a href=\"https://owasp.org/Top10/A05_2021-Security_Misconfiguration/\">Top 10 2021 Category A5 - Security Misconfiguration</a> </li>\n  <li> OWASP - <a href=\"https://mas.owasp.org/checklists/MASVS-STORAGE/\">Mobile AppSec Verification Standard</a> - Data Storage and Privacy\n  Requirements </li>\n  <li> OWASP - <a href=\"https://owasp.org/www-project-mobile-top-10/2016-risks/m2-insecure-data-storage\">Mobile Top 10 2016 Category M2 - Insecure\n  Data Storage</a> </li>\n  <li> OWASP - <a href=\"https://owasp.org/www-project-mobile-top-10/2023-risks/m9-insecure-data-storage\">Mobile Top 10 2024 Category M9 - Insecure\n  Data Storage</a> </li>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/311\">CWE-311 - Missing Encryption of Sensitive Data</a> </li>\n</ul>",
    "moreInfo": "",
    "status": "DEPRECATED",
    "name_ko": "모바일 애플리케이션에서 암호화되지 않은 데이터베이스 사용은 보안에 민감합니다",
    "why_ko": "<p>이 규칙은 더 이상 사용되지 않으며 향후 제거될 예정입니다.</p>\n<p>로컬에 데이터를 저장하는 것은 모바일 애플리케이션의 일반적인 작업입니다. 이러한 데이터에는 환경설정이나 외부 서비스용 인증 토큰 등이 포함됩니다. SQLiteDatabase, SharedPreferences, Realm 등 데이터를 영구적으로 저장할 수 있는 편리한 솔루션이 많이 있습니다. 기본적으로 이러한 시스템은 데이터를 암호화하지 않고 저장하므로 기기에 물리적으로 접근할 수 있는 공격자가 쉽게 읽을 수 있습니다. 민감한 데이터에 대한 접근은 예를 들어 기기가 도난당했을 때 애플리케이션 사용자에게 해로울 수 있습니다.</p>\n",
    "howToFix_ko": "<h2>권장 보안 코딩 관행</h2>\n<p>민감한 정보가 포함된 로컬 데이터베이스는 비밀번호로 암호화하는 것이 권장됩니다. 대부분의 시스템은 일반 텍스트 저장소에 대한 안전한 대안을 제공하며 이를 사용해야 합니다. 안전한 대안이 없는 경우 데이터를 저장하기 전에 수동으로 암호화할 수도 있습니다.</p>\n<p>암호화 비밀번호는 애플리케이션에 하드코딩되면 안 됩니다. 데이터베이스를 암호화하고 복호화하기 위한 비밀번호를 제공하는 다양한 접근 방식이 있습니다. <code>EncryptedSharedPreferences</code>의 경우 Android Keystore를 사용하여 비밀번호를 저장할 수 있습니다. 다른 데이터베이스는 <code>EncryptedSharedPreferences</code>를 사용하여 비밀번호를 저장할 수 있습니다. 비밀번호는 애플리케이션 사용자가 동적으로 제공하거나 다른 방법이 불가능한 경우 원격 서버에서 가져올 수도 있습니다.</p>\n<h2>규칙을 준수하는 해결책</h2>\n<p>SQLiteDatabase 대신 <a href=\"https://www.zetetic.net/sqlcipher/sqlcipher-for-android/\">SQLCipher</a>를 사용할 수 있습니다:</p>\n<pre>\nSQLiteDatabase db = SQLiteDatabase.openOrCreateDatabase(\"test.db\", getKey(), null);\n</pre>\n<p>SharedPreferences 대신 <a href=\"https://developer.android.com/reference/androidx/security/crypto/EncryptedSharedPreferences\">EncryptedSharedPreferences</a>를 사용할 수 있습니다:</p>\n<pre>\nString masterKeyAlias = new MasterKeys.getOrCreate(MasterKeys.AES256_GCM_SPEC);\nEncryptedSharedPreferences.create(\n    \"secret\",\n    masterKeyAlias,\n    context,\n    EncryptedSharedPreferences.PrefKeyEncryptionScheme.AES256_SIV,\n    EncryptedSharedPreferences.PrefValueEncryptionScheme.AES256_GCM\n);\n</pre>\n<p>Realm의 경우 설정에서 암호화 키를 지정할 수 있습니다:</p>\n<pre>\nRealmConfiguration config = new RealmConfiguration.Builder()\n    .encryptionKey(getKey())\n    .build();\nRealm realm = Realm.getInstance(config);\n</pre>\n<h2>참고</h2>\n<ul>\n  <li> OWASP - <a href=\"https://owasp.org/www-project-top-ten/2017/A3_2017-Sensitive_Data_Exposure\">Top 10 2017 Category A3 - 민감한 데이터 노출</a> </li>\n  <li> OWASP - <a href=\"https://owasp.org/www-project-top-ten/2017/A6_2017-Security_Misconfiguration\">Top 10 2017 Category A6 - 보안 구성 오류</a> </li>\n  <li> OWASP - <a href=\"https://owasp.org/Top10/A02_2021-Cryptographic_Failures/\">Top 10 2021 Category A2 - 암호화 실패</a> </li>\n  <li> OWASP - <a href=\"https://owasp.org/Top10/A04_2021-Insecure_Design/\">Top 10 2021 Category A4 - 안전하지 않은 설계</a> </li>\n  <li> OWASP - <a href=\"https://owasp.org/Top10/A05_2021-Security_Misconfiguration/\">Top 10 2021 Category A5 - 보안 구성 오류</a> </li>\n  <li> OWASP - <a href=\"https://mas.owasp.org/checklists/MASVS-STORAGE/\">Mobile AppSec Verification Standard</a> - 데이터 저장소 및 개인정보 보호 요구사항 </li>\n  <li> OWASP - <a href=\"https://owasp.org/www-project-mobile-top-10/2016-risks/m2-insecure-data-storage\">Mobile Top 10 2016 Category M2 - 안전하지 않은 데이터 저장소</a> </li>\n  <li> OWASP - <a href=\"https://owasp.org/www-project-mobile-top-10/2023-risks/m9-insecure-data-storage\">Mobile Top 10 2024 Category M9 - 안전하지 않은 데이터 저장소</a> </li>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/311\">CWE-311 - 민감한 데이터의 암호화 누락</a> </li>\n</ul>",
    "moreInfo_ko": ""
  },
  {
    "id": "S1104",
    "key": "java:S1104",
    "name": "Class variable fields should not have public accessibility",
    "type": "code-smell",
    "severity": "minor",
    "tags": [
      "cwe"
    ],
    "why": "<p>Public fields in public classes do not respect the encapsulation principle and have three main disadvantages:</p>\n<ul>\n  <li> Additional behavior such as validation cannot be added. </li>\n  <li> The internal representation is exposed, and cannot be changed afterwards. </li>\n  <li> Member values are subject to change from anywhere in the code and may not meet the programmer's assumptions. </li>\n</ul>\n<p>To prevent unauthorized modifications, private attributes and accessor methods (set and get) should be used.</p>\n<h3>What is the potential impact?</h3>\n<p>Public fields can be modified by any part of the code and this can lead to unexpected changes and hard-to-trace bugs.</p>\n<p>Public fields don't hide the implementation details. As a consequence, it is no longer possible to change how the data is stored internally without\nimpacting the client code of the class.</p>\n<p>The code is harder to maintain.</p>\n<h3>Exceptions</h3>\n<p>This rule ignores <code>public final</code> fields because they are not modifiable. Also, annotated fields, whatever the annotation(s) will be\nignored, as annotations are often used by injection frameworks, which in exchange require having public fields.</p>",
    "howToFix": "<p>Depending on your need there are multiple options:</p>\n<ul>\n  <li> Encapsulate the field\n    <ol>\n      <li> Make the field private. </li>\n      <li> Define methods to get and set the value of the field.<br> These methods are commonly known as getter and setter methods and are prefixed by\n      <code>get</code> and <code>set</code> followed by the name of the field. <em>Note:</em> as a bonus it is now possible to monitor value changes\n      using breakpoints. </li>\n    </ol>  </li>\n  <li> Mark the field as <code>public final</code> if it is not supposed to change. </li>\n</ul>\n\n<h4>Noncompliant code example</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\npublic class MyClass {\n\n  public static final int SOME_CONSTANT = 0;     // Compliant - constants are not checked\n\n  public String firstName;                       // Noncompliant\n\n}\n</pre>\n<h4>Compliant solution</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\npublic class MyClass {\n\n  public static final int SOME_CONSTANT = 0;     // Compliant - constants are not checked\n\n  private String firstName;\n\n  public String getFirstName() {\n    return firstName;\n  }\n\n  public void setFirstName(String firstName) {\n    this.firstName = firstName;\n  }\n\n}\n</pre>\n<h3>How does this work?</h3>\n<p>By having a setter and a getter the code can control how the field is accessed and modified. For example, adding validation in the setter method\nwill ensure that only valid values are set.</p>\n<p>The access modifiers on the setter can also be changed to <code>private</code> or <code>protected</code> to restrain which code can modify the\nvalue.</p>",
    "moreInfo": "<ul>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/493\">CWE-493 - Critical Public Variable Without Final Modifier</a> </li>\n</ul>",
    "status": "READY",
    "name_ko": "클래스 변수 필드는 public 접근성을 가지면 안 됩니다",
    "why_ko": "<p>public 클래스의 public 필드는 캡슐화 원칙을 준수하지 않으며 세 가지 주요 단점이 있습니다:</p>\n<ul>\n  <li> 유효성 검사와 같은 추가 동작을 추가할 수 없습니다. </li>\n  <li> 내부 표현이 노출되어 나중에 변경할 수 없습니다. </li>\n  <li> 멤버 값은 코드의 어느 곳에서든 변경될 수 있으며 프로그래머의 가정을 충족하지 않을 수 있습니다. </li>\n</ul>\n<p>권한 없는 수정을 방지하려면 private 속성과 접근자 메서드(set 및 get)를 사용해야 합니다.</p>\n<h3>잠재적 영향은 무엇인가요?</h3>\n<p>public 필드는 코드의 모든 부분에서 수정될 수 있으며, 이로 인해 예기치 않은 변경과 추적하기 어려운 버그가 발생할 수 있습니다.</p>\n<p>public 필드는 구현 세부 사항을 숨기지 않습니다. 결과적으로 클래스의 클라이언트 코드에 영향을 주지 않고 데이터가 내부적으로 저장되는 방식을 변경하는 것이 더 이상 불가능합니다.</p>\n<p>코드를 유지 관리하기가 더 어렵습니다.</p>\n<h3>예외</h3>\n<p>이 규칙은 수정할 수 없기 때문에 <code>public final</code> 필드를 무시합니다. 또한 어노테이션 처리된 필드는 어노테이션이 무엇이든 무시됩니다. 어노테이션은 종종 주입 프레임워크에서 사용되며, 이 프레임워크는 public 필드를 가져야 합니다.</p>",
    "howToFix_ko": "<p>필요에 따라 여러 가지 옵션이 있습니다:</p>\n<ul>\n  <li> 필드 캡슐화\n    <ol>\n      <li> 필드를 private로 만드세요. </li>\n      <li> 필드의 값을 가져오고 설정하는 메서드를 정의하세요.<br> 이러한 메서드는 일반적으로 getter 및 setter 메서드라고 하며 <code>get</code> 및 <code>set</code>으로 시작하고 그 뒤에 필드 이름이 옵니다. <em>참고:</em> 보너스로 이제 중단점을 사용하여 값 변경을 모니터링할 수 있습니다. </li>\n    </ol>  </li>\n  <li> 필드가 변경되면 안 되는 경우 <code>public final</code>로 표시하세요. </li>\n</ul>\n\n<h4>규칙을 준수하지 않는 코드 예시</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\npublic class MyClass {\n\n  public static final int SOME_CONSTANT = 0;     // 규칙 준수 - 상수는 확인되지 않음\n\n  public String firstName;                       // 규칙 위반\n\n}\n</pre>\n<h4>규칙을 준수하는 해결책</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\npublic class MyClass {\n\n  public static final int SOME_CONSTANT = 0;     // 규칙 준수 - 상수는 확인되지 않음\n\n  private String firstName;\n\n  public String getFirstName() {\n    return firstName;\n  }\n\n  public void setFirstName(String firstName) {\n    this.firstName = firstName;\n  }\n\n}\n</pre>\n<h3>어떻게 작동하나요?</h3>\n<p>setter와 getter를 사용하면 코드가 필드에 접근하고 수정하는 방식을 제어할 수 있습니다. 예를 들어 setter 메서드에 유효성 검사를 추가하면 유효한 값만 설정되도록 할 수 있습니다.</p>\n<p>setter의 접근 제어자를 <code>private</code> 또는 <code>protected</code>로 변경하여 어떤 코드가 값을 수정할 수 있는지 제한할 수도 있습니다.</p>",
    "moreInfo_ko": "<ul>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/493\">CWE-493 - Final 수정자가 없는 중요한 Public 변수</a> </li>\n</ul>"
  },
  {
    "id": "S1942",
    "key": "java:S1942",
    "name": "Simple class names should be used",
    "type": "code-smell",
    "severity": "minor",
    "tags": [
      "confusing",
      "redundant"
    ],
    "why": "<p>Java's <code>import</code> mechanism allows the use of simple class names. Therefore, using a class' fully qualified name in a file that\n<code>import</code>s the class is redundant and confusing.</p>\n<h3>Noncompliant code example</h3>\n<pre>\nimport java.util.List;\nimport java.sql.Timestamp;\n\n//...\n\njava.util.List&lt;String&gt; myList;  // Noncompliant\njava.sql.Timestamp tStamp; // Noncompliant\n</pre>\n<h3>Compliant solution</h3>\n<pre>\nimport java.util.List;\nimport java.sql.Timestamp;\n\n//...\n\nList&lt;String&gt; myList;\nTimestamp tStamp;\n</pre>",
    "howToFix": "",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "단순 클래스 이름을 사용해야 합니다",
    "why_ko": "<p>Java의 <code>import</code> 메커니즘은 단순 클래스 이름의 사용을 허용합니다. 따라서 클래스를 <code>import</code>하는 파일에서 클래스의 완전한 이름을 사용하는 것은 중복이며 혼란스럽습니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\nimport java.util.List;\nimport java.sql.Timestamp;\n\n//...\n\njava.util.List&lt;String&gt; myList;  // 규칙 위반\njava.sql.Timestamp tStamp; // 규칙 위반\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre>\nimport java.util.List;\nimport java.sql.Timestamp;\n\n//...\n\nList&lt;String&gt; myList;\nTimestamp tStamp;\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": ""
  },
  {
    "id": "S2114",
    "key": "java:S2114",
    "name": "Collections should not be passed as arguments to their own methods",
    "type": "bug",
    "severity": "major",
    "tags": [],
    "why": "<p>Passing a collection as an argument to the collection's own method is either an error - some other argument was intended - or simply nonsensical\ncode.</p>\n<p>Further, because some methods require that the argument remain unmodified during the execution, passing a collection to itself can result in\nundefined behavior.</p>\n<h3>Noncompliant code example</h3>\n<pre>\nList &lt;Object&gt; objs = new ArrayList&lt;Object&gt;();\nobjs.add(\"Hello\");\n\nobjs.add(objs); // Noncompliant; StackOverflowException if objs.hashCode() called\nobjs.addAll(objs); // Noncompliant; behavior undefined\nobjs.containsAll(objs); // Noncompliant; always true\nobjs.removeAll(objs); // Noncompliant; confusing. Use clear() instead\nobjs.retainAll(objs); // Noncompliant; NOOP\n</pre>",
    "howToFix": "",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "Collection은 자기 자신의 메서드에 인수로 전달하면 안 됩니다",
    "why_ko": "<p>컬렉션을 컬렉션 자신의 메서드에 인수로 전달하는 것은 오류이거나(다른 인수가 의도된 것) 단순히 무의미한 코드입니다.</p>\n<p>또한, 일부 메서드는 실행 중에 인수가 수정되지 않아야 하므로, 컬렉션을 자기 자신에게 전달하면 정의되지 않은 동작이 발생할 수 있습니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\nList &lt;Object&gt; objs = new ArrayList&lt;Object&gt;();\nobjs.add(\"Hello\");\n\nobjs.add(objs); // 규칙 위반; objs.hashCode()가 호출되면 StackOverflowException 발생\nobjs.addAll(objs); // 규칙 위반; 동작이 정의되지 않음\nobjs.containsAll(objs); // 규칙 위반; 항상 true\nobjs.removeAll(objs); // 규칙 위반; 혼란스러움. 대신 clear() 사용\nobjs.retainAll(objs); // 규칙 위반; 아무 동작도 하지 않음\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": ""
  },
  {
    "id": "S1153",
    "key": "java:S1153",
    "name": "\"String.valueOf()\" should not be appended to a \"String\"",
    "type": "code-smell",
    "severity": "minor",
    "tags": [
      "clumsy"
    ],
    "why": "<p>Appending <code>String.valueOf()</code> to a <code>String</code> decreases the code readability.</p>\n<p>The argument passed to <code>String.valueOf()</code> should be directly appended instead.</p>\n<h3>Noncompliant code example</h3>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\nString message = \"Output is \" + String.valueOf(12);\n</pre>\n<h3>Compliant solution</h3>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\nString message = \"Output is \" + 12;\n</pre>",
    "howToFix": "",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "\"String.valueOf()\"를 \"String\"에 연결하면 안 됩니다",
    "why_ko": "<p><code>String.valueOf()</code>를 <code>String</code>에 연결하면 코드 가독성이 떨어집니다.</p>\n<p><code>String.valueOf()</code>에 전달된 인수를 대신 직접 연결해야 합니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\nString message = \"Output is \" + String.valueOf(12);\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\nString message = \"Output is \" + 12;\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": ""
  },
  {
    "id": "S4351",
    "key": "java:S4351",
    "name": "\"compareTo\" should not be overloaded",
    "type": "bug",
    "severity": "major",
    "tags": [
      "pitfall"
    ],
    "why": "<p>When implementing the <code>Comparable&lt;T&gt;.compareTo</code> method, the parameter's type has to match the type used in the\n<code>Comparable</code> declaration. When a different type is used this creates an overload instead of an override, which is unlikely to be the\nintent.</p>\n<p>This rule raises an issue when the parameter of the <code>compareTo</code> method of a class implementing <code>Comparable&lt;T&gt;</code> is not\nsame as the one used in the <code>Comparable</code> declaration.</p>\n<h3>Noncompliant code example</h3>\n<pre>\npublic class Foo {\n  static class Bar implements Comparable&lt;Bar&gt; {\n    public int compareTo(Bar rhs) {\n      return -1;\n    }\n  }\n\n  static class FooBar extends Bar {\n    public int compareTo(FooBar rhs) {  // Noncompliant: Parameter should be of type Bar\n      return 0;\n    }\n  }\n}\n</pre>\n<h3>Compliant solution</h3>\n<pre>\npublic class Foo {\n  static class Bar implements Comparable&lt;Bar&gt; {\n    public int compareTo(Bar rhs) {\n      return -1;\n    }\n  }\n\n  static class FooBar extends Bar {\n    public int compareTo(Bar rhs) {\n      return 0;\n    }\n  }\n}\n</pre>",
    "howToFix": "",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "\"compareTo\"를 오버로드하면 안 됩니다",
    "why_ko": "<p><code>Comparable&lt;T&gt;.compareTo</code> 메서드를 구현할 때 매개변수의 타입은 <code>Comparable</code> 선언에서 사용된 타입과 일치해야 합니다. 다른 타입이 사용되면 오버라이드 대신 오버로드가 생성되며, 이는 의도한 바가 아닐 가능성이 높습니다.</p>\n<p>이 규칙은 <code>Comparable&lt;T&gt;</code>를 구현하는 클래스의 <code>compareTo</code> 메서드의 매개변수가 <code>Comparable</code> 선언에서 사용된 것과 동일하지 않을 때 문제를 제기합니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\npublic class Foo {\n  static class Bar implements Comparable&lt;Bar&gt; {\n    public int compareTo(Bar rhs) {\n      return -1;\n    }\n  }\n\n  static class FooBar extends Bar {\n    public int compareTo(FooBar rhs) {  // 규칙 위반: 매개변수는 Bar 타입이어야 함\n      return 0;\n    }\n  }\n}\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre>\npublic class Foo {\n  static class Bar implements Comparable&lt;Bar&gt; {\n    public int compareTo(Bar rhs) {\n      return -1;\n    }\n  }\n\n  static class FooBar extends Bar {\n    public int compareTo(Bar rhs) {\n      return 0;\n    }\n  }\n}\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": ""
  },
  {
    "id": "S2143",
    "key": "java:S2143",
    "name": "\"java.time\" classes should be used for dates and times",
    "type": "code-smell",
    "severity": "major",
    "tags": [
      "java8",
      "pitfall"
    ],
    "why": "<p>The old, much-derided <code>Date</code> and <code>Calendar</code> classes have always been confusing and difficult to use properly, particularly in\na multi-threaded context. <code>JodaTime</code> has long been a popular alternative, but now an even better option is built-in. Java 8's JSR 310\nimplementation offers specific classes for:</p>\n<table>\n  <colgroup>\n    <col style=\"width: 50%;\">\n    <col style=\"width: 50%;\">\n  </colgroup>\n  <thead>\n    <tr>\n      <th>Class</th>\n      <th>Use for</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td><p>LocalDate</p></td>\n      <td><p>a date, without time of day, offset, or zone</p></td>\n    </tr>\n    <tr>\n      <td><p>LocalTime</p></td>\n      <td><p>the time of day, without date, offset, or zone</p></td>\n    </tr>\n    <tr>\n      <td><p>LocalDateTime</p></td>\n      <td><p>the date and time, without offset, or zone</p></td>\n    </tr>\n    <tr>\n      <td><p>OffsetDate</p></td>\n      <td><p>a date with an offset such as +02:00, without time of day, or zone</p></td>\n    </tr>\n    <tr>\n      <td><p>OffsetTime</p></td>\n      <td><p>the time of day with an offset such as +02:00, without date, or zone</p></td>\n    </tr>\n    <tr>\n      <td><p>OffsetDateTime</p></td>\n      <td><p>the date and time with an offset such as +02:00, without a zone</p></td>\n    </tr>\n    <tr>\n      <td><p>ZonedDateTime</p></td>\n      <td><p>the date and time with a time zone and offset</p></td>\n    </tr>\n    <tr>\n      <td><p>YearMonth</p></td>\n      <td><p>a year and month</p></td>\n    </tr>\n    <tr>\n      <td><p>MonthDay</p></td>\n      <td><p>month and day</p></td>\n    </tr>\n    <tr>\n      <td><p>Year/MonthOfDay/DayOfWeek/…​</p></td>\n      <td><p>classes for the important fields</p></td>\n    </tr>\n    <tr>\n      <td><p>DateTimeFields</p></td>\n      <td><p>stores a map of field-value pairs which may be invalid</p></td>\n    </tr>\n    <tr>\n      <td><p>Calendrical</p></td>\n      <td><p>access to the low-level API</p></td>\n    </tr>\n    <tr>\n      <td><p>Period</p></td>\n      <td><p>a descriptive amount of time, such as \"2 months and 3 days\"</p></td>\n    </tr>\n  </tbody>\n</table>\n<h3>Noncompliant code example</h3>\n<pre>\nDate now = new Date();  // Noncompliant\nDateFormat df = new SimpleDateFormat(\"dd.MM.yyyy\");\nCalendar christmas  = Calendar.getInstance();  // Noncompliant\nchristmas.setTime(df.parse(\"25.12.2020\"));\n</pre>\n<h3>Compliant solution</h3>\n<pre>\nLocalDate now = LocalDate.now();  // gets calendar date. no time component\nLocalTime now2 = LocalTime.now(); // gets current time. no date component\nLocalDate christmas = LocalDate.of(2020,12,25);\n</pre>",
    "howToFix": "",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "날짜와 시간에는 \"java.time\" 클래스를 사용해야 합니다",
    "why_ko": "<p>오래되고 많은 비판을 받아온 <code>Date</code>와 <code>Calendar</code> 클래스는 항상 혼란스럽고 올바르게 사용하기 어려웠으며, 특히 멀티스레드 컨텍스트에서 그렇습니다. <code>JodaTime</code>이 오랫동안 인기 있는 대안이었지만, 이제 더 좋은 옵션이 내장되어 있습니다. Java 8의 JSR 310 구현은 다음을 위한 특정 클래스를 제공합니다:</p>\n<table>\n  <colgroup>\n    <col style=\"width: 50%;\">\n    <col style=\"width: 50%;\">\n  </colgroup>\n  <thead>\n    <tr>\n      <th>클래스</th>\n      <th>용도</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td><p>LocalDate</p></td>\n      <td><p>시간, 오프셋, 또는 시간대 없이 날짜만</p></td>\n    </tr>\n    <tr>\n      <td><p>LocalTime</p></td>\n      <td><p>날짜, 오프셋, 또는 시간대 없이 시간만</p></td>\n    </tr>\n    <tr>\n      <td><p>LocalDateTime</p></td>\n      <td><p>오프셋 또는 시간대 없이 날짜와 시간</p></td>\n    </tr>\n    <tr>\n      <td><p>OffsetDate</p></td>\n      <td><p>시간이나 시간대 없이 +02:00과 같은 오프셋이 있는 날짜</p></td>\n    </tr>\n    <tr>\n      <td><p>OffsetTime</p></td>\n      <td><p>날짜나 시간대 없이 +02:00과 같은 오프셋이 있는 시간</p></td>\n    </tr>\n    <tr>\n      <td><p>OffsetDateTime</p></td>\n      <td><p>시간대 없이 +02:00과 같은 오프셋이 있는 날짜와 시간</p></td>\n    </tr>\n    <tr>\n      <td><p>ZonedDateTime</p></td>\n      <td><p>시간대와 오프셋이 있는 날짜와 시간</p></td>\n    </tr>\n    <tr>\n      <td><p>YearMonth</p></td>\n      <td><p>연도와 월</p></td>\n    </tr>\n    <tr>\n      <td><p>MonthDay</p></td>\n      <td><p>월과 일</p></td>\n    </tr>\n    <tr>\n      <td><p>Year/MonthOfDay/DayOfWeek/…​</p></td>\n      <td><p>중요한 필드를 위한 클래스</p></td>\n    </tr>\n    <tr>\n      <td><p>DateTimeFields</p></td>\n      <td><p>유효하지 않을 수 있는 필드-값 쌍의 맵을 저장</p></td>\n    </tr>\n    <tr>\n      <td><p>Calendrical</p></td>\n      <td><p>저수준 API에 대한 접근</p></td>\n    </tr>\n    <tr>\n      <td><p>Period</p></td>\n      <td><p>\"2개월 3일\"과 같이 설명적인 시간 양</p></td>\n    </tr>\n  </tbody>\n</table>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\nDate now = new Date();  // 규칙 위반\nDateFormat df = new SimpleDateFormat(\"dd.MM.yyyy\");\nCalendar christmas  = Calendar.getInstance();  // 규칙 위반\nchristmas.setTime(df.parse(\"25.12.2020\"));\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre>\nLocalDate now = LocalDate.now();  // 달력 날짜를 가져옴. 시간 구성요소 없음\nLocalTime now2 = LocalTime.now(); // 현재 시간을 가져옴. 날짜 구성요소 없음\nLocalDate christmas = LocalDate.of(2020,12,25);\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": ""
  },
  {
    "id": "S3752",
    "key": "java:S3752",
    "name": "Allowing both safe and unsafe HTTP methods is security-sensitive",
    "type": "security-hotspot",
    "severity": "minor",
    "tags": [
      "cwe",
      "spring"
    ],
    "why": "<p>An HTTP method is safe when used to perform a read-only operation, such as retrieving information. In contrast, an unsafe HTTP method is used to\nchange the state of an application, for instance to update a user's profile on a web application.</p>\n<p>Common safe HTTP methods are GET, HEAD, or OPTIONS.</p>\n<p>Common unsafe HTTP methods are POST, PUT and DELETE.</p>\n<p>Allowing both safe and unsafe HTTP methods to perform a specific operation on a web application could impact its security, for example CSRF\nprotections are most of the time only protecting operations performed by unsafe HTTP methods.</p>\n",
    "howToFix": "<h2>Recommended Secure Coding Practices</h2>\n<p>For all the routes/controllers of an application, the authorized HTTP methods should be explicitly defined and safe HTTP methods should only be\nused to perform read-only operations.</p>\n<h2>Compliant Solution</h2>\n<pre>\n@RequestMapping(\"/delete_user\", method = RequestMethod.POST)  // Compliant\npublic String delete1(String username) {\n// state of the application will be changed here\n}\n\n@RequestMapping(path = \"/delete_user\", method = RequestMethod.POST) // Compliant\nString delete2(@RequestParam(\"id\") String id) {\n// state of the application will be changed here\n}\n</pre>\n<h2>See</h2>\n<ul>\n  <li> OWASP - <a href=\"https://owasp.org/Top10/A01_2021-Broken_Access_Control/\">Top 10 2021 Category A1 - Broken Access Control</a> </li>\n  <li> OWASP - <a href=\"https://owasp.org/Top10/A04_2021-Insecure_Design/\">Top 10 2021 Category A4 - Insecure Design</a> </li>\n  <li> OWASP - <a href=\"https://owasp.org/www-project-top-ten/2017/A5_2017-Broken_Access_Control\">Top 10 2017 Category A5 - Broken Access Control</a>\n  </li>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/352\">CWE-352 - Cross-Site Request Forgery (CSRF)</a> </li>\n  <li> <a href=\"https://owasp.org/www-community/attacks/csrf\">OWASP: Cross-Site Request Forgery</a> </li>\n  <li> <a href=\"https://docs.spring.io/spring-security/site/docs/5.0.x/reference/html/csrf.html#csrf-use-proper-verbs\">Spring Security Official\n  Documentation: Use proper HTTP verbs (CSRF protection)</a> </li>\n</ul>",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "안전한 HTTP 메서드와 안전하지 않은 HTTP 메서드를 모두 허용하는 것은 보안에 민감합니다",
    "why_ko": "<p>HTTP 메서드는 정보 검색과 같은 읽기 전용 작업을 수행하는 데 사용될 때 안전합니다. 반면, 안전하지 않은 HTTP 메서드는 웹 애플리케이션에서 사용자 프로필을 업데이트하는 것과 같이 애플리케이션의 상태를 변경하는 데 사용됩니다.</p>\n<p>일반적인 안전한 HTTP 메서드는 GET, HEAD, OPTIONS입니다.</p>\n<p>일반적인 안전하지 않은 HTTP 메서드는 POST, PUT, DELETE입니다.</p>\n<p>웹 애플리케이션에서 특정 작업을 수행하기 위해 안전한 HTTP 메서드와 안전하지 않은 HTTP 메서드를 모두 허용하면 보안에 영향을 미칠 수 있습니다. 예를 들어 CSRF 보호는 대부분 안전하지 않은 HTTP 메서드로 수행되는 작업만 보호합니다.</p>\n",
    "howToFix_ko": "<h2>권장되는 보안 코딩 관행</h2>\n<p>애플리케이션의 모든 라우트/컨트롤러에 대해 허용된 HTTP 메서드를 명시적으로 정의해야 하며, 안전한 HTTP 메서드는 읽기 전용 작업을 수행하는 데만 사용해야 합니다.</p>\n<h2>규칙을 준수하는 해결책</h2>\n<pre>\n@RequestMapping(\"/delete_user\", method = RequestMethod.POST)  // 규칙 준수\npublic String delete1(String username) {\n// 여기서 애플리케이션의 상태가 변경됩니다\n}\n\n@RequestMapping(path = \"/delete_user\", method = RequestMethod.POST) // 규칙 준수\nString delete2(@RequestParam(\"id\") String id) {\n// 여기서 애플리케이션의 상태가 변경됩니다\n}\n</pre>\n<h2>참고</h2>\n<ul>\n  <li> OWASP - <a href=\"https://owasp.org/Top10/A01_2021-Broken_Access_Control/\">Top 10 2021 카테고리 A1 - 취약한 접근 제어</a> </li>\n  <li> OWASP - <a href=\"https://owasp.org/Top10/A04_2021-Insecure_Design/\">Top 10 2021 카테고리 A4 - 안전하지 않은 설계</a> </li>\n  <li> OWASP - <a href=\"https://owasp.org/www-project-top-ten/2017/A5_2017-Broken_Access_Control\">Top 10 2017 카테고리 A5 - 취약한 접근 제어</a> </li>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/352\">CWE-352 - Cross-Site Request Forgery (CSRF)</a> </li>\n  <li> <a href=\"https://owasp.org/www-community/attacks/csrf\">OWASP: Cross-Site Request Forgery</a> </li>\n  <li> <a href=\"https://docs.spring.io/spring-security/site/docs/5.0.x/reference/html/csrf.html#csrf-use-proper-verbs\">Spring Security 공식 문서: 올바른 HTTP 동사 사용 (CSRF 보호)</a> </li>\n</ul>",
    "moreInfo_ko": ""
  },
  {
    "id": "S5669",
    "key": "java:S5669",
    "name": "Vararg method arguments should not be confusing",
    "type": "code-smell",
    "severity": "major",
    "tags": [],
    "why": "<p>Passing single <code>null</code> or primitive array argument to the variable arity method may not work as expected. In the case of\n<code>null</code>, it is not passed as array with single element, but the argument itself is <code>null</code>. In the case of a primitive array, if\nthe formal parameter is <code>Object...</code>, it is passed as a single element array. This may not be obvious to someone not familiar with such\ncorner cases, and it is probably better to avoid such ambiguities by explicitly casting the argument to the desired type.</p>\n<h3>Noncompliant code example</h3>\n<pre>\nclass A {\n  public static void main(String[] args) {\n    vararg(null);  // Noncompliant, prints \"null\"\n    int[] arr = {1,2,3};\n    vararg(arr);  // Noncompliant, prints \"length: 1\"\n  }\n\n  static void vararg(Object... s) {\n    if (s == null) {\n      System.out.println(\"null\");\n    } else {\n      System.out.println(\"length: \" + s.length);\n    }\n  }\n}\n</pre>\n<h3>Compliant solution</h3>\n<pre>\nclass A {\n  public static void main(String[] args) {\n    vararg((Object) null); // prints 1\n    Object[] arr = {1,2,3};\n    vararg(arr); // prints 3\n  }\n\n  static void vararg(Object... s) {\n    if (s == null) {\n      System.out.println(\"null\"); // not reached\n    } else {\n      System.out.println(\"length: \" + s.length);\n    }\n  }\n}\n</pre>",
    "howToFix": "",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "가변 인수 메서드 인수가 혼란스러우면 안 됩니다",
    "why_ko": "<p>가변 인수 메서드에 단일 <code>null</code> 또는 기본 타입 배열 인수를 전달하면 예상대로 작동하지 않을 수 있습니다. <code>null</code>의 경우 단일 요소를 가진 배열로 전달되지 않고 인수 자체가 <code>null</code>입니다. 기본 타입 배열의 경우 형식 매개변수가 <code>Object...</code>이면 단일 요소 배열로 전달됩니다. 이는 이러한 코너 케이스에 익숙하지 않은 사람에게는 명확하지 않을 수 있으며, 원하는 타입으로 인수를 명시적으로 캐스팅하여 이러한 모호함을 피하는 것이 좋습니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\nclass A {\n  public static void main(String[] args) {\n    vararg(null);  // 규칙 위반, \"null\" 출력\n    int[] arr = {1,2,3};\n    vararg(arr);  // 규칙 위반, \"length: 1\" 출력\n  }\n\n  static void vararg(Object... s) {\n    if (s == null) {\n      System.out.println(\"null\");\n    } else {\n      System.out.println(\"length: \" + s.length);\n    }\n  }\n}\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre>\nclass A {\n  public static void main(String[] args) {\n    vararg((Object) null); // 1 출력\n    Object[] arr = {1,2,3};\n    vararg(arr); // 3 출력\n  }\n\n  static void vararg(Object... s) {\n    if (s == null) {\n      System.out.println(\"null\"); // 도달하지 않음\n    } else {\n      System.out.println(\"length: \" + s.length);\n    }\n  }\n}\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": ""
  },
  {
    "id": "S2211",
    "key": "java:S2211",
    "name": "Types should be used in lambdas",
    "type": "code-smell",
    "severity": "major",
    "tags": [
      "convention",
      "java8"
    ],
    "why": "<p>Shared coding conventions allow teams to collaborate effectively. While types for lambda arguments are optional, specifying them anyway makes the\ncode clearer and easier to read.</p>\n<h3>Noncompliant code example</h3>\n<pre>\nArrays.sort(rosterAsArray,\n    (a, b) -&gt; {  // Noncompliant\n        return a.getBirthday().compareTo(b.getBirthday());\n    }\n);\n</pre>\n<h3>Compliant solution</h3>\n<pre>\nArrays.sort(rosterAsArray,\n    (Person a, Person b) -&gt; {\n        return a.getBirthday().compareTo(b.getBirthday());\n    }\n);\n</pre>\n<h3>Exceptions</h3>\n<p>When the lambda has one or two parameters and does not have a block this rule will not fire up an issue as things are considered more readable in\nthose cases.</p>\n<pre>\nstream.map((a, b) -&gt; a.length); // compliant\n</pre>",
    "howToFix": "",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "람다에서 타입을 명시해야 합니다",
    "why_ko": "<p>공유된 코딩 규칙을 통해 팀이 효과적으로 협업할 수 있습니다. 람다 인수의 타입은 선택 사항이지만, 어쨌든 지정하면 코드가 더 명확해지고 읽기 쉬워집니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\nArrays.sort(rosterAsArray,\n    (a, b) -&gt; {  // 규칙 위반\n        return a.getBirthday().compareTo(b.getBirthday());\n    }\n);\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre>\nArrays.sort(rosterAsArray,\n    (Person a, Person b) -&gt; {\n        return a.getBirthday().compareTo(b.getBirthday());\n    }\n);\n</pre>\n<h3>예외</h3>\n<p>람다에 하나 또는 두 개의 매개변수가 있고 블록이 없는 경우 이러한 경우가 더 읽기 쉽다고 간주되므로 이 규칙은 이슈를 발생시키지 않습니다.</p>\n<pre>\nstream.map((a, b) -&gt; a.length); // 규칙 준수\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": ""
  },
  {
    "id": "S3400",
    "key": "java:S3400",
    "name": "Methods should not return constants",
    "type": "code-smell",
    "severity": "minor",
    "tags": [
      "confusing"
    ],
    "why": "<p>There's no point in forcing the overhead of a method call for a method that always returns the same constant value. Even worse, the fact that a\nmethod call must be made will likely mislead developers who call the method thinking that something more is done. Declare a constant instead.</p>\n<p>This rule raises an issue if on methods that contain only one statement: the <code>return</code> of a constant value.</p>\n<h3>Noncompliant code example</h3>\n<pre>\nint getBestNumber() {\n  return 12;  // Noncompliant\n}\n</pre>\n<h3>Compliant solution</h3>\n<pre>\nstatic final int BEST_NUMBER = 12;\n</pre>\n<h3>Exceptions</h3>\n<p>The following types of method are ignored:</p>\n<ul>\n  <li> methods that override a method. </li>\n  <li> methods that are not final (not having the <code>final</code>, <code>private</code> or <code>static</code> modifier and not in a record or a\n  final class). </li>\n  <li> methods with annotations, such as <code>@Override</code> or Spring's <code>@RequestMapping</code>. </li>\n</ul>",
    "howToFix": "",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "메서드가 상수를 반환하면 안 됩니다",
    "why_ko": "<p>항상 같은 상수 값을 반환하는 메서드에 대해 메서드 호출의 오버헤드를 강제하는 것은 의미가 없습니다. 더 나쁜 것은, 메서드 호출이 필요하다는 사실이 메서드를 호출하는 개발자들이 더 많은 작업이 수행된다고 생각하여 오해를 불러일으킬 가능성이 높다는 것입니다. 대신 상수를 선언하세요.</p>\n<p>이 규칙은 하나의 문장만 포함하는 메서드, 즉 상수 값의 <code>return</code>에 대해 문제를 제기합니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\nint getBestNumber() {\n  return 12;  // 규칙 위반\n}\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre>\nstatic final int BEST_NUMBER = 12;\n</pre>\n<h3>예외</h3>\n<p>다음 유형의 메서드는 무시됩니다:</p>\n<ul>\n  <li> 메서드를 오버라이드하는 메서드. </li>\n  <li> final이 아닌 메서드 (<code>final</code>, <code>private</code> 또는 <code>static</code> 수정자가 없고 record나 final 클래스에 있지 않은 경우). </li>\n  <li> <code>@Override</code> 또는 Spring의 <code>@RequestMapping</code>과 같은 어노테이션이 있는 메서드. </li>\n</ul>",
    "howToFix_ko": "",
    "moreInfo_ko": ""
  },
  {
    "id": "S1128",
    "key": "java:S1128",
    "name": "Unnecessary imports should be removed",
    "type": "code-smell",
    "severity": "minor",
    "tags": [
      "unused"
    ],
    "why": "<p>Unnecessary imports refer to importing types that are not used or referenced anywhere in the code.</p>\n<p>Although they don't affect the runtime behavior of the application after compilation, removing them will:</p>\n<ul>\n  <li> Improve the readability and maintainability of the code. </li>\n  <li> Help avoid potential naming conflicts. </li>\n  <li> Improve the build time, as the compiler has fewer lines to read and fewer types to resolve. </li>\n  <li> Reduce the number of items the code editor will show for auto-completion, thereby showing fewer irrelevant suggestions. </li>\n</ul>\n<h3>Exceptions</h3>\n<p>Imports for types mentioned in Javadocs are ignored.</p>",
    "howToFix": "<p>While it's not difficult to remove these unneeded lines manually, modern code editors support the removal of every unnecessary import with a single\nclick from every file of the project.</p>\n\n<h4>Noncompliant code example</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\npackage myapp.helpers;\n\nimport java.io.IOException;\nimport java.nio.file.*;\nimport java.nio.file.*;     // Noncompliant - package is imported twice\nimport java.lang.Runnable;  // Noncompliant - java.lang is imported by default\n\npublic class FileHelper {\n    public static String readFirstLine(String filePath) throws IOException {\n        return Files.readAllLines(Paths.get(filePath)).get(0);\n    }\n}\n</pre>\n<h4>Compliant solution</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\npackage myapp.helpers;\n\nimport java.io.IOException;\nimport java.nio.file.*;\n\npublic class FileHelper {\n    public static String readFirstLine(String filePath) throws IOException {\n        return Files.readAllLines(Paths.get(filePath)).get(0);\n    }\n}\n</pre>",
    "moreInfo": "<h3>Documentation</h3>\n<ul>\n  <li> <a href=\"https://docs.oracle.com/javase/tutorial/java/package/usepkgs.html\">Java packages</a> </li>\n</ul>\n<h3>Related rules</h3>\n<ul>\n  <li> <a href='/coding_rules#rule_key=java%3AS1144'>S1144</a> - Unused \"private\" methods should be removed </li>\n  <li> <a href='/coding_rules#rule_key=java%3AS1481'>S1481</a> - Unused local variables should be removed </li>\n</ul>",
    "status": "READY",
    "name_ko": "불필요한 import는 제거해야 합니다",
    "why_ko": "<p>불필요한 import는 코드 어디에서도 사용되거나 참조되지 않는 타입을 import하는 것을 말합니다.</p>\n<p>컴파일 후 애플리케이션의 런타임 동작에 영향을 미치지는 않지만, 제거하면:</p>\n<ul>\n  <li> 코드의 가독성과 유지보수성이 향상됩니다. </li>\n  <li> 잠재적인 이름 충돌을 피하는 데 도움이 됩니다. </li>\n  <li> 컴파일러가 읽을 줄 수와 해석할 타입이 줄어들어 빌드 시간이 개선됩니다. </li>\n  <li> 코드 편집기가 자동 완성에 표시하는 항목 수가 줄어들어 관련 없는 제안이 적게 표시됩니다. </li>\n</ul>\n<h3>예외 사항</h3>\n<p>Javadoc에 언급된 타입에 대한 import는 무시됩니다.</p>",
    "howToFix_ko": "<p>이러한 불필요한 줄을 수동으로 제거하는 것은 어렵지 않지만, 최신 코드 편집기는 프로젝트의 모든 파일에서 불필요한 모든 import를 한 번의 클릭으로 제거하는 기능을 지원합니다.</p>\n\n<h4>규칙을 준수하지 않는 코드 예시</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\npackage myapp.helpers;\n\nimport java.io.IOException;\nimport java.nio.file.*;\nimport java.nio.file.*;     // 규칙 위반 - 패키지가 두 번 import됨\nimport java.lang.Runnable;  // 규칙 위반 - java.lang은 기본적으로 import됨\n\npublic class FileHelper {\n    public static String readFirstLine(String filePath) throws IOException {\n        return Files.readAllLines(Paths.get(filePath)).get(0);\n    }\n}\n</pre>\n<h4>규칙을 준수하는 해결책</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\npackage myapp.helpers;\n\nimport java.io.IOException;\nimport java.nio.file.*;\n\npublic class FileHelper {\n    public static String readFirstLine(String filePath) throws IOException {\n        return Files.readAllLines(Paths.get(filePath)).get(0);\n    }\n}\n</pre>",
    "moreInfo_ko": "<h3>문서</h3>\n<ul>\n  <li> <a href=\"https://docs.oracle.com/javase/tutorial/java/package/usepkgs.html\">Java 패키지</a> </li>\n</ul>\n<h3>관련 규칙</h3>\n<ul>\n  <li> <a href='/coding_rules#rule_key=java%3AS1144'>S1144</a> - 사용되지 않는 \"private\" 메서드는 제거해야 합니다 </li>\n  <li> <a href='/coding_rules#rule_key=java%3AS1481'>S1481</a> - 사용되지 않는 지역 변수는 제거해야 합니다 </li>\n</ul>"
  },
  {
    "id": "S5868",
    "key": "java:S5868",
    "name": "Unicode Grapheme Clusters should be avoided inside regex character classes",
    "type": "bug",
    "severity": "major",
    "tags": [
      "regex"
    ],
    "why": "<p>When placing Unicode <a href=\"https://unicode.org/glossary/#grapheme_cluster\">Grapheme Clusters</a> (characters which require to be encoded in\nmultiple <a href=\"https://unicode.org/glossary/#code_point\">Code Points</a>) inside a character class of a regular expression, this will likely lead\nto unintended behavior.</p>\n<p>For instance, the grapheme cluster <code>c̈</code> requires two code points: one for <code>'c'</code>, followed by one for the <em>umlaut</em>\nmodifier <code>'\\u{0308}'</code>. If placed within a character class, such as <code>[c̈]</code>, the regex will consider the character class being the\nenumeration <code>[c\\u{0308}]</code> instead. It will, therefore, match every <code>'c'</code> and every <em>umlaut</em> that isn't expressed as a\nsingle codepoint, which is extremely unlikely to be the intended behavior.</p>\n<p>This rule raises an issue every time Unicode Grapheme Clusters are used within a character class of a regular expression.</p>\n<h3>Noncompliant code example</h3>\n<pre>\n\"cc̈d̈d\".replaceAll(\"[c̈d̈]\", \"X\"); // Noncompliant, print \"XXXXXX\" instead of expected \"cXXd\".\n</pre>\n<h3>Compliant solution</h3>\n<pre>\n\"cc̈d̈d\".replaceAll(\"c̈|d̈\", \"X\"); // print \"cXXd\"\n</pre>",
    "howToFix": "",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "정규식 문자 클래스 내에서 Unicode Grapheme Cluster를 사용하면 안 됩니다",
    "why_ko": "<p>Unicode <a href=\"https://unicode.org/glossary/#grapheme_cluster\">Grapheme Cluster</a>(여러 <a href=\"https://unicode.org/glossary/#code_point\">코드 포인트</a>로 인코딩되어야 하는 문자)를 정규 표현식의 문자 클래스 안에 넣으면 의도하지 않은 동작이 발생할 수 있습니다.</p>\n<p>예를 들어, grapheme cluster <code>c̈</code>는 두 개의 코드 포인트가 필요합니다: <code>'c'</code>용 하나와 <em>움라우트</em> 수정자 <code>'\\u{0308}'</code>용 하나입니다. <code>[c̈]</code>와 같이 문자 클래스 안에 배치하면 정규식은 문자 클래스를 대신 열거형 <code>[c\\u{0308}]</code>로 간주합니다. 따라서 모든 <code>'c'</code>와 단일 코드포인트로 표현되지 않은 모든 <em>움라우트</em>와 일치하게 되며, 이는 의도된 동작일 가능성이 극히 낮습니다.</p>\n<p>이 규칙은 Unicode Grapheme Cluster가 정규 표현식의 문자 클래스 내에서 사용될 때마다 문제를 제기합니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\n\"cc̈d̈d\".replaceAll(\"[c̈d̈]\", \"X\"); // 규칙 위반, 예상한 \"cXXd\" 대신 \"XXXXXX\" 출력.\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre>\n\"cc̈d̈d\".replaceAll(\"c̈|d̈\", \"X\"); // \"cXXd\" 출력\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": ""
  },
  {
    "id": "S1201",
    "key": "java:S1201",
    "name": "\"equals\" method overrides should accept \"Object\" parameters",
    "type": "bug",
    "severity": "major",
    "tags": [
      "suspicious"
    ],
    "why": "<p>In Java, the <code>Object.equals()</code> method is used for object comparison, and it is typically overridden in classes to provide a custom\nequality check based on your criteria for equality.</p>\n<p>The default implementation of <code>equals()</code> provided by the <code>Object</code> class compares the memory references of the two objects,\nthat means it checks if the objects are actually the same instance in memory.</p>\n<p>The \"equals\" as a method name should be used exclusively to override <code>Object.equals(Object)</code> to prevent confusion.</p>\n<p>It is important to note that when you override <code>equals()</code>, you should also override the <code>hashCode()</code> method to maintain the\ncontract between <code>equals()</code> and <code>hashCode()</code>.</p>",
    "howToFix": "<p>Either override <code>Object.equals(Object)</code> or rename the method.</p>\n\n<h4>Noncompliant code example</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\nclass MyClass {\n  private int foo = 1;\n\n  public boolean equals(MyClass o) {  // Noncompliant; does not override Object.equals(Object)\n    return o != null &amp;&amp; o.foo == this.foo;\n  }\n\n  public static void main(String[] args) {\n    MyClass o1 = new MyClass();\n    Object o2 = new MyClass();\n    System.out.println(o1.equals(o2));  // Prints \"false\" because o2 an Object not a MyClass\n  }\n}\n</pre>\n<h4>Compliant solution</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\nclass MyClass {\n  private int foo = 1;\n\n  @Override\n  public boolean equals(Object o) {  // Compliant\n    if (this == o) {\n        return true;\n    }\n\n    if (o == null || getClass() != o.getClass()) {\n      return false;\n    }\n\n    MyClass other = (MyClass)o;\n    return this.foo == other.foo;\n  }\n}\n</pre>",
    "moreInfo": "<h3>Documentation</h3>\n<ul>\n  <li> <a href=\"https://docs.oracle.com/en/java/javase/20/docs/api/java.base/java/lang/Object.html#equals(java.lang.Object)\">Oracle SDK -\n  Object.equals(Object)</a> </li>\n</ul>",
    "status": "READY",
    "name_ko": "\"equals\" 메서드 오버라이드는 \"Object\" 매개변수를 받아야 합니다","why_ko": "<p>Java에서 <code>Object.equals()</code> 메서드는 객체 비교에 사용되며, 일반적으로 동등성 기준에 따라 사용자 정의 동등성 검사를 제공하기 위해 클래스에서 오버라이드됩니다.</p>\n<p><code>Object</code> 클래스가 제공하는 <code>equals()</code>의 기본 구현은 두 객체의 메모리 참조를 비교합니다. 즉, 객체가 실제로 메모리에서 동일한 인스턴스인지 확인합니다.</p>\n<p>\"equals\"라는 메서드 이름은 혼란을 방지하기 위해 <code>Object.equals(Object)</code>를 오버라이드하는 데만 사용해야 합니다.</p>\n<p><code>equals()</code>를 오버라이드할 때 <code>equals()</code>와 <code>hashCode()</code> 사이의 계약을 유지하기 위해 <code>hashCode()</code> 메서드도 오버라이드해야 한다는 점에 유의해야 합니다.</p>","howToFix_ko": "<p><code>Object.equals(Object)</code>를 오버라이드하거나 메서드 이름을 변경하세요.</p>\n\n<h4>규칙을 준수하지 않는 코드 예시</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\nclass MyClass {\n  private int foo = 1;\n\n  public boolean equals(MyClass o) {  // 규칙 위반; Object.equals(Object)를 오버라이드하지 않음\n    return o != null &amp;&amp; o.foo == this.foo;\n  }\n\n  public static void main(String[] args) {\n    MyClass o1 = new MyClass();\n    Object o2 = new MyClass();\n    System.out.println(o1.equals(o2));  // o2가 MyClass가 아닌 Object이므로 \"false\"를 출력함\n  }\n}\n</pre>\n<h4>규칙을 준수하는 해결책</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\nclass MyClass {\n  private int foo = 1;\n\n  @Override\n  public boolean equals(Object o) {  // 규칙 준수\n    if (this == o) {\n        return true;\n    }\n\n    if (o == null || getClass() != o.getClass()) {\n      return false;\n    }\n\n    MyClass other = (MyClass)o;\n    return this.foo == other.foo;\n  }\n}\n</pre>",
    "moreInfo_ko": "<h3>문서</h3>\n<ul>\n  <li> <a href=\"https://docs.oracle.com/en/java/javase/20/docs/api/java.base/java/lang/Object.html#equals(java.lang.Object)\">Oracle SDK - Object.equals(Object)</a> </li>\n</ul>"
  },
  {
    "id": "S5612",
    "key": "java:S5612",
    "name": "Lambdas should not have too many lines",
    "type": "code-smell",
    "severity": "major",
    "tags": [],
    "why": "<p>Lambdas (introduced with Java 8) are a very convenient and compact way to inject a behavior without having to create a dedicated class or method.\nBut those lambdas should be used only if the behavior to be injected can be defined in a few lines of code, otherwise the source code can quickly\nbecome unreadable.</p>",
    "howToFix": "",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "Lambda는 너무 많은 줄을 가지면 안 됩니다",
    "why_ko": "<p>Lambda(Java 8에서 도입됨)는 전용 클래스나 메서드를 만들지 않고도 동작을 주입할 수 있는 매우 편리하고 간결한 방법입니다. 하지만 이러한 람다는 주입할 동작을 몇 줄의 코드로 정의할 수 있는 경우에만 사용해야 합니다. 그렇지 않으면 소스 코드가 빠르게 읽기 어려워질 수 있습니다.</p>",
    "howToFix_ko": "",
    "moreInfo_ko": ""
  },
  {
    "id": "S2092",
    "key": "java:S2092",
    "name": "Creating cookies without the \"secure\" flag is security-sensitive",
    "type": "security-hotspot",
    "severity": "minor",
    "tags": [
      "spring",
      "cwe",
      "privacy"
    ],
    "why": "<p>When a cookie is protected with the <code>secure</code> attribute set to <em>true</em> it will not be send by the browser over an unencrypted HTTP\nrequest and thus cannot be observed by an unauthorized person during a man-in-the-middle attack.</p>\n",
    "howToFix": "<h2>Recommended Secure Coding Practices</h2>\n<ul>\n  <li> It is recommended to use <code>HTTPs</code> everywhere so setting the <code>secure</code> flag to <em>true</em> should be the default behaviour\n  when creating cookies. </li>\n  <li> Set the <code>secure</code> flag to <em>true</em> for session-cookies. </li>\n</ul>\n<h2>Compliant Solution</h2>\n<pre>\nCookie c = new Cookie(COOKIENAME, sensitivedata);\nc.setSecure(true); // Compliant: the sensitive cookie will not be send during an unencrypted HTTP request thanks to the secure flag set to true\n</pre>\n<h2>See</h2>\n<ul>\n  <li> OWASP - <a href=\"https://owasp.org/Top10/A04_2021-Insecure_Design/\">Top 10 2021 Category A4 - Insecure Design</a> </li>\n  <li> OWASP - <a href=\"https://owasp.org/Top10/A05_2021-Security_Misconfiguration/\">Top 10 2021 Category A5 - Security Misconfiguration</a> </li>\n  <li> OWASP - <a href=\"https://owasp.org/www-project-top-ten/2017/A3_2017-Sensitive_Data_Exposure\">Top 10 2017 Category A3 - Sensitive Data\n  Exposure</a> </li>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/311\">CWE-311 - Missing Encryption of Sensitive Data</a> </li>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/315\">CWE-315 - Cleartext Storage of Sensitive Information in a Cookie</a> </li>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/614\">CWE-614 - Sensitive Cookie in HTTPS Session Without 'Secure' Attribute</a> </li>\n  <li> STIG Viewer - <a href=\"https://stigviewer.com/stigs/application_security_and_development/2024-12-06/finding/V-222576\">Application Security and\n  Development: V-222576</a> - The application must set the secure flag on session cookies. </li>\n</ul>",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "\"secure\" 플래그 없이 쿠키를 생성하는 것은 보안에 민감합니다",
    "why_ko": "<p>쿠키가 <code>secure</code> 속성이 <em>true</em>로 설정되어 보호되면 암호화되지 않은 HTTP 요청을 통해 브라우저가 전송하지 않으므로 중간자 공격 중에 권한이 없는 사람이 관찰할 수 없습니다.</p>\n",
    "howToFix_ko": "<h2>권장 보안 코딩 방법</h2>\n<ul>\n  <li> 모든 곳에서 <code>HTTPs</code>를 사용하는 것이 권장되므로 쿠키를 생성할 때 <code>secure</code> 플래그를 <em>true</em>로 설정하는 것이 기본 동작이어야 합니다. </li>\n  <li> 세션 쿠키에 대해 <code>secure</code> 플래그를 <em>true</em>로 설정하세요. </li>\n</ul>\n<h2>규칙을 준수하는 해결책</h2>\n<pre>\nCookie c = new Cookie(COOKIENAME, sensitivedata);\nc.setSecure(true); // 규칙 준수: secure 플래그가 true로 설정되어 민감한 쿠키가 암호화되지 않은 HTTP 요청 중에 전송되지 않습니다\n</pre>\n<h2>참고</h2>\n<ul>\n  <li> OWASP - <a href=\"https://owasp.org/Top10/A04_2021-Insecure_Design/\">Top 10 2021 Category A4 - Insecure Design</a> </li>\n  <li> OWASP - <a href=\"https://owasp.org/Top10/A05_2021-Security_Misconfiguration/\">Top 10 2021 Category A5 - Security Misconfiguration</a> </li>\n  <li> OWASP - <a href=\"https://owasp.org/www-project-top-ten/2017/A3_2017-Sensitive_Data_Exposure\">Top 10 2017 Category A3 - Sensitive Data Exposure</a> </li>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/311\">CWE-311 - Missing Encryption of Sensitive Data</a> </li>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/315\">CWE-315 - Cleartext Storage of Sensitive Information in a Cookie</a> </li>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/614\">CWE-614 - Sensitive Cookie in HTTPS Session Without 'Secure' Attribute</a> </li>\n  <li> STIG Viewer - <a href=\"https://stigviewer.com/stigs/application_security_and_development/2024-12-06/finding/V-222576\">Application Security and Development: V-222576</a> - The application must set the secure flag on session cookies. </li>\n</ul>",
    "moreInfo_ko": ""
  },
  {
    "id": "S6878",
    "key": "java:S6878",
    "name": "Use record pattern instead of explicit field access",
    "type": "code-smell",
    "severity": "major",
    "tags": [
      "java21"
    ],
    "why": "<p>Java 21 enhances Pattern Matching, introduced in Java 16, with a <em>record pattern</em> that decomposes records into local variables. This form\nshould be used when all fields of a record are accessed within a block for improved readability. Nested record patterns are also allowed and should be\nused when a record field is another record, and all its fields are accessed.</p>\n<h2>Exceptions</h2>\n<p>This rule does not apply when not all record fields are accessed. This prevents the creation of unused local variables in the decomposed record\nstructure.</p>",
    "howToFix": "<p>Replace the instance check or simple pattern matching with a record pattern.</p>\n\n<h4>Noncompliant code example</h4>\n<p>This example uses pattern matching but not a record pattern, even though all fields of the record are accessed in the block.</p>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\nrecord Point(Float x, Float y, Float z) {}\n\nvoid print(Object obj) {\n    if (obj instanceof Point p) { // Noncompliant, because all three fields x, y, z are accessed\n        Float x = p.x;\n        Float y = p.y();\n        System.out.println(x + y + p.z);\n    }\n}\n</pre>\n<h4>Compliant solution</h4>\n<p>The compliant example uses a record pattern to decompose the record structure.</p>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\nrecord Point(Float x, Float y, Float z) {}\n\nvoid print(Object obj) {\n    if (obj instanceof Point(Float x, Float y, Float z)) { // Compliant\n        System.out.println(x + y + z);\n    }\n}\n</pre>\n<h4>Noncompliant code example</h4>\n<p>This example does not use pattern matching or a record pattern. Rule <em><a\nhref=\"https://sonarsource.github.io/rspec/#/rspec/<a href='/coding_rules#rule_key=java%3AS6201'>S6201</a>\"><a href='/coding_rules#rule_key=java%3AS6201'>S6201</a> - Pattern matching or \"instanceOf\" operator should be\nused</a></em> would report first. When fixed using simple pattern matching instead of a record pattern, this rule (<a href='/coding_rules#rule_key=java%3AS6878'>S6878</a>) will report.</p>\n<pre data-diff-id=\"2\" data-diff-type=\"noncompliant\">\nvoid print(Object obj) {\n    if (obj instanceof Point) { // Noncompliant\n        Point p = (Point) obj;\n        Float x = p.x;\n        Float y = p.y();\n        System.out.println(x + y + p.z);\n    }\n}\n</pre>\n<h4>Compliant solution</h4>\n<p>The solution compliant with both rules, <a href='/coding_rules#rule_key=java%3AS6201'>S6201</a> and <a href='/coding_rules#rule_key=java%3AS6878'>S6878</a>, uses pattern matching and decomposes the record structure using a\nrecord pattern.</p>\n<pre data-diff-id=\"2\" data-diff-type=\"compliant\">\nvoid print(Object obj) {\n    if (obj instanceof Point(Float x, Float y, Float z)) { // Compliant\n        System.out.println(x + y + z);\n    }\n}\n</pre>\n<h4>Noncompliant code example</h4>\n<p>This example is noncompliant because a nested record pattern could have been used.</p>\n<pre data-diff-id=\"3\" data-diff-type=\"noncompliant\">\nrecord Plane(Point normal, Float d) {}\n\nvoid print(Object obj) {\n    // Noncompliant, because all field of \"normal\" are accessed\n    if (obj instanceof Plane(Point normal, Float d)) {\n        System.out.println(normal.x + normal.y + normal.z);\n        System.out.println(d);\n    }\n}\n</pre>\n<h4>Compliant solution</h4>\n<p>This is the same example using a nested record pattern.</p>\n<pre data-diff-id=\"3\" data-diff-type=\"compliant\">\nvoid print(Object obj) {\n    if (obj instanceof Plane(Point(Float x, Float y, Float z), Float d)) { // Compliant\n        System.out.println(x + y + z);\n        System.out.println(d);\n    }\n}\n</pre>\n<h4>Compliant solution</h4>\n<p>This example uses <code>var</code> instead of replicating the field types in the record pattern, which is less verbose and keeps the code more\nreadable, especially in the case of longer type names. Also, it uses variable names that do not match the original field names. The reason for this\ncan be to avoid name collisions with fields or other local variables.</p>\n<pre>\nvoid print(Object obj) {\n    if (obj instanceof Point(var px, var py, var pz)) { // Compliant\n        System.out.println(px + py + pz);\n    }\n}\n</pre>\n<h4>Compliant solution</h4>\n<p>This example is compliant without using a record pattern, as it does not access all fields.</p>\n<pre>\nvoid print(Object obj) {\n    if (obj instanceof Point p) { // Compliant, because z is never accessed\n        Float x = p.x;\n        Float y = p.y();\n        System.out.println(x + y);\n    }\n}\n</pre>",
    "moreInfo": "<ul>\n  <li> <a href=\"https://openjdk.org/jeps/440\">JEP 440: Record Patterns</a> </li>\n</ul>",
    "status": "READY",
    "name_ko": "명시적 필드 접근 대신 record 패턴을 사용하세요",
    "why_ko": "<p>Java 21은 Java 16에서 도입된 패턴 매칭을 레코드를 로컬 변수로 분해하는 <em>record 패턴</em>으로 향상시킵니다. 이 형식은 블록 내에서 레코드의 모든 필드에 접근할 때 가독성을 향상시키기 위해 사용해야 합니다. 중첩된 record 패턴도 허용되며 레코드 필드가 다른 레코드이고 그 모든 필드에 접근할 때 사용해야 합니다.</p>\n<h2>예외</h2>\n<p>이 규칙은 모든 레코드 필드에 접근하지 않을 때는 적용되지 않습니다. 이는 분해된 레코드 구조에서 사용되지 않는 로컬 변수의 생성을 방지합니다.</p>",
    "howToFix_ko": "<p>인스턴스 검사 또는 단순 패턴 매칭을 record 패턴으로 교체하세요.</p>\n\n<h4>규칙을 준수하지 않는 코드 예시</h4>\n<p>이 예제는 패턴 매칭을 사용하지만 블록에서 레코드의 모든 필드에 접근하더라도 record 패턴을 사용하지 않습니다.</p>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\nrecord Point(Float x, Float y, Float z) {}\n\nvoid print(Object obj) {\n    if (obj instanceof Point p) { // 규칙 위반, 세 필드 x, y, z 모두에 접근하기 때문\n        Float x = p.x;\n        Float y = p.y();\n        System.out.println(x + y + p.z);\n    }\n}\n</pre>\n<h4>규칙을 준수하는 해결책</h4>\n<p>규칙을 준수하는 예제는 record 패턴을 사용하여 레코드 구조를 분해합니다.</p>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\nrecord Point(Float x, Float y, Float z) {}\n\nvoid print(Object obj) {\n    if (obj instanceof Point(Float x, Float y, Float z)) { // 규칙 준수\n        System.out.println(x + y + z);\n    }\n}\n</pre>\n<h4>규칙을 준수하지 않는 코드 예시</h4>\n<p>이 예제는 패턴 매칭이나 record 패턴을 사용하지 않습니다. 규칙 <em><a href=\"https://sonarsource.github.io/rspec/#/rspec/<a href='/coding_rules#rule_key=java%3AS6201'>S6201</a>\"><a href='/coding_rules#rule_key=java%3AS6201'>S6201</a> - 패턴 매칭 또는 \"instanceOf\" 연산자를 사용해야 합니다</a></em>가 먼저 보고합니다. record 패턴 대신 단순 패턴 매칭으로 수정하면 이 규칙(<a href='/coding_rules#rule_key=java%3AS6878'>S6878</a>)이 보고합니다.</p>\n<pre data-diff-id=\"2\" data-diff-type=\"noncompliant\">\nvoid print(Object obj) {\n    if (obj instanceof Point) { // 규칙 위반\n        Point p = (Point) obj;\n        Float x = p.x;\n        Float y = p.y();\n        System.out.println(x + y + p.z);\n    }\n}\n</pre>\n<h4>규칙을 준수하는 해결책</h4>\n<p>두 규칙 <a href='/coding_rules#rule_key=java%3AS6201'>S6201</a>과 <a href='/coding_rules#rule_key=java%3AS6878'>S6878</a>을 모두 준수하는 해결책은 패턴 매칭을 사용하고 record 패턴을 사용하여 레코드 구조를 분해합니다.</p>\n<pre data-diff-id=\"2\" data-diff-type=\"compliant\">\nvoid print(Object obj) {\n    if (obj instanceof Point(Float x, Float y, Float z)) { // 규칙 준수\n        System.out.println(x + y + z);\n    }\n}\n</pre>\n<h4>규칙을 준수하지 않는 코드 예시</h4>\n<p>이 예제는 중첩된 record 패턴을 사용할 수 있었기 때문에 규칙을 준수하지 않습니다.</p>\n<pre data-diff-id=\"3\" data-diff-type=\"noncompliant\">\nrecord Plane(Point normal, Float d) {}\n\nvoid print(Object obj) {\n    // 규칙 위반, \"normal\"의 모든 필드에 접근하기 때문\n    if (obj instanceof Plane(Point normal, Float d)) {\n        System.out.println(normal.x + normal.y + normal.z);\n        System.out.println(d);\n    }\n}\n</pre>\n<h4>규칙을 준수하는 해결책</h4>\n<p>이것은 중첩된 record 패턴을 사용하는 동일한 예제입니다.</p>\n<pre data-diff-id=\"3\" data-diff-type=\"compliant\">\nvoid print(Object obj) {\n    if (obj instanceof Plane(Point(Float x, Float y, Float z), Float d)) { // 규칙 준수\n        System.out.println(x + y + z);\n        System.out.println(d);\n    }\n}\n</pre>\n<h4>규칙을 준수하는 해결책</h4>\n<p>이 예제는 record 패턴에서 필드 타입을 복제하는 대신 <code>var</code>를 사용하여 덜 장황하고 코드를 더 읽기 쉽게 유지합니다. 특히 긴 타입 이름의 경우에 유용합니다. 또한 원래 필드 이름과 일치하지 않는 변수 이름을 사용합니다. 이유는 필드나 다른 로컬 변수와의 이름 충돌을 피하기 위해서입니다.</p>\n<pre>\nvoid print(Object obj) {\n    if (obj instanceof Point(var px, var py, var pz)) { // 규칙 준수\n        System.out.println(px + py + pz);\n    }\n}\n</pre>\n<h4>규칙을 준수하는 해결책</h4>\n<p>이 예제는 모든 필드에 접근하지 않으므로 record 패턴을 사용하지 않고도 규칙을 준수합니다.</p>\n<pre>\nvoid print(Object obj) {\n    if (obj instanceof Point p) { // 규칙 준수, z에 접근하지 않기 때문\n        Float x = p.x;\n        Float y = p.y();\n        System.out.println(x + y);\n    }\n}\n</pre>",
    "moreInfo_ko": "<ul>\n  <li> <a href=\"https://openjdk.org/jeps/440\">JEP 440: Record Patterns</a> </li>\n</ul>"
  },
  {
    "id": "S3457",
    "key": "java:S3457",
    "name": "Format strings should be used correctly",
    "type": "code-smell",
    "severity": "major",
    "tags": [
      "cert",
      "confusing"
    ],
    "why": "<p>A <code>printf-</code>-style format string is a string that contains placeholders, usually represented by special characters such as \"%s\" or \"{}\",\ndepending on the technology in use. These placeholders are replaced by values when the string is printed or logged.</p>\n<p>Because <code>printf</code>-style format strings are interpreted at runtime, rather than validated by the compiler, they can contain errors that\nresult in the wrong strings being created.</p>\n<p>This rule checks whether every format string specifier can be correctly matched with one of the additional arguments when calling the following\nmethods:</p>\n<ul>\n  <li> <a\n  href=\"https://docs.oracle.com/javase/8/docs/api/java/lang/String.html#format-java.lang.String-java.lang.Object…​-\"><code>java.lang.String#format</code></a> </li>\n  <li> <a\n  href=\"https://docs.oracle.com/javase/8/docs/api/java/util/Formatter.html#format-java.lang.String-java.lang.Object…​-\"><code>java.util.Formatter#format</code></a> </li>\n  <li> <a\n  href=\"https://docs.oracle.com/javase/8/docs/api/java/io/PrintStream.html#format-java.lang.String-java.lang.Object…​-\"><code>java.io.PrintStream#format</code></a> </li>\n  <li> <a\n  href=\"https://docs.oracle.com/javase/8/docs/api/java/text/MessageFormat.html#format-java.lang.String-java.lang.Object…​-\"><code>java.text.MessageFormat#format</code></a> </li>\n  <li> <a\n  href=\"https://docs.oracle.com/javase/8/docs/api/java/io/PrintWriter.html#format-java.lang.String-java.lang.Object…​-\"><code>java.io.PrintWriter#format</code></a> </li>\n  <li> <a\n  href=\"https://docs.oracle.com/javase/8/docs/api/java/io/PrintStream.html#printf-java.lang.String-java.lang.Object…​-\"><code>java.io.PrintStream#printf</code></a> </li>\n  <li> <a\n  href=\"https://docs.oracle.com/javase/8/docs/api/java/io/PrintWriter.html#printf-java.lang.String-java.lang.Object…​-\"><code>java.io.PrintWriter#printf</code></a> </li>\n  <li> <a\n  href=\"https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/String.html#formatted(java.lang.Object…​)\"><code>java.lang.String#formatted</code></a> (since Java 15) </li>\n  <li> logging methods of <a href=\"https://www.slf4j.org/api/org/slf4j/Logger.html\"><code>org.slf4j.Logger</code></a>, <a\n  href=\"https://docs.oracle.com/javase/8/docs/api/java/util/logging/Logger.html\"><code>java.util.logging.Logger</code></a>, <a\n  href=\"https://logging.apache.org/log4j/2.x/javadoc/log4j-api/org/apache/logging/log4j/Logger.html\"><code>org.apache.logging.log4j.Logger</code></a>.\n  </li>\n</ul>",
    "howToFix": "<p>A <code>printf-</code>-style format string is a string that contains placeholders, which are replaced by values when the string is printed or\nlogged. Mismatch in the format specifiers and the arguments provided can lead to incorrect strings being created.</p>\n<p>To avoid issues, a developer should ensure that the provided arguments match format specifiers.</p>\n<p>Note that <a href=\"https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/text/MessageFormat.html\">MessageFormat</a> is used by most\nlogging mechanisms, for example <code>java.util.logging.Logger</code>, thus the <em>single quote</em> must be escaped by a <em>double single\nquote</em>.</p>\n\n<h4>Noncompliant code example</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\nvoid logging(org.slf4j.Logger slf4jLog, java.util.logging.Logger logger) {\n    String.format(\"Too many arguments %d and %d\", 1, 2, 3); // Noncompliant - the third argument '3' is unused\n    String.format(\"First {0} and then {1}\", \"foo\", \"bar\");  //Noncompliant - it appears there is confusion with the use of \"java.text.MessageFormat\" - parameters \"foo\" and \"bar\" will be ignored here\n\n\n    slf4jLog.debug(\"The number: \", 1); // Noncompliant - String contains no format specifiers.\n\n    logger.log(level, \"Can't load library \\\"{0}\\\"!\", \"foo\"); // Noncompliant - the single quote ' must be escaped\n}\n</pre>\n<h4>Compliant solution</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\nvoid logging(org.slf4j.Logger slf4jLog, java.util.logging.Logger logger) {\n    String.format(\"Too many arguments %d and %d\", 1, 2);\n    String.format(\"First %s and then %s\", \"foo\", \"bar\");\n\n    slf4jLog.debug(\"The number: {}\", 1);\n\n    logger.log(level, \"Can''t load library \\\"{0}\\\"!\", \"foo\");\n}\n</pre>",
    "moreInfo": "<ul>\n  <li> <a href=\"https://wiki.sei.cmu.edu/confluence/x/J9YxBQ\">CERT, FIO47-C.</a> - Use valid format strings </li>\n  <li> <a href=\"https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/text/MessageFormat.html\">java.text.MessageFormat</a> </li>\n</ul>",
    "status": "READY",
    "name_ko": "포맷 문자열을 올바르게 사용해야 합니다",
    "why_ko": "<p><code>printf-</code> 스타일 포맷 문자열은 사용 중인 기술에 따라 \"%s\" 또는 \"{}\"와 같은 특수 문자로 표현되는 플레이스홀더를 포함하는 문자열입니다. 이러한 플레이스홀더는 문자열이 출력되거나 로깅될 때 값으로 대체됩니다.</p>\n<p><code>printf</code> 스타일 포맷 문자열은 컴파일러가 아닌 런타임에 해석되기 때문에 잘못된 문자열이 생성되는 오류가 포함될 수 있습니다.</p>\n<p>이 규칙은 다음 메서드를 호출할 때 모든 포맷 문자열 지정자가 추가 인수 중 하나와 올바르게 일치할 수 있는지 확인합니다:</p>\n<ul>\n  <li> <a\n  href=\"https://docs.oracle.com/javase/8/docs/api/java/lang/String.html#format-java.lang.String-java.lang.Object…​-\"><code>java.lang.String#format</code></a> </li>\n  <li> <a\n  href=\"https://docs.oracle.com/javase/8/docs/api/java/util/Formatter.html#format-java.lang.String-java.lang.Object…​-\"><code>java.util.Formatter#format</code></a> </li>\n  <li> <a\n  href=\"https://docs.oracle.com/javase/8/docs/api/java/io/PrintStream.html#format-java.lang.String-java.lang.Object…​-\"><code>java.io.PrintStream#format</code></a> </li>\n  <li> <a\n  href=\"https://docs.oracle.com/javase/8/docs/api/java/text/MessageFormat.html#format-java.lang.String-java.lang.Object…​-\"><code>java.text.MessageFormat#format</code></a> </li>\n  <li> <a\n  href=\"https://docs.oracle.com/javase/8/docs/api/java/io/PrintWriter.html#format-java.lang.String-java.lang.Object…​-\"><code>java.io.PrintWriter#format</code></a> </li>\n  <li> <a\n  href=\"https://docs.oracle.com/javase/8/docs/api/java/io/PrintStream.html#printf-java.lang.String-java.lang.Object…​-\"><code>java.io.PrintStream#printf</code></a> </li>\n  <li> <a\n  href=\"https://docs.oracle.com/javase/8/docs/api/java/io/PrintWriter.html#printf-java.lang.String-java.lang.Object…​-\"><code>java.io.PrintWriter#printf</code></a> </li>\n  <li> <a\n  href=\"https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/String.html#formatted(java.lang.Object…​)\"><code>java.lang.String#formatted</code></a> (Java 15 이후) </li>\n  <li> <a href=\"https://www.slf4j.org/api/org/slf4j/Logger.html\"><code>org.slf4j.Logger</code></a>, <a\n  href=\"https://docs.oracle.com/javase/8/docs/api/java/util/logging/Logger.html\"><code>java.util.logging.Logger</code></a>, <a\n  href=\"https://logging.apache.org/log4j/2.x/javadoc/log4j-api/org/apache/logging/log4j/Logger.html\"><code>org.apache.logging.log4j.Logger</code></a>의 로깅 메서드.\n  </li>\n</ul>",
    "howToFix_ko": "<p><code>printf-</code> 스타일 포맷 문자열은 문자열이 출력되거나 로깅될 때 값으로 대체되는 플레이스홀더를 포함하는 문자열입니다. 포맷 지정자와 제공된 인수가 일치하지 않으면 잘못된 문자열이 생성될 수 있습니다.</p>\n<p>문제를 피하려면 개발자는 제공된 인수가 포맷 지정자와 일치하는지 확인해야 합니다.</p>\n<p><a href=\"https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/text/MessageFormat.html\">MessageFormat</a>은 대부분의 로깅 메커니즘에서 사용됩니다. 예를 들어 <code>java.util.logging.Logger</code>가 있으며, 따라서 <em>작은따옴표</em>는 <em>이중 작은따옴표</em>로 이스케이프해야 합니다.</p>\n\n<h4>규칙을 준수하지 않는 코드 예시</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\nvoid logging(org.slf4j.Logger slf4jLog, java.util.logging.Logger logger) {\n    String.format(\"Too many arguments %d and %d\", 1, 2, 3); // 규칙 위반 - 세 번째 인수 '3'이 사용되지 않음\n    String.format(\"First {0} and then {1}\", \"foo\", \"bar\");  // 규칙 위반 - \"java.text.MessageFormat\" 사용과 혼동된 것으로 보임 - 매개변수 \"foo\"와 \"bar\"가 여기서 무시됨\n\n\n    slf4jLog.debug(\"The number: \", 1); // 규칙 위반 - String에 포맷 지정자가 없음.\n\n    logger.log(level, \"Can't load library \\\"{0}\\\"!\", \"foo\"); // 규칙 위반 - 작은따옴표 '를 이스케이프해야 함\n}\n</pre>\n<h4>규칙을 준수하는 해결책</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\nvoid logging(org.slf4j.Logger slf4jLog, java.util.logging.Logger logger) {\n    String.format(\"Too many arguments %d and %d\", 1, 2);\n    String.format(\"First %s and then %s\", \"foo\", \"bar\");\n\n    slf4jLog.debug(\"The number: {}\", 1);\n\n    logger.log(level, \"Can''t load library \\\"{0}\\\"!\", \"foo\");\n}\n</pre>",
    "moreInfo_ko": "<ul>\n  <li> <a href=\"https://wiki.sei.cmu.edu/confluence/x/J9YxBQ\">CERT, FIO47-C.</a> - 유효한 포맷 문자열 사용 </li>\n  <li> <a href=\"https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/text/MessageFormat.html\">java.text.MessageFormat</a> </li>\n</ul>"
  },
  {
    "id": "S1190",
    "key": "java:S1190",
    "name": "Future keywords should not be used as names",
    "type": "code-smell",
    "severity": "blocker",
    "tags": [
      "obsolete",
      "pitfall"
    ],
    "why": "<p>Programming languages evolve over time, and new versions of Java introduce additional keywords. If future keywords are used in the current code, it\ncan create compatibility issues when transitioning to newer versions of Java. The code may fail to compile or behave unexpectedly due to conflicts\nwith newly introduced keywords.</p>\n<p>The <code>_</code> keyword was deprecated in Java 9 and disallowed since Java 11. Starting from Java 22 the <code>_</code> was introduced as\n<code>unnamed variable</code>.</p>\n<p>This rule reports an issue when <code>_</code> is used in versions prior to Java 22.</p>",
    "howToFix": "<p>Rename the <code>_</code> identifiers.</p>\n\n<h4>Noncompliant code example</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\npublic class MyClass {\n    String _ = \"\";            // Noncompliant\n}\n</pre>\n<h4>Compliant solution</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\npublic class MyClass {\n    String s = \"\";            // Compliant\n}\n</pre>",
    "moreInfo": "<h3>Documentation</h3>\n<ul>\n  <li> <a href=\"https://docs.oracle.com/en/java/javase/22/docs/specs/unnamed-jls.html#jls-3.9\">Oracle - Unnamed Variables and Patterns Keywords</a>\n  </li>\n  <li> <a href=\"https://docs.oracle.com/en/java/javase/22/language/unnamed-variables-and-patterns.html\">Oracle - Unnamed Variables and Patterns</a>\n  </li>\n</ul>",
    "status": "READY",
    "name_ko": "예약된 키워드는 이름으로 사용하면 안 됩니다",
    "why_ko": "<p>프로그래밍 언어는 시간이 지남에 따라 발전하며, 새로운 Java 버전에서는 추가 키워드가 도입됩니다. 현재 코드에서 미래의 키워드를 사용하면 새로운 Java 버전으로 전환할 때 호환성 문제가 발생할 수 있습니다. 새로 도입된 키워드와의 충돌로 인해 코드가 컴파일에 실패하거나 예상치 못한 동작을 할 수 있습니다.</p>\n<p><code>_</code> 키워드는 Java 9에서 deprecated되었고 Java 11부터 사용이 금지되었습니다. Java 22부터 <code>_</code>는 <code>이름 없는 변수(unnamed variable)</code>로 도입되었습니다.</p>\n<p>이 규칙은 Java 22 이전 버전에서 <code>_</code>가 사용될 때 이슈를 보고합니다.</p>",
    "howToFix_ko": "<p><code>_</code> 식별자의 이름을 변경하세요.</p>\n\n<h4>규칙을 준수하지 않는 코드 예시</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\npublic class MyClass {\n    String _ = \"\";            // 규칙 위반\n}\n</pre>\n<h4>규칙을 준수하는 해결책</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\npublic class MyClass {\n    String s = \"\";            // 규칙 준수\n}\n</pre>",
    "moreInfo_ko": "<h3>문서</h3>\n<ul>\n  <li> <a href=\"https://docs.oracle.com/en/java/javase/22/docs/specs/unnamed-jls.html#jls-3.9\">Oracle - 이름 없는 변수와 패턴 키워드</a>\n  </li>\n  <li> <a href=\"https://docs.oracle.com/en/java/javase/22/language/unnamed-variables-and-patterns.html\">Oracle - 이름 없는 변수와 패턴</a>\n  </li>\n</ul>"
  },
  {
    "id": "S6205",
    "key": "java:S6205",
    "name": "Switch arrow labels should not use redundant keywords",
    "type": "code-smell",
    "severity": "minor",
    "tags": [
      "java14"
    ],
    "why": "<p>In Switch Expressions, an arrow label consisting of a block with a single <code>yield</code> can be simplified to directly return the value,\nresulting in cleaner code.</p>\n<p>Similarly, for Switch Statements and arrow labels, a <code>break</code> in a block is always redundant and should not be used. Furthermore, if the\nresulting block contains only one statement, the curly braces of that block can also be omitted.</p>\n<p>This rule reports an issue when a case of a Switch Expression contains a block with a single <code>yield</code> or when a Switch Statement contains\na block with a <code>break</code>.</p>\n<h3>Noncompliant code example</h3>\n<pre>\nint i = switch (mode) {\n  case \"a\" -&gt; {        // Noncompliant: Remove the redundant block and yield.\n    yield 1;\n  }\n  default -&gt; {         // Noncompliant: Remove the redundant block and yield.\n    yield 2;\n  }\n};\n\nswitch (mode) {\n  case \"a\" -&gt; {        // Noncompliant: Remove the redundant block and break.\n    result = 1;\n    break;\n  }\n  default -&gt; {         // Noncompliant: Remove the redundant break.\n    doSomethingElse();\n    result = 2;\n    break;\n  }\n}\n</pre>\n<h3>Compliant solution</h3>\n<pre>\nint i = switch (mode) {\n  case \"a\" -&gt; 1;\n  default -&gt; 2;\n};\n\nswitch (mode) {\n  case \"a\" -&gt; result = 1;\n  default -&gt; {\n   doSomethingElse();\n   result = 2;\n }\n}\n</pre>",
    "howToFix": "",
    "moreInfo": "<ul>\n  <li> <a href=\"https://openjdk.java.net/jeps/361\">JEP 361: Switch Expressions</a> </li>\n</ul>",
    "status": "READY",
    "name_ko": "Switch 화살표 레이블에 불필요한 키워드를 사용하면 안 됩니다",
    "why_ko": "<p>Switch 표현식에서 단일 <code>yield</code>가 있는 블록으로 구성된 화살표 레이블은 직접 값을 반환하도록 단순화할 수 있어 더 깔끔한 코드가 됩니다.</p>\n<p>마찬가지로, Switch 문과 화살표 레이블에서 블록 내의 <code>break</code>는 항상 불필요하며 사용하지 않아야 합니다. 또한, 결과 블록이 하나의 문만 포함하면 해당 블록의 중괄호도 생략할 수 있습니다.</p>\n<p>이 규칙은 Switch 표현식의 case가 단일 <code>yield</code>가 있는 블록을 포함하거나 Switch 문이 <code>break</code>가 있는 블록을 포함할 때 문제를 보고합니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\nint i = switch (mode) {\n  case \"a\" -&gt; {        // 규칙 위반: 불필요한 블록과 yield를 제거하세요.\n    yield 1;\n  }\n  default -&gt; {         // 규칙 위반: 불필요한 블록과 yield를 제거하세요.\n    yield 2;\n  }\n};\n\nswitch (mode) {\n  case \"a\" -&gt; {        // 규칙 위반: 불필요한 블록과 break를 제거하세요.\n    result = 1;\n    break;\n  }\n  default -&gt; {         // 규칙 위반: 불필요한 break를 제거하세요.\n    doSomethingElse();\n    result = 2;\n    break;\n  }\n}\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre>\nint i = switch (mode) {\n  case \"a\" -&gt; 1;\n  default -&gt; 2;\n};\n\nswitch (mode) {\n  case \"a\" -&gt; result = 1;\n  default -&gt; {\n   doSomethingElse();\n   result = 2;\n }\n}\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": "<ul>\n  <li> <a href=\"https://openjdk.java.net/jeps/361\">JEP 361: Switch 표현식</a> </li>\n</ul>"
  },
  {
    "id": "S1939",
    "key": "java:S1939",
    "name": "Extensions and implementations should not be redundant",
    "type": "code-smell",
    "severity": "minor",
    "tags": [
      "clumsy"
    ],
    "why": "<p>All classes extend <code>Object</code> implicitly. Doing so explicitly is redundant.</p>\n<p>Further, declaring the implementation of an interface <em>and</em> one if its parents is also redundant. If you implement the interface, you also\nimplicitly implement its parents and there's no need to do so explicitly.</p>\n<h3>Noncompliant code example</h3>\n<pre>\npublic interface MyFace {\n  // ...\n}\n\npublic interface MyOtherFace extends MyFace {\n  // ...\n}\n\npublic class Foo\n    extends Object // Noncompliant\n    implements MyFace, MyOtherFace {  // Noncompliant\n  //...\n}\n</pre>\n<h3>Compliant solution</h3>\n<pre>\npublic interface MyFace {\n  // ...\n}\n\npublic interface MyOtherFace extends MyFace {\n  // ...\n}\n\npublic class Foo implements MyOtherFace {\n  //...\n}\n</pre>",
    "howToFix": "",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "중복된 상속과 구현이 있으면 안 됩니다",
    "why_ko": "<p>모든 클래스는 암시적으로 <code>Object</code>를 상속합니다. 명시적으로 하는 것은 중복입니다.</p>\n<p>또한, 인터페이스와 그 부모 인터페이스 중 하나의 구현을 선언하는 것도 중복입니다. 인터페이스를 구현하면 암시적으로 그 부모도 구현하므로 명시적으로 할 필요가 없습니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\npublic interface MyFace {\n  // ...\n}\n\npublic interface MyOtherFace extends MyFace {\n  // ...\n}\n\npublic class Foo\n    extends Object // 규칙 위반\n    implements MyFace, MyOtherFace {  // 규칙 위반\n  //...\n}\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre>\npublic interface MyFace {\n  // ...\n}\n\npublic interface MyOtherFace extends MyFace {\n  // ...\n}\n\npublic class Foo implements MyOtherFace {\n  //...\n}\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": ""
  },
  {
    "id": "S1313",
    "key": "java:S1313",
    "name": "Using hardcoded IP addresses is security-sensitive",
    "type": "security-hotspot",
    "severity": "minor",
    "tags": [
      "cert"
    ],
    "why": "<p>Hardcoding IP addresses is security-sensitive. It has led in the past to the following vulnerabilities:</p>\n<ul>\n  <li> <a href=\"https://www.cve.org/CVERecord?id=CVE-2006-5901\">CVE-2006-5901</a> </li>\n  <li> <a href=\"https://www.cve.org/CVERecord?id=CVE-2005-3725\">CVE-2005-3725</a> </li>\n</ul>\n<p>Today's services have an ever-changing architecture due to their scaling and redundancy needs. It is a mistake to think that a service will always\nhave the same IP address. When it does change, the hardcoded IP will have to be modified too. This will have an impact on the product development,\ndelivery, and deployment:</p>\n<ul>\n  <li> The developers will have to do a rapid fix every time this happens, instead of having an operation team change a configuration file. </li>\n  <li> It misleads to use the same address in every environment (dev, sys, qa, prod). </li>\n</ul>\n<p>Last but not least it has an effect on application security. Attackers might be able to decompile the code and thereby discover a potentially\nsensitive address. They can perform a Denial of Service attack on the service, try to get access to the system, or try to spoof the IP address to\nbypass security checks. Such attacks can always be possible, but in the case of a hardcoded IP address solving the issue will take more time, which\nwill increase an attack's impact.</p>\n<h2>Exceptions</h2>\n<p>No issue is reported for the following cases because they are not considered sensitive:</p>\n<ul>\n  <li> Loopback addresses 127.0.0.0/8 in CIDR notation (from 127.0.0.0 to 127.255.255.255) </li>\n  <li> Broadcast address 255.255.255.255 </li>\n  <li> Non-routable address 0.0.0.0 </li>\n  <li> Strings of the form <code>2.5.&lt;number&gt;.&lt;number&gt;</code> as they <a href=\"https://en.wikipedia.org/wiki/Object_identifier\">often\n  match Object Identifiers</a> (OID) </li>\n  <li> Addresses in the ranges 192.0.2.0/24, 198.51.100.0/24, 203.0.113.0/24, reserved for documentation purposes by <a\n  href=\"https://datatracker.ietf.org/doc/html/rfc5737\">RFC 5737</a> </li>\n  <li> Addresses in the range 2001:db8::/32, reserved for documentation purposes by <a href=\"https://datatracker.ietf.org/doc/html/rfc3849\">RFC\n  3849</a> </li>\n</ul>\n",
    "howToFix": "<h2>Recommended Secure Coding Practices</h2>\n<p>Don't hard-code the IP address in the source code, instead make it configurable with environment variables, configuration files, or a similar\napproach. Alternatively, if confidentially is not required a domain name can be used since it allows to change the destination quickly without having\nto rebuild the software.</p>\n<h2>Compliant Solution</h2>\n<pre>\nString ip = System.getenv(\"IP_ADDRESS\"); // Compliant\nSocket socket = new Socket(ip, 6667);\n</pre>\n<h2>See</h2>\n<ul>\n  <li> OWASP - <a href=\"https://owasp.org/Top10/A01_2021-Broken_Access_Control/\">Top 10 2021 Category A1 - Broken Access Control</a> </li>\n  <li> OWASP - <a href=\"https://owasp.org/www-project-top-ten/2017/A3_2017-Sensitive_Data_Exposure\">Top 10 2017 Category A3 - Sensitive Data\n  Exposure</a> </li>\n  <li> <a href=\"https://wiki.sei.cmu.edu/confluence/x/OjdGBQ\">CERT, MSC03-J.</a> - Never hard code sensitive information </li>\n</ul>",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "하드코딩된 IP 주소 사용은 보안에 민감합니다",
    "why_ko": "<p>IP 주소를 하드코딩하는 것은 보안에 민감합니다. 과거에 다음과 같은 취약점으로 이어졌습니다:</p>\n<ul>\n  <li> <a href=\"https://www.cve.org/CVERecord?id=CVE-2006-5901\">CVE-2006-5901</a> </li>\n  <li> <a href=\"https://www.cve.org/CVERecord?id=CVE-2005-3725\">CVE-2005-3725</a> </li>\n</ul>\n<p>오늘날의 서비스는 확장성과 중복성 요구로 인해 끊임없이 변화하는 아키텍처를 가지고 있습니다. 서비스가 항상 동일한 IP 주소를 가질 것이라고 생각하는 것은 실수입니다. IP 주소가 변경되면 하드코딩된 IP도 수정해야 합니다. 이는 제품 개발, 제공 및 배포에 영향을 미칩니다:</p>\n<ul>\n  <li> 운영 팀이 구성 파일을 변경하는 대신 개발자가 이런 일이 발생할 때마다 빠른 수정을 해야 합니다. </li>\n  <li> 모든 환경(dev, sys, qa, prod)에서 동일한 주소를 사용하도록 오도합니다. </li>\n</ul>\n<p>마지막으로 중요한 것은 애플리케이션 보안에 영향을 미친다는 것입니다. 공격자는 코드를 디컴파일하여 잠재적으로 민감한 주소를 발견할 수 있습니다. 서비스에 대한 서비스 거부 공격을 수행하거나, 시스템에 대한 액세스를 시도하거나, 보안 검사를 우회하기 위해 IP 주소를 스푸핑할 수 있습니다. 이러한 공격은 항상 가능하지만 하드코딩된 IP 주소의 경우 문제 해결에 더 많은 시간이 소요되어 공격의 영향이 증가합니다.</p>\n<h2>예외</h2>\n<p>다음 경우는 민감하지 않은 것으로 간주되어 이슈가 보고되지 않습니다:</p>\n<ul>\n  <li> CIDR 표기법의 루프백 주소 127.0.0.0/8 (127.0.0.0에서 127.255.255.255까지) </li>\n  <li> 브로드캐스트 주소 255.255.255.255 </li>\n  <li> 라우팅 불가능한 주소 0.0.0.0 </li>\n  <li> <code>2.5.&lt;number&gt;.&lt;number&gt;</code> 형식의 문자열은 종종 <a href=\"https://en.wikipedia.org/wiki/Object_identifier\">Object Identifier</a>(OID)와 일치하기 때문입니다 </li>\n  <li> <a href=\"https://datatracker.ietf.org/doc/html/rfc5737\">RFC 5737</a>에 의해 문서 목적으로 예약된 192.0.2.0/24, 198.51.100.0/24, 203.0.113.0/24 범위의 주소 </li>\n  <li> <a href=\"https://datatracker.ietf.org/doc/html/rfc3849\">RFC 3849</a>에 의해 문서 목적으로 예약된 2001:db8::/32 범위의 주소 </li>\n</ul>\n",
    "howToFix_ko": "<h2>권장 보안 코딩 관행</h2>\n<p>소스 코드에 IP 주소를 하드코딩하지 말고 환경 변수, 구성 파일 또는 유사한 방식으로 구성 가능하게 만드세요. 또는 기밀성이 필요하지 않은 경우 소프트웨어를 다시 빌드하지 않고도 대상을 빠르게 변경할 수 있는 도메인 이름을 사용할 수 있습니다.</p>\n<h2>규칙을 준수하는 해결책</h2>\n<pre>\nString ip = System.getenv(\"IP_ADDRESS\"); // 규칙 준수\nSocket socket = new Socket(ip, 6667);\n</pre>\n<h2>참고</h2>\n<ul>\n  <li> OWASP - <a href=\"https://owasp.org/Top10/A01_2021-Broken_Access_Control/\">Top 10 2021 Category A1 - 취약한 접근 제어</a> </li>\n  <li> OWASP - <a href=\"https://owasp.org/www-project-top-ten/2017/A3_2017-Sensitive_Data_Exposure\">Top 10 2017 Category A3 - 민감한 데이터 노출</a> </li>\n  <li> <a href=\"https://wiki.sei.cmu.edu/confluence/x/OjdGBQ\">CERT, MSC03-J.</a> - 민감한 정보를 절대 하드코딩하지 마세요 </li>\n</ul>",
    "moreInfo_ko": ""
  },
  {
    "id": "S2250",
    "key": "java:S2250",
    "name": "Collection methods with O(n) performance should be used carefully",
    "type": "code-smell",
    "severity": "minor",
    "tags": [
      "performance"
    ],
    "why": "<p>The time complexity of method calls on collections is not always obvious. For instance, for most collections the <code>size()</code> method takes\nconstant time, but the time required to execute <code>ConcurrentLinkedQueue.size()</code> is O(n), i.e. directly proportional to the number of\nelements in the collection. When the collection is large, this could therefore be an expensive operation.</p>\n<p>This rule raises an issue when the following O(n) methods are called outside of constructors on class fields:</p>\n<ul>\n  <li> <code>ArrayList</code>\n    <ul>\n      <li> <code>contains</code> </li>\n      <li> <code>remove</code> </li>\n    </ul>  </li>\n  <li> <code>LinkedList</code>\n    <ul>\n      <li> <code>get</code> </li>\n      <li> <code>contains</code> </li>\n    </ul>  </li>\n  <li> <code>ConcurrentLinkedQueue</code>\n    <ul>\n      <li> <code>size</code> </li>\n      <li> <code>contains</code> </li>\n    </ul>  </li>\n  <li> <code>ConcurrentLinkedDeque</code>\n    <ul>\n      <li> <code>size</code> </li>\n      <li> <code>contains</code> </li>\n    </ul>  </li>\n  <li> <code>CopyOnWriteArrayList</code>\n    <ul>\n      <li> <code>add</code> </li>\n      <li> <code>contains</code> </li>\n      <li> <code>remove</code> </li>\n    </ul>  </li>\n  <li> <code>CopyOnWriteArraySet</code>\n    <ul>\n      <li> <code>add</code> </li>\n      <li> <code>contains</code> </li>\n      <li> <code>remove</code> </li>\n    </ul>  </li>\n</ul>\n<h3>Noncompliant code example</h3>\n<pre>\nConcurrentLinkedQueue queue = new ConcurrentLinkedQueue();\n//...\nlog.info(\"Queue contains \" + queue.size() + \" elements\");  // Noncompliant\n</pre>",
    "howToFix": "",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "O(n) 성능을 가진 Collection 메서드는 신중하게 사용해야 합니다",
    "why_ko": "<p>컬렉션에 대한 메서드 호출의 시간 복잡도가 항상 명확한 것은 아닙니다. 예를 들어 대부분의 컬렉션에서 <code>size()</code> 메서드는 상수 시간이 걸리지만 <code>ConcurrentLinkedQueue.size()</code>를 실행하는 데 필요한 시간은 O(n)으로, 컬렉션의 요소 수에 직접 비례합니다. 컬렉션이 크면 이것은 비용이 많이 드는 연산이 될 수 있습니다.</p>\n<p>이 규칙은 다음 O(n) 메서드가 클래스 필드에서 생성자 외부에서 호출될 때 이슈를 발생시킵니다:</p>\n<ul>\n  <li> <code>ArrayList</code>\n    <ul>\n      <li> <code>contains</code> </li>\n      <li> <code>remove</code> </li>\n    </ul>  </li>\n  <li> <code>LinkedList</code>\n    <ul>\n      <li> <code>get</code> </li>\n      <li> <code>contains</code> </li>\n    </ul>  </li>\n  <li> <code>ConcurrentLinkedQueue</code>\n    <ul>\n      <li> <code>size</code> </li>\n      <li> <code>contains</code> </li>\n    </ul>  </li>\n  <li> <code>ConcurrentLinkedDeque</code>\n    <ul>\n      <li> <code>size</code> </li>\n      <li> <code>contains</code> </li>\n    </ul>  </li>\n  <li> <code>CopyOnWriteArrayList</code>\n    <ul>\n      <li> <code>add</code> </li>\n      <li> <code>contains</code> </li>\n      <li> <code>remove</code> </li>\n    </ul>  </li>\n  <li> <code>CopyOnWriteArraySet</code>\n    <ul>\n      <li> <code>add</code> </li>\n      <li> <code>contains</code> </li>\n      <li> <code>remove</code> </li>\n    </ul>  </li>\n</ul>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\nConcurrentLinkedQueue queue = new ConcurrentLinkedQueue();\n//...\nlog.info(\"Queue contains \" + queue.size() + \" elements\");  // 규칙 위반\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": ""
  },
  {
    "id": "S6213",
    "key": "java:S6213",
    "name": "Restricted Identifiers should not be used as Identifiers",
    "type": "code-smell",
    "severity": "major",
    "tags": [],
    "why": "<p>Even if it is technically possible, <a href=\"https://docs.oracle.com/javase/specs/jls/se16/html/jls-3.html#jls-3.8\">Restricted Identifiers</a>\nshould not be used as identifiers. This is only possible for compatibility reasons, using it in Java code is confusing and should be avoided.</p>\n<p>Note that this applies to any version of Java, including the one where these identifiers are not yet restricted, to avoid future confusion.</p>\n<p>This rule reports an issue when restricted identifiers:</p>\n<ul>\n  <li> var </li>\n  <li> yield </li>\n  <li> record </li>\n</ul>\n<p>are used as identifiers.</p>\n<h3>Noncompliant code example</h3>\n<pre>\nvar var = \"var\"; // Noncompliant: compiles but this code is confusing\nvar = \"what is this?\";\n\nint yield(int i) { // Noncompliant\n  return switch (i) {\n    case 1: yield(0); // This is a yield from switch expression, not a recursive call.\n    default: yield(i-1);\n  };\n}\n\nString record = \"record\"; // Noncompliant\n</pre>\n<h3>Compliant solution</h3>\n<pre>\nvar myVariable = \"var\";\n\nint minusOne(int i) {\n  return switch (i) {\n    case 1: yield(0);\n    default: yield(i-1);\n  };\n}\n\nString myRecord = \"record\";\n</pre>",
    "howToFix": "",
    "moreInfo": "<ul>\n  <li> <a href=\"https://docs.oracle.com/javase/specs/jls/se16/html/jls-3.html#jls-3.8\">JLS16, 3.8: Identifiers</a> </li>\n</ul>",
    "status": "READY",
    "name_ko": "제한된 식별자를 식별자로 사용하면 안 됩니다",
    "why_ko": "<p>기술적으로 가능하더라도 <a href=\"https://docs.oracle.com/javase/specs/jls/se16/html/jls-3.html#jls-3.8\">제한된 식별자</a>를 식별자로 사용하면 안 됩니다. 이것은 호환성상의 이유로만 가능하며, Java 코드에서 사용하면 혼란스럽고 피해야 합니다.</p>\n<p>이것은 향후 혼란을 피하기 위해 이러한 식별자가 아직 제한되지 않은 버전을 포함하여 모든 Java 버전에 적용됩니다.</p>\n<p>이 규칙은 제한된 식별자:</p>\n<ul>\n  <li> var </li>\n  <li> yield </li>\n  <li> record </li>\n</ul>\n<p>가 식별자로 사용될 때 문제를 보고합니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\nvar var = \"var\"; // 규칙 위반: 컴파일되지만 이 코드는 혼란스러움\nvar = \"what is this?\";\n\nint yield(int i) { // 규칙 위반\n  return switch (i) {\n    case 1: yield(0); // 이것은 switch 표현식의 yield이며 재귀 호출이 아님.\n    default: yield(i-1);\n  };\n}\n\nString record = \"record\"; // 규칙 위반\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre>\nvar myVariable = \"var\";\n\nint minusOne(int i) {\n  return switch (i) {\n    case 1: yield(0);\n    default: yield(i-1);\n  };\n}\n\nString myRecord = \"record\";\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": "<ul>\n  <li> <a href=\"https://docs.oracle.com/javase/specs/jls/se16/html/jls-3.html#jls-3.8\">JLS16, 3.8: 식별자</a> </li>\n</ul>"
  },
  {
    "id": "S3011",
    "key": "java:S3011",
    "name": "Reflection should not be used to increase accessibility of classes, methods, or fields",
    "type": "code-smell",
    "severity": "major",
    "tags": [
      "cert"
    ],
    "why": "<p>Altering or bypassing the accessibility of classes, methods, or fields through reflection violates the encapsulation principle. This can break the\ninternal contracts of the accessed target and lead to maintainability issues and runtime errors.</p>\n<p>This rule raises an issue when reflection is used to change the visibility of a class, method or field, and when it is used to directly update a\nfield value.</p>\n<pre>\npublic void makeItPublic(String methodName) throws NoSuchMethodException {\n\n  this.getClass().getMethod(methodName).setAccessible(true); // Noncompliant\n}\n\npublic void setItAnyway(String fieldName, int value) {\n  this.getClass().getDeclaredField(fieldName).setInt(this, value); // Noncompliant; bypasses controls in setter\n}\n</pre>",
    "howToFix": "",
    "moreInfo": "<h3>Documentation</h3>\n<ul>\n  <li> <a href=\"https://en.wikipedia.org/wiki/Encapsulation_(computer_programming)\">Wikipedia definition of Encapsulation</a> </li>\n  <li> <a href=\"https://wiki.sei.cmu.edu/confluence/x/_jZGBQ\">CERT, SEC05-J.</a> - Do not use reflection to increase accessibility of classes,\n  methods, or fields </li>\n</ul>",
    "status": "READY",
    "name_ko": "클래스, 메서드, 필드의 접근성을 높이기 위해 Reflection을 사용하면 안 됩니다","why_ko": "<p>Reflection을 통해 클래스, 메서드 또는 필드의 접근성을 변경하거나 우회하면 캡슐화 원칙을 위반합니다. 이는 액세스 대상의 내부 계약을 깨뜨리고 유지 관리 문제와 런타임 오류를 초래할 수 있습니다.</p>\n<p>이 규칙은 Reflection이 클래스, 메서드 또는 필드의 가시성을 변경하는 데 사용되거나 필드 값을 직접 업데이트하는 데 사용될 때 문제를 제기합니다.</p>\n<pre>\npublic void makeItPublic(String methodName) throws NoSuchMethodException {\n\n  this.getClass().getMethod(methodName).setAccessible(true); // 규칙 위반\n}\n\npublic void setItAnyway(String fieldName, int value) {\n  this.getClass().getDeclaredField(fieldName).setInt(this, value); // 규칙 위반; setter의 제어를 우회합니다\n}\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": "<h3>문서</h3>\n<ul>\n  <li> <a href=\"https://en.wikipedia.org/wiki/Encapsulation_(computer_programming)\">Wikipedia definition of Encapsulation</a> </li>\n  <li> <a href=\"https://wiki.sei.cmu.edu/confluence/x/_jZGBQ\">CERT, SEC05-J.</a> - 클래스, 메서드 또는 필드의 접근성을 높이기 위해 Reflection을 사용하지 마세요 </li>\n</ul>"
  },
  {
    "id": "S1186",
    "key": "java:S1186",
    "name": "Methods should not be empty",
    "type": "code-smell",
    "severity": "critical",
    "tags": [
      "suspicious"
    ],
    "why": "<p>An empty method is generally considered bad practice and can lead to confusion, readability, and maintenance issues. Empty methods bring no\nfunctionality and are misleading to others as they might think the method implementation fulfills a specific and identified requirement.</p>\n<p>There are several reasons for a method not to have a body:</p>\n<ul>\n  <li> It is an unintentional omission, and should be fixed to prevent an unexpected behavior in production. </li>\n  <li> It is not yet, or never will be, supported. In this case an exception should be thrown. </li>\n  <li> The method is an intentionally-blank override. In this case a nested comment should explain the reason for the blank override. </li>\n</ul>\n<h3>Exceptions</h3>\n<p>This does not raise an issue in the following cases:</p>\n<ul>\n  <li> Methods with a comment to explain why they are empty </li>\n  <li> Non-public default (no-argument) constructors </li>\n  <li> Public default (no-argument) constructors when there are other constructors in the class </li>\n  <li> Empty methods in abstract classes </li>\n  <li> Methods annotated with <code>@org.aspectj.lang.annotation.Pointcut()</code> </li>\n</ul>\n<pre>\npublic abstract class Animal {\n  void speak() {  // default implementation ignored\n  }\n}\n</pre>",
    "howToFix": "<p>To fix this issue, either make the method do something, throw an exception, or add a comment to explain why it is empty.</p>\n\n<h4>Noncompliant code example</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\npublic void shouldNotBeEmpty() {  // Noncompliant - method is empty\n}\n\npublic void notImplemented() {  // Noncompliant - method is empty\n}\n\n@Override\npublic void emptyOnPurpose() {  // Noncompliant - method is empty\n}\n</pre>\n<h4>Compliant solution</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\npublic void doSomething() {\n  doSomething();\n}\n\npublic void notImplemented() {\n  throw new UnsupportedOperationException(\"notImplemented() cannot be performed because ...\");\n}\n\n@Override\npublic void emptyOnPurpose() {\n  // comment explaining why the method is empty\n}\n</pre>",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "메서드는 비어 있으면 안 됩니다",
    "why_ko": "<p>빈 메서드는 일반적으로 나쁜 관행으로 간주되며 혼란, 가독성 및 유지보수 문제를 야기할 수 있습니다. 빈 메서드는 기능을 제공하지 않으며, 다른 사람들이 메서드 구현이 특정하고 식별된 요구 사항을 충족한다고 생각할 수 있어 오해를 불러일으킵니다.</p>\n<p>메서드에 본문이 없는 데에는 여러 가지 이유가 있습니다:</p>\n<ul>\n  <li> 의도치 않은 누락이며, 프로덕션에서 예상치 못한 동작을 방지하기 위해 수정해야 합니다. </li>\n  <li> 아직 지원되지 않거나, 앞으로도 지원되지 않을 것입니다. 이 경우 예외를 던져야 합니다. </li>\n  <li> 메서드가 의도적으로 비어 있는 오버라이드입니다. 이 경우 중첩된 주석으로 비어 있는 오버라이드의 이유를 설명해야 합니다. </li>\n</ul>\n<h3>예외 사항</h3>\n<p>다음의 경우에는 이슈를 제기하지 않습니다:</p>\n<ul>\n  <li> 비어 있는 이유를 설명하는 주석이 있는 메서드 </li>\n  <li> public이 아닌 기본(인수 없는) 생성자 </li>\n  <li> 클래스에 다른 생성자가 있을 때의 public 기본(인수 없는) 생성자 </li>\n  <li> 추상 클래스의 빈 메서드 </li>\n  <li> <code>@org.aspectj.lang.annotation.Pointcut()</code>으로 어노테이션된 메서드 </li>\n</ul>\n<pre>\npublic abstract class Animal {\n  void speak() {  // 기본 구현 무시됨\n  }\n}\n</pre>",
    "howToFix_ko": "<p>이 문제를 해결하려면 메서드가 무언가를 수행하게 하거나, 예외를 던지거나, 왜 비어 있는지 설명하는 주석을 추가하세요.</p>\n\n<h4>규칙을 준수하지 않는 코드 예시</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\npublic void shouldNotBeEmpty() {  // 규칙 위반 - 메서드가 비어 있음\n}\n\npublic void notImplemented() {  // 규칙 위반 - 메서드가 비어 있음\n}\n\n@Override\npublic void emptyOnPurpose() {  // 규칙 위반 - 메서드가 비어 있음\n}\n</pre>\n<h4>규칙을 준수하는 해결책</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\npublic void doSomething() {\n  doSomething();\n}\n\npublic void notImplemented() {\n  throw new UnsupportedOperationException(\"notImplemented()는 ... 때문에 수행할 수 없습니다\");\n}\n\n@Override\npublic void emptyOnPurpose() {\n  // 메서드가 비어 있는 이유를 설명하는 주석\n}\n</pre>","moreInfo_ko": ""
  },
  {
    "id": "S1610",
    "key": "java:S1610",
    "name": "Abstract classes without fields should be converted to interfaces",
    "type": "code-smell",
    "severity": "minor",
    "tags": [],
    "why": "<p>With Java 8's \"default method\" feature, any abstract class without direct or inherited field should be converted into an interface. However, this\nchange may not be appropriate in libraries or other applications where the class is intended to be used as an API.</p>\n<p><strong>Note</strong> that this rule is automatically disabled when the project's <code>sonar.java.source</code> is lower than <code>8</code>.</p>\n<h3>Noncompliant code example</h3>\n<pre>\npublic abstract class Car {\n  public abstract void start(Environment c);\n\n  public void stop(Environment c) {\n    c.freeze(this);\n  }\n}\n</pre>\n<h3>Compliant solution</h3>\n<pre>\npublic interface Car {\n  public void start(Environment c);\n\n  public default void stop(Environment c) {\n    c.freeze(this);\n  }\n}\n</pre>",
    "howToFix": "",
    "moreInfo": "",
    "status": "DEPRECATED",
    "name_ko": "필드가 없는 추상 클래스는 인터페이스로 변환해야 합니다",
    "why_ko": "<p>Java 8의 \"default 메서드\" 기능으로 직접 또는 상속된 필드가 없는 추상 클래스는 인터페이스로 변환해야 합니다. 그러나 이 변경은 클래스가 API로 사용되도록 의도된 라이브러리나 다른 애플리케이션에서는 적절하지 않을 수 있습니다.</p>\n<p><strong>참고</strong>: 이 규칙은 프로젝트의 <code>sonar.java.source</code>가 <code>8</code>보다 낮으면 자동으로 비활성화됩니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\npublic abstract class Car {\n  public abstract void start(Environment c);\n\n  public void stop(Environment c) {\n    c.freeze(this);\n  }\n}\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre>\npublic interface Car {\n  public void start(Environment c);\n\n  public default void stop(Environment c) {\n    c.freeze(this);\n  }\n}\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": ""
  },
  {
    "id": "S4042",
    "key": "java:S4042",
    "name": "\"java.nio.Files#delete\" should be preferred",
    "type": "code-smell",
    "severity": "major",
    "tags": [
      "error-handling",
      "api-design"
    ],
    "why": "<p>When <code>java.io.File#delete</code> fails, this <code>boolean</code> method simply returns <code>false</code> with no indication of the cause. On\nthe other hand, when <code>java.nio.file.Files#delete</code> fails, this <code>void</code> method returns one of a series of exception types to better\nindicate the cause of the failure. And since more information is generally better in a debugging situation, <code>java.nio.file.Files#delete</code> is\nthe preferred option.</p>\n<h3>Noncompliant code example</h3>\n<pre>\npublic void cleanUp(Path path) {\n  File file = new File(path);\n  if (!file.delete()) {  // Noncompliant\n    //...\n  }\n}\n</pre>\n<h3>Compliant solution</h3>\n<pre>\npublic void cleanUp(Path path) throws NoSuchFileException, DirectoryNotEmptyException, IOException {\n  Files.delete(path);\n}\n</pre>",
    "howToFix": "",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "\"java.nio.Files#delete\"를 사용하는 것이 좋습니다",
    "why_ko": "<p><code>java.io.File#delete</code>가 실패하면 이 <code>boolean</code> 메서드는 원인에 대한 표시 없이 단순히 <code>false</code>를 반환합니다. 반면에 <code>java.nio.file.Files#delete</code>가 실패하면 이 <code>void</code> 메서드는 실패 원인을 더 잘 나타내기 위해 일련의 예외 유형 중 하나를 반환합니다. 디버깅 상황에서는 일반적으로 더 많은 정보가 좋으므로 <code>java.nio.file.Files#delete</code>가 선호되는 옵션입니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\npublic void cleanUp(Path path) {\n  File file = new File(path);\n  if (!file.delete()) {  // 규칙 위반\n    //...\n  }\n}\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre>\npublic void cleanUp(Path path) throws NoSuchFileException, DirectoryNotEmptyException, IOException {\n  Files.delete(path);\n}\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": ""
  },
  {
    "id": "S2196",
    "key": "java:S2196",
    "name": "Switches should be used for sequences of simple \"String\" tests",
    "type": "code-smell",
    "severity": "minor",
    "tags": [
      "clumsy"
    ],
    "why": "<p>Since Java 7, <code>String</code>s can be used as <code>switch</code> arguments. So when a single <code>String</code> is tested against three or\nmore values in an <code>if</code>/<code>else if</code> structure, it should be converted to a switch instead for greater readability.</p>\n<p><strong>Note</strong> that this rule is automatically disabled when the project's <code>sonar.java.source</code> is lower than <code>7</code>.</p>\n<h3>Noncompliant code example</h3>\n<pre>\nif (\"red\".equals(choice)) {  // Noncompliant\n  dispenseRed();\n} else if (\"blue\".equals(choice)) {\n  dispenseBlue();\n} else if (\"yellow\".equals(choice)) {\n  dispenseYellow();\n} else {\n  promptUser();\n}\n</pre>\n<h3>Compliant solution</h3>\n<pre>\nswitch(choice) {\n  case \"Red\":\n    dispenseRed();\n    break;\n  case \"Blue\":\n    dispenseBlue():\n    break;\n  case \"Yellow\":\n    dispenseYellow();\n    break;\n  default:\n    promptUser();\n    break;\n}\n</pre>",
    "howToFix": "",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "단순한 \"String\" 테스트 시퀀스에는 switch를 사용해야 합니다",
    "why_ko": "<p>Java 7부터 <code>String</code>을 <code>switch</code> 인자로 사용할 수 있습니다. 따라서 단일 <code>String</code>이 <code>if</code>/<code>else if</code> 구조에서 세 개 이상의 값에 대해 테스트될 때 가독성을 높이기 위해 switch로 변환해야 합니다.</p>\n<p><strong>참고</strong>: 이 규칙은 프로젝트의 <code>sonar.java.source</code>가 <code>7</code>보다 낮을 때 자동으로 비활성화됩니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\nif (\"red\".equals(choice)) {  // 규칙 위반\n  dispenseRed();\n} else if (\"blue\".equals(choice)) {\n  dispenseBlue();\n} else if (\"yellow\".equals(choice)) {\n  dispenseYellow();\n} else {\n  promptUser();\n}\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre>\nswitch(choice) {\n  case \"Red\":\n    dispenseRed();\n    break;\n  case \"Blue\":\n    dispenseBlue():\n    break;\n  case \"Yellow\":\n    dispenseYellow();\n    break;\n  default:\n    promptUser();\n    break;\n}\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": ""
  },
  {
    "id": "S3416",
    "key": "java:S3416",
    "name": "Loggers should be named for their enclosing classes",
    "type": "code-smell",
    "severity": "minor",
    "tags": [
      "logging",
      "confusing"
    ],
    "why": "<p>It is convention to name each class's logger for the class itself. Doing so allows you to set up clear, communicative logger configuration. Naming\nloggers by some other convention confuses configuration, and using the same class name for multiple class loggers prevents the granular configuration\nof each class' logger. Some libraries, such as SLF4J warn about this, but not all do.</p>\n<p>This rule raises an issue when a logger is not named for its enclosing class.</p>\n<h3>Noncompliant code example</h3>\n<pre>\npublic class MyClass {\n  private final static Logger LOG = LoggerFactory.getLogger(WrongClass.class);  // Noncompliant; multiple classes using same logger\n}\n</pre>\n<h3>Compliant solution</h3>\n<pre>\npublic class MyClass {\n  private final static Logger LOG = LoggerFactory.getLogger(MyClass.class);\n}\n</pre>",
    "howToFix": "",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "Logger는 해당 클래스 이름으로 명명해야 합니다",
    "why_ko": "<p>각 클래스의 logger를 해당 클래스 이름으로 명명하는 것이 관례입니다. 이렇게 하면 명확하고 이해하기 쉬운 logger 구성을 설정할 수 있습니다. 다른 규칙으로 logger를 명명하면 구성이 혼란스러워지고, 여러 클래스 logger에 동일한 클래스 이름을 사용하면 각 클래스 logger의 세분화된 구성이 불가능해집니다. SLF4J와 같은 일부 라이브러리는 이에 대해 경고하지만 모든 라이브러리가 그렇지는 않습니다.</p>\n<p>이 규칙은 logger가 해당 클래스 이름으로 명명되지 않았을 때 문제를 제기합니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\npublic class MyClass {\n  private final static Logger LOG = LoggerFactory.getLogger(WrongClass.class);  // 규칙 위반; 여러 클래스가 동일한 logger 사용\n}\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre>\npublic class MyClass {\n  private final static Logger LOG = LoggerFactory.getLogger(MyClass.class);\n}\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": ""
  },
  {
    "id": "S3046",
    "key": "java:S3046",
    "name": "\"wait\" should not be called when multiple locks are held",
    "type": "bug",
    "severity": "blocker",
    "tags": [
      "multi-threading",
      "deadlock"
    ],
    "why": "<p>When two locks are held simultaneously, a <code>wait</code> call only releases one of them. The other will be held until some other thread requests\na lock on the awaited object. If no unrelated code tries to lock on that object, then all other threads will be locked out, resulting in a\ndeadlock.</p>\n<h3>Noncompliant code example</h3>\n<pre>\nsynchronized (this.mon1) {  // threadB can't enter this block to request this.mon2 lock &amp; release threadA\n\tsynchronized (this.mon2) {\n\t\tthis.mon2.wait();  // Noncompliant; threadA is stuck here holding lock on this.mon1\n\t}\n}\n</pre>",
    "howToFix": "",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "여러 lock을 보유한 상태에서 \"wait\"를 호출하면 안 됩니다",
    "why_ko": "<p>두 개의 lock이 동시에 보유되어 있을 때, <code>wait</code> 호출은 그 중 하나만 해제합니다. 다른 lock은 다른 스레드가 대기 중인 객체에 대한 lock을 요청할 때까지 유지됩니다. 관련 없는 코드가 해당 객체에 대한 lock을 시도하지 않으면, 다른 모든 스레드가 잠겨서 데드락이 발생합니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\nsynchronized (this.mon1) {  // threadB는 이 블록에 진입하여 this.mon2 lock을 요청하고 threadA를 해제할 수 없습니다\n\tsynchronized (this.mon2) {\n\t\tthis.mon2.wait();  // 규칙 위반; threadA는 this.mon1의 lock을 유지한 채 여기서 멈춥니다\n\t}\n}\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": ""
  },
  {
    "id": "S6244",
    "key": "java:S6244",
    "name": "Consumer Builders should be used",
    "type": "code-smell",
    "severity": "minor",
    "tags": [
      "aws"
    ],
    "why": "<p>Some API, like the AWS SDK, heavily rely on the builder pattern to create different data structures. Despite all the benefits, this pattern can\nbecome really verbose, especially when dealing with nested structures. In order to reach a more concise code, \"Consumer Builders\", also called\n\"Consumer Interface\" are often introduced.</p>\n<p>The idea is to overload the methods taking others structures in a Builder with a Consumer of Builder instead. This enables to use a lambda instead\nof nesting another Builder, resulting in more concise and readable code.</p>\n<p>This rule reports an issue when the Consumer Builder methods could be used instead of the classical ones.</p>\n<h3>Noncompliant code example</h3>\n<pre>\nSendEmailRequest.builder()\n  .destination(Destination.builder()\n    .toAddresses(\"to-email@domain.com\")\n    .bccAddresses(\"bcc-email@domain.com\")\n    .build())\n.build();\n</pre>\n<h3>Compliant solution</h3>\n<pre>\nSendEmailRequest.builder()\n  .destination(d -&gt; d.toAddresses(\"to-email@domain.com\").bccAddresses(\"bcc-email@domain.com\"))\n  .build();\n</pre>",
    "howToFix": "",
    "moreInfo": "<ul>\n  <li> <a href=\"https://aws.amazon.com/fr/blogs/developer/consumer-builders-in-the-aws-sdk-for-java-v2/\">Consumer Builders in the AWS SDK for Java\n  v2</a> </li>\n</ul>",
    "status": "READY",
    "name_ko": "Consumer Builder를 사용해야 합니다",
    "why_ko": "<p>AWS SDK와 같은 일부 API는 다양한 데이터 구조를 생성하기 위해 빌더 패턴에 크게 의존합니다. 모든 이점에도 불구하고 이 패턴은 특히 중첩된 구조를 다룰 때 매우 장황해질 수 있습니다. 더 간결한 코드를 위해 \"Consumer Builder\"(\"Consumer Interface\"라고도 함)가 종종 도입됩니다.</p>\n<p>아이디어는 Builder에서 다른 구조를 받는 메서드를 Builder의 Consumer로 오버로드하는 것입니다. 이렇게 하면 다른 Builder를 중첩하는 대신 람다를 사용할 수 있어 더 간결하고 읽기 쉬운 코드가 됩니다.</p>\n<p>이 규칙은 고전적인 메서드 대신 Consumer Builder 메서드를 사용할 수 있을 때 문제를 보고합니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\nSendEmailRequest.builder()\n  .destination(Destination.builder()\n    .toAddresses(\"to-email@domain.com\")\n    .bccAddresses(\"bcc-email@domain.com\")\n    .build())\n.build();\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre>\nSendEmailRequest.builder()\n  .destination(d -&gt; d.toAddresses(\"to-email@domain.com\").bccAddresses(\"bcc-email@domain.com\"))\n  .build();\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": "<ul>\n  <li> <a href=\"https://aws.amazon.com/fr/blogs/developer/consumer-builders-in-the-aws-sdk-for-java-v2/\">AWS SDK for Java v2의 Consumer Builder</a> </li>\n</ul>"
  },
  {
    "id": "S138",
    "key": "java:S138",
    "name": "Methods should not have too many lines",
    "type": "code-smell",
    "severity": "major",
    "tags": [
      "brain-overload"
    ],
    "why": "<p>A method that grows too large tends to aggregate too many responsibilities. Such method inevitably become harder to understand and therefore harder\nto maintain.</p>\n<p>Above a specific threshold, it is strongly advised to refactor into smaller methods which focus on well-defined tasks. Those smaller methods will\nnot only be easier to understand, but also probably easier to test.</p>",
    "howToFix": "",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "메서드에 너무 많은 라인이 있으면 안 됩니다",
    "why_ko": "<p>너무 커지는 메서드는 너무 많은 책임을 집계하는 경향이 있습니다. 이러한 메서드는 필연적으로 이해하기 어려워지고 따라서 유지 관리하기도 어려워집니다.</p>\n<p>특정 임계값을 초과하면 잘 정의된 작업에 집중하는 더 작은 메서드로 리팩터링하는 것이 강력히 권장됩니다. 이러한 더 작은 메서드는 이해하기 쉬울 뿐만 아니라 테스트하기도 더 쉬울 것입니다.</p>",
    "howToFix_ko": "",
    "moreInfo_ko": ""
  },
  {
    "id": "S3553",
    "key": "java:S3553",
    "name": "\"Optional\" should not be used for parameters",
    "type": "code-smell",
    "severity": "major",
    "tags": [
      "clumsy"
    ],
    "why": "<p>The Java language authors have been quite frank that <code>Optional</code> was intended for use only as a return type, as a way to convey that a\nmethod may or may not return a value.</p>\n<p>And for that, it's valuable but using <code>Optional</code> on the input side increases the work you have to do in the method without really\nincreasing the value. With an <code>Optional</code> parameter, you go from having 2 possible inputs: null and not-null, to three: null,\nnon-null-without-value, and non-null-with-value. Add to that the fact that overloading has long been available to convey that some parameters are\noptional, and there's really no reason to have <code>Optional</code> parameters.</p>\n<p>The rule also checks for Guava's <code>Optional</code>, as it was the inspiration for the JDK <code>Optional</code>. Although it is different in\nsome aspects (serialization, being recommended for use as collection elements), using it as a parameter type causes exactly the same problems as for\nJDK <code>Optional</code>.</p>\n<h3>Noncompliant code example</h3>\n<pre>\npublic String sayHello(Optional&lt;String&gt; name) {  // Noncompliant\n  if (name == null || !name.isPresent()) {\n    return \"Hello World\";\n  } else {\n    return \"Hello \" + name;\n  }\n}\n</pre>\n<h3>Compliant solution</h3>\n<pre>\npublic String sayHello(String name) {\n  if (name == null) {\n    return \"Hello World\";\n  } else {\n    return \"Hello \" + name;\n  }\n}\n</pre>\n<h3>Exceptions</h3>\n<p>No issues will be raised if a method is overriding, as the developer has no control over the signature at this point.</p>\n<pre>\n@Override\npublic String sayHello(Optional&lt;String&gt; name) {\n  if (name == null || !name.isPresent()) {\n    return \"Hello World\";\n  } else {\n    return \"Hello \" + name;\n  }\n}\n</pre>",
    "howToFix": "",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "\"Optional\"은 매개변수로 사용하면 안 됩니다",
    "why_ko": "<p>Java 언어 개발자들은 <code>Optional</code>이 메서드가 값을 반환할 수도 있고 반환하지 않을 수도 있다는 것을 전달하는 방법으로 반환 타입으로만 사용하도록 의도되었다고 상당히 솔직하게 밝혔습니다.</p>\n<p>그 용도로는 가치 있지만 입력 측에서 <code>Optional</code>을 사용하면 실제로 가치를 높이지 않으면서 메서드에서 해야 할 작업이 늘어납니다. <code>Optional</code> 매개변수를 사용하면 가능한 입력이 null과 non-null의 2개에서 null, 값이 없는 non-null, 값이 있는 non-null의 3개로 늘어납니다. 일부 매개변수가 선택적이라는 것을 전달하기 위해 오버로딩이 오랫동안 사용 가능했다는 사실을 더하면 <code>Optional</code> 매개변수를 사용할 이유가 없습니다.</p>\n<p>이 규칙은 JDK <code>Optional</code>의 영감이 된 Guava의 <code>Optional</code>도 확인합니다. 일부 측면(직렬화, 컬렉션 요소로 사용 권장)에서 다르지만 매개변수 타입으로 사용하면 JDK <code>Optional</code>과 정확히 동일한 문제가 발생합니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\npublic String sayHello(Optional&lt;String&gt; name) {  // 규칙 위반\n  if (name == null || !name.isPresent()) {\n    return \"Hello World\";\n  } else {\n    return \"Hello \" + name;\n  }\n}\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre>\npublic String sayHello(String name) {\n  if (name == null) {\n    return \"Hello World\";\n  } else {\n    return \"Hello \" + name;\n  }\n}\n</pre>\n<h3>예외</h3>\n<p>메서드가 오버라이딩하는 경우 개발자가 이 시점에서 시그니처를 제어할 수 없으므로 문제가 제기되지 않습니다.</p>\n<pre>\n@Override\npublic String sayHello(Optional&lt;String&gt; name) {\n  if (name == null || !name.isPresent()) {\n    return \"Hello World\";\n  } else {\n    return \"Hello \" + name;\n  }\n}\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": ""
  },
  {
    "id": "S6301",
    "key": "java:S6301",
    "name": "Mobile database encryption keys should not be disclosed",
    "type": "vulnerability",
    "severity": "major",
    "tags": [
      "cwe",
      "android"
    ],
    "why": "<p>Mobile applications often need to store data (which might be sensitive) locally. For Android, there exist several libraries that simplify this\nprocess by offering a feature-rich database system. <a href=\"https://www.zetetic.net/sqlcipher/\">SQLCipher</a> and <a\nhref=\"https://realm.io/\">Realm</a> are examples of such libraries. These libraries often add support for database encryption, to protect the contents\nfrom being read by other apps or by attackers.</p>\n<p>When using encryption for such a database, it is important that the encryption key stays secret. If this key is hardcoded in the application, then\nit should be considered compromised. The key will be known by anyone with access to the application's binary code or source code. This means that the\nsensitive encrypted data can be decrypted by anyone having access to the binary of the mobile application.</p>\n<p>Furthermore, if the key is hardcoded, it is the same for every user. A compromise of this encryption key implicates every user of the app.</p>\n<p>The encryption key is meant to stay secret and should not be hard-coded in the application as it would mean that:</p>\n<h3>What is the potential impact?</h3>\n<p>If an attacker is able to find the encryption key for the mobile database, this can potentially have severe consequences.</p>\n<h4>Theft of sensitive data</h4>\n<p>If a mobile database is encrypted, it is likely to contain data that is sensitive for the user or the app publisher. For example, it can contain\npersonally identifiable information (PII), financial data, login credentials, or other sensitive user data.</p>\n<p>By not protecting the encryption key properly, it becomes very easy for an attacker to recover it and then decrypt the mobile database. At that\npoint, the theft of sensitive data might lead to identity theft, financial fraud, and other forms of malicious activities.</p>",
    "howToFix": "<p>In the example below, a local database is opened using a hardcoded key. To fix this, the key is moved to a secure location instead and retrieved\nusing a <code>getKey()</code> method.</p>\n<h4>Noncompliant code example</h4>\n<pre data-diff-id=\"101\" data-diff-type=\"noncompliant\">\nString key = \"gb09ym9ydoolp3w886d0tciczj6ve9kszqd65u7d126040gwy86xqimjpuuc788g\";\nSQLiteDatabase db = SQLiteDatabase.openOrCreateDatabase(\"test.db\", key, null); // Noncompliant\n</pre>\n<h4>Compliant solution</h4>\n<pre data-diff-id=\"101\" data-diff-type=\"compliant\">\nSQLiteDatabase db = SQLiteDatabase.openOrCreateDatabase(\"test.db\", getKey(), null);\n</pre>\n<h3>How does this work?</h3>\n<h4>Using Android's builtin key storage options</h4>\n<p>The <a href=\"https://developer.android.com/privacy-and-security/keystore\">Android Keystore</a> system allows apps to store encryption keys in a\ncontainer that is protected on a system level. Additionally, it can restrict when and how the keys are used. For example, it allows the app to require\nuser authentication (for example using a fingerprint) before the key is made available. This is the recommended way to store cryptographic keys on\nAndroid.</p>\n<h4>Dynamically retrieving encryption keys remotely</h4>\n<p>As user devices are less trusted than controlled environments such as the application backend, the latter should be preferred for the storage of\nencryption keys. This requires that a user's device has an internet connection, which may not be suitable for every use case.</p>\n<h3>Going the extra mile</h3>\n<h4>Avoid storing sensitive data on user devices</h4>\n<p>In general, it is always preferable to store as little sensitive data on user devices as possible.</p>\n<p>Of course, some sensitive data always has to be stored on client devices, such as the data required for authentication. In this case, consider\nwhether the application logic can also function with a hash (or otherwise non-reversible form) of that data. For example, if an email address is\nrequired for authentication, it might be possible to use and store a hashed version of this address instead.</p>",
    "moreInfo": "<h3>Documentation</h3>\n<ul>\n  <li> Android Documentation - <a href=\"https://developer.android.com/privacy-and-security/keystore\">Android Keystore system</a> </li>\n  <li> Android Documentation - <a href=\"https://developer.android.com/privacy-and-security/security-tips#UserData\">Security tips - User data</a> </li>\n  <li> OWASP Mobile Application Security Testing Guide - <a href=\"https://mas.owasp.org/MASTG/0x05d-Testing-Data-Storage/\">Data Storage on Android</a>\n  </li>\n</ul>\n<h3>Standards</h3>\n<ul>\n  <li> OWASP - <a href=\"https://owasp.org/www-project-top-ten/2017/A3_2017-Sensitive_Data_Exposure\">Top 10 2017 Category A3 - Sensitive Data\n  Exposure</a> </li>\n  <li> OWASP - <a href=\"https://owasp.org/www-project-top-ten/2017/A6_2017-Security_Misconfiguration\">Top 10 2017 Category A6 - Security\n  Misconfiguration</a> </li>\n  <li> OWASP - <a href=\"https://owasp.org/Top10/A02_2021-Cryptographic_Failures/\">Top 10 2021 Category A2 - Cryptographic Failures</a> </li>\n  <li> OWASP - <a href=\"https://owasp.org/Top10/A04_2021-Insecure_Design/\">Top 10 2021 Category A4 - Insecure Design</a> </li>\n  <li> OWASP - <a href=\"https://mas.owasp.org/checklists/MASVS-STORAGE/\">Mobile AppSec Verification Standard - Data Storage and Privacy\n  Requirements</a> </li>\n  <li> OWASP - <a href=\"https://owasp.org/www-project-mobile-top-10/2016-risks/m2-insecure-data-storage\">Mobile Top 10 2016 Category M2 - Insecure\n  Data Storage</a> </li>\n  <li> OWASP - <a href=\"https://owasp.org/www-project-mobile-top-10/2023-risks/m1-improper-credential-usage\">Mobile Top 10 2024 Category M1 - Improper\n  Credential Usage</a> </li>\n  <li> OWASP - <a href=\"https://owasp.org/www-project-mobile-top-10/2023-risks/m9-insecure-data-storage\">Mobile Top 10 2024 Category M9 - Insecure\n  Data Storage</a> </li>\n  <li> OWASP - <a href=\"https://owasp.org/www-project-mobile-top-10/2023-risks/m10-insufficient-cryptography\">Mobile Top 10 2024 Category M10 -\n  Insufficient Cryptography</a> </li>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/311\">CWE-311 - Missing Encryption of Sensitive Data</a> </li>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/321\">CWE-321 - Use of Hard-coded Cryptographic Key</a> </li>\n</ul>",
    "status": "READY",
    "name_ko": "모바일 데이터베이스 암호화 키는 노출되면 안 됩니다",
    "why_ko": "<p>모바일 애플리케이션은 종종 (민감할 수 있는) 데이터를 로컬에 저장해야 합니다. Android의 경우 기능이 풍부한 데이터베이스 시스템을 제공하여 이 프로세스를 단순화하는 여러 라이브러리가 있습니다. <a href=\"https://www.zetetic.net/sqlcipher/\">SQLCipher</a>와 <a href=\"https://realm.io/\">Realm</a>이 이러한 라이브러리의 예입니다. 이러한 라이브러리는 다른 앱이나 공격자가 콘텐츠를 읽지 못하도록 보호하기 위해 데이터베이스 암호화 지원을 추가하는 경우가 많습니다.</p>\n<p>이러한 데이터베이스에 암호화를 사용할 때 암호화 키를 비밀로 유지하는 것이 중요합니다. 이 키가 애플리케이션에 하드코딩되어 있다면 손상된 것으로 간주해야 합니다. 애플리케이션의 바이너리 코드나 소스 코드에 접근할 수 있는 모든 사람이 키를 알게 됩니다. 이는 모바일 애플리케이션의 바이너리에 접근할 수 있는 모든 사람이 민감한 암호화된 데이터를 복호화할 수 있다는 것을 의미합니다.</p>\n<p>또한 키가 하드코딩되어 있으면 모든 사용자에게 동일합니다. 이 암호화 키가 손상되면 앱의 모든 사용자에게 영향을 미칩니다.</p>\n<p>암호화 키는 비밀로 유지되어야 하며 애플리케이션에 하드코딩되면 안 됩니다:</p>\n<h3>잠재적 영향은 무엇인가요?</h3>\n<p>공격자가 모바일 데이터베이스의 암호화 키를 찾을 수 있다면 심각한 결과를 초래할 수 있습니다.</p>\n<h4>민감한 데이터 도난</h4>\n<p>모바일 데이터베이스가 암호화되어 있다면 사용자나 앱 게시자에게 민감한 데이터가 포함되어 있을 가능성이 높습니다. 예를 들어 개인 식별 정보(PII), 금융 데이터, 로그인 자격 증명 또는 기타 민감한 사용자 데이터가 포함될 수 있습니다.</p>\n<p>암호화 키를 제대로 보호하지 않으면 공격자가 쉽게 복구한 다음 모바일 데이터베이스를 복호화할 수 있습니다. 그 시점에서 민감한 데이터 도난은 신원 도용, 금융 사기 및 기타 형태의 악의적인 활동으로 이어질 수 있습니다.</p>",
    "howToFix_ko": "<p>아래 예제에서는 하드코딩된 키를 사용하여 로컬 데이터베이스를 엽니다. 이를 수정하려면 키를 안전한 위치로 이동하고 <code>getKey()</code> 메서드를 사용하여 검색합니다.</p>\n<h4>규칙을 준수하지 않는 코드 예시</h4>\n<pre data-diff-id=\"101\" data-diff-type=\"noncompliant\">\nString key = \"gb09ym9ydoolp3w886d0tciczj6ve9kszqd65u7d126040gwy86xqimjpuuc788g\";\nSQLiteDatabase db = SQLiteDatabase.openOrCreateDatabase(\"test.db\", key, null); // 규칙 위반\n</pre>\n<h4>규칙을 준수하는 해결책</h4>\n<pre data-diff-id=\"101\" data-diff-type=\"compliant\">\nSQLiteDatabase db = SQLiteDatabase.openOrCreateDatabase(\"test.db\", getKey(), null);\n</pre>\n<h3>어떻게 작동하나요?</h3>\n<h4>Android의 내장 키 저장소 옵션 사용</h4>\n<p><a href=\"https://developer.android.com/privacy-and-security/keystore\">Android Keystore</a> 시스템을 사용하면 앱이 시스템 수준에서 보호되는 컨테이너에 암호화 키를 저장할 수 있습니다. 또한 키가 사용되는 시기와 방법을 제한할 수 있습니다. 예를 들어 키를 사용할 수 있기 전에 앱에서 사용자 인증(예: 지문 사용)을 요구할 수 있습니다. 이것이 Android에서 암호화 키를 저장하는 권장 방법입니다.</p>\n<h4>원격에서 동적으로 암호화 키 검색</h4>\n<p>사용자 기기는 애플리케이션 백엔드와 같은 통제된 환경보다 신뢰도가 낮으므로 암호화 키 저장에는 후자가 선호됩니다. 이를 위해서는 사용자의 기기에 인터넷 연결이 필요하며, 이는 모든 사용 사례에 적합하지 않을 수 있습니다.</p>\n<h3>더 나아가기</h3>\n<h4>사용자 기기에 민감한 데이터 저장 피하기</h4>\n<p>일반적으로 사용자 기기에 가능한 한 적은 민감한 데이터를 저장하는 것이 항상 바람직합니다.</p>\n<p>물론 인증에 필요한 데이터와 같은 일부 민감한 데이터는 항상 클라이언트 기기에 저장해야 합니다. 이 경우 애플리케이션 로직이 해당 데이터의 해시(또는 다른 비가역적 형태)로도 작동할 수 있는지 고려하세요. 예를 들어 인증에 이메일 주소가 필요한 경우 이 주소의 해시된 버전을 대신 사용하고 저장할 수 있습니다.</p>",
    "moreInfo_ko": "<h3>문서</h3>\n<ul>\n  <li> Android Documentation - <a href=\"https://developer.android.com/privacy-and-security/keystore\">Android Keystore 시스템</a> </li>\n  <li> Android Documentation - <a href=\"https://developer.android.com/privacy-and-security/security-tips#UserData\">보안 팁 - 사용자 데이터</a> </li>\n  <li> OWASP Mobile Application Security Testing Guide - <a href=\"https://mas.owasp.org/MASTG/0x05d-Testing-Data-Storage/\">Android의 데이터 저장소</a> </li>\n</ul>\n<h3>표준</h3>\n<ul>\n  <li> OWASP - <a href=\"https://owasp.org/www-project-top-ten/2017/A3_2017-Sensitive_Data_Exposure\">Top 10 2017 Category A3 - 민감한 데이터 노출</a> </li>\n  <li> OWASP - <a href=\"https://owasp.org/www-project-top-ten/2017/A6_2017-Security_Misconfiguration\">Top 10 2017 Category A6 - 보안 구성 오류</a> </li>\n  <li> OWASP - <a href=\"https://owasp.org/Top10/A02_2021-Cryptographic_Failures/\">Top 10 2021 Category A2 - 암호화 실패</a> </li>\n  <li> OWASP - <a href=\"https://owasp.org/Top10/A04_2021-Insecure_Design/\">Top 10 2021 Category A4 - 안전하지 않은 설계</a> </li>\n  <li> OWASP - <a href=\"https://mas.owasp.org/checklists/MASVS-STORAGE/\">Mobile AppSec Verification Standard - 데이터 저장소 및 개인정보 보호 요구사항</a> </li>\n  <li> OWASP - <a href=\"https://owasp.org/www-project-mobile-top-10/2016-risks/m2-insecure-data-storage\">Mobile Top 10 2016 Category M2 - 안전하지 않은 데이터 저장소</a> </li>\n  <li> OWASP - <a href=\"https://owasp.org/www-project-mobile-top-10/2023-risks/m1-improper-credential-usage\">Mobile Top 10 2024 Category M1 - 부적절한 자격 증명 사용</a> </li>\n  <li> OWASP - <a href=\"https://owasp.org/www-project-mobile-top-10/2023-risks/m9-insecure-data-storage\">Mobile Top 10 2024 Category M9 - 안전하지 않은 데이터 저장소</a> </li>\n  <li> OWASP - <a href=\"https://owasp.org/www-project-mobile-top-10/2023-risks/m10-insufficient-cryptography\">Mobile Top 10 2024 Category M10 - 불충분한 암호화</a> </li>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/311\">CWE-311 - 민감한 데이터의 암호화 누락</a> </li>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/321\">CWE-321 - 하드코딩된 암호화 키 사용</a> </li>\n</ul>"
  },
  {
    "id": "S6881",
    "key": "java:S6881",
    "name": "Virtual threads should be used for tasks that include heavy blocking operations",
    "type": "bug",
    "severity": "critical",
    "tags": [
      "multi-threading",
      "java21"
    ],
    "why": "<p>Whenever a virtual thread is started, the JVM will mount it on an OS thread. As soon as the virtual thread runs into a blocking operation like an\nHTTP request or a filesystem read/write operation, the JVM will detect this and unmount the virtual thread. This allows another virtual thread to take\nover the OS thread and continue its execution.</p>\n<p>This is why virtual threads should be preferred to platform threads for tasks that involve blocking operations. By default, a Java thread is a\nplatform thread. To use a virtual thread it must be started either with <code>Thread.startVirtualThread(Runnable)</code> or\n<code>Thread.ofVirtual().start(Runnable)</code>.</p>\n<p>This rule raises an issue when a platform thread is created with a task that includes heavy blocking operations.</p>",
    "howToFix": "<p>Replace platform thread instances or platform thread pools with virtual threads, if their task involves blocking operations.</p>\n\n<h4>Noncompliant code example</h4>\n<p>The following example creates a platform thread to handle a blocking operation, here denoted by <code>Thread.sleep(1000)</code>. The overhead for\ninstantiating a platform thread is higher than for a virtual thread. Further, instantiating too many platform threads can lead to problems if the\nnumber of instantiated threads exceeds the maximum number of platform threads allowed by the OS.</p>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\nnew Thread(() -&gt; {\n    try {\n        Thread.sleep(1000); // Noncompliant blocking operation in platform thread\n    } catch (InterruptedException e) {\n        throw new RuntimeException(e);\n    }\n});\n</pre>\n<p>In the context of thread pools, using platform threads for heavy blocking operations can lead to the thread pool running out of available threads.\nEven though the threads spend most of their time waiting for e.g. I/O operations to complete and subsequently the CPU usage is low, the application\ncannot continue processing efficiently, due to the lack of available threads.</p>\n<h4>Compliant solution</h4>\n<p>Using virtual threads allows the developer to abstract from any pooling logic as they are much lighter than platform threads, and the number of\nvirtual threads that can be instantiated is only limited by the available memory. In this example, the execution of 10000 requests would take just\nover ~1 second without any risk of exceeding the allowed number of platform threads.</p>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\nThread.ofVirtual().start(() -&gt; {\n    try {\n        Thread.sleep(1000); // Compliant\n    } catch (InterruptedException e) {\n        throw new RuntimeException(e);\n    }\n});\n</pre>",
    "moreInfo": "<h3>Documentation</h3>\n<ul>\n  <li> Java Documentation - <a href=\"https://docs.oracle.com/en/java/javase/21/core/virtual-threads.html\">Virtual Threads</a> </li>\n  <li> Java Documentation - <a\n  href=\"https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/Thread.html#startVirtualThread(java.lang.Runnable)\">Thread.startVirtualThread(Runnable)</a> </li>\n</ul>",
    "status": "READY",
    "name_ko": "무거운 블로킹 작업이 포함된 태스크에는 Virtual Thread를 사용해야 합니다",
    "why_ko": "<p>가상 스레드가 시작되면 JVM은 이를 OS 스레드에 마운트합니다. 가상 스레드가 HTTP 요청이나 파일 시스템 읽기/쓰기 작업과 같은 블로킹 작업을 만나면 JVM은 이를 감지하고 가상 스레드를 언마운트합니다. 이를 통해 다른 가상 스레드가 OS 스레드를 이어받아 실행을 계속할 수 있습니다.</p>\n<p>이것이 블로킹 작업이 포함된 태스크에 플랫폼 스레드보다 가상 스레드를 선호해야 하는 이유입니다. 기본적으로 Java 스레드는 플랫폼 스레드입니다. 가상 스레드를 사용하려면 <code>Thread.startVirtualThread(Runnable)</code> 또는 <code>Thread.ofVirtual().start(Runnable)</code>로 시작해야 합니다.</p>\n<p>이 규칙은 무거운 블로킹 작업이 포함된 태스크로 플랫폼 스레드가 생성될 때 문제를 발생시킵니다.</p>",
    "howToFix_ko": "<p>태스크가 블로킹 작업을 포함하는 경우 플랫폼 스레드 인스턴스나 플랫폼 스레드 풀을 가상 스레드로 교체하세요.</p>\n\n<h4>규칙을 준수하지 않는 코드 예시</h4>\n<p>다음 예제는 블로킹 작업을 처리하기 위해 플랫폼 스레드를 생성합니다. 여기서 <code>Thread.sleep(1000)</code>으로 표시됩니다. 플랫폼 스레드를 인스턴스화하는 오버헤드는 가상 스레드보다 높습니다. 또한 너무 많은 플랫폼 스레드를 인스턴스화하면 인스턴스화된 스레드 수가 OS에서 허용하는 최대 플랫폼 스레드 수를 초과하는 문제가 발생할 수 있습니다.</p>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\nnew Thread(() -&gt; {\n    try {\n        Thread.sleep(1000); // 규칙 위반 플랫폼 스레드에서 블로킹 작업\n    } catch (InterruptedException e) {\n        throw new RuntimeException(e);\n    }\n});\n</pre>\n<p>스레드 풀 컨텍스트에서 무거운 블로킹 작업에 플랫폼 스레드를 사용하면 스레드 풀의 사용 가능한 스레드가 부족해질 수 있습니다. 스레드가 대부분의 시간을 I/O 작업 완료를 기다리는 데 보내고 그로 인해 CPU 사용량이 낮더라도 사용 가능한 스레드 부족으로 인해 애플리케이션이 효율적으로 처리를 계속할 수 없습니다.</p>\n<h4>규칙을 준수하는 해결책</h4>\n<p>가상 스레드를 사용하면 개발자는 풀링 로직에서 추상화할 수 있습니다. 가상 스레드는 플랫폼 스레드보다 훨씬 가볍고 인스턴스화할 수 있는 가상 스레드 수는 사용 가능한 메모리에 의해서만 제한됩니다. 이 예제에서 10000개의 요청 실행은 허용된 플랫폼 스레드 수를 초과할 위험 없이 약 1초 조금 넘게 걸립니다.</p>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\nThread.ofVirtual().start(() -&gt; {\n    try {\n        Thread.sleep(1000); // 규칙 준수\n    } catch (InterruptedException e) {\n        throw new RuntimeException(e);\n    }\n});\n</pre>",
    "moreInfo_ko": "<h3>문서</h3>\n<ul>\n  <li> Java 문서 - <a href=\"https://docs.oracle.com/en/java/javase/21/core/virtual-threads.html\">Virtual Threads</a> </li>\n  <li> Java 문서 - <a href=\"https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/Thread.html#startVirtualThread(java.lang.Runnable)\">Thread.startVirtualThread(Runnable)</a> </li>\n</ul>"
  },
  {
    "id": "S1217",
    "key": "java:S1217",
    "name": "\"Thread.run()\" should not be called directly",
    "type": "bug",
    "severity": "major",
    "tags": [
      "cwe",
      "multi-threading",
      "cert"
    ],
    "why": "<p>The likely intention of a user calling <code>Thread.run()</code> is to start the execution of code within a new thread. This, however, is not what\nhappens when this method is called.</p>\n<p>The purpose of <code>Thread.run()</code> is to provide a method that users can overwrite to specify the code to be executed. The actual thread is\nthen started by calling <code>Thread.start()</code>. When <code>Thread.run()</code> is called directly, it will be executed as a regular method within\nthe current thread.</p>",
    "howToFix": "<p>If you intend to execute the contents of the <code>Thread.run()</code> method within a new thread, call <code>Thread.start()</code> instead.</p>\n<p>If your intention is only to have a container for a method but execute this method within the current thread, do not use <code>Thread</code> but\n<code>Runnable</code> or another functional interface.</p>\n\n<h4>Noncompliant code example</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\nThread myThread = new Thread(runnable);\nmyThread.run(); // Noncompliant, does not start a thread\n</pre>\n<h4>Compliant solution</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\nThread myThread = new Thread(runnable);\nmyThread.start(); // Compliant\n</pre>\n<h4>Noncompliant code example</h4>\n<pre data-diff-id=\"2\" data-diff-type=\"noncompliant\">\nclass ComputePrimesThread extends Thread {\n    @Override\n    public void run() {\n        // ...\n    }\n}\nnew ComputePrimesThread().run(); // Noncompliant, does not start a thread\n</pre>\n<h4>Compliant solution</h4>\n<pre data-diff-id=\"2\" data-diff-type=\"compliant\">\nclass ComputePrimesThread extends Thread {\n    @Override\n    public void run() {\n        // ...\n    }\n}\nnew ComputePrimesThread().start(); // Compliant\n</pre>\n<h4>Noncompliant code example</h4>\n<pre data-diff-id=\"3\" data-diff-type=\"noncompliant\">\nclass Button {\n\n    private Thread onClick;\n\n    Button(Thread onClick) {\n        this.onClick = onClick;\n    }\n\n    private void clicked() {\n        if (onClick != null) onClick.run(); // Noncompliant, use functional interface\n    }\n}\n\nnew Button(new Thread() {\n    @Override public void run() {\n        System.out.println(\"clicked!\");\n    }\n});\n</pre>\n<h4>Compliant solution</h4>\n<pre data-diff-id=\"3\" data-diff-type=\"compliant\">\nclass Button {\n\n    private Runnable onClick;\n\n    Button(Runnable onClick) {\n        this.onClick = onClick;\n    }\n\n    private void clicked() {\n        if (onClick != null) onClick.run(); // compliant\n    }\n}\n\nnew Button(() -&gt; System.out.println(\"clicked!\"));\n</pre>",
    "moreInfo": "<h3>Documentation</h3>\n<ul>\n  <li> <a href=\"https://docs.oracle.com/javase/8/docs/api/java/lang/Thread.html#start--\">Java™ Platform, Standard Edition 8 API Specification -\n  Thread.start()</a> </li>\n</ul>\n<h3>Articles &amp; blog posts</h3>\n<ul>\n  <li> <a href=\"https://www.tpointtech.com/what-if-we-call-java-run-method-directly\">TPointTech - What if we call Java run() method directly instead\n  start() method?</a> </li>\n</ul>",
    "status": "READY",
    "name_ko": "\"Thread.run()\"을 직접 호출하면 안 됩니다",
    "why_ko": "<p><code>Thread.run()</code>을 호출하는 사용자의 의도는 새 스레드 내에서 코드 실행을 시작하는 것일 가능성이 높습니다. 그러나 이 메서드를 호출할 때 실제로 일어나는 일은 그것이 아닙니다.</p>\n<p><code>Thread.run()</code>의 목적은 사용자가 실행할 코드를 지정하기 위해 오버라이트할 수 있는 메서드를 제공하는 것입니다. 실제 스레드는 <code>Thread.start()</code>를 호출하여 시작됩니다. <code>Thread.run()</code>이 직접 호출되면 현재 스레드 내에서 일반 메서드로 실행됩니다.</p>",
    "howToFix_ko": "<p><code>Thread.run()</code> 메서드의 내용을 새 스레드 내에서 실행하려면 대신 <code>Thread.start()</code>를 호출하세요.</p>\n<p>메서드의 컨테이너만 갖고 현재 스레드 내에서 이 메서드를 실행하려는 의도라면 <code>Thread</code>가 아닌 <code>Runnable</code> 또는 다른 함수형 인터페이스를 사용하세요.</p>\n\n<h4>규칙을 준수하지 않는 코드 예시</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\nThread myThread = new Thread(runnable);\nmyThread.run(); // 규칙 위반, 스레드를 시작하지 않음\n</pre>\n<h4>규칙을 준수하는 해결책</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\nThread myThread = new Thread(runnable);\nmyThread.start(); // 규칙 준수\n</pre>\n<h4>규칙을 준수하지 않는 코드 예시</h4>\n<pre data-diff-id=\"2\" data-diff-type=\"noncompliant\">\nclass ComputePrimesThread extends Thread {\n    @Override\n    public void run() {\n        // ...\n    }\n}\nnew ComputePrimesThread().run(); // 규칙 위반, 스레드를 시작하지 않음\n</pre>\n<h4>규칙을 준수하는 해결책</h4>\n<pre data-diff-id=\"2\" data-diff-type=\"compliant\">\nclass ComputePrimesThread extends Thread {\n    @Override\n    public void run() {\n        // ...\n    }\n}\nnew ComputePrimesThread().start(); // 규칙 준수\n</pre>\n<h4>규칙을 준수하지 않는 코드 예시</h4>\n<pre data-diff-id=\"3\" data-diff-type=\"noncompliant\">\nclass Button {\n\n    private Thread onClick;\n\n    Button(Thread onClick) {\n        this.onClick = onClick;\n    }\n\n    private void clicked() {\n        if (onClick != null) onClick.run(); // 규칙 위반, 함수형 인터페이스를 사용하세요\n    }\n}\n\nnew Button(new Thread() {\n    @Override public void run() {\n        System.out.println(\"clicked!\");\n    }\n});\n</pre>\n<h4>규칙을 준수하는 해결책</h4>\n<pre data-diff-id=\"3\" data-diff-type=\"compliant\">\nclass Button {\n\n    private Runnable onClick;\n\n    Button(Runnable onClick) {\n        this.onClick = onClick;\n    }\n\n    private void clicked() {\n        if (onClick != null) onClick.run(); // 규칙 준수\n    }\n}\n\nnew Button(() -&gt; System.out.println(\"clicked!\"));\n</pre>",
    "moreInfo_ko": "<h3>문서</h3>\n<ul>\n  <li> <a href=\"https://docs.oracle.com/javase/8/docs/api/java/lang/Thread.html#start--\">Java™ Platform, Standard Edition 8 API 명세 - Thread.start()</a> </li>\n</ul>\n<h3>관련 글 및 블로그 포스트</h3>\n<ul>\n  <li> <a href=\"https://www.tpointtech.com/what-if-we-call-java-run-method-directly\">TPointTech - start() 메서드 대신 Java run() 메서드를 직접 호출하면 어떻게 될까요?</a> </li>\n</ul>"
  },
  {
    "id": "S2159",
    "key": "java:S2159",
    "name": "Unnecessary equality checks should not be made",
    "type": "bug",
    "severity": "major",
    "tags": [
      "unused",
      "cert"
    ],
    "why": "<p>Comparisons of dissimilar types will always return false. The comparison and all its dependent code can simply be removed. This includes:</p>\n<ul>\n  <li> comparing an object with null </li>\n  <li> comparing an object with an unrelated primitive (E.G. a string with an int) </li>\n  <li> comparing unrelated classes </li>\n  <li> comparing an unrelated <code>class</code> and <code>interface</code> </li>\n  <li> comparing unrelated <code>interface</code> types </li>\n  <li> comparing an array to a non-array </li>\n  <li> comparing two arrays </li>\n</ul>\n<p>Specifically in the case of arrays, since arrays don't override <code>Object.equals()</code>, calling <code>equals</code> on two arrays is the same\nas comparing their addresses. This means that <code>array1.equals(array2)</code> is equivalent to <code>array1==array2</code>.</p>\n<p>However, some developers might expect <code>Array.equals(Object obj)</code> to do more than a simple memory address comparison, comparing for\ninstance the size and content of the two arrays. Instead, the <code>==</code> operator or <code>Arrays.equals(array1, array2)</code> should always be\nused with arrays.</p>\n<h3>Noncompliant code example</h3>\n<pre>\ninterface KitchenTool { ... };\ninterface Plant {...}\n\npublic class Spatula implements KitchenTool { ... }\npublic class Tree implements Plant { ...}\n//...\n\nSpatula spatula = new Spatula();\nKitchenTool tool = spatula;\nKitchenTool [] tools = {tool};\n\nTree tree = new Tree();\nPlant plant = tree;\nTree [] trees = {tree};\n\n\nif (spatula.equals(tree)) { // Noncompliant; unrelated classes\n  // ...\n}\nelse if (spatula.equals(plant)) { // Noncompliant; unrelated class and interface\n  // ...\n}\nelse if (tool.equals(plant)) { // Noncompliant; unrelated interfaces\n  // ...\n}\nelse if (tool.equals(tools)) { // Noncompliant; array &amp; non-array\n  // ...\n}\nelse if (trees.equals(tools)) { // Noncompliant; incompatible arrays\n  // ...\n}\nelse if (tree.equals(null)) { // Noncompliant\n  // ...\n}\n</pre>",
    "howToFix": "",
    "moreInfo": "<ul>\n  <li> <a href=\"https://wiki.sei.cmu.edu/confluence/x/5zdGBQ\">CERT, EXP02-J.</a> - Do not use the Object.equals() method to compare two arrays </li>\n</ul>",
    "status": "READY",
    "name_ko": "불필요한 동등성 검사를 수행하면 안 됩니다",
    "why_ko": "<p>서로 다른 타입의 비교는 항상 false를 반환합니다. 비교문과 모든 종속 코드는 간단히 제거할 수 있습니다. 여기에는 다음이 포함됩니다:</p>\n<ul>\n  <li> 객체와 null 비교 </li>\n  <li> 객체와 관련 없는 primitive 비교 (예: 문자열과 int) </li>\n  <li> 관련 없는 클래스 비교 </li>\n  <li> 관련 없는 <code>class</code>와 <code>interface</code> 비교 </li>\n  <li> 관련 없는 <code>interface</code> 타입 비교 </li>\n  <li> 배열과 비배열 비교 </li>\n  <li> 두 배열 비교 </li>\n</ul>\n<p>특히 배열의 경우 배열이 <code>Object.equals()</code>를 재정의하지 않으므로 두 배열에 대해 <code>equals</code>를 호출하는 것은 주소를 비교하는 것과 같습니다. 이는 <code>array1.equals(array2)</code>가 <code>array1==array2</code>와 동등함을 의미합니다.</p>\n<p>그러나 일부 개발자는 <code>Array.equals(Object obj)</code>가 단순한 메모리 주소 비교 이상을 수행하여 예를 들어 두 배열의 크기와 내용을 비교할 것으로 기대할 수 있습니다. 대신 배열에서는 항상 <code>==</code> 연산자 또는 <code>Arrays.equals(array1, array2)</code>를 사용해야 합니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\ninterface KitchenTool { ... };\ninterface Plant {...}\n\npublic class Spatula implements KitchenTool { ... }\npublic class Tree implements Plant { ...}\n//...\n\nSpatula spatula = new Spatula();\nKitchenTool tool = spatula;\nKitchenTool [] tools = {tool};\n\nTree tree = new Tree();\nPlant plant = tree;\nTree [] trees = {tree};\n\n\nif (spatula.equals(tree)) { // 규칙 위반; 관련 없는 클래스\n  // ...\n}\nelse if (spatula.equals(plant)) { // 규칙 위반; 관련 없는 클래스와 인터페이스\n  // ...\n}\nelse if (tool.equals(plant)) { // 규칙 위반; 관련 없는 인터페이스\n  // ...\n}\nelse if (tool.equals(tools)) { // 규칙 위반; 배열과 비배열\n  // ...\n}\nelse if (trees.equals(tools)) { // 규칙 위반; 호환되지 않는 배열\n  // ...\n}\nelse if (tree.equals(null)) { // 규칙 위반\n  // ...\n}\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": "<ul>\n  <li> <a href=\"https://wiki.sei.cmu.edu/confluence/x/5zdGBQ\">CERT, EXP02-J.</a> - 두 배열을 비교하는 데 Object.equals() 메서드를 사용하지 마세요 </li>\n</ul>"
  },
  {
    "id": "S1149",
    "key": "java:S1149",
    "name": "Synchronized classes \"Vector\", \"Hashtable\", \"Stack\" and \"StringBuffer\" should not be used",
    "type": "code-smell",
    "severity": "major",
    "tags": [
      "performance"
    ],
    "why": "<p>Early classes of the Java API, such as <code>Vector</code>, <code>Hashtable</code> and <code>StringBuffer</code>, were synchronized to make them\nthread-safe. However, synchronization has a significant negative impact on performance, even when using these collections from a single thread.</p>\n<p>It is often best to use their non-synchronized counterparts:</p>\n<ul>\n  <li> <code>ArrayList</code> or <code>LinkedList</code> instead of <code>Vector</code> </li>\n  <li> <code>Deque</code> instead of <code>Stack</code> </li>\n  <li> <code>HashMap</code> instead of <code>Hashtable</code> </li>\n  <li> <code>StringBuilder</code> instead of <code>StringBuffer</code> </li>\n</ul>\n<p>Even when used in synchronized contexts, you should think twice before using their synchronized counterparts, since their usage can be costly. If\nyou are confident the usage is legitimate, you can safely ignore this warning.</p>\n<h3>Noncompliant code example</h3>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\nVector&lt;Cat&gt; cats = new Vector&lt;&gt;();\n</pre>\n<h3>Compliant solution</h3>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\nArrayList&lt;Cat&gt; cats = new ArrayList&lt;&gt;();\n</pre>\n<h3>Exceptions</h3>\n<p>Usage of these synchronized classes is ignored in the signatures of overriding methods.</p>\n<pre>\n@Override\npublic Vector getCats() {...} // Compliant\n</pre>",
    "howToFix": "",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "동기화된 클래스 \"Vector\", \"Hashtable\", \"Stack\", \"StringBuffer\"는 사용하면 안 됩니다",
    "why_ko": "<p><code>Vector</code>, <code>Hashtable</code>, <code>StringBuffer</code>와 같은 Java API의 초기 클래스들은 스레드 안전성을 위해 동기화되었습니다. 그러나 동기화는 단일 스레드에서 이러한 컬렉션을 사용하더라도 성능에 상당한 부정적 영향을 미칩니다.</p>\n<p>비동기화된 대응 클래스를 사용하는 것이 종종 최선입니다:</p>\n<ul>\n  <li> <code>Vector</code> 대신 <code>ArrayList</code> 또는 <code>LinkedList</code> </li>\n  <li> <code>Stack</code> 대신 <code>Deque</code> </li>\n  <li> <code>Hashtable</code> 대신 <code>HashMap</code> </li>\n  <li> <code>StringBuffer</code> 대신 <code>StringBuilder</code> </li>\n</ul>\n<p>동기화된 컨텍스트에서 사용하더라도 동기화된 대응 클래스를 사용하기 전에 다시 생각해야 합니다. 사용 비용이 높을 수 있기 때문입니다. 사용이 적절하다고 확신한다면 이 경고를 무시해도 됩니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\nVector&lt;Cat&gt; cats = new Vector&lt;&gt;();\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\nArrayList&lt;Cat&gt; cats = new ArrayList&lt;&gt;();\n</pre>\n<h3>예외 사항</h3>\n<p>오버라이딩 메서드의 시그니처에서 이러한 동기화된 클래스의 사용은 무시됩니다.</p>\n<pre>\n@Override\npublic Vector getCats() {...} // 규칙 준수\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": ""
  },
  {
    "id": "S6376",
    "key": "java:S6376",
    "name": "XML parsers should not be vulnerable to Denial of Service attacks",
    "type": "vulnerability",
    "severity": "major",
    "tags": [
      "symbolic-execution"
    ],
    "why": "<p>XML files are complex data structures. When a malicious user is able to submit an XML file, it triggers complex processing that may overwhelm the\nparser. Most of the time, those complex processing are enabled by default, and XML parsers do not take preventive measures against Denial of Service\nattacks.</p>\n<h3>What is the potential impact?</h3>\n<p>When an attacker successfully exploits the vulnerability, it can lead to a Denial of Service (DoS) condition.</p>\n<h3>System Unavailability</h3>\n<p>Affected system becomes unresponsive or crashes, rendering it unavailable to legitimate users. This can have severe consequences, especially for\ncritical systems that rely on continuous availability, such as web servers, APIs, or network services.</p>\n<h3>Amplification Attacks</h3>\n<p>In some cases, XML parsers Denial of Service attacks can be used as a part of larger-scale amplification attacks. By leveraging the vulnerability,\nattackers can generate a disproportionately large response from the targeted system, amplifying the impact of their attack. This can result in\noverwhelming network bandwidth and causing widespread disruption.</p>",
    "howToFix": "<h4>Noncompliant code example</h4>\n<pre data-diff-id=\"2\" data-diff-type=\"noncompliant\">\nimport org.dom4j.io.SAXReader;\n\nSAXReader xmlReader = new SAXReader();\nxmlReader.setFeature(XMLConstants.FEATURE_SECURE_PROCESSING, false); // Noncompliant\n</pre>\n<h4>Compliant solution</h4>\n<pre data-diff-id=\"2\" data-diff-type=\"compliant\">\nimport org.dom4j.io.SAXReader;\n\nSAXReader xmlReader = new SAXReader();\nxmlReader.setFeature(XMLConstants.FEATURE_SECURE_PROCESSING, true);\n</pre>",
    "moreInfo": "<h3>Documentation</h3>\n<ul>\n  <li> Java Documentation - <a\n  href=\"https://docs.oracle.com/en/java/javase/21/docs/api/java.xml/javax/xml/parsers/DocumentBuilderFactory.html\">DocumentBuilderFactory Class</a>\n  </li>\n  <li> Java Documentation - <a\n  href=\"https://docs.oracle.com/en/java/javase/21/docs/api/java.xml/javax/xml/parsers/SAXParserFactory.html\">SAXParserFactory Class</a> </li>\n  <li> Java Documentation - <a\n  href=\"https://docs.oracle.com/en/java/javase/21/docs/api/java.xml/javax/xml/validation/SchemaFactory.html\">SchemaFactory Class</a> </li>\n  <li> Java Documentation - <a\n  href=\"https://docs.oracle.com/en/java/javase/21/docs/api/java.xml/javax/xml/transform/TransformerFactory.html\">TransformerFactory Class</a> </li>\n  <li> Java Documentation - <a href=\"https://docs.oracle.com/en/java/javase/21/security/java-api-xml-processing-jaxp-security-guide.html\">Java API for\n  XML Processing (JAXP) Security Guide</a> </li>\n  <li> Dom4j Documentation - <a href=\"https://dom4j.github.io/javadoc/2.1.4/org/dom4j/io/SAXReader.html\">SAXReader Class</a> </li>\n  <li> Jdom2 Documentation - <a href=\"https://javadoc.io/static/org.jdom/jdom2/2.0.6.1/org/jdom2/input/SAXBuilder.html\">SAXBuilder class</a> </li>\n  <li> OWASP - <a href=\"https://cheatsheetseries.owasp.org/cheatsheets/XML_External_Entity_Prevention_Cheat_Sheet.html#java\">XXE Prevention Cheat\n  Sheet</a> </li>\n</ul>\n<h3>Standards</h3>\n<ul>\n  <li> OWASP - <a href=\"https://owasp.org/Top10/A05_2021-Security_Misconfiguration/\">Top 10 2021 Category A5 - Security Misconfiguration</a> </li>\n  <li> OWASP - <a href=\"https://owasp.org/www-project-top-ten/2017/A4_2017-XML_External_Entities_(XXE)\">Top 10 2017 Category A4 - XML External\n  Entities (XXE)</a> </li>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/776\">CWE-776 - Improper Restriction of Recursive Entity References in DTDs ('XML Entity\n  Expansion')</a> </li>\n  <li> STIG Viewer - <a href=\"https://stigviewer.com/stig/application_security_and_development/2023-06-08/finding/V-222593\">Application Security and\n  Development: V-222593</a> - XML-based applications must mitigate DoS attacks by using XML filters, parser options, or gateways. </li>\n  <li> STIG Viewer - <a href=\"https://stigviewer.com/stig/application_security_and_development/2023-06-08/finding/V-222667\">Application Security and\n  Development: V-222667</a> - Protections against DoS attacks must be implemented. </li>\n  <li> STIG Viewer - <a href=\"https://stigviewer.com/stig/application_security_and_development/2023-06-08/finding/V-222608\">Application Security and\n  Development: V-222608</a> - The application must not be vulnerable to XML-oriented attacks. </li>\n</ul>",
    "status": "READY",
    "name_ko": "XML 파서는 서비스 거부 공격에 취약하면 안 됩니다",
    "why_ko": "<p>XML 파일은 복잡한 데이터 구조입니다. 악의적인 사용자가 XML 파일을 제출할 수 있을 때 파서를 압도할 수 있는 복잡한 처리가 트리거됩니다. 대부분의 경우 이러한 복잡한 처리는 기본적으로 활성화되어 있으며 XML 파서는 서비스 거부 공격에 대한 예방 조치를 취하지 않습니다.</p>\n<h3>잠재적 영향은 무엇인가요?</h3>\n<p>공격자가 취약점을 성공적으로 악용하면 서비스 거부(DoS) 상태가 발생할 수 있습니다.</p>\n<h3>시스템 불가용성</h3>\n<p>영향받는 시스템이 응답하지 않거나 충돌하여 합법적인 사용자에게 사용할 수 없게 됩니다. 이는 웹 서버, API 또는 네트워크 서비스와 같이 지속적인 가용성에 의존하는 중요한 시스템에 특히 심각한 결과를 초래할 수 있습니다.</p>\n<h3>증폭 공격</h3>\n<p>일부 경우 XML 파서 서비스 거부 공격은 대규모 증폭 공격의 일부로 사용될 수 있습니다. 취약점을 활용하여 공격자는 대상 시스템에서 불균형적으로 큰 응답을 생성하여 공격의 영향을 증폭시킬 수 있습니다. 이로 인해 네트워크 대역폭이 압도되고 광범위한 중단이 발생할 수 있습니다.</p>",
    "howToFix_ko": "<h4>규칙을 준수하지 않는 코드 예시</h4>\n<pre data-diff-id=\"2\" data-diff-type=\"noncompliant\">\nimport org.dom4j.io.SAXReader;\n\nSAXReader xmlReader = new SAXReader();\nxmlReader.setFeature(XMLConstants.FEATURE_SECURE_PROCESSING, false); // 규칙 위반\n</pre>\n<h4>규칙을 준수하는 해결책</h4>\n<pre data-diff-id=\"2\" data-diff-type=\"compliant\">\nimport org.dom4j.io.SAXReader;\n\nSAXReader xmlReader = new SAXReader();\nxmlReader.setFeature(XMLConstants.FEATURE_SECURE_PROCESSING, true);\n</pre>",
    "moreInfo_ko": "<h3>문서</h3>\n<ul>\n  <li> Java Documentation - <a href=\"https://docs.oracle.com/en/java/javase/21/docs/api/java.xml/javax/xml/parsers/DocumentBuilderFactory.html\">DocumentBuilderFactory 클래스</a> </li>\n  <li> Java Documentation - <a href=\"https://docs.oracle.com/en/java/javase/21/docs/api/java.xml/javax/xml/parsers/SAXParserFactory.html\">SAXParserFactory 클래스</a> </li>\n  <li> Java Documentation - <a href=\"https://docs.oracle.com/en/java/javase/21/docs/api/java.xml/javax/xml/validation/SchemaFactory.html\">SchemaFactory 클래스</a> </li>\n  <li> Java Documentation - <a href=\"https://docs.oracle.com/en/java/javase/21/docs/api/java.xml/javax/xml/transform/TransformerFactory.html\">TransformerFactory 클래스</a> </li>\n  <li> Java Documentation - <a href=\"https://docs.oracle.com/en/java/javase/21/security/java-api-xml-processing-jaxp-security-guide.html\">Java API for XML Processing (JAXP) 보안 가이드</a> </li>\n  <li> Dom4j Documentation - <a href=\"https://dom4j.github.io/javadoc/2.1.4/org/dom4j/io/SAXReader.html\">SAXReader 클래스</a> </li>\n  <li> Jdom2 Documentation - <a href=\"https://javadoc.io/static/org.jdom/jdom2/2.0.6.1/org/jdom2/input/SAXBuilder.html\">SAXBuilder 클래스</a> </li>\n  <li> OWASP - <a href=\"https://cheatsheetseries.owasp.org/cheatsheets/XML_External_Entity_Prevention_Cheat_Sheet.html#java\">XXE 예방 치트 시트</a> </li>\n</ul>\n<h3>표준</h3>\n<ul>\n  <li> OWASP - <a href=\"https://owasp.org/Top10/A05_2021-Security_Misconfiguration/\">Top 10 2021 Category A5 - 보안 구성 오류</a> </li>\n  <li> OWASP - <a href=\"https://owasp.org/www-project-top-ten/2017/A4_2017-XML_External_Entities_(XXE)\">Top 10 2017 Category A4 - XML 외부 엔티티(XXE)</a> </li>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/776\">CWE-776 - DTD의 재귀 엔티티 참조에 대한 부적절한 제한('XML 엔티티 확장')</a> </li>\n  <li> STIG Viewer - <a href=\"https://stigviewer.com/stig/application_security_and_development/2023-06-08/finding/V-222593\">Application Security and Development: V-222593</a> - XML 기반 애플리케이션은 XML 필터, 파서 옵션 또는 게이트웨이를 사용하여 DoS 공격을 완화해야 합니다. </li>\n  <li> STIG Viewer - <a href=\"https://stigviewer.com/stig/application_security_and_development/2023-06-08/finding/V-222667\">Application Security and Development: V-222667</a> - DoS 공격에 대한 보호가 구현되어야 합니다. </li>\n  <li> STIG Viewer - <a href=\"https://stigviewer.com/stig/application_security_and_development/2023-06-08/finding/V-222608\">Application Security and Development: V-222608</a> - 애플리케이션은 XML 기반 공격에 취약하면 안 됩니다. </li>\n</ul>"
  },
  {
    "id": "S2698",
    "key": "java:S2698",
    "name": "Test assertions should include messages",
    "type": "code-smell",
    "severity": "minor",
    "tags": [
      "junit",
      "tests"
    ],
    "why": "<p>Adding messages to JUnit, FEST and AssertJ assertions is an investment in your future productivity. Spend a few seconds writing them now, and\nyou'll save a lot of time on the other end when either the tests fail and you need to quickly diagnose the problem, or when you need to maintain the\ntests and the assertion messages work as a sort of documentation.</p>\n<h3>Noncompliant code example</h3>\n<pre>\nassertEquals(4, list.size());  // Noncompliant\n\ntry {\n  fail();  // Noncompliant\n} catch (Exception e) {\n  assertThat(list.get(0)).isEqualTo(\"pear\");  // Noncompliant\n}\n</pre>\n<h3>Compliant solution</h3>\n<pre>\nassertEquals(\"There should have been 4 Fruits in the list\", 4, list.size());\n\ntry {\n  fail(\"And exception is expected here\");\n} catch (Exception e) {\n  assertThat(list.get(0)).as(\"check first element\").overridingErrorMessage(\"The first element should be a pear, not a %s\", list.get(0)).isEqualTo(\"pear\");\n}\n</pre>",
    "howToFix": "",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "테스트 assertion에는 메시지를 포함해야 합니다",
    "why_ko": "<p>JUnit, FEST 및 AssertJ assertion에 메시지를 추가하는 것은 미래의 생산성에 대한 투자입니다. 지금 몇 초를 들여 작성하면, 테스트가 실패하여 문제를 빠르게 진단해야 하거나 테스트를 유지 관리해야 할 때 assertion 메시지가 일종의 문서 역할을 하여 많은 시간을 절약할 수 있습니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\nassertEquals(4, list.size());  // 규칙 위반\n\ntry {\n  fail();  // 규칙 위반\n} catch (Exception e) {\n  assertThat(list.get(0)).isEqualTo(\"pear\");  // 규칙 위반\n}\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre>\nassertEquals(\"There should have been 4 Fruits in the list\", 4, list.size());\n\ntry {\n  fail(\"And exception is expected here\");\n} catch (Exception e) {\n  assertThat(list.get(0)).as(\"check first element\").overridingErrorMessage(\"The first element should be a pear, not a %s\", list.get(0)).isEqualTo(\"pear\");\n}\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": ""
  },
  {
    "id": "S3436",
    "key": "java:S3436",
    "name": "Value-based classes should not be used for locking",
    "type": "bug",
    "severity": "major",
    "tags": [
      "multi-threading",
      "java8",
      "lock-in"
    ],
    "why": "<p>According to the documentation,</p>\n<blockquote>\n  <p>A program may produce unpredictable results if it attempts to distinguish two references to equal values of a value-based class, whether directly\n  via reference equality or indirectly via an appeal to synchronization…​</p>\n</blockquote>\n<p>This is because value-based classes are intended to be wrappers for value types, which will be primitive-like collections of data (similar to\n<code>struct</code>s in other languages) that will come in future versions of Java.</p>\n<blockquote>\n  <p>Instances of a value-based class …​</p>\n  <ul>\n    <li> do not have accessible constructors, but are instead instantiated through factory methods which make no commitment as to the identity of\n    returned instances; </li>\n  </ul>\n</blockquote>\n<p>This means that you can't be sure you're the only one trying to lock on any given instance of a value-based class, opening your code up to\ncontention and deadlock issues.</p>\n<p>Under Java 8 breaking this rule may not actually break your code, but there are no guarantees of the behavior beyond that.</p>\n<p>This rule raises an issue when a known value-based class is used for synchronization. That includes all the classes in the <code>java.time</code>\npackage except <code>Clock</code>; the date classes for alternate calendars, <code>HijrahDate</code>, <code>JapaneseDate</code>,\n<code>MinguoDate</code>, <code>ThaiBuddhistDate</code>; and the optional classes: <code>Optional</code>, <code>OptionalDouble</code>,\n<code>OptionalLong</code>, <code>OptionalInt</code>.</p>\n<p><strong>Note</strong> that this rule is automatically disabled when the project's <code>sonar.java.source</code> is lower than <code>8</code>.</p>\n<h3>Noncompliant code example</h3>\n<pre>\nOptional&lt;Foo&gt; fOpt = doSomething();\nsynchronized (fOpt) {  // Noncompliant\n  // ...\n}\n</pre>",
    "howToFix": "",
    "moreInfo": "<ul>\n  <li> <a href=\"https://docs.oracle.com/javase/8/docs/api/java/lang/doc-files/ValueBased.html\">Value-based classes</a> </li>\n</ul>",
    "status": "READY",
    "name_ko": "값 기반 클래스는 동기화 잠금에 사용하면 안 됩니다",
    "why_ko": "<p>문서에 따르면,</p>\n<blockquote>\n  <p>프로그램이 값 기반 클래스의 동일한 값에 대한 두 참조를 참조 동등성을 통해 직접적으로 또는 동기화를 통해 간접적으로 구별하려고 하면 예측할 수 없는 결과가 발생할 수 있습니다…​</p>\n</blockquote>\n<p>이는 값 기반 클래스가 값 타입의 래퍼로 의도되었기 때문입니다. 값 타입은 Java의 향후 버전에서 제공될 기본형과 유사한 데이터 컬렉션(다른 언어의 <code>struct</code>와 유사)입니다.</p>\n<blockquote>\n  <p>값 기반 클래스의 인스턴스는 …​</p>\n  <ul>\n    <li> 접근 가능한 생성자가 없고, 대신 반환된 인스턴스의 동일성에 대해 어떤 보장도 하지 않는 팩토리 메서드를 통해 인스턴스화됩니다; </li>\n  </ul>\n</blockquote>\n<p>이는 값 기반 클래스의 특정 인스턴스에 대해 잠금을 시도하는 것이 자신뿐인지 확신할 수 없다는 것을 의미하며, 코드가 경쟁 및 데드락 문제에 노출될 수 있습니다.</p>\n<p>Java 8에서는 이 규칙을 위반해도 실제로 코드가 손상되지 않을 수 있지만, 그 이후의 동작에 대한 보장은 없습니다.</p>\n<p>이 규칙은 알려진 값 기반 클래스가 동기화에 사용될 때 문제를 제기합니다. 여기에는 <code>Clock</code>을 제외한 <code>java.time</code> 패키지의 모든 클래스; 대체 달력의 날짜 클래스인 <code>HijrahDate</code>, <code>JapaneseDate</code>, <code>MinguoDate</code>, <code>ThaiBuddhistDate</code>; 그리고 optional 클래스인 <code>Optional</code>, <code>OptionalDouble</code>, <code>OptionalLong</code>, <code>OptionalInt</code>가 포함됩니다.</p>\n<p><strong>참고</strong> 이 규칙은 프로젝트의 <code>sonar.java.source</code>가 <code>8</code>보다 낮을 때 자동으로 비활성화됩니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\nOptional&lt;Foo&gt; fOpt = doSomething();\nsynchronized (fOpt) {  // 규칙 위반\n  // ...\n}\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": "<ul>\n  <li> <a href=\"https://docs.oracle.com/javase/8/docs/api/java/lang/doc-files/ValueBased.html\">Value-based classes</a> </li>\n</ul>"
  },
  {
    "id": "S3066",
    "key": "java:S3066",
    "name": "\"enum\" fields should not be publicly mutable",
    "type": "code-smell",
    "severity": "minor",
    "tags": [
      "bad-practice"
    ],
    "why": "<p><code>enum</code>s are generally thought of as constant, but an <code>enum</code> with a <code>public</code> field or <code>public</code> setter is\nnon-constant. Ideally fields in an <code>enum</code> are <code>private</code> and set in the constructor, but if that's not possible, their visibility\nshould be reduced as much as possible.</p>\n<h3>Noncompliant code example</h3>\n<pre>\npublic enum Continent {\n\n  NORTH_AMERICA (23, 24709000),\n  // ...\n  EUROPE (50, 39310000);\n\n  public int countryCount;  // Noncompliant\n  private int landMass;\n\n  Continent(int countryCount, int landMass) {\n    // ...\n  }\n\n  public void setLandMass(int landMass) {  // Noncompliant\n    this.landMass = landMass;\n  }\n</pre>\n<h3>Compliant solution</h3>\n<pre>\npublic enum Continent {\n\n  NORTH_AMERICA (23, 24709000),\n  // ...\n  EUROPE (50, 39310000);\n\n  private int countryCount;\n  private int landMass;\n\n  Continent(int countryCount, int landMass) {\n    // ...\n  }\n</pre>",
    "howToFix": "",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "\"enum\" 필드는 공개적으로 변경 가능하면 안 됩니다",
    "why_ko": "<p><code>enum</code>은 일반적으로 상수로 간주되지만, <code>public</code> 필드 또는 <code>public</code> setter가 있는 <code>enum</code>은 상수가 아닙니다. 이상적으로 <code>enum</code>의 필드는 <code>private</code>이고 생성자에서 설정되어야 하지만, 그것이 불가능하다면 가시성을 가능한 한 줄여야 합니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\npublic enum Continent {\n\n  NORTH_AMERICA (23, 24709000),\n  // ...\n  EUROPE (50, 39310000);\n\n  public int countryCount;  // 규칙 위반\n  private int landMass;\n\n  Continent(int countryCount, int landMass) {\n    // ...\n  }\n\n  public void setLandMass(int landMass) {  // 규칙 위반\n    this.landMass = landMass;\n  }\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre>\npublic enum Continent {\n\n  NORTH_AMERICA (23, 24709000),\n  // ...\n  EUROPE (50, 39310000);\n\n  private int countryCount;\n  private int landMass;\n\n  Continent(int countryCount, int landMass) {\n    // ...\n  }\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": ""
  },
  {
    "id": "S118",
    "key": "java:S118",
    "name": "Abstract class names should comply with a naming convention",
    "type": "code-smell",
    "severity": "minor",
    "tags": [
      "convention"
    ],
    "why": "<p>Sharing some naming conventions is a key point to make it possible for a team to efficiently collaborate. This rule allows to check that all\n<code>abstract</code> class names match a provided regular expression. If a non-abstract class match the regular expression, an issue is raised to\nsuggest to either make it abstract or to rename it.</p>\n<h3>Noncompliant code example</h3>\n<p>With the default regular expression: <code>^Abstract[A-Z][a-zA-Z0-9]*$</code>:</p>\n<pre>\nabstract class MyClass { // Noncompliant\n}\n\nclass AbstractLikeClass { // Noncompliant\n}\n</pre>\n<h3>Compliant solution</h3>\n<pre>\nabstract class AbstractClass {\n}\n\nclass LikeClass {\n}\n</pre>",
    "howToFix": "",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "추상 클래스 이름은 명명 규칙을 준수해야 합니다",
    "why_ko": "<p>일부 명명 규칙을 공유하는 것은 팀이 효율적으로 협업할 수 있도록 하는 핵심 포인트입니다. 이 규칙을 사용하면 모든 <code>abstract</code> 클래스 이름이 제공된 정규 표현식과 일치하는지 확인할 수 있습니다. 비추상 클래스가 정규 표현식과 일치하면 추상 클래스로 만들거나 이름을 변경하도록 제안하는 이슈가 발생합니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<p>기본 정규 표현식 <code>^Abstract[A-Z][a-zA-Z0-9]*$</code>의 경우:</p>\n<pre>\nabstract class MyClass { // 규칙 위반\n}\n\nclass AbstractLikeClass { // 규칙 위반\n}\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre>\nabstract class AbstractClass {\n}\n\nclass LikeClass {\n}\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": ""
  },
  {
    "id": "S2677",
    "key": "java:S2677",
    "name": "\"read\" and \"readLine\" return values should be used",
    "type": "bug",
    "severity": "major",
    "tags": [],
    "why": "<p>The <code>Reader.read()</code> and the <code>BufferedReader.readLine()</code> are used for reading data from a data source. The return value of\nthese methods is the data read from the data source, or <code>null</code> when the end of the data source is reached. If the return value is ignored,\nthe data read from the source is thrown away and may indicate a bug.</p>\n<p>This rule raises an issue when the return values of <code>Reader.read()</code> and <code>BufferedReader.readLine()</code> and their subclasses are\nignored or merely null-checked.</p>\n<h3>Noncompliant code example</h3>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\npublic void doSomethingWithFile(String fileName) {\n  try(BufferedReader buffReader = new BufferedReader(new FileReader(fileName))) {\n    while (buffReader.readLine() != null) { // Noncompliant\n      // ...\n    }\n  } catch (IOException e) {\n    // ...\n  }\n}\n</pre>\n<h3>Compliant solution</h3>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\npublic void doSomethingWithFile(String fileName) {\n  try(BufferedReader buffReader = new BufferedReader(new FileReader(fileName))) {\n    String line = null;\n    while ((line = buffReader.readLine()) != null) {\n      // ...\n    }\n  } catch (IOException e) {\n    // ...\n  }\n}\n</pre>",
    "howToFix": "",
    "moreInfo": "<ul>\n  <li> <a href=\"https://docs.oracle.com/en/java/javase/20/docs/api/java.base/java/io/Reader.html#read()\">Oracle SDK 20 - Reader.read()</a> </li>\n  <li> <a href=\"https://docs.oracle.com/en/java/javase/20/docs/api/java.base/java/io/BufferedReader.html#readLine()\">Oracle SDK 20 -\n  BufferedReader.readLine()</a> </li>\n</ul>",
    "status": "READY",
    "name_ko": "read와 readLine의 반환 값을 사용해야 합니다",
    "why_ko": "<p><code>Reader.read()</code>와 <code>BufferedReader.readLine()</code>은 데이터 소스에서 데이터를 읽는 데 사용됩니다. 이러한 메서드의 반환 값은 데이터 소스에서 읽은 데이터이거나, 데이터 소스의 끝에 도달하면 <code>null</code>입니다. 반환 값이 무시되면 소스에서 읽은 데이터가 버려지며 버그를 나타낼 수 있습니다.</p>\n<p>이 규칙은 <code>Reader.read()</code> 및 <code>BufferedReader.readLine()</code>과 그 하위 클래스의 반환 값이 무시되거나 단순히 null 검사만 수행될 때 문제를 제기합니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\npublic void doSomethingWithFile(String fileName) {\n  try(BufferedReader buffReader = new BufferedReader(new FileReader(fileName))) {\n    while (buffReader.readLine() != null) { // 규칙 위반\n      // ...\n    }\n  } catch (IOException e) {\n    // ...\n  }\n}\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\npublic void doSomethingWithFile(String fileName) {\n  try(BufferedReader buffReader = new BufferedReader(new FileReader(fileName))) {\n    String line = null;\n    while ((line = buffReader.readLine()) != null) {\n      // ...\n    }\n  } catch (IOException e) {\n    // ...\n  }\n}\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": "<ul>\n  <li> <a href=\"https://docs.oracle.com/en/java/javase/20/docs/api/java.base/java/io/Reader.html#read()\">Oracle SDK 20 - Reader.read()</a> </li>\n  <li> <a href=\"https://docs.oracle.com/en/java/javase/20/docs/api/java.base/java/io/BufferedReader.html#readLine()\">Oracle SDK 20 -\n  BufferedReader.readLine()</a> </li>\n</ul>"
  },
  {
    "id": "S7475",
    "key": "java:S7475",
    "name": "Types of unused record components should be removed from pattern matching",
    "type": "code-smell",
    "severity": "info",
    "tags": [
      "unused",
      "java22"
    ],
    "why": "<p>When using pattern matching on records, matching is done against the canonical constructor of the record. This implies listing all the components\nin the canonical constructor even if some are unused. To make the intent of not using the component clear, Java 22 introduced the unnamed variable\npattern <code>_</code>.</p>\n<p>Because we can only pattern match against the canonical constructor, there is no need to disambiguate by specifying the types of its parameters.\nTherefore, the type of unused variables in pattern matching should be omitted, as it does not bring additional value.</p>",
    "howToFix": "<p>Remove the type of the unused component.</p>\n\n<h4>Noncompliant code example</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\nrecord Guest(String name, String email, String phoneNumber) {}\n\nString greet(Object o) {\n    if (o instanceof Guest(String name, String _, String _)) { // Noncompliant\n        return \"Hello \" + name + \"!\";\n    }\n    return \"Hello!\";\n}\n\nString switchToGreet(Object o) {\n    return switch (o) {\n        case Guest(String name, String _, String _) -&gt; \"Hello \" + name + \"!\"; // Noncompliant\n        default -&gt; \"Hello!\";\n    };\n}\n</pre>\n<h4>Compliant solution</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\nrecord Guest(String name, String email, String phoneNumber) {}\n\nString greet(Object o) {\n    if (o instanceof Guest(String name, _, _)) {\n        return \"Hello \" + name + \"!\";\n    }\n    return \"Hello!\";\n}\n\nString switchToGreet(Object o) {\n    return switch (o) {\n        case Guest(String name, _, _) -&gt; \"Hello \" + name + \"!\";\n        default -&gt; \"Hello!\";\n    };\n}\n</pre>",
    "moreInfo": "<h3>Documentation</h3>\n<ul>\n  <li> <a href=\"https://openjdk.org/jeps/456\">JEP 456: Unnamed Variables &amp; Patterns</a> </li>\n</ul>",
    "status": "READY",
    "name_ko": "사용되지 않는 record 컴포넌트의 타입은 패턴 매칭에서 제거해야 합니다",
    "why_ko": "<p>record에서 패턴 매칭을 사용할 때 매칭은 record의 정규 생성자에 대해 수행됩니다. 이는 일부가 사용되지 않더라도 정규 생성자의 모든 컴포넌트를 나열해야 함을 의미합니다. 컴포넌트를 사용하지 않겠다는 의도를 명확히 하기 위해 Java 22에서는 이름 없는 변수 패턴 <code>_</code>를 도입했습니다.</p>\n<p>정규 생성자에 대해서만 패턴 매칭을 할 수 있으므로 매개변수의 타입을 지정하여 구분할 필요가 없습니다. 따라서 패턴 매칭에서 사용되지 않는 변수의 타입은 추가적인 가치를 제공하지 않으므로 생략해야 합니다.</p>",
    "howToFix_ko": "<p>사용되지 않는 컴포넌트의 타입을 제거하세요.</p>\n\n<h4>규칙을 준수하지 않는 코드 예시</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\nrecord Guest(String name, String email, String phoneNumber) {}\n\nString greet(Object o) {\n    if (o instanceof Guest(String name, String _, String _)) { // 규칙 위반\n        return \"Hello \" + name + \"!\";\n    }\n    return \"Hello!\";\n}\n\nString switchToGreet(Object o) {\n    return switch (o) {\n        case Guest(String name, String _, String _) -&gt; \"Hello \" + name + \"!\"; // 규칙 위반\n        default -&gt; \"Hello!\";\n    };\n}\n</pre>\n<h4>규칙을 준수하는 해결책</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\nrecord Guest(String name, String email, String phoneNumber) {}\n\nString greet(Object o) {\n    if (o instanceof Guest(String name, _, _)) {\n        return \"Hello \" + name + \"!\";\n    }\n    return \"Hello!\";\n}\n\nString switchToGreet(Object o) {\n    return switch (o) {\n        case Guest(String name, _, _) -&gt; \"Hello \" + name + \"!\";\n        default -&gt; \"Hello!\";\n    };\n}\n</pre>",
    "moreInfo_ko": "<h3>문서</h3>\n<ul>\n  <li> <a href=\"https://openjdk.org/jeps/456\">JEP 456: 이름 없는 변수 및 패턴</a> </li>\n</ul>"
  },
  {
    "id": "S2118",
    "key": "java:S2118",
    "name": "\"writeObject\" argument must implement \"Serializable\"",
    "type": "bug",
    "severity": "major",
    "tags": [
      "serialization"
    ],
    "why": "<p>Serialization is a platform-independent mechanism for writing the state of an object into a byte-stream. For serializing the object, we call the\n<code>writeObject()</code> method of <code>java.io.ObjectOutputStream</code> class. Only classes that implement <code>Serializable</code> or extend a\nclass that does it can successfully be serialized (or de-serialized).</p>\n<p>Attempting to write a class with the <code>writeObject</code> method of the <code>ObjectOutputStream</code> class that does not implement\n<code>Serializable</code> or extends a class that implements it, will throw an <code>IOException</code>.</p>",
    "howToFix": "<p>The object class passed as an argument to the <code>writeObject</code> must implement <code>Serializable</code>.</p>\n\n<h4>Noncompliant code example</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\npublic class Vegetable {\n  // ...\n}\n\npublic class Menu {\n  public void meal(ObjectOutputStream oos) throws IOException {\n    Vegetable veg = new Vegetable();\n    oos.writeObject(veg);  // Noncompliant\n  }\n}\n</pre>\n<h4>Compliant solution</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\npublic class Vegetable implements Serializable {\n  // ...\n}\n\npublic class Menu {\n  public void meal(ObjectOutputStream oos) throws IOException {\n    Vegetable veg = new Vegetable();\n    oos.writeObject(veg);\n  }\n}\n</pre>",
    "moreInfo": "<ul>\n  <li> <a href=\"https://docs.oracle.com/en/java/javase/20/docs/api/java.base/java/io/Serializable.html\">Oracle Java SE - Serializable</a> </li>\n  <li> <a href=\"https://docs.oracle.com/en/java/javase/20/docs/api/java.base/java/io/ObjectOutputStream.html\">Oracle Java SE - ObjectOutputStream</a>\n  </li>\n</ul>",
    "status": "READY",
    "name_ko": "\"writeObject\" 인수는 \"Serializable\"을 구현해야 합니다",
    "why_ko": "<p>직렬화는 객체의 상태를 바이트 스트림으로 쓰기 위한 플랫폼 독립적 메커니즘입니다. 객체를 직렬화하기 위해 <code>java.io.ObjectOutputStream</code> 클래스의 <code>writeObject()</code> 메서드를 호출합니다. <code>Serializable</code>을 구현하거나 이를 구현하는 클래스를 확장하는 클래스만 성공적으로 직렬화(또는 역직렬화)될 수 있습니다.</p>\n<p><code>Serializable</code>을 구현하지 않거나 이를 구현하는 클래스를 확장하지 않는 클래스를 <code>ObjectOutputStream</code> 클래스의 <code>writeObject</code> 메서드로 쓰려고 시도하면 <code>IOException</code>이 발생합니다.</p>",
    "howToFix_ko": "<p><code>writeObject</code>에 인수로 전달되는 객체 클래스는 <code>Serializable</code>을 구현해야 합니다.</p>\n\n<h4>규칙을 준수하지 않는 코드 예시</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\npublic class Vegetable {\n  // ...\n}\n\npublic class Menu {\n  public void meal(ObjectOutputStream oos) throws IOException {\n    Vegetable veg = new Vegetable();\n    oos.writeObject(veg);  // 규칙 위반\n  }\n}\n</pre>\n<h4>규칙을 준수하는 해결책</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\npublic class Vegetable implements Serializable {\n  // ...\n}\n\npublic class Menu {\n  public void meal(ObjectOutputStream oos) throws IOException {\n    Vegetable veg = new Vegetable();\n    oos.writeObject(veg);\n  }\n}\n</pre>",
    "moreInfo_ko": "<ul>\n  <li> <a href=\"https://docs.oracle.com/en/java/javase/20/docs/api/java.base/java/io/Serializable.html\">Oracle Java SE - Serializable</a> </li>\n  <li> <a href=\"https://docs.oracle.com/en/java/javase/20/docs/api/java.base/java/io/ObjectOutputStream.html\">Oracle Java SE - ObjectOutputStream</a> </li>\n</ul>"
  },
  {
    "id": "S5777",
    "key": "java:S5777",
    "name": "Exception testing via JUnit @Test annotation should be avoided",
    "type": "code-smell",
    "severity": "minor",
    "tags": [
      "junit",
      "tests"
    ],
    "why": "<p>When testing exception via <code>@Test</code> annotation, having additional assertions inside that test method can be problematic because any code\nafter the raised exception will not be executed. It will prevent you to test the state of the program after the raised exception and, at worst, make\nyou&nbsp;misleadingly think that it is executed.</p>\n<p>You should consider moving any assertions into a separate test method where possible, or using <a\nhref=\"https://github.com/junit-team/junit4/wiki/Exception-testing#using-assertthrows-method\">org.junit.Assert.assertThrows</a> instead.</p>\n<p>Alternatively, you could use <a href=\"https://github.com/junit-team/junit4/wiki/Exception-testing#trycatch-idiom\">try-catch idiom</a> for JUnit\nversion &lt; 4.13 or if your project does not support lambdas.</p>\n<h3>Noncompliant code example</h3>\n<pre>\n@Test(expected = IndexOutOfBoundsException.class)\npublic void testShouldFail() {\n  get();\n  // This test pass since execution will never get past this line.\n  Assert.assertEquals(0, 1);\n}\n\nprivate Object get() {\n  throw new IndexOutOfBoundsException();\n}\n</pre>\n<h3>Compliant solution</h3>\n<ul>\n  <li> For JUnit &gt;= 4.13, use <a\n  href=\"https://github.com/junit-team/junit4/wiki/Exception-testing#using-assertthrows-method\">org.junit.Assert.assertThrows</a>: </li>\n</ul>\n<pre>\n// This test correctly fails.\n@Test\npublic void testToString() {\n    Object obj = get();\n    Assert.assertThrows(IndexOutOfBoundsException.class, () -&gt; obj.toString());\n    Assert.assertEquals(0, 1);\n}\n</pre>\n<ul>\n  <li> For JUnit &lt; 4.13, use the <a href=\"https://github.com/junit-team/junit4/wiki/Exception-testing#trycatch-idiom\">try-catch idiom</a>: </li>\n</ul>\n<pre>\n@Test\npublic void testShouldFail() {\n    Object obj = get();\n    try {\n        obj.toString();\n        Assert.fail(\"Expected an IndexOutOfBoundsException to be thrown\");\n    } catch (IndexOutOfBoundsException e) {}\n    Assert.assertEquals(0, 1); // Correctly fails.\n}\n</pre>",
    "howToFix": "",
    "moreInfo": "<ul>\n  <li> <a href=\"https://github.com/junit-team/junit4/wiki/Exception-testing\">JUnit exception testing documentation</a> </li>\n</ul>",
    "status": "READY",
    "name_ko": "JUnit @Test 어노테이션을 통한 예외 테스트는 피해야 합니다","why_ko": "<p><code>@Test</code> 어노테이션을 통해 예외를 테스트할 때 해당 테스트 메서드 내에 추가 assertion이 있으면 문제가 될 수 있습니다. 발생한 예외 이후의 모든 코드가 실행되지 않기 때문입니다. 이는 발생한 예외 이후의 프로그램 상태를 테스트하는 것을 방지하고, 최악의 경우 실행된다고 오해하게 만들 수 있습니다.</p>\n<p>가능한 경우 assertion을 별도의 테스트 메서드로 이동하거나 대신 <a href=\"https://github.com/junit-team/junit4/wiki/Exception-testing#using-assertthrows-method\">org.junit.Assert.assertThrows</a>를 사용하는 것을 고려해야 합니다.</p>\n<p>또는 JUnit 버전 < 4.13이거나 프로젝트가 람다를 지원하지 않는 경우 <a href=\"https://github.com/junit-team/junit4/wiki/Exception-testing#trycatch-idiom\">try-catch 관용구</a>를 사용할 수 있습니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\n@Test(expected = IndexOutOfBoundsException.class)\npublic void testShouldFail() {\n  get();\n  // 실행이 이 줄을 지나지 않으므로 이 테스트는 통과합니다.\n  Assert.assertEquals(0, 1);\n}\n\nprivate Object get() {\n  throw new IndexOutOfBoundsException();\n}\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<ul>\n  <li> JUnit >= 4.13의 경우 <a href=\"https://github.com/junit-team/junit4/wiki/Exception-testing#using-assertthrows-method\">org.junit.Assert.assertThrows</a>를 사용하세요: </li>\n</ul>\n<pre>\n// 이 테스트는 올바르게 실패합니다.\n@Test\npublic void testToString() {\n    Object obj = get();\n    Assert.assertThrows(IndexOutOfBoundsException.class, () -&gt; obj.toString());\n    Assert.assertEquals(0, 1);\n}\n</pre>\n<ul>\n  <li> JUnit < 4.13의 경우 <a href=\"https://github.com/junit-team/junit4/wiki/Exception-testing#trycatch-idiom\">try-catch 관용구</a>를 사용하세요: </li>\n</ul>\n<pre>\n@Test\npublic void testShouldFail() {\n    Object obj = get();\n    try {\n        obj.toString();\n        Assert.fail(\"IndexOutOfBoundsException이 발생해야 합니다\");\n    } catch (IndexOutOfBoundsException e) {}\n    Assert.assertEquals(0, 1); // 올바르게 실패합니다.\n}\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": "<ul>\n  <li> <a href=\"https://github.com/junit-team/junit4/wiki/Exception-testing\">JUnit 예외 테스트 문서</a> </li>\n</ul>"
  },
  {
    "id": "S1221",
    "key": "java:S1221",
    "name": "Methods should not be named \"tostring\", \"hashcode\" or \"equal\"",
    "type": "bug",
    "severity": "major",
    "tags": [
      "pitfall"
    ],
    "why": "<p>Due to the similar name with the methods <code>Object.toString</code>, <code>Object.hashCode</code> and <code>Object.equals</code>, there is a\nsignificant likelihood that a developer intended to override one of these methods but made a spelling error.</p>\n<p>Even if no such error exists and the naming was done on purpose, these method names can be misleading. Readers might not notice the difference, or\nif they do, they may falsely assume that the developer made a mistake.</p>",
    "howToFix": "<p>If you intended to override one of the methods <code>Object.toString</code>, <code>Object.hashCode</code>, or <code>Object.equals</code>, correct\nthe spelling. Also, you should add the <code>@Override</code> modifier, which causes a compiler error message in case the annotated method does not\noverride anything.</p>\n<p>If the naming was done on purpose, you should rename the methods to be more distinctive.</p>\n\n<h4>Noncompliant code example</h4>\n<pre>\npublic int hashcode() { /* ... */ }             // Noncompliant\n\npublic String tostring() { /* ... */ }          // Noncompliant\n\npublic boolean equal(Object obj) { /* ... */ }  // Noncompliant\n</pre>\n<h4>Compliant solution</h4>\n<pre>\n@Override\npublic int hashCode() { /* ... */ }             // Compliant\n\n@Override\npublic String toString() { /* ... */ }          // Compliant\n\n@Override\npublic boolean equals(Object obj) { /* ... */ } // Compliant\n</pre>",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "메서드 이름을 \"tostring\", \"hashcode\", \"equal\"로 지정하면 안 됩니다",
    "why_ko": "<p><code>Object.toString</code>, <code>Object.hashCode</code>, <code>Object.equals</code> 메서드와 이름이 비슷하기 때문에 개발자가 이러한 메서드 중 하나를 오버라이드하려고 했지만 철자 오류를 범했을 가능성이 상당합니다.</p>\n<p>그러한 오류가 없고 의도적으로 이름을 지정했더라도 이러한 메서드 이름은 오해를 불러일으킬 수 있습니다. 독자가 차이를 눈치채지 못할 수 있고, 눈치채더라도 개발자가 실수했다고 잘못 가정할 수 있습니다.</p>",
    "howToFix_ko": "<p><code>Object.toString</code>, <code>Object.hashCode</code> 또는 <code>Object.equals</code> 메서드 중 하나를 오버라이드하려고 했다면 철자를 수정하세요. 또한 어노테이션된 메서드가 아무것도 오버라이드하지 않는 경우 컴파일러 오류 메시지를 발생시키는 <code>@Override</code> 수정자를 추가해야 합니다.</p>\n<p>의도적으로 이름을 지정한 경우, 더 구별되도록 메서드 이름을 변경해야 합니다.</p>\n\n<h4>규칙을 준수하지 않는 코드 예시</h4>\n<pre>\npublic int hashcode() { /* ... */ }             // 규칙 위반\n\npublic String tostring() { /* ... */ }          // 규칙 위반\n\npublic boolean equal(Object obj) { /* ... */ }  // 규칙 위반\n</pre>\n<h4>규칙을 준수하는 해결책</h4>\n<pre>\n@Override\npublic int hashCode() { /* ... */ }             // 규칙 준수\n\n@Override\npublic String toString() { /* ... */ }          // 규칙 준수\n\n@Override\npublic boolean equals(Object obj) { /* ... */ } // 규칙 준수\n</pre>",
    "moreInfo_ko": ""
  },
  {
    "id": "S1108",
    "key": "java:S1108",
    "name": "Close curly brace and the next \"else\", \"catch\" and \"finally\" keywords should be on two different lines",
    "type": "code-smell",
    "severity": "minor",
    "tags": [
      "convention"
    ],
    "why": "<p>Shared coding conventions make it possible for a team to collaborate efficiently.</p>\n<p>This rule makes it mandatory to place a closing curly brace and the next <code>else</code>, <code>catch</code> or <code>finally</code> keyword on\ntwo different lines.</p>\n<h3>Noncompliant code example</h3>\n<pre>\npublic void myMethod() {\n  if(something) {\n    executeTask();\n  } else if (somethingElse) {          // Noncompliant\n    doSomethingElse();\n  }\n  else {                               // Compliant\n     generateError();\n  }\n\n  try {\n    generateOrder();\n  } catch (Exception e) {\n    log(e);\n  }\n  finally {\n    closeConnection();\n  }\n}\n</pre>\n<h3>Compliant solution</h3>\n<pre>\npublic void myMethod() {\n  if(something) {\n    executeTask();\n  }\n  else if (somethingElse) {\n    doSomethingElse();\n  }\n  else {\n     generateError();\n  }\n\n  try {\n    generateOrder();\n  }\n  catch (Exception e) {\n    log(e);\n  }\n  finally {\n    closeConnection();\n  }\n}\n</pre>",
    "howToFix": "",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "닫는 중괄호와 다음 \"else\", \"catch\", \"finally\" 키워드는 서로 다른 줄에 위치해야 합니다",
    "why_ko": "<p>공유된 코딩 규칙은 팀이 효율적으로 협업할 수 있게 해줍니다.</p>\n<p>이 규칙은 닫는 중괄호와 다음 <code>else</code>, <code>catch</code> 또는 <code>finally</code> 키워드를 서로 다른 두 줄에 배치하도록 의무화합니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\npublic void myMethod() {\n  if(something) {\n    executeTask();\n  } else if (somethingElse) {          // 규칙 위반\n    doSomethingElse();\n  }\n  else {                               // 규칙 준수\n     generateError();\n  }\n\n  try {\n    generateOrder();\n  } catch (Exception e) {\n    log(e);\n  }\n  finally {\n    closeConnection();\n  }\n}\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre>\npublic void myMethod() {\n  if(something) {\n    executeTask();\n  }\n  else if (somethingElse) {\n    doSomethingElse();\n  }\n  else {\n     generateError();\n  }\n\n  try {\n    generateOrder();\n  }\n  catch (Exception e) {\n    log(e);\n  }\n  finally {\n    closeConnection();\n  }\n}\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": ""
  },
  {
    "id": "S3973",
    "key": "java:S3973",
    "name": "A conditionally executed single line should be denoted by indentation",
    "type": "code-smell",
    "severity": "critical",
    "tags": [
      "confusing",
      "suspicious"
    ],
    "why": "<p>When the line immediately after a conditional has neither curly braces nor indentation, the intent of the code is unclear and perhaps not what is\nexecuted. Additionally, such code is confusing to maintainers.</p>\n<pre>\nif (condition)  // Noncompliant\ndoTheThing();\ndoTheOtherThing(); // Was the intent to call this function unconditionally?\n</pre>\n<p>It becomes even more confusing and bug-prone if lines get commented out.</p>\n<pre>\nif (condition)  // Noncompliant\n//  doTheThing();\ndoTheOtherThing(); // Was the intent to call this function conditionally?\n</pre>\n<p>Indentation alone or together with curly braces makes the intent clear.</p>\n<pre>\nif (condition)\n  doTheThing();\ndoTheOtherThing(); // Clear intent to call this function unconditionally\n\n// or\n\nif (condition) {\n  doTheThing();\n}\ndoTheOtherThing(); // Clear intent to call this function unconditionally\n</pre>\n<p>This rule raises an issue if the line controlled by a conditional has the same indentation as the conditional and is not enclosed in curly\nbraces.</p>",
    "howToFix": "",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "조건부로 실행되는 단일 라인은 들여쓰기로 표시해야 합니다",
    "why_ko": "<p>조건문 바로 다음 줄에 중괄호도 들여쓰기도 없으면 코드의 의도가 불분명하고 실행되는 것과 다를 수 있습니다. 또한 이러한 코드는 유지보수 담당자에게 혼란을 줍니다.</p>\n<pre>\nif (condition)  // 규칙 위반\ndoTheThing();\ndoTheOtherThing(); // 이 함수를 무조건 호출하려는 의도였나요?\n</pre>\n<p>줄이 주석 처리되면 더 혼란스럽고 버그가 발생하기 쉽습니다.</p>\n<pre>\nif (condition)  // 규칙 위반\n//  doTheThing();\ndoTheOtherThing(); // 이 함수를 조건부로 호출하려는 의도였나요?\n</pre>\n<p>들여쓰기만 또는 중괄호와 함께 사용하면 의도가 명확해집니다.</p>\n<pre>\nif (condition)\n  doTheThing();\ndoTheOtherThing(); // 이 함수를 무조건 호출하려는 명확한 의도\n\n// 또는\n\nif (condition) {\n  doTheThing();\n}\ndoTheOtherThing(); // 이 함수를 무조건 호출하려는 명확한 의도\n</pre>\n<p>이 규칙은 조건문에 의해 제어되는 줄이 조건문과 동일한 들여쓰기를 가지고 중괄호로 둘러싸이지 않은 경우 문제를 제기합니다.</p>",
    "howToFix_ko": "",
    "moreInfo_ko": ""
  },
  {
    "id": "S5665",
    "key": "java:S5665",
    "name": "Escape sequences should not be used in text blocks",
    "type": "code-smell",
    "severity": "minor",
    "tags": [
      "java14"
    ],
    "why": "<p>The use of escape sequences is mostly unnecessary in text blocks.</p>\n<h3>Noncompliant code example</h3>\n<p><code>\\n</code> can be replaced by simply introducing the newline, <code>\\\"\\\"\\\"</code> it is sufficient to escape only the first qoute.</p>\n<pre>\nString textBlock = \"\"\"\n        \\\"\\\"\\\" this \\nis\n        text  block!\n        !!!!\n      \"\"\";\n</pre>\n<h3>Compliant solution</h3>\n<pre>\nString textBlock = \"\"\"\n        \\\"\"\" this\n        is\n        text  block!\n        !!!!\n      \"\"\";\n</pre>",
    "howToFix": "",
    "moreInfo": "<ul>\n  <li> <a href=\"https://openjdk.java.net/jeps/378\">JEP 378: Text Blocks</a> </li>\n  <li> <a href=\"https://openjdk.org/projects/amber/guides/text-blocks-guide\">Programmer's Guide To Text Blocks</a>, by Jim Laskey and Stuart Marks\n  </li>\n</ul>",
    "status": "READY",
    "name_ko": "텍스트 블록에서 이스케이프 시퀀스를 사용하면 안 됩니다",
    "why_ko": "<p>텍스트 블록에서 이스케이프 시퀀스의 사용은 대부분 불필요합니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<p><code>\\n</code>은 단순히 줄바꿈을 도입하여 대체할 수 있으며, <code>\\\"\\\"\\\"</code>의 경우 첫 번째 따옴표만 이스케이프하면 충분합니다.</p>\n<pre>\nString textBlock = \"\"\"\n        \\\"\\\"\\\" this \\nis\n        text  block!\n        !!!!\n      \"\"\";\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre>\nString textBlock = \"\"\"\n        \\\"\"\" this\n        is\n        text  block!\n        !!!!\n      \"\"\";\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": "<ul>\n  <li> <a href=\"https://openjdk.java.net/jeps/378\">JEP 378: Text Blocks</a> </li>\n  <li> <a href=\"https://openjdk.org/projects/amber/guides/text-blocks-guide\">Programmer's Guide To Text Blocks</a>, Jim Laskey와 Stuart Marks 저 </li>\n</ul>"
  },
  {
    "id": "S4977",
    "key": "java:S4977",
    "name": "Type parameters should not shadow other type parameters",
    "type": "code-smell",
    "severity": "minor",
    "tags": [],
    "why": "<p>Shadowing makes it impossible to use the type parameter from the outer scope. Also, it can be confusing to distinguish which type parameter is\nbeing used.</p>\n<p>This rule raises an issue when a type parameter from an inner scope uses the same name as one in an outer scope.</p>\n<h3>Noncompliant code example</h3>\n<pre>\n public class TypeParameterHidesAnotherType&lt;T&gt; {\n\n    public class Inner&lt;T&gt; { // Noncompliant\n      //...\n    }\n\n    private &lt;T&gt; T method() { // Noncompliant\n      return null;\n    }\n\n  }\n</pre>\n<h3>Compliant solution</h3>\n<pre>\npublic class NoTypeParameterHiding&lt;T&gt; {\n\n    public class Inner&lt;S&gt; { // Compliant\n      List&lt;S&gt; listOfS;\n    }\n\n    private &lt;V&gt; V method() { // Compliant\n      return null;\n    }\n\n  }\n</pre>",
    "howToFix": "",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "타입 매개변수가 다른 타입 매개변수를 가리면 안 됩니다",
    "why_ko": "<p>섀도잉은 외부 스코프의 타입 매개변수를 사용할 수 없게 만듭니다. 또한 어떤 타입 매개변수가 사용되고 있는지 구분하기 혼란스러울 수 있습니다.</p>\n<p>이 규칙은 내부 스코프의 타입 매개변수가 외부 스코프의 타입 매개변수와 같은 이름을 사용할 때 문제를 제기합니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\n public class TypeParameterHidesAnotherType&lt;T&gt; {\n\n    public class Inner&lt;T&gt; { // 규칙 위반\n      //...\n    }\n\n    private &lt;T&gt; T method() { // 규칙 위반\n      return null;\n    }\n\n  }\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre>\npublic class NoTypeParameterHiding&lt;T&gt; {\n\n    public class Inner&lt;S&gt; { // 규칙 준수\n      List&lt;S&gt; listOfS;\n    }\n\n    private &lt;V&gt; V method() { // 규칙 준수\n      return null;\n    }\n\n  }\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": ""
  },
  {
    "id": "S2972",
    "key": "java:S2972",
    "name": "Inner classes should not have too many lines of code",
    "type": "code-smell",
    "severity": "major",
    "tags": [
      "brain-overload"
    ],
    "why": "<p>Inner classes should be short and sweet, to manage complexity in the overall file. An inner class that has grown longer than a certain threshold\nshould probably be externalized to its own file.</p>",
    "howToFix": "",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "내부 클래스의 코드 줄 수가 너무 많으면 안 됩니다",
    "why_ko": "<p>내부 클래스는 전체 파일의 복잡성을 관리하기 위해 짧고 간결해야 합니다. 특정 임계값보다 길어진 내부 클래스는 별도의 파일로 외부화해야 합니다.</p>",
    "howToFix_ko": "",
    "moreInfo_ko": ""
  },
  {
    "id": "S3725",
    "key": "java:S3725",
    "name": "Java 8's \"Files.exists\" should not be used",
    "type": "code-smell",
    "severity": "major",
    "tags": [
      "performance",
      "java8"
    ],
    "why": "<p>The <code>Files.exists</code> method has noticeably poor performance in JDK 8, and can slow an application significantly when used to check files\nthat don't actually exist.</p>\n<p>The same goes for <code>Files.notExists</code>, <code>Files.isDirectory</code> and <code>Files.isRegularFile</code> from <code>java.nio.file</code>\npackage.</p>\n<p><strong>Note</strong> that this rule is automatically disabled when the project's <code>sonar.java.source</code> is not 8.</p>\n<h3>Noncompliant code example</h3>\n<pre>\nPath myPath;\nif(java.nio.file.Files.exists(myPath)) {  // Noncompliant\n // do something\n}\n</pre>\n<h3>Compliant solution</h3>\n<pre>\nPath myPath;\nif(myPath.toFile().exists())) {\n // do something\n}\n</pre>",
    "howToFix": "",
    "moreInfo": "<ul>\n  <li> <a href=\"https://bugs.openjdk.java.net/browse/JDK-8153414\">https://bugs.openjdk.java.net/browse/JDK-8153414</a> </li>\n  <li> <a href=\"https://bugs.openjdk.java.net/browse/JDK-8154077\">https://bugs.openjdk.java.net/browse/JDK-8154077</a> </li>\n</ul>",
    "status": "READY",
    "name_ko": "Java 8의 Files.exists를 사용하면 안 됩니다",
    "why_ko": "<p><code>Files.exists</code> 메서드는 JDK 8에서 눈에 띄게 성능이 좋지 않으며, 실제로 존재하지 않는 파일을 검사하는 데 사용될 때 애플리케이션 속도를 상당히 저하시킬 수 있습니다.</p>\n<p><code>java.nio.file</code> 패키지의 <code>Files.notExists</code>, <code>Files.isDirectory</code>, <code>Files.isRegularFile</code>도 마찬가지입니다.</p>\n<p><strong>참고</strong>: 이 규칙은 프로젝트의 <code>sonar.java.source</code>가 8이 아닐 때 자동으로 비활성화됩니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\nPath myPath;\nif(java.nio.file.Files.exists(myPath)) {  // 규칙 위반\n // do something\n}\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre>\nPath myPath;\nif(myPath.toFile().exists())) {\n // do something\n}\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": "<ul>\n  <li> <a href=\"https://bugs.openjdk.java.net/browse/JDK-8153414\">https://bugs.openjdk.java.net/browse/JDK-8153414</a> </li>\n  <li> <a href=\"https://bugs.openjdk.java.net/browse/JDK-8154077\">https://bugs.openjdk.java.net/browse/JDK-8154077</a> </li>\n</ul>"
  },
  {
    "id": "S2134",
    "key": "java:S2134",
    "name": "Classes extending java.lang.Thread should provide a specific \"run\" behavior",
    "type": "bug",
    "severity": "major",
    "tags": [
      "multi-threading",
      "pitfall"
    ],
    "why": "<p>The default implementation of <code>java.lang.Thread</code> 's <code>run</code> will only perform a task passed as a <code>Runnable</code>. If no\n<code>Runnable</code> has been provided at construction time, then the thread will not perform any action.</p>\n<p>When extending <code>java.lang.Thread</code>, you should override the <code>run</code> method or pass a <code>Runnable</code> target to the\nconstructor of <code>java.lang.Thread</code>.</p>\n<h3>Noncompliant code example</h3>\n<pre>\npublic class MyThread extends Thread { // Noncompliant\n  public void doSomething() {\n    System.out.println(\"Hello, World!\");\n  }\n}\n</pre>",
    "howToFix": "<p>To fix this issue, you have 2 options:</p>\n<ul>\n  <li> override the <code>run</code> method </li>\n</ul>\n<pre>\npublic class MyThread extends Thread {\n  @Override\n  public void run() {\n    System.out.println(\"Hello, World!\");\n  }\n}\n</pre>\n<ul>\n  <li> provide a <code>Runnable</code> at construction time </li>\n</ul>\n<pre>\npublic class MyRunnable implements Runnable {\n  @Override\n  public void run() {\n    System.out.println(\"Hello, World!\");\n  }\n}\npublic class MyThread extends Thread {\n  public MyThread(Runnable runnable) {\n    super(runnable);\n  }\n}\n\npublic class Main() {\n  public static void main(String [] args) {\n    Runnable runnable = new MyRunnable();\n    Thread customThread = new MyThread(runnable);\n    Thread regularThread = new Thread(runnable);\n  }\n}\n</pre>",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "java.lang.Thread를 상속하는 클래스는 고유한 run 동작을 제공해야 합니다",
    "why_ko": "<p><code>java.lang.Thread</code>의 <code>run</code> 기본 구현은 <code>Runnable</code>로 전달된 작업만 수행합니다. 생성 시 <code>Runnable</code>이 제공되지 않으면 스레드는 어떤 동작도 수행하지 않습니다.</p>\n<p><code>java.lang.Thread</code>를 상속할 때는 <code>run</code> 메서드를 재정의하거나 <code>java.lang.Thread</code> 생성자에 <code>Runnable</code> 대상을 전달해야 합니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\npublic class MyThread extends Thread { // 규칙 위반\n  public void doSomething() {\n    System.out.println(\"Hello, World!\");\n  }\n}\n</pre>",
    "howToFix_ko": "<p>이 문제를 해결하려면 2가지 옵션이 있습니다:</p>\n<ul>\n  <li> <code>run</code> 메서드를 재정의 </li>\n</ul>\n<pre>\npublic class MyThread extends Thread {\n  @Override\n  public void run() {\n    System.out.println(\"Hello, World!\");\n  }\n}\n</pre>\n<ul>\n  <li> 생성 시 <code>Runnable</code> 제공 </li>\n</ul>\n<pre>\npublic class MyRunnable implements Runnable {\n  @Override\n  public void run() {\n    System.out.println(\"Hello, World!\");\n  }\n}\npublic class MyThread extends Thread {\n  public MyThread(Runnable runnable) {\n    super(runnable);\n  }\n}\n\npublic class Main() {\n  public static void main(String [] args) {\n    Runnable runnable = new MyRunnable();\n    Thread customThread = new MyThread(runnable);\n    Thread regularThread = new Thread(runnable);\n  }\n}\n</pre>",
    "moreInfo_ko": ""
  },
  {
    "id": "S122",
    "key": "java:S122",
    "name": "Statements should be on separate lines",
    "type": "code-smell",
    "severity": "major",
    "tags": [
      "convention"
    ],
    "why": "<p>Putting multiple statements on a single line lowers the code readability and makes debugging the code more complex.</p>\n<pre>\nif (someCondition) doSomething(); // Noncompliant\n</pre>\n<p>Write one statement per line to improve readability.</p>\n<pre>\nif (someCondition) {\n  doSomething();\n}\n</pre>",
    "howToFix": "",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "문장은 별도의 줄에 있어야 합니다",
    "why_ko": "<p>한 줄에 여러 문장을 배치하면 코드 가독성이 떨어지고 코드 디버깅이 더 복잡해집니다.</p>\n<pre>\nif (someCondition) doSomething(); // 규칙 위반\n</pre>\n<p>가독성을 향상시키려면 한 줄에 하나의 문장을 작성하세요.</p>\n<pre>\nif (someCondition) {\n  doSomething();\n}\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": ""
  },
  {
    "id": "S1124",
    "key": "java:S1124",
    "name": "Modifiers should be declared in the correct order",
    "type": "code-smell",
    "severity": "minor",
    "tags": [
      "convention"
    ],
    "why": "<p>The Java Language Specification recommends listing modifiers in the following order:</p>\n<ol>\n  <li> Annotations </li>\n  <li> public </li>\n  <li> protected </li>\n  <li> private </li>\n  <li> abstract </li>\n  <li> static </li>\n  <li> final </li>\n  <li> transient </li>\n  <li> volatile </li>\n  <li> synchronized </li>\n  <li> native </li>\n  <li> default </li>\n  <li> strictfp </li>\n</ol>\n<p>Not following this convention has no technical impact, but will reduce the code's readability because most developers are used to the standard\norder.</p>\n<h3>Noncompliant code example</h3>\n<pre>\nstatic public void main(String[] args) {   // Noncompliant\n}\n</pre>\n<h3>Compliant solution</h3>\n<pre>\npublic static void main(String[] args) {   // Compliant\n}\n</pre>",
    "howToFix": "",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "수정자는 올바른 순서로 선언해야 합니다",
    "why_ko": "<p>Java 언어 명세서는 다음 순서로 수정자를 나열할 것을 권장합니다:</p>\n<ol>\n  <li> 어노테이션 </li>\n  <li> public </li>\n  <li> protected </li>\n  <li> private </li>\n  <li> abstract </li>\n  <li> static </li>\n  <li> final </li>\n  <li> transient </li>\n  <li> volatile </li>\n  <li> synchronized </li>\n  <li> native </li>\n  <li> default </li>\n  <li> strictfp </li>\n</ol>\n<p>이 규칙을 따르지 않아도 기술적인 영향은 없지만, 대부분의 개발자가 표준 순서에 익숙하기 때문에 코드의 가독성이 저하됩니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\nstatic public void main(String[] args) {   // 규칙 위반\n}\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre>\npublic static void main(String[] args) {   // 규칙 준수\n}\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": ""
  },
  {
    "id": "S2925",
    "key": "java:S2925",
    "name": "\"Thread.sleep\" should not be used in tests",
    "type": "code-smell",
    "severity": "major",
    "tags": [
      "tests",
      "bad-practice"
    ],
    "why": "<p>In asynchronous testing, the test code is written in a way that allows it to wait for the asynchronous operation to complete before continuing with\nthe test.</p>\n<p>Using <code>Thread.sleep</code> in this case can cause flaky tests, slow test execution, and inaccurate test results. It creates brittle tests that\ncan fail unpredictably depending on the environment or load.</p>\n<p>Use mocks or libraries such as <code>Awaitility</code> instead. These tools provide features such as timeouts, assertions, and error handling to\nmake it easier to write and manage asynchronous tests.</p>\n<h3>Noncompliant code example</h3>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\n@Test\npublic void testDoTheThing(){\n\n  MyClass myClass = new MyClass();\n  myClass.doTheThing();\n\n  Thread.sleep(500);  // Noncompliant\n  // assertions...\n}\n</pre>\n<h3>Compliant solution</h3>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\n@Test\npublic void testDoTheThing(){\n\n  MyClass myClass = new MyClass();\n  myClass.doTheThing();\n\n  await().atMost(2, Duration.SECONDS).until(didTheThing());  // Compliant\n  // assertions...\n}\n\nprivate Callable&lt;Boolean&gt; didTheThing() {\n  return new Callable&lt;Boolean&gt;() {\n    public Boolean call() throws Exception {\n      // check the condition that must be fulfilled...\n    }\n  };\n}\n</pre>",
    "howToFix": "",
    "moreInfo": "<h3>Documentation</h3>\n<ul>\n  <li> <a href=\"https://docs.oracle.com/en/java/javase/20/docs/api/java.base/java/lang/Thread.html\">Oracle SE 20 - Thread</a> </li>\n  <li> <a href=\"http://www.awaitility.org/\">Awaitility</a> </li>\n</ul>\n<h3>Articles &amp; blog posts</h3>\n<ul>\n  <li> <a href=\"https://www.baeldung.com/java-thread-sleep-vs-awaitility-await\">Baeldung - Thread.sleep() vs Awaitility.await()</a> </li>\n  <li> <a href=\"https://www.baeldung.com/awaitility-testing\">Baeldung - Awaitility testing</a> </li>\n</ul>",
    "status": "READY",
    "name_ko": "테스트에서 \"Thread.sleep\"을 사용하면 안 됩니다",
    "why_ko": "<p>비동기 테스트에서 테스트 코드는 테스트를 계속하기 전에 비동기 작업이 완료될 때까지 기다리도록 작성됩니다.</p>\n<p>이 경우 <code>Thread.sleep</code>을 사용하면 불안정한 테스트, 느린 테스트 실행 및 부정확한 테스트 결과가 발생할 수 있습니다. 이는 환경이나 부하에 따라 예측할 수 없이 실패할 수 있는 취약한 테스트를 만듭니다.</p>\n<p>대신 mock이나 <code>Awaitility</code>와 같은 라이브러리를 사용하세요. 이러한 도구는 타임아웃, assertion 및 오류 처리와 같은 기능을 제공하여 비동기 테스트를 더 쉽게 작성하고 관리할 수 있게 합니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\n@Test\npublic void testDoTheThing(){\n\n  MyClass myClass = new MyClass();\n  myClass.doTheThing();\n\n  Thread.sleep(500);  // 규칙 위반\n  // assertions...\n}\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\n@Test\npublic void testDoTheThing(){\n\n  MyClass myClass = new MyClass();\n  myClass.doTheThing();\n\n  await().atMost(2, Duration.SECONDS).until(didTheThing());  // 규칙 준수\n  // assertions...\n}\n\nprivate Callable&lt;Boolean&gt; didTheThing() {\n  return new Callable&lt;Boolean&gt;() {\n    public Boolean call() throws Exception {\n      // 충족되어야 하는 조건 확인...\n    }\n  };\n}\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": "<h3>문서</h3>\n<ul>\n  <li> <a href=\"https://docs.oracle.com/en/java/javase/20/docs/api/java.base/java/lang/Thread.html\">Oracle SE 20 - Thread</a> </li>\n  <li> <a href=\"http://www.awaitility.org/\">Awaitility</a> </li>\n</ul>\n<h3>관련 문서 및 블로그 게시물</h3>\n<ul>\n  <li> <a href=\"https://www.baeldung.com/java-thread-sleep-vs-awaitility-await\">Baeldung - Thread.sleep() vs Awaitility.await()</a> </li>\n  <li> <a href=\"https://www.baeldung.com/awaitility-testing\">Baeldung - Awaitility testing</a> </li>\n</ul>"
  },
  {
    "id": "S6209",
    "key": "java:S6209",
    "name": "Members ignored during record serialization should not be used",
    "type": "bug",
    "severity": "critical",
    "tags": [
      "java16"
    ],
    "why": "<p>In Records, serialization is not done the same way as for ordinary serializable or externalizable classes. The serialized representation of a\nrecord object will be a sequence of values (record components). During the deserialization of records, the stream of components is read and components\nare constructed. Then the record object is recreated by invoking the record's canonical constructor with the component values serving as arguments (or\ndefault values for absent arguments).</p>\n<p>This process cannot be customized, so any class-specific <code>writeObject</code>, <code>readObject</code>, <code>readObjectNoData</code>,\n<code>writeExternal</code>, and <code>readExternal</code> methods or <code>serialPersistentFields</code> fields in record classes are ignored during\nserialization and deserialization.</p>\n<p>However, there is a way to substitute serialized/deserialized objects in <code>writeReplace</code> and <code>readResolve</code>.</p>\n<p>This rule raises an issue when any of <code>writeObject</code>, <code>readObject</code>, <code>readObjectNoData</code>, <code>writeExternal</code>,\n<code>readExternal</code> or <code>serialPersistentFields</code> are present as members in a Record class.</p>\n<h3>Noncompliant code example</h3>\n<pre>\nrecord Record() implements Serializable {\n  @Serial\n  private static final ObjectStreamField[] serialPersistentFields = new ObjectStreamField[0]; // Noncompliant\n  @Serial\n  private void writeObject(ObjectOutputStream out) throws IOException { // Noncompliant\n    ...\n  }\n}\nrecord Record() implements Externalizable {\n  @Override\n  public void writeExternal(ObjectOutput out) throws IOException { // Noncompliant\n    ...\n  }\n  @Override\n  public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException { // Noncompliant\n    ...\n  }\n}\n</pre>\n<h3>Compliant solution</h3>\n<pre>\nrecord Record() implements Serializable {}\n\nrecord Record() implements Serializable {\n  private Object writeReplace() throws ObjectStreamException {\n    ...\n  }\n  private Object readResolve() throws ObjectStreamException {\n    ...\n  }\n}\n</pre>",
    "howToFix": "",
    "moreInfo": "<ul>\n  <li> <a href=\"https://docs.oracle.com/javase/specs/jls/se16/html/jls-8.html#jls-8.10\">Records specification</a> </li>\n  <li> <a href=\"https://docs.oracle.com/en/java/javase/16/docs/specs/serialization/serial-arch.html#serialization-of-records\">serialization of\n  records</a> </li>\n</ul>",
    "status": "READY",
    "name_ko": "Record 직렬화 중 무시되는 멤버를 사용하면 안 됩니다",
    "why_ko": "<p>Record에서 직렬화는 일반적인 Serializable 또는 Externalizable 클래스와 동일한 방식으로 수행되지 않습니다. Record 객체의 직렬화된 표현은 값(record 구성 요소)의 시퀀스입니다. Record 역직렬화 중에 구성 요소 스트림을 읽고 구성 요소가 생성됩니다. 그런 다음 구성 요소 값을 인자로 사용하여(또는 없는 인자에 대한 기본값) record의 정규 생성자를 호출하여 record 객체가 다시 생성됩니다.</p>\n<p>이 프로세스는 사용자 정의할 수 없으므로 record 클래스의 클래스별 <code>writeObject</code>, <code>readObject</code>, <code>readObjectNoData</code>, <code>writeExternal</code>, <code>readExternal</code> 메서드 또는 <code>serialPersistentFields</code> 필드는 직렬화 및 역직렬화 중에 무시됩니다.</p>\n<p>그러나 <code>writeReplace</code>와 <code>readResolve</code>에서 직렬화/역직렬화된 객체를 대체하는 방법이 있습니다.</p>\n<p>이 규칙은 <code>writeObject</code>, <code>readObject</code>, <code>readObjectNoData</code>, <code>writeExternal</code>, <code>readExternal</code> 또는 <code>serialPersistentFields</code>가 Record 클래스의 멤버로 존재할 때 문제를 보고합니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\nrecord Record() implements Serializable {\n  @Serial\n  private static final ObjectStreamField[] serialPersistentFields = new ObjectStreamField[0]; // 규칙 위반\n  @Serial\n  private void writeObject(ObjectOutputStream out) throws IOException { // 규칙 위반\n    ...\n  }\n}\nrecord Record() implements Externalizable {\n  @Override\n  public void writeExternal(ObjectOutput out) throws IOException { // 규칙 위반\n    ...\n  }\n  @Override\n  public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException { // 규칙 위반\n    ...\n  }\n}\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre>\nrecord Record() implements Serializable {}\n\nrecord Record() implements Serializable {\n  private Object writeReplace() throws ObjectStreamException {\n    ...\n  }\n  private Object readResolve() throws ObjectStreamException {\n    ...\n  }\n}\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": "<ul>\n  <li> <a href=\"https://docs.oracle.com/javase/specs/jls/se16/html/jls-8.html#jls-8.10\">Record 명세</a> </li>\n  <li> <a href=\"https://docs.oracle.com/en/java/javase/16/docs/specs/serialization/serial-arch.html#serialization-of-records\">Record 직렬화</a> </li>\n</ul>"
  },
  {
    "id": "S5976",
    "key": "java:S5976",
    "name": "Similar tests should be grouped in a single Parameterized test",
    "type": "code-smell",
    "severity": "major",
    "tags": [
      "tests",
      "bad-practice",
      "clumsy"
    ],
    "why": "<p>When multiple tests differ only by a few hardcoded values they should be refactored as a single \"parameterized\" test. This reduces the chances of\nadding a bug and makes them more readable. Parameterized tests exist in most test frameworks (JUnit, TestNG, etc…​).</p>\n<p>The right balance needs of course to be found. There is no point in factorizing test methods when the parameterized version is a lot more complex\nthan initial tests.</p>\n<p>This rule raises an issue when at least 3 tests could be refactored as one parameterized test with less than 4 parameters. Only test methods which\nhave at least one duplicated statement are considered.</p>\n<h3>Noncompliant code example</h3>\n<p>with JUnit 5</p>\n<pre>\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nimport org.junit.jupiter.api.Test;\n\npublic class AppTest\n{\n    @Test\n    void test_not_null1() {  // Noncompliant. The 3 following tests differ only by one hardcoded number.\n      setupTax();\n      assertNotNull(getTax(1));\n    }\n\n    @Test\n    void test_not_null2() {\n      setupTax();\n      assertNotNull(getTax(2));\n    }\n\n    @Test\n    void test_not_nul3l() {\n      setupTax();\n      assertNotNull(getTax(3));\n    }\n\n    @Test\n    void testLevel1() {  // Noncompliant. The 3 following tests differ only by a few hardcoded numbers.\n        setLevel(1);\n        runGame();\n        assertEquals(playerHealth(), 100);\n    }\n\n    @Test\n    void testLevel2() {  // Similar test\n        setLevel(2);\n        runGame();\n        assertEquals(playerHealth(), 200);\n    }\n\n    @Test\n    void testLevel3() {  // Similar test\n        setLevel(3);\n        runGame();\n        assertEquals(playerHealth(), 300);\n    }\n}\n</pre>\n<h3>Compliant solution</h3>\n<pre>\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nimport org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.provider.CsvSource;\n\npublic class AppTest\n{\n\n   @ParameterizedTest\n   @ValueSource(ints = {1, 2, 3})\n   void test_not_null(int arg) {\n     setupTax();\n     assertNotNull(getTax(arg));\n   }\n\n    @ParameterizedTest\n    @CsvSource({\n        \"1, 100\",\n        \"2, 200\",\n        \"3, 300\",\n    })\n    void testLevels(int level, int health) {\n        setLevel(level);\n        runGame();\n        assertEquals(playerHealth(), health);\n    }\n}\n</pre>",
    "howToFix": "",
    "moreInfo": "<ul>\n  <li> <a href=\"https://phauer.com/2019/modern-best-practices-testing-java/#use-parameterized-tests\">Modern Best Practices for Testing in Java -\n  Philipp Hauer</a> </li>\n  <li> <a href=\"https://junit.org/junit5/docs/current/user-guide/#writing-tests-parameterized-tests\">JUnit 5 documentation - Parameterized tests</a>\n  </li>\n  <li> <a href=\"https://www.testwithspring.com/lesson/writing-parameterized-tests-with-junit-4/\">Writing Parameterized Tests With JUnit 4</a> </li>\n  <li> <a href=\"https://testng.org/#_parameters\">TestNG documentation - Parameters</a> </li>\n</ul>",
    "status": "READY",
    "name_ko": "유사한 테스트는 단일 Parameterized 테스트로 그룹화해야 합니다",
    "why_ko": "<p>여러 테스트가 몇 가지 하드코딩된 값으로만 다른 경우 단일 \"매개변수화된\" 테스트로 리팩터링해야 합니다. 이렇게 하면 버그 추가 가능성이 줄어들고 가독성이 향상됩니다. 매개변수화된 테스트는 대부분의 테스트 프레임워크(JUnit, TestNG 등)에 있습니다.</p>\n<p>물론 적절한 균형을 찾아야 합니다. 매개변수화된 버전이 초기 테스트보다 훨씬 복잡한 경우 테스트 메서드를 팩토링할 의미가 없습니다.</p>\n<p>이 규칙은 최소 3개의 테스트가 4개 미만의 매개변수를 가진 하나의 매개변수화된 테스트로 리팩터링될 수 있을 때 문제를 제기합니다. 하나 이상의 중복된 문이 있는 테스트 메서드만 고려됩니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<p>JUnit 5 사용</p>\n<pre>\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nimport org.junit.jupiter.api.Test;\n\npublic class AppTest\n{\n    @Test\n    void test_not_null1() {  // 규칙 위반. 다음 3개의 테스트는 하나의 하드코딩된 숫자로만 다릅니다.\n      setupTax();\n      assertNotNull(getTax(1));\n    }\n\n    @Test\n    void test_not_null2() {\n      setupTax();\n      assertNotNull(getTax(2));\n    }\n\n    @Test\n    void test_not_nul3l() {\n      setupTax();\n      assertNotNull(getTax(3));\n    }\n\n    @Test\n    void testLevel1() {  // 규칙 위반. 다음 3개의 테스트는 몇 가지 하드코딩된 숫자로만 다릅니다.\n        setLevel(1);\n        runGame();\n        assertEquals(playerHealth(), 100);\n    }\n\n    @Test\n    void testLevel2() {  // 유사한 테스트\n        setLevel(2);\n        runGame();\n        assertEquals(playerHealth(), 200);\n    }\n\n    @Test\n    void testLevel3() {  // 유사한 테스트\n        setLevel(3);\n        runGame();\n        assertEquals(playerHealth(), 300);\n    }\n}\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre>\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nimport org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.provider.CsvSource;\n\npublic class AppTest\n{\n\n   @ParameterizedTest\n   @ValueSource(ints = {1, 2, 3})\n   void test_not_null(int arg) {\n     setupTax();\n     assertNotNull(getTax(arg));\n   }\n\n    @ParameterizedTest\n    @CsvSource({\n        \"1, 100\",\n        \"2, 200\",\n        \"3, 300\",\n    })\n    void testLevels(int level, int health) {\n        setLevel(level);\n        runGame();\n        assertEquals(playerHealth(), health);\n    }\n}\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": "<ul>\n  <li> <a href=\"https://phauer.com/2019/modern-best-practices-testing-java/#use-parameterized-tests\">Java 테스트를 위한 현대적 모범 사례 - Philipp Hauer</a> </li>\n  <li> <a href=\"https://junit.org/junit5/docs/current/user-guide/#writing-tests-parameterized-tests\">JUnit 5 문서 - 매개변수화된 테스트</a> </li>\n  <li> <a href=\"https://www.testwithspring.com/lesson/writing-parameterized-tests-with-junit-4/\">JUnit 4로 매개변수화된 테스트 작성</a> </li>\n  <li> <a href=\"https://testng.org/#_parameters\">TestNG 문서 - 매개변수</a> </li>\n</ul>"
  },
  {
    "id": "S899",
    "key": "java:S899",
    "name": "Return values should not be ignored when they contain the operation status code",
    "type": "bug",
    "severity": "minor",
    "tags": [
      "error-handling",
      "cwe",
      "cert"
    ],
    "why": "<p>When the return value of a function call contains the operation status code, this value should be tested to make sure the operation completed\nsuccessfully.</p>\n<p>This rule raises an issue when the return values of the following are ignored:</p>\n<ul>\n  <li> <code>java.io.File</code> operations that return a status code (except <code>mkdirs</code>) </li>\n  <li> <code>Iterator.hasNext()</code> </li>\n  <li> <code>Enumeration.hasMoreElements()</code> </li>\n  <li> <code>Lock.tryLock()</code> </li>\n  <li> non-void <code>Condition.await*</code> methods </li>\n  <li> <code>CountDownLatch.await(long, TimeUnit)</code> </li>\n  <li> <code>Semaphore.tryAcquire</code> </li>\n  <li> <code>BlockingQueue</code>: <code>offer</code>, <code>remove</code> </li>\n</ul>\n<h3>Noncompliant code example</h3>\n<pre>\npublic void doSomething(File file, Lock lock) {\n  file.delete();  // Noncompliant\n  // ...\n  lock.tryLock(); // Noncompliant\n}\n</pre>\n<h3>Compliant solution</h3>\n<pre>\npublic void doSomething(File file, Lock lock) {\n  if (!lock.tryLock()) {\n    // lock failed; take appropriate action\n  }\n  if (!file.delete()) {\n    // file delete failed; take appropriate action\n  }\n}\n</pre>",
    "howToFix": "",
    "moreInfo": "<ul>\n  <li> <a href=\"https://wiki.sei.cmu.edu/confluence/x/xzdGBQ\">CERT, EXP00-J.</a> - Do not ignore values returned by methods </li>\n  <li> <a href=\"https://wiki.sei.cmu.edu/confluence/x/TTZGBQ\">CERT, FIO02-J.</a> - Detect and handle file-related errors </li>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/754\">CWE-754 - Improper Check for Unusual Exceptional Conditions</a> </li>\n</ul>",
    "status": "READY",
    "name_ko": "작업 상태 코드를 포함하는 반환값을 무시하면 안 됩니다",
    "why_ko": "<p>함수 호출의 반환값이 작업 상태 코드를 포함할 때, 작업이 성공적으로 완료되었는지 확인하기 위해 이 값을 테스트해야 합니다.</p>\n<p>이 규칙은 다음의 반환값이 무시될 때 이슈를 발생시킵니다:</p>\n<ul>\n  <li> 상태 코드를 반환하는 <code>java.io.File</code> 작업(<code>mkdirs</code> 제외) </li>\n  <li> <code>Iterator.hasNext()</code> </li>\n  <li> <code>Enumeration.hasMoreElements()</code> </li>\n  <li> <code>Lock.tryLock()</code> </li>\n  <li> void가 아닌 <code>Condition.await*</code> 메서드 </li>\n  <li> <code>CountDownLatch.await(long, TimeUnit)</code> </li>\n  <li> <code>Semaphore.tryAcquire</code> </li>\n  <li> <code>BlockingQueue</code>: <code>offer</code>, <code>remove</code> </li>\n</ul>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\npublic void doSomething(File file, Lock lock) {\n  file.delete();  // 규칙 위반\n  // ...\n  lock.tryLock(); // 규칙 위반\n}\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre>\npublic void doSomething(File file, Lock lock) {\n  if (!lock.tryLock()) {\n    // lock 실패; 적절한 조치 수행\n  }\n  if (!file.delete()) {\n    // 파일 삭제 실패; 적절한 조치 수행\n  }\n}\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": "<ul>\n  <li> <a href=\"https://wiki.sei.cmu.edu/confluence/x/xzdGBQ\">CERT, EXP00-J.</a> - 메서드가 반환하는 값을 무시하지 마세요 </li>\n  <li> <a href=\"https://wiki.sei.cmu.edu/confluence/x/TTZGBQ\">CERT, FIO02-J.</a> - 파일 관련 오류를 감지하고 처리하세요 </li>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/754\">CWE-754 - 비정상적인 예외 조건에 대한 부적절한 검사</a> </li>\n</ul>"
  },
  {
    "id": "S5833",
    "key": "java:S5833",
    "name": "AssertJ methods setting the assertion context should come before an assertion",
    "type": "bug",
    "severity": "major",
    "tags": [
      "tests",
      "assertj"
    ],
    "why": "<p>Describing, setting error message or adding a comparator in <a href=\"https://assertj.github.io/doc/\">AssertJ</a> must be done before calling the\nassertion, otherwise, settings will not be taken into account.</p>\n<p>This rule raises an issue when one of the method (with all similar methods):</p>\n<ul>\n  <li> <code>as</code> </li>\n  <li> <code>describedAs</code> </li>\n  <li> <code>withFailMessage</code> </li>\n  <li> <code>overridingErrorMessage</code> </li>\n  <li> <code>usingComparator</code> </li>\n  <li> <code>usingElementComparator</code> </li>\n  <li> <code>extracting</code> </li>\n  <li> <code>filteredOn</code> </li>\n</ul>\n<p>is called without calling an AssertJ assertion afterward.</p>\n<h3>Noncompliant code example</h3>\n<pre>\nassertThat(actual).isEqualTo(expected).as(\"Description\"); // Noncompliant\nassertThat(actual).isEqualTo(expected).withFailMessage(\"Fail message\"); // Noncompliant\nassertThat(actual).isEqualTo(expected).usingComparator(new CustomComparator()); // Noncompliant\n</pre>\n<h3>Compliant solution</h3>\n<pre>\nassertThat(actual).as(\"Description\").isEqualTo(expected);\nassertThat(actual).withFailMessage(\"Fail message\").isEqualTo(expected);\nassertThat(actual).usingComparator(new CustomComparator()).isEqualTo(expected);\n</pre>",
    "howToFix": "",
    "moreInfo": "<ul>\n  <li> <a href=\"https://assertj.github.io/doc/#calling-as-after-the-assertion\">AssertJ incorrect usage documentation</a> </li>\n</ul>",
    "status": "READY",
    "name_ko": "AssertJ의 assertion 컨텍스트 설정 메서드는 assertion 앞에 위치해야 합니다",
    "why_ko": "<p><a href=\"https://assertj.github.io/doc/\">AssertJ</a>에서 설명 추가, 오류 메시지 설정 또는 비교자 추가는 assertion을 호출하기 전에 수행해야 합니다. 그렇지 않으면 설정이 적용되지 않습니다.</p>\n<p>이 규칙은 다음 메서드(및 유사한 모든 메서드) 중 하나가 AssertJ assertion 호출 없이 사용될 때 문제를 제기합니다:</p>\n<ul>\n  <li> <code>as</code> </li>\n  <li> <code>describedAs</code> </li>\n  <li> <code>withFailMessage</code> </li>\n  <li> <code>overridingErrorMessage</code> </li>\n  <li> <code>usingComparator</code> </li>\n  <li> <code>usingElementComparator</code> </li>\n  <li> <code>extracting</code> </li>\n  <li> <code>filteredOn</code> </li>\n</ul>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\nassertThat(actual).isEqualTo(expected).as(\"Description\"); // 규칙 위반\nassertThat(actual).isEqualTo(expected).withFailMessage(\"Fail message\"); // 규칙 위반\nassertThat(actual).isEqualTo(expected).usingComparator(new CustomComparator()); // 규칙 위반\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre>\nassertThat(actual).as(\"Description\").isEqualTo(expected);\nassertThat(actual).withFailMessage(\"Fail message\").isEqualTo(expected);\nassertThat(actual).usingComparator(new CustomComparator()).isEqualTo(expected);\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": "<ul>\n  <li> <a href=\"https://assertj.github.io/doc/#calling-as-after-the-assertion\">AssertJ 잘못된 사용법 문서</a> </li>\n</ul>"
  },
  {
    "id": "S6073",
    "key": "java:S6073",
    "name": "Mockito argument matchers should be used on all parameters",
    "type": "bug",
    "severity": "major",
    "tags": [
      "tests",
      "mockito"
    ],
    "why": "<p>Mockito provides <em>argument matchers</em> and <em>argument captors</em> for flexibly stubbing or verifying method calls.</p>\n<p><code>Mockito.verify()</code>, <code>Mockito.when()</code>, <code>Stubber.when()</code> and <code>BDDMockito.given()</code> each have overloads\nwith and without argument matchers.</p>\n<p>However, if argument matchers or captors are used only on some of the parameters, all the parameters need to have matchers as well, otherwise an\n<code>InvalidUseOfMatchersException</code> will be thrown.</p>\n<p>This rule consequently raises an issue every time matchers are not used on all the parameters of a stubbed/verified method.</p>",
    "howToFix": "<h4>Noncompliant code example</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\n@Test\npublic void myTest() {\n    // Setting up mock responses\n    given(foo.bar(anyInt(), i1, i2)).willReturn(null); // Noncompliant, no matchers for \"i1\" and \"i2\"\n    when(foo.baz(eq(val1), val2)).thenReturn(\"hi\"); // Noncompliant, no matcher for \"val2\"\n\n    // Simulating exceptions\n    doThrow(new RuntimeException()).when(foo).quux(intThat(x -&gt; x &gt;= 42), -1); // Noncompliant, no matcher for \"-1\"\n\n    // Verifying method invocations\n    verify(foo).bar(i1, anyInt(), i2); // Noncompliant, no matchers for \"i1\" and \"i2\"\n\n    // Capturing arguments for verification\n    ArgumentCaptor&lt;Integer&gt; captor = ArgumentCaptor.forClass(Integer.class);\n    verify(foo).bar(captor.capture(), i1, any()); // Noncompliant, no matchers for \"i1\"\n}\n</pre>\n<h4>Compliant solution</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\n@Test\npublic void myTest() {\n    // Setting up mock responses\n    given(foo.bar(anyInt(), eq(i1), eq(i2))).willReturn(null); // Compliant, all arguments have matchers\n    when(foo.baz(val1, val2)).thenReturn(\"hi\"); // Compliant, no argument has matchers\n\n    // Simulating exceptions\n    doThrow(new RuntimeException()).when(foo).quux(intThat(x -&gt; x &gt;= 42), eq(-1)); // Compliant, all arguments have matchers\n\n    // Verifying method invocations\n    verify(foo).bar(eq(i1), anyInt(), eq(i2)); // Compliant, all arguments have matchers\n\n    // Capturing arguments for verification\n    ArgumentCaptor&lt;Integer&gt; captor = ArgumentCaptor.forClass(Integer.class);\n    verify(foo).bar(captor.capture(), any(), any()); // Compliant, all arguments have matchers\n}\n</pre>",
    "moreInfo": "<ul>\n  <li> <a href=\"https://javadoc.io/doc/org.mockito/mockito-core/latest/org/mockito/Mockito.html#argument_matchers\">Mockito documentation</a> -\n  argument matchers </li>\n  <li> <a href=\"https://sonarsource.github.io/rspec/#/rspec/<a href='/coding_rules#rule_key=java%3AS6068'>S6068</a>/java\"><a href='/coding_rules#rule_key=java%3AS6068'>S6068</a> - Call to Mockito method \"verify\", \"when\" or\n  \"given\" should be simplified</a> </li>\n</ul>",
    "status": "READY",
    "name_ko": "Mockito argument matcher는 모든 매개변수에 사용해야 합니다",
    "why_ko": "<p>Mockito는 메서드 호출을 유연하게 스텁하거나 검증하기 위한 <em>argument matcher</em>와 <em>argument captor</em>를 제공합니다.</p>\n<p><code>Mockito.verify()</code>, <code>Mockito.when()</code>, <code>Stubber.when()</code>, <code>BDDMockito.given()</code>은 각각 argument matcher가 있는 오버로드와 없는 오버로드가 있습니다.</p>\n<p>그러나 일부 매개변수에만 argument matcher나 captor가 사용되면, 모든 매개변수에 matcher가 있어야 합니다. 그렇지 않으면 <code>InvalidUseOfMatchersException</code>이 발생합니다.</p>\n<p>따라서 이 규칙은 스텁/검증된 메서드의 모든 매개변수에 matcher가 사용되지 않을 때마다 문제를 보고합니다.</p>",
    "howToFix_ko": "<h4>규칙을 준수하지 않는 코드 예시</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\n@Test\npublic void myTest() {\n    // mock 응답 설정\n    given(foo.bar(anyInt(), i1, i2)).willReturn(null); // 규칙 위반, \"i1\"과 \"i2\"에 matcher가 없음\n    when(foo.baz(eq(val1), val2)).thenReturn(\"hi\"); // 규칙 위반, \"val2\"에 matcher가 없음\n\n    // 예외 시뮬레이션\n    doThrow(new RuntimeException()).when(foo).quux(intThat(x -&gt; x &gt;= 42), -1); // 규칙 위반, \"-1\"에 matcher가 없음\n\n    // 메서드 호출 검증\n    verify(foo).bar(i1, anyInt(), i2); // 규칙 위반, \"i1\"과 \"i2\"에 matcher가 없음\n\n    // 검증을 위한 인자 캡처\n    ArgumentCaptor&lt;Integer&gt; captor = ArgumentCaptor.forClass(Integer.class);\n    verify(foo).bar(captor.capture(), i1, any()); // 규칙 위반, \"i1\"에 matcher가 없음\n}\n</pre>\n<h4>규칙을 준수하는 해결책</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\n@Test\npublic void myTest() {\n    // mock 응답 설정\n    given(foo.bar(anyInt(), eq(i1), eq(i2))).willReturn(null); // 규칙 준수, 모든 인자에 matcher가 있음\n    when(foo.baz(val1, val2)).thenReturn(\"hi\"); // 규칙 준수, 어떤 인자에도 matcher가 없음\n\n    // 예외 시뮬레이션\n    doThrow(new RuntimeException()).when(foo).quux(intThat(x -&gt; x &gt;= 42), eq(-1)); // 규칙 준수, 모든 인자에 matcher가 있음\n\n    // 메서드 호출 검증\n    verify(foo).bar(eq(i1), anyInt(), eq(i2)); // 규칙 준수, 모든 인자에 matcher가 있음\n\n    // 검증을 위한 인자 캡처\n    ArgumentCaptor&lt;Integer&gt; captor = ArgumentCaptor.forClass(Integer.class);\n    verify(foo).bar(captor.capture(), any(), any()); // 규칙 준수, 모든 인자에 matcher가 있음\n}\n</pre>",
    "moreInfo_ko": "<ul>\n  <li> <a href=\"https://javadoc.io/doc/org.mockito/mockito-core/latest/org/mockito/Mockito.html#argument_matchers\">Mockito 문서</a> - argument matcher </li>\n  <li> <a href=\"https://sonarsource.github.io/rspec/#/rspec/<a href='/coding_rules#rule_key=java%3AS6068'>S6068</a>/java\"><a href='/coding_rules#rule_key=java%3AS6068'>S6068</a> - Mockito 메서드 \"verify\", \"when\" 또는 \"given\" 호출은 단순화해야 합니다</a> </li>\n</ul>"
  },
  {
    "id": "S1309",
    "key": "java:S1309",
    "name": "Track uses of \"@SuppressWarnings\" annotations",
    "type": "code-smell",
    "severity": "info",
    "tags": [],
    "why": "<p>This rule allows you to track the usage of the <code>@SuppressWarnings</code> mechanism.</p>\n<h3>Noncompliant code example</h3>\n<p>With a parameter value of \"unused\" :</p>\n<pre>\n@SuppressWarnings(\"unused\")\n@SuppressWarnings(\"unchecked\")  // Noncompliant\n</pre>",
    "howToFix": "",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "\"@SuppressWarnings\" 어노테이션 사용을 추적합니다",
    "why_ko": "<p>이 규칙을 사용하면 <code>@SuppressWarnings</code> 메커니즘의 사용을 추적할 수 있습니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<p>파라미터 값이 \"unused\"인 경우:</p>\n<pre>\n@SuppressWarnings(\"unused\")\n@SuppressWarnings(\"unchecked\")  // 규칙 위반\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": ""
  },
  {
    "id": "S2175",
    "key": "java:S2175",
    "name": "Inappropriate \"Collection\" calls should not be made",
    "type": "bug",
    "severity": "major",
    "tags": [
      "cert"
    ],
    "why": "<p>The <code>java.util.Collection</code> type and its subtypes provide methods to access and modify collections such as <code>Collection.remove(Object\no)</code> and <code>Collection.contains(Object o)</code>. Some of these methods accept arguments of type <code>java.lang.Object</code> and will\ncompare said argument with objects already in the collection.</p>\n<p>If the actual type of the argument is unrelated to the type of object contained in the collection, these methods will always return\n<code>false</code>, <code>null</code>, or <code>-1</code>. This behavior is most likely unintended and can be indicative of a design issue.</p>\n<p>This rule raises an issue when the type of the argument provided to one of the following methods is unrelated to the type used for the collection\ndeclaration:</p>\n<ul>\n  <li> <code>Collection.remove(Object o)</code> </li>\n  <li> <code>Collection.removeAll(Collection&lt;?&gt;)</code> </li>\n  <li> <code>Collection.contains(Object o)</code> </li>\n  <li> <code>List.indexOf(Object o)</code> </li>\n  <li> <code>List.lastIndexOf(Object o)</code> </li>\n  <li> <code>Map.containsKey(Object key)</code> </li>\n  <li> <code>Map.containsValue(Object value)</code> </li>\n  <li> <code>Map.get(Object key)</code> </li>\n  <li> <code>Map.getOrDefault(Object key, V defaultValue)</code> </li>\n  <li> <code>Map.remove(Object key)</code> </li>\n  <li> <code>Map.remove(Object key, Object value)</code> </li>\n</ul>",
    "howToFix": "<p>Ask yourself what the purpose of this method call is. Check whether the provided argument and collection are correct in this context and for the\ndesired purpose. Remove unnecessary calls and otherwise provide an argument of which the type is compatible with the list content's type.</p>\n\n<h4>Noncompliant code example</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\nvoid removeFromMap(Map&lt;Integer, Object&gt; map, String strKey) {\n  map.remove(strKey); // Noncompliant, this call will remove nothing and always return 'null' because 'map' is handling only Integer keys and String cannot be cast to Integer.\n}\n\nvoid listContains(List&lt;String&gt; list, Integer integer) {\n  if (list.contains(integer)) { // Noncompliant; always false as the list only contains Strings, not integers.\n    // ...\n  }\n}\n</pre>\n<h4>Compliant solution</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\nvoid removeFromMap(Map&lt;Integer, Object&gt; map, String strKey) {\n  map.remove(Integer.parseInt(strKey)); // Compliant, strKey is parsed into an Integer before trying to remove it from the map.\n}\n\nvoid listContains(List&lt;String&gt; list, Integer integer) {\n  if (list.contains(integer.toString())) { // Compliant, 'integer' is converted to a String before checking if the list contains it.\n    // ...\n  }\n}\n</pre>",
    "moreInfo": "<ul>\n  <li> <a href=\"https://wiki.sei.cmu.edu/confluence/x/uDdGBQ\">CERT, EXP04-J.</a> - Do not pass arguments to certain Java Collections Framework methods\n  that are a different type than the collection parameter type </li>\n  <li> <a href=\"https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/Collection.html\">Java SE 17 &amp; JDK 17</a> - Collection\n  interface </li>\n</ul>",
    "status": "READY",
    "name_ko": "부적절한 \"Collection\" 호출은 하면 안 됩니다",
    "why_ko": "<p><code>java.util.Collection</code> 타입과 그 하위 타입은 <code>Collection.remove(Object o)</code> 및 <code>Collection.contains(Object o)</code>와 같이 컬렉션에 접근하고 수정하는 메서드를 제공합니다. 이러한 메서드 중 일부는 <code>java.lang.Object</code> 타입의 인자를 받아 해당 인자를 컬렉션에 이미 있는 객체와 비교합니다.</p>\n<p>인자의 실제 타입이 컬렉션에 포함된 객체의 타입과 관련이 없는 경우, 이러한 메서드는 항상 <code>false</code>, <code>null</code> 또는 <code>-1</code>을 반환합니다. 이 동작은 대부분 의도하지 않은 것이며 설계 문제를 나타낼 수 있습니다.</p>\n<p>이 규칙은 다음 메서드 중 하나에 제공된 인자의 타입이 컬렉션 선언에 사용된 타입과 관련이 없을 때 문제를 제기합니다:</p>\n<ul>\n  <li> <code>Collection.remove(Object o)</code> </li>\n  <li> <code>Collection.removeAll(Collection&lt;?&gt;)</code> </li>\n  <li> <code>Collection.contains(Object o)</code> </li>\n  <li> <code>List.indexOf(Object o)</code> </li>\n  <li> <code>List.lastIndexOf(Object o)</code> </li>\n  <li> <code>Map.containsKey(Object key)</code> </li>\n  <li> <code>Map.containsValue(Object value)</code> </li>\n  <li> <code>Map.get(Object key)</code> </li>\n  <li> <code>Map.getOrDefault(Object key, V defaultValue)</code> </li>\n  <li> <code>Map.remove(Object key)</code> </li>\n  <li> <code>Map.remove(Object key, Object value)</code> </li>\n</ul>",
    "howToFix_ko": "<p>이 메서드 호출의 목적이 무엇인지 스스로 확인하세요. 제공된 인자와 컬렉션이 이 컨텍스트와 원하는 목적에 맞는지 확인하세요. 불필요한 호출을 제거하고, 그렇지 않으면 리스트 내용의 타입과 호환되는 타입의 인자를 제공하세요.</p>\n\n<h4>규칙을 준수하지 않는 코드 예시</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\nvoid removeFromMap(Map&lt;Integer, Object&gt; map, String strKey) {\n  map.remove(strKey); // 규칙 위반, 이 호출은 아무것도 제거하지 않고 항상 'null'을 반환합니다. 'map'은 Integer 키만 처리하고 String은 Integer로 캐스팅할 수 없기 때문입니다.\n}\n\nvoid listContains(List&lt;String&gt; list, Integer integer) {\n  if (list.contains(integer)) { // 규칙 위반; 리스트는 String만 포함하고 Integer는 포함하지 않으므로 항상 false입니다.\n    // ...\n  }\n}\n</pre>\n<h4>규칙을 준수하는 해결책</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\nvoid removeFromMap(Map&lt;Integer, Object&gt; map, String strKey) {\n  map.remove(Integer.parseInt(strKey)); // 규칙 준수, strKey를 맵에서 제거하기 전에 Integer로 파싱합니다.\n}\n\nvoid listContains(List&lt;String&gt; list, Integer integer) {\n  if (list.contains(integer.toString())) { // 규칙 준수, 리스트에 포함되어 있는지 확인하기 전에 'integer'를 String으로 변환합니다.\n    // ...\n  }\n}\n</pre>",
    "moreInfo_ko": "<ul>\n  <li> <a href=\"https://wiki.sei.cmu.edu/confluence/x/uDdGBQ\">CERT, EXP04-J.</a> - 컬렉션 파라미터 타입과 다른 타입의 인자를 특정 Java Collections Framework 메서드에 전달하지 마세요 </li>\n  <li> <a href=\"https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/Collection.html\">Java SE 17 &amp; JDK 17</a> - Collection 인터페이스 </li>\n</ul>"
  },
  {
    "id": "S5960",
    "key": "java:S5960",
    "name": "Assertions should not be used in production code",
    "type": "bug",
    "severity": "major",
    "tags": [],
    "why": "<p>Assertions are intended to be used in <strong>test</strong> code, but not in <strong>production</strong> code. It is confusing, and might lead to\n<code>ClassNotFoundException</code> when the build tools only provide the required dependency in test scope.</p>\n<p>In addition, assertions will throw a sub-class of <code>Error</code>: <code>AssertionError</code>, which should be avoided in production code.</p>\n<p>This rule raises an issue when any assertion intended to be used in test is used in production code.</p>\n<p>Supported frameworks:</p>\n<ul>\n  <li> JUnit </li>\n  <li> FestAssert </li>\n  <li> AssertJ </li>\n</ul>\n<p>Note: this does not apply for <code>assert</code> from Java itself or if the source code package name is related to tests (contains:\n<code>test</code> or <code>assert</code> or <code>junit</code>).</p>",
    "howToFix": "",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "assertion은 프로덕션 코드에서 사용하면 안 됩니다",
    "why_ko": "<p>Assertion은 <strong>테스트</strong> 코드에서 사용하기 위한 것이지 <strong>프로덕션</strong> 코드에서 사용하기 위한 것이 아닙니다. 이는 혼란스럽고 빌드 도구가 테스트 범위에서만 필요한 의존성을 제공할 때 <code>ClassNotFoundException</code>이 발생할 수 있습니다.</p>\n<p>또한 assertion은 <code>Error</code>의 하위 클래스인 <code>AssertionError</code>를 throw하며, 이는 프로덕션 코드에서 피해야 합니다.</p>\n<p>이 규칙은 테스트에서 사용하도록 의도된 assertion이 프로덕션 코드에서 사용될 때 문제를 제기합니다.</p>\n<p>지원되는 프레임워크:</p>\n<ul>\n  <li> JUnit </li>\n  <li> FestAssert </li>\n  <li> AssertJ </li>\n</ul>\n<p>참고: 이것은 Java 자체의 <code>assert</code>에는 적용되지 않으며 소스 코드 패키지 이름이 테스트와 관련된 경우(<code>test</code> 또는 <code>assert</code> 또는 <code>junit</code> 포함)에도 적용되지 않습니다.</p>",
    "howToFix_ko": "",
    "moreInfo_ko": ""
  },
  {
    "id": "S1165",
    "key": "java:S1165",
    "name": "Exception classes should have final fields",
    "type": "code-smell",
    "severity": "minor",
    "tags": [
      "error-handling"
    ],
    "why": "<p>When a class has all <code>final</code> fields, the compiler ensures that the object's state remains constant. It also enforces a clear design\nintent of immutability, making the class easier to reason about and use correctly.</p>\n<p>Exceptions are meant to represent the application's state at the point at which an error occurred. Making all fields in an <code>Exception</code>\nclass <code>final</code> ensures that these class fields do not change after initialization.</p>\n<h3>Noncompliant code example</h3>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\npublic class MyException extends Exception {\n\n  private int status;                        // Noncompliant\n\n  public MyException(String message) {\n    super(message);\n  }\n\n  public int getStatus() {\n    return status;\n  }\n\n  public void setStatus(int status) {\n    this.status = status;\n  }\n\n}\n</pre>\n<h3>Compliant solution</h3>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\npublic class MyException extends Exception {\n\n  private final int status;                  // Compliant\n\n  public MyException(String message, int status) {\n    super(message);\n    this.status = status;\n  }\n\n  public int getStatus() {\n    return status;\n  }\n\n}\n</pre>",
    "howToFix": "",
    "moreInfo": "<ul>\n  <li> Effective Java 3rd Edition, Joshua Bloch - Exceptions - Item 76 : Strive for failure atomicity </li>\n</ul>",
    "status": "READY",
    "name_ko": "Exception 클래스는 final 필드를 가져야 합니다",
    "why_ko": "<p>클래스의 모든 필드가 <code>final</code>이면 컴파일러가 객체의 상태가 일정하게 유지되도록 보장합니다. 또한 불변성에 대한 명확한 설계 의도를 강제하여 클래스를 더 쉽게 이해하고 올바르게 사용할 수 있게 합니다.</p>\n<p>예외는 오류가 발생한 시점의 애플리케이션 상태를 나타내기 위한 것입니다. <code>Exception</code> 클래스의 모든 필드를 <code>final</code>로 만들면 이러한 클래스 필드가 초기화 후에 변경되지 않도록 합니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\npublic class MyException extends Exception {\n\n  private int status;                        // 규칙 위반\n\n  public MyException(String message) {\n    super(message);\n  }\n\n  public int getStatus() {\n    return status;\n  }\n\n  public void setStatus(int status) {\n    this.status = status;\n  }\n\n}\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\npublic class MyException extends Exception {\n\n  private final int status;                  // 규칙 준수\n\n  public MyException(String message, int status) {\n    super(message);\n    this.status = status;\n  }\n\n  public int getStatus() {\n    return status;\n  }\n\n}\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": "<ul>\n  <li> Effective Java 3판, Joshua Bloch - Exceptions - 항목 76 : 실패 원자성을 위해 노력하세요 </li>\n</ul>"
  },
  {
    "id": "S4449",
    "key": "java:S4449",
    "name": "Nullness of parameters should be guaranteed",
    "type": "code-smell",
    "severity": "major",
    "tags": [
      "symbolic-execution"
    ],
    "why": "<p>When using null-related annotations at global scope level, for instance using <code>javax.annotation.ParametersAreNonnullByDefault</code> (from\nJSR-305) at package level, it means that all the parameters to all the methods included in the package will, or should, be considered\nNon-<code>null</code>. It is equivalent to annotating every parameter in every method with non-null annotations (such as <code>@Nonnull</code>).</p>\n<p>The rule raises an issue every time a parameter could be <code>null</code> for a method invocation, where the method is annotated as forbidding\nnull parameters.</p>\n<h3>Noncompliant code example</h3>\n<pre>\n@javax.annotation.ParametersAreNonnullByDefault\nclass A {\n\n  void foo() {\n    bar(getValue()); // Noncompliant - method 'bar' do not expect 'null' values as parameter\n  }\n\n  void bar(Object o) { // 'o' is by contract expected never to be null\n    // ...\n  }\n\n  @javax.annotation.CheckForNull\n  abstract Object getValue();\n}\n</pre>\n<h3>Compliant solution</h3>\n<p>Two solutions are possible:</p>\n<ul>\n  <li> The signature of the method is correct, and null check should be done prior to the call. </li>\n  <li> The signature of the method is not coherent and should be annotated to allow null values being passed as parameter </li>\n</ul>\n<pre>\n@javax.annotation.ParametersAreNonnullByDefault\nabstract class A {\n\n  void foo() {\n      Object o = getValue();\n      if (o != null) {\n        bar(o); // Compliant - 'o' can not be null\n      }\n  }\n\n  void bar(Object o) {\n    // ...\n  }\n\n  @javax.annotation.CheckForNull\n  abstract Object getValue();\n}\n</pre>\n<p>or</p>\n<pre>\n@javax.annotation.ParametersAreNonnullByDefault\nabstract class A {\n\n  void foo() {\n    bar(getValue());\n  }\n\n  void bar(@javax.annotation.Nullable Object o) { // annotation was missing\n    // ...\n  }\n\n  @javax.annotation.CheckForNull\n  abstract Object getValue();\n}\n</pre>",
    "howToFix": "",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "매개변수의 null 여부가 보장되어야 합니다",
    "why_ko": "<p>글로벌 범위 수준에서 null 관련 어노테이션을 사용할 때, 예를 들어 패키지 수준에서 <code>javax.annotation.ParametersAreNonnullByDefault</code>(JSR-305에서)를 사용하면 패키지에 포함된 모든 메서드의 모든 매개변수가 Non-<code>null</code>로 간주되어야 합니다. 이는 모든 메서드의 모든 매개변수에 non-null 어노테이션(예: <code>@Nonnull</code>)을 추가하는 것과 동일합니다.</p>\n<p>이 규칙은 null 매개변수를 금지하는 것으로 어노테이션된 메서드 호출에서 매개변수가 <code>null</code>일 수 있을 때마다 문제를 제기합니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\n@javax.annotation.ParametersAreNonnullByDefault\nclass A {\n\n  void foo() {\n    bar(getValue()); // 규칙 위반 - 메서드 'bar'는 매개변수로 'null' 값을 예상하지 않음\n  }\n\n  void bar(Object o) { // 'o'는 계약상 절대 null이 아니어야 함\n    // ...\n  }\n\n  @javax.annotation.CheckForNull\n  abstract Object getValue();\n}\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<p>두 가지 해결책이 가능합니다:</p>\n<ul>\n  <li> 메서드의 시그니처가 올바르며, 호출 전에 null 검사를 수행해야 합니다. </li>\n  <li> 메서드의 시그니처가 일관성이 없으며, 매개변수로 null 값이 전달되도록 어노테이션을 추가해야 합니다. </li>\n</ul>\n<pre>\n@javax.annotation.ParametersAreNonnullByDefault\nabstract class A {\n\n  void foo() {\n      Object o = getValue();\n      if (o != null) {\n        bar(o); // 규칙 준수 - 'o'는 null이 될 수 없음\n      }\n  }\n\n  void bar(Object o) {\n    // ...\n  }\n\n  @javax.annotation.CheckForNull\n  abstract Object getValue();\n}\n</pre>\n<p>또는</p>\n<pre>\n@javax.annotation.ParametersAreNonnullByDefault\nabstract class A {\n\n  void foo() {\n    bar(getValue());\n  }\n\n  void bar(@javax.annotation.Nullable Object o) { // 어노테이션이 누락되었음\n    // ...\n  }\n\n  @javax.annotation.CheckForNull\n  abstract Object getValue();\n}\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": ""
  },
  {
    "id": "S2437",
    "key": "java:S2437",
    "name": "Unnecessary bit operations should not be performed",
    "type": "code-smell",
    "severity": "blocker",
    "tags": [
      "suspicious"
    ],
    "why": "<p>Certain bit operations are just silly and should not be performed because their results are predictable.</p>\n<p>Specifically, using <code>&amp; -1</code> with any value will always result in the original value, as will <code>anyValue ^ 0</code> and\n<code>anyValue | 0</code>.</p>",
    "howToFix": "",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "불필요한 비트 연산을 수행하면 안 됩니다",
    "why_ko": "<p>특정 비트 연산은 결과를 예측할 수 있기 때문에 어리석은 것이며 수행해서는 안 됩니다.</p>\n<p>구체적으로 어떤 값과 <code>&amp; -1</code>을 사용하면 항상 원래 값이 되며, <code>anyValue ^ 0</code>과 <code>anyValue | 0</code>도 마찬가지입니다.</p>",
    "howToFix_ko": "",
    "moreInfo_ko": ""
  },
  {
    "id": "S2122",
    "key": "java:S2122",
    "name": "\"ScheduledThreadPoolExecutor\" should not have 0 core threads",
    "type": "bug",
    "severity": "critical",
    "tags": [],
    "why": "<p><code>ThreadPoolExecutor</code> is an object that efficiently manages and controls the execution of multiple tasks in a thread pool. A thread pool\nis a collection of pre-initialized threads ready to execute tasks. Instead of creating a new thread for each task, which can be costly in terms of\nsystem resources, a thread pool reuses existing threads.</p>\n<p><code>java.util.concurrent.ScheduledThreadPoolExecutor</code> is an extension of <code>ThreadPoolExecutor</code> that can additionally schedule\ncommands to run after a given delay or to execute periodically.</p>\n<p><code>ScheduledThreadPoolExecutor</code> 's pool is sized with <code>corePoolSize</code>, so setting <code>corePoolSize</code> to zero means the\nexecutor will have no threads and run nothing. <code>corePoolSize</code> should have a value greater than zero and valid for your tasks.</p>\n<p>This rule detects instances where <code>corePoolSize</code> is set to zero via its setter or the object constructor.</p>\n<h3>Noncompliant code example</h3>\n<pre>\npublic void do(){\n\n  int poolSize = 5; // value greater than 0\n\n  ScheduledThreadPoolExecutor threadPool1 = new ScheduledThreadPoolExecutor(0); // Noncompliant\n\n  ScheduledThreadPoolExecutor threadPool2 = new ScheduledThreadPoolExecutor(poolSize);\n  threadPool2.setCorePoolSize(0);  // Noncompliant\n}\n</pre>",
    "howToFix": "",
    "moreInfo": "<h3>Documentation</h3>\n<ul>\n  <li> <a href=\"https://docs.oracle.com/en/java/javase/20/docs/api/java.base/java/util/concurrent/ScheduledThreadPoolExecutor.html\">Oracle Java SE -\n  ScheduledThreadPoolExecutor</a> </li>\n</ul>\n<h3>Articles &amp; blog posts</h3>\n<ul>\n  <li> <a href=\"https://engineering.zalando.com/posts/2019/04/how-to-set-an-ideal-thread-pool-size.html\">Zalando - How to set an ideal thread pool\n  size</a> </li>\n  <li> <a href=\"https://www.baeldung.com/java-threadpooltaskexecutor-core-vs-max-poolsize\">Baeldung - ThreadPoolTaskExecutor corePoolSize vs.\n  maxPoolSize</a> </li>\n</ul>",
    "status": "READY",
    "name_ko": "\"ScheduledThreadPoolExecutor\"는 0개의 코어 스레드를 가지면 안 됩니다",
    "why_ko": "<p><code>ThreadPoolExecutor</code>는 스레드 풀에서 여러 작업의 실행을 효율적으로 관리하고 제어하는 객체입니다. 스레드 풀은 작업을 실행할 준비가 된 사전 초기화된 스레드의 컬렉션입니다. 시스템 리소스 측면에서 비용이 많이 들 수 있는 각 작업에 대해 새 스레드를 생성하는 대신 스레드 풀은 기존 스레드를 재사용합니다.</p>\n<p><code>java.util.concurrent.ScheduledThreadPoolExecutor</code>는 주어진 지연 후에 명령을 실행하거나 주기적으로 실행하도록 추가로 스케줄링할 수 있는 <code>ThreadPoolExecutor</code>의 확장입니다.</p>\n<p><code>ScheduledThreadPoolExecutor</code>의 풀은 <code>corePoolSize</code>로 크기가 조정되므로 <code>corePoolSize</code>를 0으로 설정하면 실행기에 스레드가 없고 아무것도 실행하지 않습니다. <code>corePoolSize</code>는 0보다 크고 작업에 유효한 값을 가져야 합니다.</p>\n<p>이 규칙은 setter나 객체 생성자를 통해 <code>corePoolSize</code>가 0으로 설정된 인스턴스를 감지합니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\npublic void do(){\n\n  int poolSize = 5; // 0보다 큰 값\n\n  ScheduledThreadPoolExecutor threadPool1 = new ScheduledThreadPoolExecutor(0); // 규칙 위반\n\n  ScheduledThreadPoolExecutor threadPool2 = new ScheduledThreadPoolExecutor(poolSize);\n  threadPool2.setCorePoolSize(0);  // 규칙 위반\n}\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": "<h3>문서</h3>\n<ul>\n  <li> <a href=\"https://docs.oracle.com/en/java/javase/20/docs/api/java.base/java/util/concurrent/ScheduledThreadPoolExecutor.html\">Oracle Java SE - ScheduledThreadPoolExecutor</a> </li>\n</ul>\n<h3>관련 문서 및 블로그 게시물</h3>\n<ul>\n  <li> <a href=\"https://engineering.zalando.com/posts/2019/04/how-to-set-an-ideal-thread-pool-size.html\">Zalando - 이상적인 스레드 풀 크기 설정 방법</a> </li>\n  <li> <a href=\"https://www.baeldung.com/java-threadpooltaskexecutor-core-vs-max-poolsize\">Baeldung - ThreadPoolTaskExecutor corePoolSize vs. maxPoolSize</a> </li>\n</ul>"
  },
  {
    "id": "S6862",
    "key": "java:S6862",
    "name": "Beans in \"@Configuration\" class should have different names",
    "type": "bug",
    "severity": "major",
    "tags": [
      "spring"
    ],
    "why": "<p>Naming conventions play a crucial role in maintaining code clarity and readability. The uniqueness of bean names in Spring configurations is vital\nto the clarity and readability of the code. When two beans share the same name within a configuration, it is not obvious to the reader which bean is\nbeing referred to. This leads to potential misunderstandings and errors.</p>",
    "howToFix": "<p>To address this issue, ensure each bean within a configuration has a distinct and meaningful name. Choose names that accurately represent the\npurpose or functionality of the bean.</p>\n\n<h4>Noncompliant code example</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\n@Configuration\nclass Config {\n  @Bean\n  public User user() {\n    return currentUser();\n  }\n  @Bean\n  public User user(AuthService auth) { // Noncompliant\n    return auth.user();\n  }\n}\n</pre>\n<h4>Compliant solution</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\n@Configuration\nclass Config {\n  @Bean\n  public User user() {\n    return currentUser();\n  }\n  @Bean\n  public User userFromAuth(AuthService auth) {\n    return auth.user();\n  }\n}\n</pre>",
    "moreInfo": "<h3>Documentation</h3>\n<ul>\n  <li> <a href=\"https://docs.spring.io/spring-framework/reference/core/beans/java/basic-concepts.html\">Spring IO - Basic concepts: @Bean and\n  @Configuration</a> </li>\n  <li> <a href=\"https://docs.spring.io/spring-framework/reference/core/beans/java/configuration-annotation.html\">Spring IO - Using the @Configuration\n  annotation</a> </li>\n  <li> <a href=\"https://docs.spring.io/spring-framework/reference/core/beans/java/bean-annotation.html\">Spring IO - Using the @Bean annotation</a>\n  </li>\n</ul>",
    "status": "READY",
    "name_ko": "\"@Configuration\" 클래스의 Bean들은 서로 다른 이름을 가져야 합니다",
    "why_ko": "<p>명명 규칙은 코드의 명확성과 가독성을 유지하는 데 중요한 역할을 합니다. Spring 구성에서 빈 이름의 고유성은 코드의 명확성과 가독성에 필수적입니다. 구성 내에서 두 개의 빈이 같은 이름을 공유하면 독자가 어떤 빈을 참조하는지 명확하지 않습니다. 이로 인해 잠재적인 오해와 오류가 발생할 수 있습니다.</p>",
    "howToFix_ko": "<p>이 문제를 해결하려면 구성 내의 각 빈이 고유하고 의미 있는 이름을 갖도록 하세요. 빈의 목적이나 기능을 정확하게 나타내는 이름을 선택하세요.</p>\n\n<h4>규칙을 준수하지 않는 코드 예시</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\n@Configuration\nclass Config {\n  @Bean\n  public User user() {\n    return currentUser();\n  }\n  @Bean\n  public User user(AuthService auth) { // 규칙 위반\n    return auth.user();\n  }\n}\n</pre>\n<h4>규칙을 준수하는 해결책</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\n@Configuration\nclass Config {\n  @Bean\n  public User user() {\n    return currentUser();\n  }\n  @Bean\n  public User userFromAuth(AuthService auth) {\n    return auth.user();\n  }\n}\n</pre>",
    "moreInfo_ko": "<h3>문서</h3>\n<ul>\n  <li> <a href=\"https://docs.spring.io/spring-framework/reference/core/beans/java/basic-concepts.html\">Spring IO - 기본 개념: @Bean과 @Configuration</a> </li>\n  <li> <a href=\"https://docs.spring.io/spring-framework/reference/core/beans/java/configuration-annotation.html\">Spring IO - @Configuration 어노테이션 사용하기</a> </li>\n  <li> <a href=\"https://docs.spring.io/spring-framework/reference/core/beans/java/bean-annotation.html\">Spring IO - @Bean 어노테이션 사용하기</a> </li>\n</ul>"
  },
  {
    "id": "S134",
    "key": "java:S134",
    "name": "Control flow statements \"if\", \"for\", \"while\", \"switch\" and \"try\" should not be nested too deeply",
    "type": "code-smell",
    "severity": "critical",
    "tags": [
      "brain-overload"
    ],
    "why": "<p>Nested control flow statements such as <code>if</code>, <code>for</code>, <code>while</code>, <code>switch</code>, and <code>try</code> are often\nkey ingredients in creating what's known as \"Spaghetti code\". This code smell can make your program difficult to understand and maintain.</p>\n<p>When numerous control structures are placed inside one another, the code becomes a tangled, complex web. This significantly reduces the code's\nreadability and maintainability, and it also complicates the testing process.</p>",
    "howToFix": "<p>The following example demonstrates the behavior of the rule with the default threshold of 3 levels of nesting and one of the potential ways to fix\nthe code smell by introducing guard clauses:</p>\n<h4>Noncompliant code example</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\nif (condition1) {                  // Compliant - depth = 1\n  /* ... */\n  if (condition2) {                // Compliant - depth = 2\n    /* ... */\n    for (int i = 0; i &lt; 10; i++) {  // Compliant - depth = 3\n      /* ... */\n      if (condition4) {            // Noncompliant - depth = 4, which exceeds the limit\n        if (condition5) {          // Depth = 5, exceeding the limit, but issues are only reported on depth = 4\n          /* ... */\n        }\n        return;\n      }\n    }\n  }\n}\n</pre>\n<h4>Compliant solution</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\nif (!condition1) {\n  return;\n}\n/* ... */\nif (!condition2) {\n  return;\n}\nfor (int i = 0; i &lt; 10; i++) {\n  /* ... */\n  if (condition4) {\n    if (condition5) {\n      /* ... */\n    }\n    return;\n  }\n}\n</pre>",
    "moreInfo": "<ul>\n  <li> <a href=\"https://en.wikipedia.org/wiki/Guard_(computer_science)\">Guard clauses in programming</a> - one of the approaches to reducing the depth\n  of nesting </li>\n</ul>",
    "status": "READY",
    "name_ko": "제어 흐름 문 \"if\", \"for\", \"while\", \"switch\", \"try\"가 너무 깊게 중첩되면 안 됩니다",
    "why_ko": "<p><code>if</code>, <code>for</code>, <code>while</code>, <code>switch</code>, <code>try</code>와 같은 중첩된 제어 흐름 문은 종종 \"스파게티 코드\"로 알려진 것을 만드는 핵심 요소입니다. 이 코드 스멜은 프로그램을 이해하고 유지 관리하기 어렵게 만들 수 있습니다.</p>\n<p>수많은 제어 구조가 서로 안에 배치되면 코드는 얽히고 복잡한 그물이 됩니다. 이는 코드의 가독성과 유지 관리성을 크게 저하시키고 테스트 프로세스도 복잡하게 만듭니다.</p>",
    "howToFix_ko": "<p>다음 예시는 기본 임계값인 3단계 중첩과 가드 절을 도입하여 코드 스멜을 수정하는 잠재적인 방법 중 하나로 규칙의 동작을 보여줍니다:</p>\n<h4>규칙을 준수하지 않는 코드 예시</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\nif (condition1) {                  // 규칙 준수 - 깊이 = 1\n  /* ... */\n  if (condition2) {                // 규칙 준수 - 깊이 = 2\n    /* ... */\n    for (int i = 0; i &lt; 10; i++) {  // 규칙 준수 - 깊이 = 3\n      /* ... */\n      if (condition4) {            // 규칙 위반 - 깊이 = 4, 한계를 초과함\n        if (condition5) {          // 깊이 = 5, 한계를 초과하지만 깊이 = 4에서만 이슈가 보고됨\n          /* ... */\n        }\n        return;\n      }\n    }\n  }\n}\n</pre>\n<h4>규칙을 준수하는 해결책</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\nif (!condition1) {\n  return;\n}\n/* ... */\nif (!condition2) {\n  return;\n}\nfor (int i = 0; i &lt; 10; i++) {\n  /* ... */\n  if (condition4) {\n    if (condition5) {\n      /* ... */\n    }\n    return;\n  }\n}\n</pre>",
    "moreInfo_ko": "<ul>\n  <li> <a href=\"https://en.wikipedia.org/wiki/Guard_(computer_science)\">프로그래밍에서의 가드 절</a> - 중첩 깊이를 줄이는 접근 방법 중 하나 </li>\n</ul>"
  },
  {
    "id": "S4275",
    "key": "java:S4275",
    "name": "Getters and setters should access the expected fields",
    "type": "bug",
    "severity": "critical",
    "tags": [
      "pitfall"
    ],
    "why": "<p>Getters and setters provide a way to enforce encapsulation by providing <code>public</code> methods that give controlled access to\n<code>private</code> fields. However, in classes with multiple fields, it is not unusual that copy and paste is used to quickly create the needed\ngetters and setters, which can result in the wrong field being accessed by a getter or setter.</p>\n<p>This rule raises an issue in any of these cases:</p>\n<ul>\n  <li> A setter does not update the field with the corresponding name. </li>\n  <li> A getter does not access the field with the corresponding name. </li>\n</ul>\n<h3>Noncompliant code example</h3>\n<pre>\nclass A {\n  private int x;\n  private int y;\n\n  public void setX(int val) { // Noncompliant: field 'x' is not updated\n    this.y = val;\n  }\n\n  public int getY() { // Noncompliant: field 'y' is not used in the return value\n    return this.x;\n  }\n}\n</pre>\n<h3>Compliant solution</h3>\n<pre>\nclass A {\n  private int x;\n  private int y;\n\n  public void setX(int val) {\n    this.x = val;\n  }\n\n  public int getY() {\n    return this.y;\n  }\n}\n</pre>",
    "howToFix": "",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "Getter와 setter는 예상되는 필드에 접근해야 합니다",
    "why_ko": "<p>Getter와 setter는 <code>private</code> 필드에 대한 제어된 접근을 제공하는 <code>public</code> 메서드를 제공하여 캡슐화를 강제하는 방법을 제공합니다. 그러나 여러 필드가 있는 클래스에서는 필요한 getter와 setter를 빠르게 만들기 위해 복사-붙여넣기가 사용되는 것이 드문 일이 아니며, 이로 인해 getter나 setter가 잘못된 필드에 접근할 수 있습니다.</p>\n<p>이 규칙은 다음과 같은 경우에 문제를 제기합니다:</p>\n<ul>\n  <li> setter가 해당 이름을 가진 필드를 업데이트하지 않는 경우. </li>\n  <li> getter가 해당 이름을 가진 필드에 접근하지 않는 경우. </li>\n</ul>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\nclass A {\n  private int x;\n  private int y;\n\n  public void setX(int val) { // 규칙 위반: 필드 'x'가 업데이트되지 않습니다\n    this.y = val;\n  }\n\n  public int getY() { // 규칙 위반: 필드 'y'가 반환 값에 사용되지 않습니다\n    return this.x;\n  }\n}\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre>\nclass A {\n  private int x;\n  private int y;\n\n  public void setX(int val) {\n    this.x = val;\n  }\n\n  public int getY() {\n    return this.y;\n  }\n}\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": ""
  },
  {
    "id": "S1132",
    "key": "java:S1132",
    "name": "Strings literals should be placed on the left side when checking for equality",
    "type": "code-smell",
    "severity": "minor",
    "tags": [
      "bad-practice"
    ],
    "why": "<p>It is preferable to place string literals on the left-hand side of an <code>equals()</code> or <code>equalsIgnoreCase()</code> method call.</p>\n<p>This prevents null pointer exceptions from being raised, as a string literal can never be null by definition.</p>\n<h3>Noncompliant code example</h3>\n<pre>\nString myString = null;\n\nSystem.out.println(\"Equal? \" + myString.equals(\"foo\"));                        // Noncompliant; will raise a NPE\nSystem.out.println(\"Equal? \" + (myString != null &amp;&amp; myString.equals(\"foo\")));  // Noncompliant; null check could be removed\n</pre>\n<h3>Compliant solution</h3>\n<pre>\nSystem.out.println(\"Equal?\" + \"foo\".equals(myString));                         // properly deals with the null case\n</pre>",
    "howToFix": "",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "문자열 리터럴은 동등성 비교 시 왼쪽에 위치해야 합니다",
    "why_ko": "<p>문자열 리터럴은 <code>equals()</code> 또는 <code>equalsIgnoreCase()</code> 메서드 호출의 왼쪽에 배치하는 것이 바람직합니다.</p>\n<p>이렇게 하면 null 포인터 예외가 발생하는 것을 방지할 수 있습니다. 문자열 리터럴은 정의상 절대 null이 될 수 없기 때문입니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\nString myString = null;\n\nSystem.out.println(\"Equal? \" + myString.equals(\"foo\"));                        // 규칙 위반; NPE가 발생함\nSystem.out.println(\"Equal? \" + (myString != null &amp;&amp; myString.equals(\"foo\")));  // 규칙 위반; null 체크를 제거할 수 있음\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre>\nSystem.out.println(\"Equal?\" + \"foo\".equals(myString));                         // null 케이스를 적절히 처리함\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": ""
  },
  {
    "id": "S135",
    "key": "java:S135",
    "name": "Loops should not contain more than a single \"break\" or \"continue\" statement",
    "type": "code-smell",
    "severity": "minor",
    "tags": [
      "brain-overload"
    ],
    "why": "<p>The use of <code>break</code> and <code>continue</code> statements increases the complexity of the control flow and makes it harder to understand\nthe program logic. In order to keep a good program structure, they should not be applied more than once per loop.</p>\n<p>This rule reports an issue when there is more than one <code>break</code> or <code>continue</code> statement in a loop. The code should be\nrefactored to increase readability if there is more than one.</p>\n<h3>Noncompliant code example</h3>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\nfor (int i = 1; i &lt;= 10; i++) {     // Noncompliant; two \"continue\" statements\n  if (i % 2 == 0) {\n    continue;\n  }\n\n  if (i % 3 == 0) {\n    continue;\n  }\n  // ...\n}\n</pre>\n<h3>Compliant solution</h3>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\nfor (int i = 1; i &lt;= 10; i++) {\n  if (i % 2 == 0 || i % 3 == 0) {\n    continue;\n  }\n  // ...\n}\n</pre>",
    "howToFix": "",
    "moreInfo": "<h3>Documentation</h3>\n<ul>\n  <li> <a href=\"https://docs.oracle.com/javase/specs/jls/se20/html/jls-14.html#jls-14.7\">Oracle - Labeled Statements</a> </li>\n</ul>\n<h3>Articles &amp; blog posts</h3>\n<ul>\n  <li> <a href=\"https://softwareengineering.stackexchange.com/questions/185944/java-labels-to-be-or-not-to-be/185945\">StackExchange - Java labels. To\n  be or not to be</a> </li>\n  <li> <a href=\"https://stackoverflow.com/questions/33689466/labels-in-java-bad-practice\">StackOverflow - Labels in Java - bad practice?</a> </li>\n</ul>",
    "status": "READY",
    "name_ko": "루프에 \"break\" 또는 \"continue\" 문이 두 개 이상 있으면 안 됩니다",
    "why_ko": "<p><code>break</code>와 <code>continue</code> 문의 사용은 제어 흐름의 복잡성을 증가시키고 프로그램 로직을 이해하기 어렵게 만듭니다. 좋은 프로그램 구조를 유지하기 위해 루프당 한 번 이상 적용하면 안 됩니다.</p>\n<p>이 규칙은 루프에 <code>break</code> 또는 <code>continue</code> 문이 두 개 이상 있을 때 이슈를 보고합니다. 두 개 이상인 경우 가독성을 높이기 위해 코드를 리팩터링해야 합니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\nfor (int i = 1; i &lt;= 10; i++) {     // 규칙 위반; 두 개의 \"continue\" 문\n  if (i % 2 == 0) {\n    continue;\n  }\n\n  if (i % 3 == 0) {\n    continue;\n  }\n  // ...\n}\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\nfor (int i = 1; i &lt;= 10; i++) {\n  if (i % 2 == 0 || i % 3 == 0) {\n    continue;\n  }\n  // ...\n}\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": "<h3>문서</h3>\n<ul>\n  <li> <a href=\"https://docs.oracle.com/javase/specs/jls/se20/html/jls-14.html#jls-14.7\">Oracle - 레이블된 문</a> </li>\n</ul>\n<h3>관련 글 및 블로그 포스트</h3>\n<ul>\n  <li> <a href=\"https://softwareengineering.stackexchange.com/questions/185944/java-labels-to-be-or-not-to-be/185945\">StackExchange - Java 레이블. 사용해야 하나 말아야 하나</a> </li>\n  <li> <a href=\"https://stackoverflow.com/questions/33689466/labels-in-java-bad-practice\">StackOverflow - Java의 레이블 - 나쁜 관행인가요?</a> </li>\n</ul>"
  },
  {
    "id": "S4274",
    "key": "java:S4274",
    "name": "Asserts should not be used to check the parameters of a public method",
    "type": "code-smell",
    "severity": "major",
    "tags": [
      "pitfall"
    ],
    "why": "<p>An <code>assert</code> is inappropriate for parameter validation because assertions can be disabled at runtime in the JVM, meaning that a bad\noperational setting would completely eliminate the intended checks. Further, <code>assert</code>s that fail throw <code>AssertionError</code>s, rather\nthan throwing some type of <code>Exception</code>. Throwing <code>Error</code>s is completely outside of the normal realm of expected\n<code>catch</code>/<code>throw</code> behavior in normal programs.</p>\n<p>This rule raises an issue when a <code>public</code> method uses one or more of its parameters with <code>assert</code>s.</p>\n<h3>Noncompliant code example</h3>\n<pre>\n public void setPrice(int price) {\n  assert price &gt;= 0 &amp;&amp; price &lt;= MAX_PRICE;\n  // Set the price\n }\n</pre>\n<h3>Compliant solution</h3>\n<pre>\n public void setPrice(int price) {\n  if (price &lt; 0 || price &gt; MAX_PRICE) {\n    throw new IllegalArgumentException(\"Invalid price: \" + price);\n  }\n  // Set the price\n }\n</pre>",
    "howToFix": "",
    "moreInfo": "<p><a href=\"https://docs.oracle.com/javase/7/docs/technotes/guides/language/assert.html\">Programming With Assertions</a></p>",
    "status": "READY",
    "name_ko": "public 메서드의 파라미터 검사에 assert를 사용하면 안 됩니다",
    "why_ko": "<p><code>assert</code>는 JVM에서 런타임에 비활성화될 수 있기 때문에 파라미터 검증에 부적절합니다. 이는 잘못된 운영 설정이 의도한 검사를 완전히 제거할 수 있음을 의미합니다. 또한 실패한 <code>assert</code>는 특정 유형의 <code>Exception</code>을 던지는 것이 아니라 <code>AssertionError</code>를 던집니다. <code>Error</code>를 던지는 것은 일반 프로그램에서 예상되는 <code>catch</code>/<code>throw</code> 동작의 정상적인 범위를 완전히 벗어납니다.</p>\n<p>이 규칙은 <code>public</code> 메서드가 <code>assert</code>와 함께 하나 이상의 파라미터를 사용할 때 문제를 제기합니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\n public void setPrice(int price) {\n  assert price &gt;= 0 &amp;&amp; price &lt;= MAX_PRICE;\n  // 가격 설정\n }\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre>\n public void setPrice(int price) {\n  if (price &lt; 0 || price &gt; MAX_PRICE) {\n    throw new IllegalArgumentException(\"Invalid price: \" + price);\n  }\n  // 가격 설정\n }\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": "<p><a href=\"https://docs.oracle.com/javase/7/docs/technotes/guides/language/assert.html\">Programming With Assertions</a></p>"
  },
  {
    "id": "S1133",
    "key": "java:S1133",
    "name": "Deprecated code should be removed",
    "type": "code-smell",
    "severity": "info",
    "tags": [
      "obsolete"
    ],
    "why": "<p>This rule is meant to be used as a way to track code which is marked as being deprecated. Deprecated code should eventually be removed.</p>\n<h3>Noncompliant code example</h3>\n<pre>\nclass Foo {\n  /**\n   * @deprecated\n   */\n  public void foo() {    // Noncompliant\n  }\n\n  @Deprecated            // Noncompliant\n  public void bar() {\n  }\n\n  public void baz() {    // Compliant\n  }\n}\n</pre>",
    "howToFix": "",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "Deprecated 코드는 제거해야 합니다",
    "why_ko": "<p>이 규칙은 deprecated로 표시된 코드를 추적하기 위한 것입니다. Deprecated 코드는 결국 제거되어야 합니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\nclass Foo {\n  /**\n   * @deprecated\n   */\n  public void foo() {    // 규칙 위반\n  }\n\n  @Deprecated            // 규칙 위반\n  public void bar() {\n  }\n\n  public void baz() {    // 규칙 준수\n  }\n}\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": ""
  },
  {
    "id": "S2066",
    "key": "java:S2066",
    "name": "\"Serializable\" inner classes of non-serializable outer classes should be \"static\"",
    "type": "bug",
    "severity": "minor",
    "tags": [
      "serialization",
      "cert"
    ],
    "why": "<p>Non-static inner classes contain a reference to an instance of the outer class. Hence, serializing a non-static inner class will result in an\nattempt at serializing the outer class as well. If the outer class is not serializable, serialization will fail, resulting in a runtime error.</p>\n<p>Making the inner class <code>static</code> (i.e., \"nested\") avoids this problem, as no reference to an instance of the outer class is required.\nSerializing the inner class can be done independently of the outer class. Hence, inner classes implementing <code>Serializable</code> should be\n<code>static</code> if the outer class does not implement <code>Serializable</code>.</p>\n<p>Be aware of the semantic differences between an inner class and a nested one:</p>\n<ul>\n  <li> an inner class can only be instantiated within the context of an instance of the outer class. </li>\n  <li> a nested (<code>static</code>) class can be instantiated independently of the outer class. </li>\n</ul>",
    "howToFix": "<p>Make the inner class <code>static</code> or make the outer class <code>Serializable</code>.</p>\n\n<h4>Noncompliant code example</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\npublic class Pomegranate {\n  // ...\n\n  public class Seed implements Serializable {  // Noncompliant, serialization will fail due to the outer class not being serializable\n    // ...\n  }\n}\n</pre>\n<h4>Compliant solution</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\npublic class Pomegranate {\n  // ...\n\n  public static class Seed implements Serializable { // Compliant, the outer class will not be serialized and hence cannot be the cause for a failure at runtime\n    // ...\n  }\n}\n</pre>",
    "moreInfo": "<ul>\n  <li> <a href=\"https://wiki.sei.cmu.edu/confluence/x/ZTdGBQ\">CERT SER05-J.</a> - Do not serialize instances of inner classes </li>\n</ul>",
    "status": "READY",
    "name_ko": "직렬화 불가능한 외부 클래스의 \"Serializable\" 내부 클래스는 \"static\"이어야 합니다",
    "why_ko": "<p>비-static 내부 클래스는 외부 클래스의 인스턴스에 대한 참조를 포함합니다. 따라서 비-static 내부 클래스를 직렬화하면 외부 클래스도 직렬화하려는 시도가 발생합니다. 외부 클래스가 직렬화 가능하지 않으면 직렬화가 실패하여 런타임 오류가 발생합니다.</p>\n<p>내부 클래스를 <code>static</code>(즉, \"중첩\")으로 만들면 외부 클래스의 인스턴스에 대한 참조가 필요하지 않으므로 이 문제를 피할 수 있습니다. 내부 클래스의 직렬화는 외부 클래스와 독립적으로 수행될 수 있습니다. 따라서 외부 클래스가 <code>Serializable</code>을 구현하지 않는 경우 <code>Serializable</code>을 구현하는 내부 클래스는 <code>static</code>이어야 합니다.</p>\n<p>내부 클래스와 중첩 클래스 사이의 의미적 차이를 인식하세요:</p>\n<ul>\n  <li> 내부 클래스는 외부 클래스의 인스턴스 컨텍스트 내에서만 인스턴스화할 수 있습니다. </li>\n  <li> 중첩(<code>static</code>) 클래스는 외부 클래스와 독립적으로 인스턴스화할 수 있습니다. </li>\n</ul>",
    "howToFix_ko": "<p>내부 클래스를 <code>static</code>으로 만들거나 외부 클래스를 <code>Serializable</code>로 만드세요.</p>\n\n<h4>규칙을 준수하지 않는 코드 예시</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\npublic class Pomegranate {\n  // ...\n\n  public class Seed implements Serializable {  // 규칙 위반, 외부 클래스가 직렬화 가능하지 않아 직렬화가 실패합니다\n    // ...\n  }\n}\n</pre>\n<h4>규칙을 준수하는 해결책</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\npublic class Pomegranate {\n  // ...\n\n  public static class Seed implements Serializable { // 규칙 준수, 외부 클래스가 직렬화되지 않으므로 런타임 실패의 원인이 될 수 없습니다\n    // ...\n  }\n}\n</pre>",
    "moreInfo_ko": "<ul>\n  <li> <a href=\"https://wiki.sei.cmu.edu/confluence/x/ZTdGBQ\">CERT SER05-J.</a> - Do not serialize instances of inner classes </li>\n</ul>"
  },
  {
    "id": "S6926",
    "key": "java:S6926",
    "name": "Bluetooth should be configured to use low power",
    "type": "code-smell",
    "severity": "major",
    "tags": [
      "android",
      "sustainability"
    ],
    "why": "<p>Using high power consumption modes for Bluetooth operations can drain the device battery faster and may not be suitable for scenarios where power\nefficiency is crucial.</p>\n<p>This rule identifies instances where high power consumption Bluetooth operations are used, specifically when <code>requestConnectionPriority</code>\nor <code>setAdvertiseMode</code> methods are invoked with arguments other than those promoting low power consumption.</p>",
    "howToFix": "<ul>\n  <li> Use <code>CONNECTION_PRIORITY_LOW_POWER</code> for <code>requestConnectionPriority</code> method. </li>\n  <li> Use <code>ADVERTISE_MODE_LOW_POWER</code> for <code>setAdvertiseMode</code> method to promote low power consumption. </li>\n</ul>\n\n<h4>Noncompliant code example</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\npublic class BluetoothExample {\n    private final BluetoothGattCallback gattCallback = new BluetoothGattCallback() {\n        @Override\n        public void onConnectionStateChange(BluetoothGatt gatt, int status, int newState) {\n          // ...\n        }\n\n        @Override\n        public void onServicesDiscovered(BluetoothGatt gatt, int status) {\n            if (status == BluetoothGatt.GATT_SUCCESS) {\n                gatt.requestConnectionPriority(BluetoothGatt.CONNECTION_PRIORITY_HIGH); // Noncompliant\n            }\n        }\n    };\n}\n</pre>\n<h4>Compliant solution</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\npublic class BluetoothExample {\n   private final BluetoothGattCallback gattCallback = new BluetoothGattCallback() {\n        @Override\n        public void onConnectionStateChange(BluetoothGatt gatt, int status, int newState) {\n          // ...\n        }\n\n        @Override\n        public void onServicesDiscovered(BluetoothGatt gatt, int status) {\n            if (status == BluetoothGatt.GATT_SUCCESS) {\n                gatt.requestConnectionPriority(BluetoothGatt.CONNECTION_PRIORITY_LOW_POWER); // Compliant\n            }\n        }\n    };\n}\n</pre>\n<h4>Noncompliant code example</h4>\n<pre data-diff-id=\"2\" data-diff-type=\"noncompliant\">\npublic class BluetoothExample {\n    private void startAdvertising() {\n        AdvertiseSettings.Builder settingsBuilder = new AdvertiseSettings.Builder();\n        settingsBuilder.setAdvertiseMode(AdvertiseSettings.ADVERTISE_MODE_LOW_LATENCY); // Noncompliant\n        // Other settings configuration...\n    }\n}\n</pre>\n<h4>Compliant solution</h4>\n<pre data-diff-id=\"2\" data-diff-type=\"compliant\">\npublic class BluetoothExample {\n    private void startAdvertising() {\n        AdvertiseSettings.Builder settingsBuilder = new AdvertiseSettings.Builder();\n        settingsBuilder.setAdvertiseMode(AdvertiseSettings.ADVERTISE_MODE_LOW_POWER); // Compliant\n        // Other settings configuration...\n    }\n}\n</pre>",
    "moreInfo": "<h3>Documentation</h3>\n<ul>\n  <li> <a href=\"https://developer.android.com/reference/android/bluetooth/BluetoothGattCallback\">Android Developers - BluetoothGattCallback</a> </li>\n  <li> <a href=\"https://developer.android.com/reference/android/bluetooth/BluetoothGatt\">Android Developers - BluetoothGatt</a> </li>\n  <li> <a href=\"https://developer.android.com/reference/android/bluetooth/BluetoothDevice\">Android Developers - BluetoothDevice</a> </li>\n  <li> <a href=\"https://developer.android.com/reference/android/bluetooth/le/AdvertiseSettings.Builder\">Android Developers -\n  AdvertiseSettings.Builder</a> </li>\n</ul>",
    "status": "READY",
    "name_ko": "Bluetooth는 저전력을 사용하도록 설정해야 합니다",
    "why_ko": "<p>Bluetooth 작업에 높은 전력 소비 모드를 사용하면 기기 배터리가 더 빨리 소모될 수 있으며 전력 효율성이 중요한 시나리오에는 적합하지 않을 수 있습니다.</p>\n<p>이 규칙은 높은 전력 소비 Bluetooth 작업이 사용되는 인스턴스를 식별합니다. 특히 <code>requestConnectionPriority</code> 또는 <code>setAdvertiseMode</code> 메서드가 저전력 소비를 촉진하는 인수가 아닌 다른 인수로 호출될 때입니다.</p>",
    "howToFix_ko": "<ul>\n  <li> <code>requestConnectionPriority</code> 메서드에는 <code>CONNECTION_PRIORITY_LOW_POWER</code>를 사용하세요. </li>\n  <li> 저전력 소비를 촉진하려면 <code>setAdvertiseMode</code> 메서드에 <code>ADVERTISE_MODE_LOW_POWER</code>를 사용하세요. </li>\n</ul>\n\n<h4>규칙을 준수하지 않는 코드 예시</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\npublic class BluetoothExample {\n    private final BluetoothGattCallback gattCallback = new BluetoothGattCallback() {\n        @Override\n        public void onConnectionStateChange(BluetoothGatt gatt, int status, int newState) {\n          // ...\n        }\n\n        @Override\n        public void onServicesDiscovered(BluetoothGatt gatt, int status) {\n            if (status == BluetoothGatt.GATT_SUCCESS) {\n                gatt.requestConnectionPriority(BluetoothGatt.CONNECTION_PRIORITY_HIGH); // 규칙 위반\n            }\n        }\n    };\n}\n</pre>\n<h4>규칙을 준수하는 해결책</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\npublic class BluetoothExample {\n   private final BluetoothGattCallback gattCallback = new BluetoothGattCallback() {\n        @Override\n        public void onConnectionStateChange(BluetoothGatt gatt, int status, int newState) {\n          // ...\n        }\n\n        @Override\n        public void onServicesDiscovered(BluetoothGatt gatt, int status) {\n            if (status == BluetoothGatt.GATT_SUCCESS) {\n                gatt.requestConnectionPriority(BluetoothGatt.CONNECTION_PRIORITY_LOW_POWER); // 규칙 준수\n            }\n        }\n    };\n}\n</pre>\n<h4>규칙을 준수하지 않는 코드 예시</h4>\n<pre data-diff-id=\"2\" data-diff-type=\"noncompliant\">\npublic class BluetoothExample {\n    private void startAdvertising() {\n        AdvertiseSettings.Builder settingsBuilder = new AdvertiseSettings.Builder();\n        settingsBuilder.setAdvertiseMode(AdvertiseSettings.ADVERTISE_MODE_LOW_LATENCY); // 규칙 위반\n        // 기타 설정 구성...\n    }\n}\n</pre>\n<h4>규칙을 준수하는 해결책</h4>\n<pre data-diff-id=\"2\" data-diff-type=\"compliant\">\npublic class BluetoothExample {\n    private void startAdvertising() {\n        AdvertiseSettings.Builder settingsBuilder = new AdvertiseSettings.Builder();\n        settingsBuilder.setAdvertiseMode(AdvertiseSettings.ADVERTISE_MODE_LOW_POWER); // 규칙 준수\n        // 기타 설정 구성...\n    }\n}\n</pre>",
    "moreInfo_ko": "<h3>문서</h3>\n<ul>\n  <li> <a href=\"https://developer.android.com/reference/android/bluetooth/BluetoothGattCallback\">Android Developers - BluetoothGattCallback</a> </li>\n  <li> <a href=\"https://developer.android.com/reference/android/bluetooth/BluetoothGatt\">Android Developers - BluetoothGatt</a> </li>\n  <li> <a href=\"https://developer.android.com/reference/android/bluetooth/BluetoothDevice\">Android Developers - BluetoothDevice</a> </li>\n  <li> <a href=\"https://developer.android.com/reference/android/bluetooth/le/AdvertiseSettings.Builder\">Android Developers - AdvertiseSettings.Builder</a> </li>\n</ul>"
  },
  {
    "id": "S2123",
    "key": "java:S2123",
    "name": "Values should not be uselessly incremented",
    "type": "bug",
    "severity": "major",
    "tags": [
      "unused"
    ],
    "why": "<p>A value that is incremented or decremented and then not stored is at best wasted code and at worst a bug.</p>\n<h3>Noncompliant code example</h3>\n<pre>\npublic int pickNumber() {\n  int i = 0;\n  int j = 0;\n\n  i = i++; // Noncompliant; i is still zero\n\n  return j++; // Noncompliant; 0 returned\n}\n</pre>\n<h3>Compliant solution</h3>\n<pre>\npublic int pickNumber() {\n  int i = 0;\n  int j = 0;\n\n  i++;\n  return ++j;\n}\n</pre>",
    "howToFix": "",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "값을 무의미하게 증가시키면 안 됩니다",
    "why_ko": "<p>증가하거나 감소한 후 저장되지 않는 값은 기껏해야 낭비되는 코드이고 최악의 경우 버그입니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\npublic int pickNumber() {\n  int i = 0;\n  int j = 0;\n\n  i = i++; // 규칙 위반; i는 여전히 0\n\n  return j++; // 규칙 위반; 0이 반환됨\n}\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre>\npublic int pickNumber() {\n  int i = 0;\n  int j = 0;\n\n  i++;\n  return ++j;\n}\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": ""
  },
  {
    "id": "S6863",
    "key": "java:S6863",
    "name": "Set appropriate Status Codes on HTTP responses",
    "type": "bug",
    "severity": "major",
    "tags": [
      "spring",
      "best-practice"
    ],
    "why": "<p>The request handler function in a <code>Controller</code> should set the appropriate HTTP status code based on the operation's success or failure.\nThis is done by returning a <code>Response</code> object with the appropriate status code.</p>\n<p>If an exception is thrown during the execution of the handler, the status code should be in the range of 4xx or 5xx. Examples of such codes are\n<code>BAD_REQUEST</code>, <code>UNAUTHORIZED</code>, <code>FORBIDDEN</code>, <code>NOT_FOUND</code>, <code>INTERNAL_SERVER_ERROR</code>,\n<code>BAD_GATEWAY</code>, <code>SERVICE_UNAVAILABLE</code>, etc.</p>\n<p>The status code should be 1xx, 2xx, or 3xx if no exception is thrown and the operation is considered successful. Such codes include\n<code>OK</code>, <code>CREATED</code>, <code>MOVED_PERMANENTLY</code>, <code>FOUND</code>, etc.</p>",
    "howToFix": "<h4>Noncompliant code example</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\n@Controller\npublic class UserController {\n    public ResponseEntity&lt;User&gt; getUserById(Long userId) {\n        try {\n            User user = userService.getUserById(userId);\n            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(user); // Noncompliant: Setting 500 for a successful operation\n        } catch (Exception e) {\n            return ResponseEntity.status(HttpStatus.OK).build(); // Noncompliant: Setting 200 for exception\n        }\n    }\n}\n</pre>\n<h4>Compliant solution</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\n@Controller\npublic class UserController {\n    public ResponseEntity&lt;User&gt; getUserById(Long userId) {\n        try {\n            User user = userService.getUserById(userId);\n            return ResponseEntity.ok(user); // Compliant: Setting 200 for a successful operation\n        } catch (Exception e) {\n            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build(); // Compliant: Setting 500 for exception\n        }\n    }\n}\n</pre>",
    "moreInfo": "<h3>Documentation</h3>\n<ul>\n  <li> <a href=\"https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/http/HttpStatus.html\">Spring Java Documentation -\n  HttpStatus</a> </li>\n  <li> <a href=\"https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/http/ResponseEntity.html\">Spring Java\n  Documentation - ResponseEntity</a> </li>\n  <li> <a href=\"https://docs.spring.io/spring-framework/reference/web/webmvc/mvc-controller/ann-methods/responseentity.html\">Spring Framework\n  Documentation - ResponseEntity</a> </li>\n  <li> <a href=\"https://docs.spring.io/spring-framework/reference/web/webmvc/mvc-ann-rest-exceptions.html\">Spring Framework Documentation - Exception\n  Handling</a> </li>\n</ul>\n<h3>Standards</h3>\n<ul>\n  <li> <a href=\"https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml\">IANA - Hypertext Transfer Protocol (HTTP) Status Code\n  Registry</a> </li>\n</ul>",
    "status": "READY",
    "name_ko": "HTTP 응답에 적절한 상태 코드를 설정하세요",
    "why_ko": "<p><code>Controller</code>의 요청 핸들러 함수는 작업의 성공 또는 실패에 따라 적절한 HTTP 상태 코드를 설정해야 합니다. 이는 적절한 상태 코드가 있는 <code>Response</code> 객체를 반환하여 수행됩니다.</p>\n<p>핸들러 실행 중에 예외가 발생하면 상태 코드는 4xx 또는 5xx 범위여야 합니다. 이러한 코드의 예로는 <code>BAD_REQUEST</code>, <code>UNAUTHORIZED</code>, <code>FORBIDDEN</code>, <code>NOT_FOUND</code>, <code>INTERNAL_SERVER_ERROR</code>, <code>BAD_GATEWAY</code>, <code>SERVICE_UNAVAILABLE</code> 등이 있습니다.</p>\n<p>예외가 발생하지 않고 작업이 성공적으로 간주되면 상태 코드는 1xx, 2xx 또는 3xx여야 합니다. 이러한 코드에는 <code>OK</code>, <code>CREATED</code>, <code>MOVED_PERMANENTLY</code>, <code>FOUND</code> 등이 포함됩니다.</p>",
    "howToFix_ko": "<h4>규칙을 준수하지 않는 코드 예시</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\n@Controller\npublic class UserController {\n    public ResponseEntity&lt;User&gt; getUserById(Long userId) {\n        try {\n            User user = userService.getUserById(userId);\n            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(user); // 규칙 위반: 성공적인 작업에 500 설정\n        } catch (Exception e) {\n            return ResponseEntity.status(HttpStatus.OK).build(); // 규칙 위반: 예외에 200 설정\n        }\n    }\n}\n</pre>\n<h4>규칙을 준수하는 해결책</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\n@Controller\npublic class UserController {\n    public ResponseEntity&lt;User&gt; getUserById(Long userId) {\n        try {\n            User user = userService.getUserById(userId);\n            return ResponseEntity.ok(user); // 규칙 준수: 성공적인 작업에 200 설정\n        } catch (Exception e) {\n            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build(); // 규칙 준수: 예외에 500 설정\n        }\n    }\n}\n</pre>",
    "moreInfo_ko": "<h3>문서</h3>\n<ul>\n  <li> <a href=\"https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/http/HttpStatus.html\">Spring Java 문서 - HttpStatus</a> </li>\n  <li> <a href=\"https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/http/ResponseEntity.html\">Spring Java 문서 - ResponseEntity</a> </li>\n  <li> <a href=\"https://docs.spring.io/spring-framework/reference/web/webmvc/mvc-controller/ann-methods/responseentity.html\">Spring Framework 문서 - ResponseEntity</a> </li>\n  <li> <a href=\"https://docs.spring.io/spring-framework/reference/web/webmvc/mvc-ann-rest-exceptions.html\">Spring Framework 문서 - 예외 처리</a> </li>\n</ul>\n<h3>표준</h3>\n<ul>\n  <li> <a href=\"https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml\">IANA - HTTP(Hypertext Transfer Protocol) 상태 코드 레지스트리</a> </li>\n</ul>"
  },
  {
    "id": "S5961",
    "key": "java:S5961",
    "name": "Test methods should not contain too many assertions",
    "type": "code-smell",
    "severity": "major",
    "tags": [
      "tests"
    ],
    "why": "<p>A common good practice is to write test methods targeting only one logical concept, that can only fail for one reason.</p>\n<p>While it might make sense to have more than one assertion to test one concept, having too many is a sign that a test became too complex and should\nbe refactored to multiples ones.</p>\n<p>This rule will report any test method containing more than a given number of assertion.</p>\n<h3>Noncompliant code example</h3>\n<p>With a parameter of 2.</p>\n<pre>\n@Test\nvoid test() { // Refactor this method.\n  assertEquals(1, f(1));\n  assertEquals(2, f(2));\n  assertEquals(3, g(1));\n}\n</pre>\n<h3>Compliant solution</h3>\n<pre>\nvoid test_f() {\n  assertEquals(1, f(1));\n  assertEquals(2, f(2));\n}\nvoid test_g() {\n  assertEquals(3, g(1));\n}\n</pre>",
    "howToFix": "",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "테스트 메서드에 너무 많은 assertion이 포함되면 안 됩니다",
    "why_ko": "<p>일반적인 좋은 관행은 하나의 논리적 개념만을 대상으로 하고 하나의 이유로만 실패할 수 있는 테스트 메서드를 작성하는 것입니다.</p>\n<p>하나의 개념을 테스트하기 위해 둘 이상의 assertion을 갖는 것이 의미가 있을 수 있지만, 너무 많은 것은 테스트가 너무 복잡해져서 여러 개로 리팩터링해야 한다는 신호입니다.</p>\n<p>이 규칙은 주어진 수보다 많은 assertion을 포함하는 모든 테스트 메서드를 보고합니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<p>매개변수가 2인 경우.</p>\n<pre>\n@Test\nvoid test() { // 이 메서드를 리팩터링하세요.\n  assertEquals(1, f(1));\n  assertEquals(2, f(2));\n  assertEquals(3, g(1));\n}\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre>\nvoid test_f() {\n  assertEquals(1, f(1));\n  assertEquals(2, f(2));\n}\nvoid test_g() {\n  assertEquals(3, g(1));\n}\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": ""
  },
  {
    "id": "S6208",
    "key": "java:S6208",
    "name": "Comma-separated labels should be used in Switch with colon case",
    "type": "code-smell",
    "severity": "info",
    "tags": [
      "java14"
    ],
    "why": "<p>In Java 14 there is a new way to write cases in Switch Statement and Expression when the same action should be performed for different cases.\nInstead of declaring multiples branches with the same action, you can combine all of them in a single case group, separated with commas. It will\nresult in a more concise code and improved readability.</p>\n<p>This rule reports an issue when multiple cases in a Switch can be grouped into a single comma-separated case.</p>\n<h3>Noncompliant code example</h3>\n<pre>\n// Switch Expression\nint i = switch (mode) {\n  case \"a\":\n  case \"b\":\n    yield 1;\n  default:\n    yield 3;\n};\n\n// Switch Statement\nswitch (mode) {\n  case \"a\":\n  case \"b\":\n    doSomething();\n    break;\n  default:\n    doSomethingElse();\n}\n</pre>\n<h3>Compliant solution</h3>\n<pre>\n// Switch Expression\nint i = switch (mode) {\n  case \"a\", \"b\":\n    yield 1;\n  default:\n    yield 3;\n};\n\n// Switch Statement\nswitch (mode) {\n  case \"a\", \"b\":\n    doSomething();\n    break;\n  default:\n    doSomethingElse();\n}\n\n// Or even better:\nswitch (mode) {\n  case \"a\", \"b\" -&gt; doSomething();\n  default -&gt; doSomethingElse();\n}\n</pre>",
    "howToFix": "",
    "moreInfo": "<ul>\n  <li> <a href=\"https://openjdk.java.net/jeps/361\">JEP 361: Switch Expressions</a> </li>\n</ul>",
    "status": "READY",
    "name_ko": "콜론 case가 있는 Switch에서는 쉼표로 구분된 레이블을 사용해야 합니다",
    "why_ko": "<p>Java 14에서는 다른 case에 대해 동일한 동작을 수행해야 할 때 Switch 문과 표현식에서 case를 작성하는 새로운 방법이 있습니다. 동일한 동작을 가진 여러 분기를 선언하는 대신 쉼표로 구분된 단일 case 그룹으로 모두 결합할 수 있습니다. 이렇게 하면 더 간결한 코드와 향상된 가독성이 제공됩니다.</p>\n<p>이 규칙은 Switch의 여러 case가 단일 쉼표로 구분된 case로 그룹화할 수 있을 때 문제를 보고합니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\n// Switch 표현식\nint i = switch (mode) {\n  case \"a\":\n  case \"b\":\n    yield 1;\n  default:\n    yield 3;\n};\n\n// Switch 문\nswitch (mode) {\n  case \"a\":\n  case \"b\":\n    doSomething();\n    break;\n  default:\n    doSomethingElse();\n}\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre>\n// Switch 표현식\nint i = switch (mode) {\n  case \"a\", \"b\":\n    yield 1;\n  default:\n    yield 3;\n};\n\n// Switch 문\nswitch (mode) {\n  case \"a\", \"b\":\n    doSomething();\n    break;\n  default:\n    doSomethingElse();\n}\n\n// 또는 더 좋은 방법:\nswitch (mode) {\n  case \"a\", \"b\" -&gt; doSomething();\n  default -&gt; doSomethingElse();\n}\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": "<ul>\n  <li> <a href=\"https://openjdk.java.net/jeps/361\">JEP 361: Switch 표현식</a> </li>\n</ul>"
  },
  {
    "id": "S5977",
    "key": "java:S5977",
    "name": "Tests should use fixed data instead of randomized data",
    "type": "code-smell",
    "severity": "major",
    "tags": [
      "tests",
      "design",
      "confusing"
    ],
    "why": "<p>Randomness in test code, whether introduced intentionally to cover multiple scenarios or unintentionally through non-deterministic library\nfunctions, undermines the principles of effective testing. In most cases, randomness leads to problems, resulting in code that is unreliable and\ndifficult to debug. Consequently, deterministic and reproducible tests are preferred, primarily for the following reasons:</p>\n<ul>\n  <li> When a test fails, the ability to reproduce the conditions that led to the failure is crucial for effective debugging. Randomness can make it\n  difficult or even impossible to pinpoint the root cause, as subsequent runs may not exhibit the same failure. </li>\n  <li> Being able to replay a scenario allows us to easily compare logs between different test runs. </li>\n  <li> Determinism gives us confidence that a bug is fixed when it no longer appears in tests. If they behave randomly, a passing test after a fix\n  might be coincidental due to a specific random input, rather than a genuine resolution of the underlying problem. </li>\n  <li> Flaky tests, which pass or fail intermittently without any code changes, are a significant problem for CI pipelines (continuous integration).\n  They erode confidence in the CI system, lead to unnecessary investigations and reruns, and ultimately slow down the development and release process.\n  A stable CI pipeline relies on deterministic test outcomes. </li>\n</ul>\n<p>This rule raises an issue when <code>new Random()</code> or <code>UUID.randomUUID()</code> are called in test code.</p>",
    "howToFix": "<ul>\n  <li> When a test uses random numbers to generate inputs, an easy fix is to replace those random inputs with pseudo-random values generated from a\n  known seed. By initializing a pseudo-random number generator with a fixed seed, tests can generate sequences of seemingly random data that are\n  reproducible across different test runs. </li>\n  <li> When randomness occurs due to the use of a library function, the solution is to replace the call with a constant. For example, rather than\n  generating a UUID at random, one should use a fixed value. </li>\n</ul>\n<h3>Noncompliant code example</h3>\n<pre>\nint userAge = new Random().nextInt(42);  // Noncompliant\nUUID userID = UUID.randomUUID(); // Noncompliant\n</pre>\n<h3>Compliant solution</h3>\n<pre>\nstatic final int SEED = 0x533d;\nint userAge = new Random(SEED).nextInt(42);\nUUID userID = UUID.fromString(\"00000000-000-0000-0000-000000000001\");\n</pre>",
    "moreInfo": "<ul>\n  <li> <a href=\"https://phauer.com/2019/modern-best-practices-testing-java/#use-fixed-data-instead-of-randomized-data\">Modern Best Practices for\n  Testing in Java - Philipp Hauer</a> </li>\n</ul>",
    "status": "READY",
    "name_ko": "테스트는 무작위 데이터 대신 고정 데이터를 사용해야 합니다",
    "why_ko": "<p>테스트 코드에서의 무작위성은 여러 시나리오를 커버하기 위해 의도적으로 도입되든 비결정적 라이브러리 함수를 통해 의도치 않게 도입되든 효과적인 테스트의 원칙을 훼손합니다. 대부분의 경우 무작위성은 문제를 일으켜 신뢰할 수 없고 디버그하기 어려운 코드를 만듭니다. 따라서 결정적이고 재현 가능한 테스트가 선호되며, 주로 다음과 같은 이유 때문입니다:</p>\n<ul>\n  <li> 테스트가 실패하면 실패를 유발한 조건을 재현하는 능력이 효과적인 디버깅에 중요합니다. 무작위성은 후속 실행에서 동일한 실패를 보이지 않을 수 있으므로 근본 원인을 정확히 찾아내기 어렵거나 심지어 불가능하게 만들 수 있습니다. </li>\n  <li> 시나리오를 재생할 수 있으면 다른 테스트 실행 간의 로그를 쉽게 비교할 수 있습니다. </li>\n  <li> 결정성은 버그가 더 이상 테스트에 나타나지 않을 때 수정되었다는 확신을 줍니다. 무작위로 동작하면 수정 후 통과한 테스트가 기본 문제의 진정한 해결이 아니라 특정 무작위 입력으로 인한 우연일 수 있습니다. </li>\n  <li> 코드 변경 없이 간헐적으로 통과하거나 실패하는 flaky 테스트는 CI 파이프라인(지속적 통합)에 심각한 문제입니다. CI 시스템에 대한 신뢰를 떨어뜨리고 불필요한 조사와 재실행을 유발하며 궁극적으로 개발 및 릴리스 프로세스를 늦춥니다. </li>\n</ul>\n<p>이 규칙은 테스트 코드에서 <code>new Random()</code> 또는 <code>UUID.randomUUID()</code>가 호출될 때 문제를 제기합니다.</p>",
    "howToFix_ko": "<ul>\n  <li> 테스트가 입력을 생성하기 위해 무작위 숫자를 사용하는 경우 쉬운 수정은 알려진 시드에서 생성된 의사 무작위 값으로 무작위 입력을 대체하는 것입니다. 고정 시드로 의사 난수 생성기를 초기화하면 테스트는 다른 테스트 실행에서 재현 가능한 겉보기에 무작위인 데이터 시퀀스를 생성할 수 있습니다. </li>\n  <li> 라이브러리 함수 사용으로 인해 무작위성이 발생하는 경우 해결책은 호출을 상수로 대체하는 것입니다. 예를 들어 UUID를 무작위로 생성하는 대신 고정 값을 사용해야 합니다. </li>\n</ul>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\nint userAge = new Random().nextInt(42);  // 규칙 위반\nUUID userID = UUID.randomUUID(); // 규칙 위반\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre>\nstatic final int SEED = 0x533d;\nint userAge = new Random(SEED).nextInt(42);\nUUID userID = UUID.fromString(\"00000000-000-0000-0000-000000000001\");\n</pre>",
    "moreInfo_ko": "<ul>\n  <li> <a href=\"https://phauer.com/2019/modern-best-practices-testing-java/#use-fixed-data-instead-of-randomized-data\">Java 테스트를 위한 현대적 모범 사례 - Philipp Hauer</a> </li>\n</ul>"
  },
  {
    "id": "S5998",
    "key": "java:S5998",
    "name": "Regular expressions should not overflow the stack",
    "type": "bug",
    "severity": "major",
    "tags": [
      "regex"
    ],
    "why": "<p>The Java regex engine uses recursive method calls to implement backtracking. Therefore when a repetition inside a regular expression contains\nmultiple paths (i.e. the body of the repetition contains an alternation (<code>|</code>), an optional element or another repetition), trying to match\nthe regular expression can cause a stack overflow on large inputs. This does not happen when using a possessive quantifier (such as <code>*+</code>\ninstead of <code>*</code>) or when using a character class inside a repetition (e.g. <code>[ab]*</code> instead of <code>(a|b)*</code>).</p>\n<p>The size of the input required to overflow the stack depends on various factors, including of course the stack size of the JVM. One thing that\nsignificantly increases the size of the input that can be processed is if each iteration of the repetition goes through a chain of multiple constant\ncharacters because such consecutive characters will be matched by the regex engine without invoking any recursion.</p>\n<p>For example, on a JVM with a stack size of 1MB, the regex <code>(?:a|b)*</code> will overflow the stack after matching around 6000 characters\n(actual numbers may differ between JVM versions and even across multiple runs on the same JVM) whereas <code>(?:abc|def)*</code> can handle around\n15000 characters.</p>\n<p>Since often times stack growth can't easily be avoided, this rule will only report issues on regular expressions if they can cause a stack overflow\non realistically sized inputs. You can adjust the <code>maxStackConsumptionFactor</code> parameter to adjust this.</p>\n<h3>Noncompliant code example</h3>\n<pre>\nPattern.compile(\"(a|b)*\"); // Noncompliant\nPattern.compile(\"(.|\\n)*\"); // Noncompliant\nPattern.compile(\"(ab?)*\"); // Noncompliant\n</pre>\n<h3>Compliant solution</h3>\n<pre>\nPattern.compile(\"[ab]*\"); // Character classes don't cause recursion the way that '|' does\nPattern.compile(\"(?s).*\"); // Enabling the (?s) flag makes '.' match line breaks, so '|\\n' isn't necessary\nPattern.compile(\"(ab?)*+\"); // Possessive quantifiers don't cause recursion because they disable backtracking\n</pre>",
    "howToFix": "",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "정규식이 스택 오버플로우를 발생시키면 안 됩니다",
    "why_ko": "<p>Java 정규식 엔진은 역추적을 구현하기 위해 재귀적 메서드 호출을 사용합니다. 따라서 정규 표현식 내의 반복이 여러 경로를 포함하는 경우(즉, 반복 본문에 대안(<code>|</code>), 선택적 요소 또는 다른 반복이 포함된 경우) 정규 표현식을 일치시키려고 하면 큰 입력에서 스택 오버플로우가 발생할 수 있습니다. 이것은 소유 수량자(예: <code>*</code> 대신 <code>*+</code>)를 사용하거나 반복 내에서 문자 클래스를 사용할 때(예: <code>(a|b)*</code> 대신 <code>[ab]*</code>) 발생하지 않습니다.</p>\n<p>스택을 오버플로우시키는 데 필요한 입력 크기는 물론 JVM의 스택 크기를 포함한 다양한 요소에 따라 다릅니다. 처리할 수 있는 입력 크기를 크게 늘리는 한 가지 방법은 반복의 각 반복이 여러 상수 문자의 체인을 통과하는 경우입니다. 이러한 연속 문자는 재귀를 호출하지 않고 정규식 엔진에 의해 일치되기 때문입니다.</p>\n<p>예를 들어, 스택 크기가 1MB인 JVM에서 정규식 <code>(?:a|b)*</code>는 약 6000자를 일치시킨 후 스택을 오버플로우시키는 반면(실제 숫자는 JVM 버전과 동일한 JVM에서 여러 실행에서도 다를 수 있음) <code>(?:abc|def)*</code>는 약 15000자를 처리할 수 있습니다.</p>\n<p>스택 증가를 쉽게 피할 수 없는 경우가 많으므로 이 규칙은 현실적인 크기의 입력에서 스택 오버플로우를 일으킬 수 있는 정규 표현식에 대해서만 문제를 보고합니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\nPattern.compile(\"(a|b)*\"); // 규칙 위반\nPattern.compile(\"(.|\\n)*\"); // 규칙 위반\nPattern.compile(\"(ab?)*\"); // 규칙 위반\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre>\nPattern.compile(\"[ab]*\"); // 문자 클래스는 '|'처럼 재귀를 일으키지 않음\nPattern.compile(\"(?s).*\"); // (?s) 플래그를 활성화하면 '.'이 줄 바꿈과 일치하므로 '|\\n'이 필요 없음\nPattern.compile(\"(ab?)*+\"); // 소유 수량자는 역추적을 비활성화하므로 재귀를 일으키지 않음\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": ""
  },
  {
    "id": "S1172",
    "key": "java:S1172",
    "name": "Unused method parameters should be removed",
    "type": "code-smell",
    "severity": "major",
    "tags": [
      "cert",
      "unused"
    ],
    "why": "<p>A typical code smell known as unused function parameters refers to parameters declared in a function but not used anywhere within the function's\nbody. While this might seem harmless at first glance, it can lead to confusion and potential errors in your code. Disregarding the values passed to\nsuch parameters, the function's behavior will be the same, but the programmer's intention won't be clearly expressed anymore. Therefore, removing\nfunction parameters that are not being utilized is considered best practice.</p>\n<h3>Exceptions</h3>\n<p>The rule will not raise issues for unused parameters:</p>\n<ul>\n  <li> that are annotated with <code>@javax.enterprise.event.Observes</code> </li>\n  <li> in overrides and implementation methods </li>\n  <li> in interface <code>default</code> methods </li>\n  <li> in non-private methods that only <code>throw</code> or that have empty bodies </li>\n  <li> in annotated methods, unless the annotation is <code>@SuppressWarning(\"unchecked\")</code> or <code>@SuppressWarning(\"rawtypes\")</code>, in\n  which case the annotation will be ignored </li>\n  <li> in overridable methods (non-final, or not member of a final class, non-static, non-private), if the parameter is documented with a proper\n  javadoc. </li>\n</ul>",
    "howToFix": "<p>Having unused function parameters in your code can lead to confusion and misunderstanding of a developer's intention. They reduce code readability\nand introduce the potential for errors. To avoid these problems, developers should remove unused parameters from function declarations.</p>\n\n<h4>Noncompliant code example</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\nvoid doSomething(int a, int b) { // Noncompliant, \"b\" is unused\n  compute(a);\n}\n</pre>\n<h4>Compliant solution</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\nvoid doSomething(int a) {\n  compute(a);\n}\n</pre>\n<p>Examples of exceptions:</p>\n<pre>\n@Override\nvoid doSomething(int a, int b) {     // no issue reported on b\n  compute(a);\n}\n\npublic void foo(String s) {\n  // designed to be extended but noop in standard case\n}\n\nprotected void bar(String s) {\n  //open-closed principle\n}\n\npublic void qix(String s) {\n  throw new UnsupportedOperationException(\"This method should be implemented in subclasses\");\n}\n\n/**\n * @param s This string may be used for further computation in overriding classes\n */\nprotected void foobar(int a, String s) { // no issue, method is overridable and unused parameter has proper javadoc\n  compute(a);\n}\n</pre>",
    "moreInfo": "<ul>\n  <li> <a href=\"https://wiki.sei.cmu.edu/confluence/x/5dUxBQ\">CERT, MSC12-C.</a> - Detect and remove code that has no effect or is never executed\n  </li>\n</ul>",
    "status": "READY",
    "name_ko": "사용되지 않는 메서드 매개변수는 제거해야 합니다",
    "why_ko": "<p>사용되지 않는 함수 매개변수라고 알려진 전형적인 코드 스멜은 함수에서 선언되었지만 함수 본문 내 어디에서도 사용되지 않는 매개변수를 말합니다. 처음에는 무해해 보일 수 있지만, 코드에서 혼란과 잠재적인 오류를 유발할 수 있습니다. 이러한 매개변수에 전달된 값을 무시하면 함수의 동작은 동일하지만 프로그래머의 의도가 더 이상 명확하게 표현되지 않습니다. 따라서 사용되지 않는 함수 매개변수를 제거하는 것이 모범 사례로 간주됩니다.</p>\n<h3>예외 사항</h3>\n<p>이 규칙은 다음 사용되지 않는 매개변수에 대해 이슈를 제기하지 않습니다:</p>\n<ul>\n  <li> <code>@javax.enterprise.event.Observes</code> 어노테이션이 있는 매개변수 </li>\n  <li> 오버라이드 및 구현 메서드의 매개변수 </li>\n  <li> 인터페이스 <code>default</code> 메서드의 매개변수 </li>\n  <li> <code>throw</code>만 하거나 빈 본문을 가진 비공개가 아닌 메서드의 매개변수 </li>\n  <li> 어노테이션이 있는 메서드의 매개변수, 단 어노테이션이 <code>@SuppressWarning(\"unchecked\")</code> 또는 <code>@SuppressWarning(\"rawtypes\")</code>인 경우 어노테이션이 무시됩니다 </li>\n  <li> 오버라이드 가능한 메서드(non-final이거나 final 클래스의 멤버가 아니고, non-static, non-private)에서 매개변수가 적절한 javadoc으로 문서화된 경우 </li>\n</ul>",
    "howToFix_ko": "<p>코드에 사용되지 않는 함수 매개변수가 있으면 개발자의 의도에 대한 혼란과 오해를 유발할 수 있습니다. 코드 가독성을 저하시키고 오류 가능성을 도입합니다. 이러한 문제를 피하려면 개발자는 함수 선언에서 사용되지 않는 매개변수를 제거해야 합니다.</p>\n\n<h4>규칙을 준수하지 않는 코드 예시</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\nvoid doSomething(int a, int b) { // 규칙 위반, \"b\"가 사용되지 않음\n  compute(a);\n}\n</pre>\n<h4>규칙을 준수하는 해결책</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\nvoid doSomething(int a) {\n  compute(a);\n}\n</pre>\n<p>예외 사항 예시:</p>\n<pre>\n@Override\nvoid doSomething(int a, int b) {     // b에 대해 이슈가 보고되지 않음\n  compute(a);\n}\n\npublic void foo(String s) {\n  // 확장되도록 설계되었지만 표준 케이스에서는 아무 작업도 하지 않음\n}\n\nprotected void bar(String s) {\n  //개방-폐쇄 원칙\n}\n\npublic void qix(String s) {\n  throw new UnsupportedOperationException(\"이 메서드는 서브클래스에서 구현해야 합니다\");\n}\n\n/**\n * @param s 이 문자열은 오버라이딩 클래스에서 추가 계산에 사용될 수 있습니다\n */\nprotected void foobar(int a, String s) { // 이슈 없음, 메서드가 오버라이드 가능하고 사용되지 않는 매개변수에 적절한 javadoc이 있음\n  compute(a);\n}\n</pre>",
    "moreInfo_ko": "<ul>\n  <li> <a href=\"https://wiki.sei.cmu.edu/confluence/x/5dUxBQ\">CERT, MSC12-C.</a> - 효과가 없거나 실행되지 않는 코드를 탐지하고 제거하기\n  </li>\n</ul>"
  },
  {
    "id": "S1488",
    "key": "java:S1488",
    "name": "Local variables should not be declared and then immediately returned or thrown",
    "type": "code-smell",
    "severity": "minor",
    "tags": [
      "clumsy"
    ],
    "why": "<p>Declaring a variable only to immediately return or throw it is considered a bad practice because it adds unnecessary complexity to the code. This\npractice can make the code harder to read and understand, as it introduces an extra step that doesn't add any value. Instead of declaring a variable\nand then immediately returning or throwing it, it is generally better to return or throw the value directly. This makes the code cleaner, simpler, and\neasier to understand.</p>",
    "howToFix": "<p>Declaring a variable only to immediately return or throw it is considered a bad practice because it adds unnecessary complexity to the code. To fix\nthe issue, return or throw the value directly.</p>\n\n<h4>Noncompliant code example</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\npublic long computeDurationInMilliseconds() {\n  long duration = (((hours * 60) + minutes) * 60 + seconds) * 1000;\n  return duration;\n}\n</pre>\n<h4>Compliant solution</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\npublic long computeDurationInMilliseconds() {\n  return (((hours * 60) + minutes) * 60 + seconds) * 1000;\n}\n</pre>\n<h4>Noncompliant code example</h4>\n<pre data-diff-id=\"2\" data-diff-type=\"noncompliant\">\npublic void doSomething() {\n  RuntimeException myException = new RuntimeException();\n  throw myException;\n}\n</pre>\n<h4>Compliant solution</h4>\n<pre data-diff-id=\"2\" data-diff-type=\"compliant\">\npublic void doSomething() {\n  throw new RuntimeException();\n}\n</pre>",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "지역 변수는 선언 후 바로 반환하거나 던지면 안 됩니다",
    "why_ko": "<p>변수를 선언한 후 바로 반환하거나 던지는 것은 코드에 불필요한 복잡성을 추가하기 때문에 나쁜 관행으로 간주됩니다. 이 관행은 가치를 추가하지 않는 추가 단계를 도입하므로 코드를 읽고 이해하기 어렵게 만들 수 있습니다. 변수를 선언한 후 바로 반환하거나 던지는 대신 값을 직접 반환하거나 던지는 것이 일반적으로 더 좋습니다. 이렇게 하면 코드가 더 깔끔하고 간단하며 이해하기 쉬워집니다.</p>",
    "howToFix_ko": "<p>변수를 선언한 후 바로 반환하거나 던지는 것은 코드에 불필요한 복잡성을 추가하기 때문에 나쁜 관행으로 간주됩니다. 이 문제를 해결하려면 값을 직접 반환하거나 던지세요.</p>\n\n<h4>규칙을 준수하지 않는 코드 예시</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\npublic long computeDurationInMilliseconds() {\n  long duration = (((hours * 60) + minutes) * 60 + seconds) * 1000;\n  return duration;\n}\n</pre>\n<h4>규칙을 준수하는 해결책</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\npublic long computeDurationInMilliseconds() {\n  return (((hours * 60) + minutes) * 60 + seconds) * 1000;\n}\n</pre>\n<h4>규칙을 준수하지 않는 코드 예시</h4>\n<pre data-diff-id=\"2\" data-diff-type=\"noncompliant\">\npublic void doSomething() {\n  RuntimeException myException = new RuntimeException();\n  throw myException;\n}\n</pre>\n<h4>규칙을 준수하는 해결책</h4>\n<pre data-diff-id=\"2\" data-diff-type=\"compliant\">\npublic void doSomething() {\n  throw new RuntimeException();\n}\n</pre>",
    "moreInfo_ko": ""
  },
  {
    "id": "S1871",
    "key": "java:S1871",
    "name": "Two branches in a conditional structure should not have exactly the same implementation",
    "type": "code-smell",
    "severity": "major",
    "tags": [
      "design",
      "suspicious"
    ],
    "why": "<p>When the same code is duplicated in two or more separate branches of a conditional, it can make the code harder to understand, maintain, and can\npotentially introduce bugs if one instance of the code is changed but others are not.</p>\n<p>Having two <code>cases</code> in a <code>switch</code> statement or two branches in an <code>if</code> chain with the same implementation is at\nbest duplicate code, and at worst a coding error.</p>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\nif (a &gt;= 0 &amp;&amp; a &lt; 10) {\n  doFirstThing();\n  doTheThing();\n}\nelse if (a &gt;= 10 &amp;&amp; a &lt; 20) {\n  doTheOtherThing();\n}\nelse if (a &gt;= 20 &amp;&amp; a &lt; 50) {\n  doFirstThing();\n  doTheThing();  // Noncompliant; duplicates first condition\n}\nelse {\n  doTheRest();\n}\n</pre>\n<pre data-diff-id=\"2\" data-diff-type=\"noncompliant\">\nswitch (i) {\n  case 1:\n    doFirstThing();\n    doSomething();\n    break;\n  case 2:\n    doSomethingDifferent();\n    break;\n  case 3:  // Noncompliant; duplicates case 1's implementation\n    doFirstThing();\n    doSomething();\n    break;\n  default:\n    doTheRest();\n}\n</pre>\n<p>If the same logic is truly needed for both instances, then:</p>\n<ul>\n  <li> in an <code>if</code> chain they should be combined </li>\n</ul>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\nif ((a &gt;= 0 &amp;&amp; a &lt; 10) || (a &gt;= 20 &amp;&amp; a &lt; 50)) { // Compliant\n  doFirstThing();\n  doTheThing();\n}\nelse if (a &gt;= 10 &amp;&amp; a &lt; 20) {\n  doTheOtherThing();\n}\nelse {\n  doTheRest();\n}\n</pre>\n<ul>\n  <li> for a <code>switch</code>, one should fall through to the other </li>\n</ul>\n<pre data-diff-id=\"2\" data-diff-type=\"compliant\">\nswitch (i) {\n  case 1:\n  case 3: // Compliant\n    doFirstThing();\n    doSomething();\n    break;\n  case 2:\n    doSomethingDifferent();\n    break;\n  default:\n    doTheRest();\n}\n</pre>\n<p>When all blocks are identical, either this rule will trigger if there is no default clause or rule <a href='/coding_rules#rule_key=java%3AS3923'>S3923</a> will raise if there is a\ndefault clause.</p>\n<h3>Exceptions</h3>\n<p>Unless all blocks are identical, blocks in an <code>if</code> chain that contain a single line of code are ignored. The same applies to blocks in a\n<code>switch</code> statement that contains a single line of code with or without a following <code>break</code>.</p>\n<pre>\nif (a == 1) {\n  doSomething();  // Compliant, usually this is done on purpose to increase the readability\n} else if (a == 2) {\n  doSomethingElse();\n} else {\n  doSomething();\n}\n</pre>",
    "howToFix": "",
    "moreInfo": "<h3>Related rules</h3>\n<ul>\n  <li> <a href='/coding_rules#rule_key=java%3AS3923'>S3923</a> - All branches in a conditional structure should not have exactly the same implementation </li>\n</ul>",
    "status": "READY",
    "name_ko": "조건문의 두 분기가 완전히 동일한 구현을 가지면 안 됩니다",
    "why_ko": "<p>동일한 코드가 조건문의 두 개 이상의 별도 분기에 중복되면 코드를 이해하고 유지보수하기 어려워질 수 있으며, 코드의 한 인스턴스가 변경되었지만 다른 인스턴스가 변경되지 않으면 잠재적으로 버그가 발생할 수 있습니다.</p>\n<p><code>switch</code> 문에 동일한 구현을 가진 두 개의 <code>case</code>가 있거나 <code>if</code> 체인에 동일한 구현을 가진 두 개의 분기가 있으면 최선의 경우 중복 코드이고, 최악의 경우 코딩 오류입니다.</p>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\nif (a &gt;= 0 &amp;&amp; a &lt; 10) {\n  doFirstThing();\n  doTheThing();\n}\nelse if (a &gt;= 10 &amp;&amp; a &lt; 20) {\n  doTheOtherThing();\n}\nelse if (a &gt;= 20 &amp;&amp; a &lt; 50) {\n  doFirstThing();\n  doTheThing();  // 규칙 위반; 첫 번째 조건과 중복\n}\nelse {\n  doTheRest();\n}\n</pre>\n<pre data-diff-id=\"2\" data-diff-type=\"noncompliant\">\nswitch (i) {\n  case 1:\n    doFirstThing();\n    doSomething();\n    break;\n  case 2:\n    doSomethingDifferent();\n    break;\n  case 3:  // 규칙 위반; case 1의 구현과 중복\n    doFirstThing();\n    doSomething();\n    break;\n  default:\n    doTheRest();\n}\n</pre>\n<p>두 인스턴스 모두에 동일한 로직이 정말로 필요하다면:</p>\n<ul>\n  <li> <code>if</code> 체인에서는 결합해야 합니다 </li>\n</ul>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\nif ((a &gt;= 0 &amp;&amp; a &lt; 10) || (a &gt;= 20 &amp;&amp; a &lt; 50)) { // 규칙 준수\n  doFirstThing();\n  doTheThing();\n}\nelse if (a &gt;= 10 &amp;&amp; a &lt; 20) {\n  doTheOtherThing();\n}\nelse {\n  doTheRest();\n}\n</pre>\n<ul>\n  <li> <code>switch</code>의 경우, 하나가 다른 하나로 fall through 해야 합니다 </li>\n</ul>\n<pre data-diff-id=\"2\" data-diff-type=\"compliant\">\nswitch (i) {\n  case 1:\n  case 3: // 규칙 준수\n    doFirstThing();\n    doSomething();\n    break;\n  case 2:\n    doSomethingDifferent();\n    break;\n  default:\n    doTheRest();\n}\n</pre>\n<p>모든 블록이 동일한 경우, default 절이 없으면 이 규칙이 트리거되고 default 절이 있으면 규칙 <a href='/coding_rules#rule_key=java%3AS3923'>S3923</a>이 발생합니다.</p>\n<h3>예외</h3>\n<p>모든 블록이 동일하지 않는 한, 한 줄의 코드를 포함하는 <code>if</code> 체인의 블록은 무시됩니다. <code>break</code>가 있거나 없는 한 줄의 코드를 포함하는 <code>switch</code> 문의 블록에도 동일하게 적용됩니다.</p>\n<pre>\nif (a == 1) {\n  doSomething();  // 규칙 준수, 일반적으로 가독성을 높이기 위해 의도적으로 수행됨\n} else if (a == 2) {\n  doSomethingElse();\n} else {\n  doSomething();\n}\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": "<h3>관련 규칙</h3>\n<ul>\n  <li> <a href='/coding_rules#rule_key=java%3AS3923'>S3923</a> - 조건문의 모든 분기가 완전히 동일한 구현을 가지면 안 됩니다 </li>\n</ul>"
  },
  {
    "id": "S2924",
    "key": "java:S2924",
    "name": "JUnit rules should be used",
    "type": "code-smell",
    "severity": "minor",
    "tags": [
      "junit",
      "tests",
      "unused"
    ],
    "why": "<p>JUnit rules are predefined classes that extend the behavior of JUnit tests, allowing to add new functionalities, such as managing resources,\nmodifying test behavior, and handling exceptions.</p>\n<p>Unused JUnit rules can lead to confusion when reading the test code, making tests harder to understand and maintain. Having unused rules can also\nslow down the test suite, as JUnit has to process the rules even though they are not being used. Some <code>TestRule</code> classes have the desired\neffect without being directly referenced by a test, while others do not. There's no reason to leave them cluttering the file if they're not in\nuse.</p>\n<p>The rule raises an issue when in a <code>Test</code> class, there is no method referencing a declared <code>TestRule</code> of the following\ntypes:</p>\n<ul>\n  <li> <code>TemporaryFolder</code> and <code>TestName</code> in JUnit </li>\n  <li> <code>TempDir</code> and <code>TestInfo</code> in JUnit 5 </li>\n</ul>",
    "howToFix": "<p>Remove the unused <code>TestRule</code> field that is expected to be referenced inside a test method.</p>\n\n<h4>Noncompliant code example</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\npublic class ProjectDefinitionTest {\n\n  @Rule\n  public TemporaryFolder temp = new TemporaryFolder();  // Noncompliant\n\n  @Test\n  public void shouldSetKey() {\n    ProjectDefinition def = ProjectDefinition.create();\n    def.setKey(\"mykey\");\n    assertThat(def.getKey(), is(\"mykey\"));\n  }\n}\n</pre>\n<h4>Compliant solution</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\npublic class ProjectDefinitionTest {\n\n  @Test\n  public void shouldSetKey() {\n    ProjectDefinition def = ProjectDefinition.create();\n    def.setKey(\"mykey\");\n    assertThat(def.getKey(), is(\"mykey\"));\n  }\n}\n</pre>",
    "moreInfo": "<h3>Documentation</h3>\n<ul>\n  <li> <a href=\"https://junit.org/junit4/javadoc/4.12/org/junit/Rule.html\">Junit API - Rule</a> </li>\n  <li> <a href=\"https://github.com/junit-team/junit4/wiki/Rules\">Junit - Rules</a> </li>\n</ul>\n<h3>Articles &amp; blog posts</h3>\n<ul>\n  <li> <a href=\"https://www.baeldung.com/junit-4-rules\">Junit 4 Rules</a> </li>\n</ul>",
    "status": "READY",
    "name_ko": "JUnit rules를 사용해야 합니다",
    "why_ko": "<p>JUnit rules는 JUnit 테스트의 동작을 확장하는 미리 정의된 클래스로, 리소스 관리, 테스트 동작 수정 및 예외 처리와 같은 새로운 기능을 추가할 수 있습니다.</p>\n<p>사용하지 않는 JUnit rules는 테스트 코드를 읽을 때 혼란을 초래할 수 있으며, 테스트를 이해하고 유지 관리하기 어렵게 만듭니다. 사용하지 않는 rules가 있으면 JUnit이 사용되지 않는 rules도 처리해야 하므로 테스트 스위트가 느려질 수 있습니다. 일부 <code>TestRule</code> 클래스는 테스트에서 직접 참조되지 않아도 원하는 효과를 내지만 다른 클래스는 그렇지 않습니다. 사용하지 않는 경우 파일을 어지럽히는 이유가 없습니다.</p>\n<p>이 규칙은 <code>Test</code> 클래스에서 다음 타입의 선언된 <code>TestRule</code>을 참조하는 메서드가 없을 때 문제를 제기합니다:</p>\n<ul>\n  <li> JUnit의 <code>TemporaryFolder</code> 및 <code>TestName</code> </li>\n  <li> JUnit 5의 <code>TempDir</code> 및 <code>TestInfo</code> </li>\n</ul>",
    "howToFix_ko": "<p>테스트 메서드 내에서 참조되어야 하는 사용하지 않는 <code>TestRule</code> 필드를 제거하세요.</p>\n\n<h4>규칙을 준수하지 않는 코드 예시</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\npublic class ProjectDefinitionTest {\n\n  @Rule\n  public TemporaryFolder temp = new TemporaryFolder();  // 규칙 위반\n\n  @Test\n  public void shouldSetKey() {\n    ProjectDefinition def = ProjectDefinition.create();\n    def.setKey(\"mykey\");\n    assertThat(def.getKey(), is(\"mykey\"));\n  }\n}\n</pre>\n<h4>규칙을 준수하는 해결책</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\npublic class ProjectDefinitionTest {\n\n  @Test\n  public void shouldSetKey() {\n    ProjectDefinition def = ProjectDefinition.create();\n    def.setKey(\"mykey\");\n    assertThat(def.getKey(), is(\"mykey\"));\n  }\n}\n</pre>",
    "moreInfo_ko": "<h3>문서</h3>\n<ul>\n  <li> <a href=\"https://junit.org/junit4/javadoc/4.12/org/junit/Rule.html\">Junit API - Rule</a> </li>\n  <li> <a href=\"https://github.com/junit-team/junit4/wiki/Rules\">Junit - Rules</a> </li>\n</ul>\n<h3>관련 문서 및 블로그 게시물</h3>\n<ul>\n  <li> <a href=\"https://www.baeldung.com/junit-4-rules\">Junit 4 Rules</a> </li>\n</ul>"
  },
  {
    "id": "S2162",
    "key": "java:S2162",
    "name": "\"equals\" methods should be symmetric and work for subclasses",
    "type": "bug",
    "severity": "minor",
    "tags": [
      "cert"
    ],
    "why": "<p>A key facet of the <code>equals</code> contract is that if <code>a.equals(b)</code> then <code>b.equals(a)</code>, i.e. that the relationship is\nsymmetric.</p>\n<p>Using <code>instanceof</code> breaks the contract when there are subclasses, because while the child is an <code>instanceof</code> the parent, the\nparent is not an <code>instanceof</code> the child. For instance, assume that <code>Raspberry extends Fruit</code> and adds some fields (requiring a\nnew implementation of <code>equals</code>):</p>\n<pre>\nFruit fruit = new Fruit();\nRaspberry raspberry = new Raspberry();\n\nif (raspberry instanceof Fruit) { ... } // true\nif (fruit instanceof Raspberry) { ... } // false\n</pre>\n<p>If similar <code>instanceof</code> checks were used in the classes' <code>equals</code> methods, the symmetry principle would be broken:</p>\n<pre>\nraspberry.equals(fruit); // false\nfruit.equals(raspberry); //true\n</pre>\n<p>Additionally, non <code>final</code> classes shouldn't use a hardcoded class name in the <code>equals</code> method because doing so breaks the\nmethod for subclasses. Instead, make the comparison dynamic.</p>\n<p>Further, comparing to an unrelated class type breaks the contract for that unrelated type, because while\n<code>thisClass.equals(unrelatedClass)</code> can return true, <code>unrelatedClass.equals(thisClass)</code> will not.</p>\n<h3>Noncompliant code example</h3>\n<pre>\npublic class Fruit extends Food {\n  private Season ripe;\n\n  public boolean equals(Object obj) {\n    if (obj == this) {\n      return true;\n    }\n    if (obj == null) {\n      return false;\n    }\n    if (Fruit.class == obj.getClass()) { // Noncompliant; broken for child classes\n      return ripe.equals(((Fruit)obj).getRipe());\n    }\n    if (obj instanceof Fruit ) {  // Noncompliant; broken for child classes\n      return ripe.equals(((Fruit)obj).getRipe());\n    }\n    else if (obj instanceof Season) { // Noncompliant; symmetry broken for Season class\n      // ...\n    }\n    //...\n</pre>\n<h3>Compliant solution</h3>\n<pre>\npublic class Fruit extends Food {\n  private Season ripe;\n\n  public boolean equals(Object obj) {\n    if (obj == this) {\n      return true;\n    }\n    if (obj == null) {\n      return false;\n    }\n    if (this.getClass() == obj.getClass()) {\n      return ripe.equals(((Fruit)obj).getRipe());\n    }\n    return false;\n}\n</pre>",
    "howToFix": "",
    "moreInfo": "<ul>\n  <li> <a href=\"https://wiki.sei.cmu.edu/confluence/x/AzZGBQ\">CERT, MET08-J.</a> - Preserve the equality contract when overriding the equals() method\n  </li>\n</ul>",
    "status": "READY",
    "name_ko": "\"equals\" 메서드는 대칭적이어야 하고 하위 클래스에서도 동작해야 합니다",
    "why_ko": "<p><code>equals</code> 계약의 핵심 측면은 <code>a.equals(b)</code>이면 <code>b.equals(a)</code>이어야 한다는 것, 즉 관계가 대칭적이어야 한다는 것입니다.</p>\n<p>하위 클래스가 있을 때 <code>instanceof</code>를 사용하면 계약이 위반됩니다. 자식 클래스는 부모의 <code>instanceof</code>이지만, 부모는 자식의 <code>instanceof</code>가 아니기 때문입니다. 예를 들어, <code>Raspberry extends Fruit</code>이고 일부 필드를 추가한다고 가정하면(<code>equals</code>의 새 구현이 필요함):</p>\n<pre>\nFruit fruit = new Fruit();\nRaspberry raspberry = new Raspberry();\n\nif (raspberry instanceof Fruit) { ... } // true\nif (fruit instanceof Raspberry) { ... } // false\n</pre>\n<p>클래스의 <code>equals</code> 메서드에서 유사한 <code>instanceof</code> 검사를 사용하면 대칭 원칙이 깨집니다:</p>\n<pre>\nraspberry.equals(fruit); // false\nfruit.equals(raspberry); //true\n</pre>\n<p>또한 <code>final</code>이 아닌 클래스는 <code>equals</code> 메서드에서 하드코딩된 클래스 이름을 사용해서는 안 됩니다. 그렇게 하면 하위 클래스에서 메서드가 깨지기 때문입니다. 대신 동적으로 비교하세요.</p>\n<p>또한 관련 없는 클래스 타입과 비교하면 해당 타입에 대한 계약이 깨집니다. <code>thisClass.equals(unrelatedClass)</code>는 true를 반환할 수 있지만 <code>unrelatedClass.equals(thisClass)</code>는 그렇지 않기 때문입니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\npublic class Fruit extends Food {\n  private Season ripe;\n\n  public boolean equals(Object obj) {\n    if (obj == this) {\n      return true;\n    }\n    if (obj == null) {\n      return false;\n    }\n    if (Fruit.class == obj.getClass()) { // 규칙 위반; 자식 클래스에서 깨짐\n      return ripe.equals(((Fruit)obj).getRipe());\n    }\n    if (obj instanceof Fruit ) {  // 규칙 위반; 자식 클래스에서 깨짐\n      return ripe.equals(((Fruit)obj).getRipe());\n    }\n    else if (obj instanceof Season) { // 규칙 위반; Season 클래스에 대해 대칭성이 깨짐\n      // ...\n    }\n    //...\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre>\npublic class Fruit extends Food {\n  private Season ripe;\n\n  public boolean equals(Object obj) {\n    if (obj == this) {\n      return true;\n    }\n    if (obj == null) {\n      return false;\n    }\n    if (this.getClass() == obj.getClass()) {\n      return ripe.equals(((Fruit)obj).getRipe());\n    }\n    return false;\n}\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": "<ul>\n  <li> <a href=\"https://wiki.sei.cmu.edu/confluence/x/AzZGBQ\">CERT, MET08-J.</a> - equals() 메서드를 오버라이드할 때 동등성 계약을 유지하세요 </li>\n</ul>"
  },
  {
    "id": "S1125",
    "key": "java:S1125",
    "name": "Boolean literals should not be redundant",
    "type": "code-smell",
    "severity": "minor",
    "tags": [
      "clumsy"
    ],
    "why": "<p>A boolean literal can be represented in two different ways: <code>true</code> or <code>false</code>. They can be combined with logical operators\n(<code>!, &amp;&amp;, ||, ==, !=</code>) to produce logical expressions that represent truth values. However, comparing a boolean literal to a\nvariable or expression that evaluates to a boolean value is unnecessary and can make the code harder to read and understand. The more complex a\nboolean expression is, the harder it will be for developers to understand its meaning and expected behavior, and it will favour the introduction of\nnew bugs.</p>",
    "howToFix": "<p>Remove redundant boolean literals from expressions to improve readability and make the code more maintainable.</p>\n\n<h4>Noncompliant code example</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\nif (booleanMethod() == true) { /* ... */ }\nif (booleanMethod() == false) { /* ... */ }\nif (booleanMethod() || false) { /* ... */ }\ndoSomething(!false);\ndoSomething(booleanMethod() == true);\n\nbooleanVariable = booleanMethod() ? true : false;\nbooleanVariable = booleanMethod() ? true : exp;\nbooleanVariable = booleanMethod() ? false : exp;\nbooleanVariable = booleanMethod() ? exp : true;\nbooleanVariable = booleanMethod() ? exp : false;\n</pre>\n<h4>Compliant solution</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\nif (booleanMethod()) { /* ... */ }\nif (!booleanMethod()) { /* ... */ }\nif (booleanMethod()) { /* ... */ }\ndoSomething(true);\ndoSomething(booleanMethod());\n\nbooleanVariable = booleanMethod();\nbooleanVariable = booleanMethod() || exp;\nbooleanVariable = !booleanMethod() &amp;&amp; exp;\nbooleanVariable = !booleanMethod() || exp;\nbooleanVariable = booleanMethod() &amp;&amp; exp;\n</pre>",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "Boolean 리터럴은 중복되면 안 됩니다",
    "why_ko": "<p>boolean 리터럴은 두 가지 방식으로 표현될 수 있습니다: <code>true</code> 또는 <code>false</code>. 이들은 논리 연산자(<code>!, &amp;&amp;, ||, ==, !=</code>)와 결합하여 진리값을 나타내는 논리 표현식을 생성할 수 있습니다. 그러나 boolean 리터럴을 boolean 값으로 평가되는 변수나 표현식과 비교하는 것은 불필요하며 코드를 읽고 이해하기 어렵게 만들 수 있습니다. boolean 표현식이 복잡할수록 개발자가 그 의미와 예상 동작을 이해하기 어려워지고 새로운 버그 도입을 촉진합니다.</p>",
    "howToFix_ko": "<p>가독성을 향상시키고 코드를 더 유지보수하기 쉽게 만들기 위해 표현식에서 중복된 boolean 리터럴을 제거하세요.</p>\n\n<h4>규칙을 준수하지 않는 코드 예시</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\nif (booleanMethod() == true) { /* ... */ }\nif (booleanMethod() == false) { /* ... */ }\nif (booleanMethod() || false) { /* ... */ }\ndoSomething(!false);\ndoSomething(booleanMethod() == true);\n\nbooleanVariable = booleanMethod() ? true : false;\nbooleanVariable = booleanMethod() ? true : exp;\nbooleanVariable = booleanMethod() ? false : exp;\nbooleanVariable = booleanMethod() ? exp : true;\nbooleanVariable = booleanMethod() ? exp : false;\n</pre>\n<h4>규칙을 준수하는 해결책</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\nif (booleanMethod()) { /* ... */ }\nif (!booleanMethod()) { /* ... */ }\nif (booleanMethod()) { /* ... */ }\ndoSomething(true);\ndoSomething(booleanMethod());\n\nbooleanVariable = booleanMethod();\nbooleanVariable = booleanMethod() || exp;\nbooleanVariable = !booleanMethod() &amp;&amp; exp;\nbooleanVariable = !booleanMethod() || exp;\nbooleanVariable = booleanMethod() &amp;&amp; exp;\n</pre>",
    "moreInfo_ko": ""
  },
  {
    "id": "S2973",
    "key": "java:S2973",
    "name": "Escaped Unicode characters should not be used",
    "type": "code-smell",
    "severity": "major",
    "tags": [
      "confusing"
    ],
    "why": "<p>The use of Unicode escape sequences should be reserved for characters that would otherwise be ambiguous, such as unprintable characters.</p>\n<p>This rule ignores sequences composed entirely of Unicode characters, but otherwise raises an issue for each Unicode character that represents a\nprintable character.</p>\n<h3>Noncompliant code example</h3>\n<pre>\nString prefix = \"n\\u00E9e\"; // Noncompliant\n</pre>\n<h3>Compliant solution</h3>\n<pre>\nString prefix = \"née\";\n</pre>",
    "howToFix": "",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "이스케이프된 유니코드 문자를 사용하면 안 됩니다",
    "why_ko": "<p>유니코드 이스케이프 시퀀스의 사용은 출력할 수 없는 문자와 같이 그렇지 않으면 모호할 수 있는 문자에만 사용해야 합니다.</p>\n<p>이 규칙은 전적으로 유니코드 문자로 구성된 시퀀스는 무시하지만, 출력 가능한 문자를 나타내는 각 유니코드 문자에 대해서는 문제를 제기합니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\nString prefix = \"n\\u00E9e\"; // 규칙 위반\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre>\nString prefix = \"née\";\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": ""
  },
  {
    "id": "S2637",
    "key": "java:S2637",
    "name": "\"@NonNull\" values should not be set to null",
    "type": "bug",
    "severity": "minor",
    "tags": [
      "symbolic-execution",
      "cwe",
      "cert"
    ],
    "why": "<p>Fields, parameters and return values marked <code>@NotNull</code>, <code>@NonNull</code>, or <code>@Nonnull</code> are assumed to have non-null\nvalues and are not typically null-checked before use. Therefore setting one of these values to <code>null</code>, or failing to set such a class field\nin a constructor, could cause <code>NullPointerException</code>s at runtime.</p>\n<h3>Noncompliant code example</h3>\n<pre>\npublic class MainClass {\n\n  @Nonnull\n  private String primary;\n  private String secondary;\n\n  public MainClass(String color) {\n    if (color != null) {\n      secondary = null;\n    }\n    primary = color;  // Noncompliant; \"primary\" is Nonnull but could be set to null here\n  }\n\n  public MainClass() { // Noncompliant; \"primary\" is Nonnull but is not initialized\n  }\n\n  @Nonnull\n  public String indirectMix() {\n    String mix = null;\n    return mix;  // Noncompliant; return value is Nonnull, but null is returned.\n  }\n</pre>",
    "howToFix": "",
    "moreInfo": "<h3>Standards</h3>\n<ul>\n  <li> CERT - <a href=\"https://wiki.sei.cmu.edu/confluence/x/QdcxBQ\">EXP34-C. Do not dereference null pointers</a> </li>\n  <li> CERT - <a href=\"https://wiki.sei.cmu.edu/confluence/display/java/EXP01-J.+Do+not+use+a+null+in+a+case+where+an+object+is+required\">EXP01-J. Do\n  not use a null in a case where an object is required</a> </li>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/476\">CWE-476 NULL Pointer Dereference</a> </li>\n</ul>",
    "status": "READY",
    "name_ko": "@NonNull 값을 null로 설정하면 안 됩니다",
    "why_ko": "<p><code>@NotNull</code>, <code>@NonNull</code> 또는 <code>@Nonnull</code>로 표시된 필드, 매개변수 및 반환 값은 null이 아닌 값을 갖는다고 가정되며 사용 전에 일반적으로 null 검사가 수행되지 않습니다. 따라서 이러한 값 중 하나를 <code>null</code>로 설정하거나 생성자에서 이러한 클래스 필드를 설정하지 않으면 런타임에 <code>NullPointerException</code>이 발생할 수 있습니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\npublic class MainClass {\n\n  @Nonnull\n  private String primary;\n  private String secondary;\n\n  public MainClass(String color) {\n    if (color != null) {\n      secondary = null;\n    }\n    primary = color;  // 규칙 위반; \"primary\"는 Nonnull이지만 여기서 null로 설정될 수 있음\n  }\n\n  public MainClass() { // 규칙 위반; \"primary\"는 Nonnull이지만 초기화되지 않음\n  }\n\n  @Nonnull\n  public String indirectMix() {\n    String mix = null;\n    return mix;  // 규칙 위반; 반환 값은 Nonnull이지만 null이 반환됨.\n  }\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": "<h3>표준</h3>\n<ul>\n  <li> CERT - <a href=\"https://wiki.sei.cmu.edu/confluence/x/QdcxBQ\">EXP34-C. null 포인터를 역참조하지 마십시오</a> </li>\n  <li> CERT - <a href=\"https://wiki.sei.cmu.edu/confluence/display/java/EXP01-J.+Do+not+use+a+null+in+a+case+where+an+object+is+required\">EXP01-J. 객체가 필요한 경우 null을 사용하지 마십시오</a> </li>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/476\">CWE-476 NULL 포인터 역참조</a> </li>\n</ul>"
  },
  {
    "id": "S7435",
    "key": "java:S7435",
    "name": "Processing persistent unique identifiers is security-sensitive",
    "type": "security-hotspot",
    "severity": "minor",
    "tags": [
      "android"
    ],
    "why": "<p>Mobile devices expose unique identifiers that can be used to identify users across applications or devices. These identifiers put user privacy at\nrisk, as they might allow the tracking of user activity without consent, while making it difficult or impossible for users to reset them.</p>\n<p>Privacy violations can cause apps to be removed from app stores and can result in legal action or loss of trust from users.</p>\n",
    "howToFix": "<h2>Recommended Secure Coding Practices</h2>\n<ul>\n  <li> Whenever possible, use identifiers that users can easily reset. </li>\n  <li> Don't link identifiers to personally identifiable information without collecting users' explicit consent. </li>\n  <li> Avoid using identifiers that are linked to the device hardware (MAC address, IMEI, etc). </li>\n  <li> Only use the Advertising ID for user profiling or ads use cases. </li>\n</ul>\n<p>For ads use cases, use the Advertising ID provided by the platform. This identifier is designed to be reset by the user and has an associated\nPersonalized Ads flag.</p>\n<p>For non-ads use cases, the most privacy-friendly identifiers that can be used are:</p>\n<ul>\n  <li> Firebase installation ID (FID) </li>\n  <li> A privately stored GUID generated by the app </li>\n</ul>\n<h2>Compliant Solution</h2>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\nString uid = UUID.randomUUID().toString();\nUser user = new User(\n    uid,\n    \"John\",\n    \"Doe\",\n);\n</pre>\n<h2>See</h2>\n<ul>\n  <li> OWASP - <a href=\"https://owasp.org/www-project-mobile-top-10/2023-risks/m6-inadequate-privacy-controls\">Mobile Top 10 2024 Category M6 -\n  Inadequate Privacy Controls</a> </li>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/213\">CWE-213 - Exposure of Sensitive Information Due to Incompatible Policies</a> </li>\n  <li> Android Documentation - <a href=\"https://developer.android.com/identity/user-data-ids\">Best practices for unique identifiers</a> </li>\n</ul>",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "영구 고유 식별자 처리는 보안에 민감합니다",
    "why_ko": "<p>모바일 기기는 애플리케이션이나 기기 간에 사용자를 식별하는 데 사용할 수 있는 고유 식별자를 노출합니다. 이러한 식별자는 동의 없이 사용자 활동을 추적할 수 있고 사용자가 재설정하기 어렵거나 불가능하게 만들어 사용자 개인 정보를 위험에 빠뜨립니다.</p>\n<p>개인 정보 위반은 앱 스토어에서 앱이 제거되는 원인이 될 수 있으며 법적 조치나 사용자의 신뢰 상실을 초래할 수 있습니다.</p>\n",
    "howToFix_ko": "<h2>권장 보안 코딩 관행</h2>\n<ul>\n  <li> 가능할 때마다 사용자가 쉽게 재설정할 수 있는 식별자를 사용하세요. </li>\n  <li> 사용자의 명시적 동의를 수집하지 않고 식별자를 개인 식별 정보에 연결하지 마세요. </li>\n  <li> 기기 하드웨어에 연결된 식별자(MAC 주소, IMEI 등)를 사용하지 마세요. </li>\n  <li> 광고 ID는 사용자 프로파일링 또는 광고 사용 사례에만 사용하세요. </li>\n</ul>\n<p>광고 사용 사례의 경우 플랫폼에서 제공하는 광고 ID를 사용하세요. 이 식별자는 사용자가 재설정할 수 있도록 설계되었으며 연관된 맞춤형 광고 플래그가 있습니다.</p>\n<p>광고가 아닌 사용 사례의 경우 가장 개인 정보 친화적인 식별자는 다음과 같습니다:</p>\n<ul>\n  <li> Firebase 설치 ID (FID) </li>\n  <li> 앱에서 생성한 개인적으로 저장된 GUID </li>\n</ul>\n<h2>규칙을 준수하는 해결책</h2>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\nString uid = UUID.randomUUID().toString();\nUser user = new User(\n    uid,\n    \"John\",\n    \"Doe\",\n);\n</pre>\n<h2>참고</h2>\n<ul>\n  <li> OWASP - <a href=\"https://owasp.org/www-project-mobile-top-10/2023-risks/m6-inadequate-privacy-controls\">Mobile Top 10 2024 카테고리 M6 - 부적절한 개인 정보 제어</a> </li>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/213\">CWE-213 - 호환되지 않는 정책으로 인한 민감한 정보 노출</a> </li>\n  <li> Android 문서 - <a href=\"https://developer.android.com/identity/user-data-ids\">고유 식별자 모범 사례</a> </li>\n</ul>",
    "moreInfo_ko": ""
  },
  {
    "id": "S5664",
    "key": "java:S5664",
    "name": "Whitespace for text block indent should be consistent",
    "type": "code-smell",
    "severity": "major",
    "tags": [
      "java14"
    ],
    "why": "<p>Either use only spaces or only tabs for the indentation of a text block. Mixing white space will lead to a result with irregular indentation.</p>\n<h3>Noncompliant code example</h3>\n<pre>\nString textBlock = \"\"\"\n        this is\n&lt;tab&gt;text block!\n        !!!!\n      \"\"\";\n</pre>\n<h3>Compliant solution</h3>\n<pre>\nString textBlock = \"\"\"\n        this is\n        text block!\n        !!!!\n      \"\"\";\n</pre>",
    "howToFix": "",
    "moreInfo": "<ul>\n  <li> <a href=\"https://openjdk.java.net/jeps/378\">JEP 378: Text Blocks</a> </li>\n  <li> <a href=\"https://openjdk.org/projects/amber/guides/text-blocks-guide\">Programmer's Guide To Text Blocks</a>, by Jim Laskey and Stuart Marks\n  </li>\n</ul>",
    "status": "READY",
    "name_ko": "텍스트 블록 들여쓰기의 공백은 일관되어야 합니다",
    "why_ko": "<p>텍스트 블록의 들여쓰기에는 공백만 사용하거나 탭만 사용하세요. 공백을 혼합하면 불규칙한 들여쓰기 결과가 발생합니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\nString textBlock = \"\"\"\n        this is\n&lt;tab&gt;text block!\n        !!!!\n      \"\"\";\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre>\nString textBlock = \"\"\"\n        this is\n        text block!\n        !!!!\n      \"\"\";\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": "<ul>\n  <li> <a href=\"https://openjdk.java.net/jeps/378\">JEP 378: Text Blocks</a> </li>\n  <li> <a href=\"https://openjdk.org/projects/amber/guides/text-blocks-guide\">Programmer's Guide To Text Blocks</a>, Jim Laskey와 Stuart Marks 저 </li>\n</ul>"
  },
  {
    "id": "S4425",
    "key": "java:S4425",
    "name": "\"Integer.toHexString\" should not be used to build hexadecimal strings",
    "type": "code-smell",
    "severity": "major",
    "tags": [
      "cwe"
    ],
    "why": "<p>Using <code>Integer.toHexString</code> is a common mistake when converting sequences of bytes into hexadecimal string representations. The problem\nis that the method trims leading zeroes, which can lead to wrong conversions. For instance a two bytes value of <code>0x4508</code> would be converted\ninto <code>45</code> and <code>8</code> which once concatenated would give <code>0x458</code>.</p>\n<p>This is particularly damaging when converting hash-codes and could lead to a security vulnerability.</p>\n<p>This rule raises an issue when <code>Integer.toHexString</code> is used in any kind of string concatenations.</p>\n<h3>Noncompliant code example</h3>\n<pre>\nMessageDigest md = MessageDigest.getInstance(\"SHA-256\");\nbyte[] bytes = md.digest(password.getBytes(\"UTF-8\"));\n\nStringBuilder sb = new StringBuilder();\nfor (byte b : bytes) {\n    sb.append(Integer.toHexString( b &amp; 0xFF )); // Noncompliant\n}\n</pre>\n<h3>Compliant solution</h3>\n<pre>\nMessageDigest md = MessageDigest.getInstance(\"SHA-256\");\nbyte[] bytes = md.digest(password.getBytes(\"UTF-8\"));\n\nStringBuilder sb = new StringBuilder();\nfor (byte b : bytes) {\n    sb.append(String.format(\"%02X\", b));\n}\n</pre>",
    "howToFix": "",
    "moreInfo": "<ul>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/704\">CWE-704 - Incorrect Type Conversion or Cast</a> </li>\n  <li> Derived from FindSecBugs rule <a href=\"https://find-sec-bugs.github.io/bugs.htm#BAD_HEXA_CONVERSION\">BAD_HEXA_CONVERSION</a> </li>\n</ul>",
    "status": "READY",
    "name_ko": "16진수 문자열 생성에 \"Integer.toHexString\"을 사용하면 안 됩니다",
    "why_ko": "<p><code>Integer.toHexString</code>을 사용하는 것은 바이트 시퀀스를 16진수 문자열 표현으로 변환할 때 흔히 하는 실수입니다. 문제는 이 메서드가 선행 0을 제거하여 잘못된 변환을 초래할 수 있다는 것입니다. 예를 들어 <code>0x4508</code>의 2바이트 값은 <code>45</code>와 <code>8</code>로 변환되어 연결하면 <code>0x458</code>이 됩니다.</p>\n<p>이는 해시 코드를 변환할 때 특히 해로우며 보안 취약점으로 이어질 수 있습니다.</p>\n<p>이 규칙은 <code>Integer.toHexString</code>이 모든 종류의 문자열 연결에서 사용될 때 문제를 제기합니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\nMessageDigest md = MessageDigest.getInstance(\"SHA-256\");\nbyte[] bytes = md.digest(password.getBytes(\"UTF-8\"));\n\nStringBuilder sb = new StringBuilder();\nfor (byte b : bytes) {\n    sb.append(Integer.toHexString( b &amp; 0xFF )); // 규칙 위반\n}\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre>\nMessageDigest md = MessageDigest.getInstance(\"SHA-256\");\nbyte[] bytes = md.digest(password.getBytes(\"UTF-8\"));\n\nStringBuilder sb = new StringBuilder();\nfor (byte b : bytes) {\n    sb.append(String.format(\"%02X\", b));\n}\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": "<ul>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/704\">CWE-704 - Incorrect Type Conversion or Cast</a> </li>\n  <li> FindSecBugs 규칙에서 파생됨 <a href=\"https://find-sec-bugs.github.io/bugs.htm#BAD_HEXA_CONVERSION\">BAD_HEXA_CONVERSION</a> </li>\n</ul>"
  },
  {
    "id": "S6418",
    "key": "java:S6418",
    "name": "Hard-coded secrets are security-sensitive",
    "type": "security-hotspot",
    "severity": "blocker",
    "tags": [
      "cwe",
      "cert"
    ],
    "why": "<p>Because it is easy to extract strings from an application source code or binary, secrets should not be hard-coded. This is particularly true for\napplications that are distributed or that are open-source.</p>\n<p>In the past, it has led to the following vulnerabilities:</p>\n<ul>\n  <li> <a href=\"https://www.cve.org/CVERecord?id=CVE-2022-25510\">CVE-2022-25510</a> </li>\n  <li> <a href=\"https://www.cve.org/CVERecord?id=CVE-2021-42635\">CVE-2021-42635</a> </li>\n</ul>\n<p>Secrets should be stored outside of the source code in a configuration file or a management service for secrets.</p>\n<p>This rule detects variables/fields having a name matching a list of words (secret, token, credential, auth, api[_.-]?key) being assigned a\npseudorandom hard-coded value. The pseudorandomness of the hard-coded value is based on its entropy and the probability to be human-readable. The\nrandomness sensibility can be adjusted if needed. Lower values will detect less random values, raising potentially more false positives.</p>\n",
    "howToFix": "<h2>Recommended Secure Coding Practices</h2>\n<ul>\n  <li> Store the secret in a configuration file that is not pushed to the code repository. </li>\n  <li> Use your cloud provider's service for managing secrets. </li>\n  <li> If a secret has been disclosed through the source code: revoke it and create a new one. </li>\n</ul>\n<h2>Compliant Solution</h2>\n<p>Using <a href=\"https://github.com/awsdocs/aws-doc-sdk-examples/tree/main/javav2/example_code/secrets-manager\">AWS Secrets Manager</a>:</p>\n<pre>\nimport software.amazon.awssdk.services.secretsmanager.model.GetSecretValueRequest;\nimport software.amazon.awssdk.services.secretsmanager.model.GetSecretValueResponse;\n\npublic static void main(String[] args) {\n  SecretsManagerClient secretsClient = ...\n  MyClass.doSomething(secretsClient, \"MY_SERVICE_SECRET\");\n}\n\npublic static void doSomething(SecretsManagerClient secretsClient, String secretName) {\n  GetSecretValueRequest valueRequest = GetSecretValueRequest.builder()\n    .secretId(secretName)\n    .build();\n\n  GetSecretValueResponse valueResponse = secretsClient.getSecretValue(valueRequest);\n  String secret = valueResponse.secretString();\n  // do something with the secret\n  MyClass.callMyService(secret);\n}\n</pre>\n<p>Using <a href=\"https://docs.microsoft.com/en-us/azure/key-vault/secrets/quick-create-java?tabs=azure-cli\">Azure Key Vault Secret</a>:</p>\n<pre>\nimport com.azure.identity.DefaultAzureCredentialBuilder;\n\nimport com.azure.security.keyvault.secrets.SecretClient;\nimport com.azure.security.keyvault.secrets.SecretClientBuilder;\nimport com.azure.security.keyvault.secrets.models.KeyVaultSecret;\n\npublic static void main(String[] args) throws InterruptedException, IllegalArgumentException {\n  String keyVaultName = System.getenv(\"KEY_VAULT_NAME\");\n  String keyVaultUri = \"https://\" + keyVaultName + \".vault.azure.net\";\n\n  SecretClient secretClient = new SecretClientBuilder()\n    .vaultUrl(keyVaultUri)\n    .credential(new DefaultAzureCredentialBuilder().build())\n    .buildClient();\n\n  MyClass.doSomething(secretClient, \"MY_SERVICE_SECRET\");\n}\n\npublic static void doSomething(SecretClient secretClient, String secretName) {\n  KeyVaultSecret retrievedSecret = secretClient.getSecret(secretName);\n  String secret = retrievedSecret.getValue(),\n\n  // do something with the secret\n  MyClass.callMyService(secret);\n}\n</pre>\n<h2>See</h2>\n<ul>\n  <li> OWASP - <a href=\"https://owasp.org/Top10/A07_2021-Identification_and_Authentication_Failures/\">Top 10 2021 Category A7 - Identification and\n  Authentication Failures</a> </li>\n  <li> OWASP - <a href=\"https://owasp.org/www-project-top-ten/2017/A2_2017-Broken_Authentication\">Top 10 2017 Category A2 - Broken Authentication</a>\n  </li>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/798\">CWE-798 - Use of Hard-coded Credentials</a> </li>\n  <li> OWASP - <a href=\"https://owasp.org/www-project-mobile-top-10/2023-risks/m1-improper-credential-usage.html\">Mobile Top 10 2024 Category M1 -\n  Improper Credential Usage</a> </li>\n  <li> MSC - <a href=\"https://wiki.sei.cmu.edu/confluence/x/OjdGBQ\">MSC03-J - Never hard code sensitive information</a> </li>\n</ul>",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "하드코딩된 비밀 정보는 보안에 민감합니다",
    "why_ko": "<p>애플리케이션 소스 코드나 바이너리에서 문자열을 추출하기 쉽기 때문에 비밀 정보는 하드코딩하면 안 됩니다. 이는 배포되거나 오픈소스인 애플리케이션에서 특히 그렇습니다.</p>\n<p>과거에 이로 인해 다음과 같은 취약점이 발생했습니다:</p>\n<ul>\n  <li> <a href=\"https://www.cve.org/CVERecord?id=CVE-2022-25510\">CVE-2022-25510</a> </li>\n  <li> <a href=\"https://www.cve.org/CVERecord?id=CVE-2021-42635\">CVE-2021-42635</a> </li>\n</ul>\n<p>비밀 정보는 소스 코드 외부의 구성 파일이나 비밀 관리 서비스에 저장해야 합니다.</p>\n<p>이 규칙은 단어 목록(secret, token, credential, auth, api[_.-]?key)과 일치하는 이름을 가진 변수/필드에 의사 난수 하드코딩된 값이 할당될 때 이를 감지합니다. 하드코딩된 값의 의사 난수성은 엔트로피와 사람이 읽을 수 있는 확률을 기반으로 합니다. 필요한 경우 난수 감도를 조정할 수 있습니다. 낮은 값은 덜 무작위한 값을 감지하여 잠재적으로 더 많은 오탐을 발생시킵니다.</p>\n",
    "howToFix_ko": "<h2>권장 보안 코딩 관행</h2>\n<ul>\n  <li> 코드 저장소에 푸시되지 않는 구성 파일에 비밀을 저장하세요. </li>\n  <li> 비밀 관리를 위해 클라우드 제공업체의 서비스를 사용하세요. </li>\n  <li> 비밀이 소스 코드를 통해 노출된 경우: 취소하고 새로 만드세요. </li>\n</ul>\n<h2>규칙을 준수하는 해결책</h2>\n<p><a href=\"https://github.com/awsdocs/aws-doc-sdk-examples/tree/main/javav2/example_code/secrets-manager\">AWS Secrets Manager</a> 사용:</p>\n<pre>\nimport software.amazon.awssdk.services.secretsmanager.model.GetSecretValueRequest;\nimport software.amazon.awssdk.services.secretsmanager.model.GetSecretValueResponse;\n\npublic static void main(String[] args) {\n  SecretsManagerClient secretsClient = ...\n  MyClass.doSomething(secretsClient, \"MY_SERVICE_SECRET\");\n}\n\npublic static void doSomething(SecretsManagerClient secretsClient, String secretName) {\n  GetSecretValueRequest valueRequest = GetSecretValueRequest.builder()\n    .secretId(secretName)\n    .build();\n\n  GetSecretValueResponse valueResponse = secretsClient.getSecretValue(valueRequest);\n  String secret = valueResponse.secretString();\n  // 비밀로 작업 수행\n  MyClass.callMyService(secret);\n}\n</pre>\n<p><a href=\"https://docs.microsoft.com/en-us/azure/key-vault/secrets/quick-create-java?tabs=azure-cli\">Azure Key Vault Secret</a> 사용:</p>\n<pre>\nimport com.azure.identity.DefaultAzureCredentialBuilder;\n\nimport com.azure.security.keyvault.secrets.SecretClient;\nimport com.azure.security.keyvault.secrets.SecretClientBuilder;\nimport com.azure.security.keyvault.secrets.models.KeyVaultSecret;\n\npublic static void main(String[] args) throws InterruptedException, IllegalArgumentException {\n  String keyVaultName = System.getenv(\"KEY_VAULT_NAME\");\n  String keyVaultUri = \"https://\" + keyVaultName + \".vault.azure.net\";\n\n  SecretClient secretClient = new SecretClientBuilder()\n    .vaultUrl(keyVaultUri)\n    .credential(new DefaultAzureCredentialBuilder().build())\n    .buildClient();\n\n  MyClass.doSomething(secretClient, \"MY_SERVICE_SECRET\");\n}\n\npublic static void doSomething(SecretClient secretClient, String secretName) {\n  KeyVaultSecret retrievedSecret = secretClient.getSecret(secretName);\n  String secret = retrievedSecret.getValue(),\n\n  // 비밀로 작업 수행\n  MyClass.callMyService(secret);\n}\n</pre>\n<h2>참고</h2>\n<ul>\n  <li> OWASP - <a href=\"https://owasp.org/Top10/A07_2021-Identification_and_Authentication_Failures/\">Top 10 2021 Category A7 - 식별 및 인증 실패</a> </li>\n  <li> OWASP - <a href=\"https://owasp.org/www-project-top-ten/2017/A2_2017-Broken_Authentication\">Top 10 2017 Category A2 - 취약한 인증</a> </li>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/798\">CWE-798 - 하드코딩된 자격 증명 사용</a> </li>\n  <li> OWASP - <a href=\"https://owasp.org/www-project-mobile-top-10/2023-risks/m1-improper-credential-usage.html\">Mobile Top 10 2024 Category M1 - 부적절한 자격 증명 사용</a> </li>\n  <li> MSC - <a href=\"https://wiki.sei.cmu.edu/confluence/x/OjdGBQ\">MSC03-J - 민감한 정보를 절대 하드코딩하지 마세요</a> </li>\n</ul>",
    "moreInfo_ko": ""
  },
  {
    "id": "S1109",
    "key": "java:S1109",
    "name": "A close curly brace should be located at the beginning of a line",
    "type": "code-smell",
    "severity": "minor",
    "tags": [
      "convention"
    ],
    "why": "<p>Shared coding conventions make it possible for a team to efficiently collaborate. This rule makes it mandatory to place a close curly brace at the\nbeginning of a line.</p>\n<h3>Noncompliant code example</h3>\n<pre>\nif(condition) {\n  doSomething();}\n</pre>\n<h3>Compliant solution</h3>\n<pre>\nif(condition) {\n  doSomething();\n}\n</pre>\n<h3>Exceptions</h3>\n<p>When blocks are inlined (open and close curly braces on the same line), no issue is triggered.</p>\n<pre>\nif(condition) {doSomething();}\n</pre>",
    "howToFix": "",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "닫는 중괄호는 줄의 시작에 위치해야 합니다",
    "why_ko": "<p>공유된 코딩 규칙은 팀이 효율적으로 협업할 수 있게 해줍니다. 이 규칙은 닫는 중괄호를 줄의 시작에 배치하도록 의무화합니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\nif(condition) {\n  doSomething();}\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre>\nif(condition) {\n  doSomething();\n}\n</pre>\n<h3>예외</h3>\n<p>블록이 인라인된 경우(여는 중괄호와 닫는 중괄호가 같은 줄에 있는 경우) 이슈가 트리거되지 않습니다.</p>\n<pre>\nif(condition) {doSomething();}\n</pre>","howToFix_ko": "",
    "moreInfo_ko": ""
  },
  {
    "id": "S7177",
    "key": "java:S7177",
    "name": "Use appropriate @DirtiesContext modes",
    "type": "code-smell",
    "severity": "major",
    "tags": [
      "spring",
      "tests"
    ],
    "why": "<p>In a Spring application, the <code>@DirtiesContext</code> annotation marks the ApplicationContext as dirty and indicates that it should be cleared\nand recreated. This is important in tests that modify the context, such as altering the state of singleton beans or databases.</p>\n<p>Misconfiguring <code>@DirtiesContext</code> by setting the <code>methodMode</code> at the class level or the <code>classMode</code> at the method\nlevel will make the annotation have no effect.</p>\n<p>This rule will raise an issue when the incorrect mode is configured on a @DirtiesContext annotation targeting a different scope.</p>",
    "howToFix": "<h4>Noncompliant code example</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\n@ContextConfiguration\n@DirtiesContext(methodMode = MethodMode.AFTER_METHOD) // Noncompliant, for class-level control, use classMode instead.\npublic class TestClass {\n  @DirtiesContext(classMode = DirtiesContext.ClassMode.AFTER_CLASS) // Non compliant, for method-level control use methodMode instead\n  public void test() {...}\n}\n</pre>\n<h4>Compliant solution</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\n@ContextConfiguration\n@DirtiesContext(classMode = DirtiesContext.ClassMode.AFTER_CLASS)\npublic class TestClass {\n  @DirtiesContext(methodMode = MethodMode.AFTER_METHOD)\n  public void test() {...}\n}\n</pre>",
    "moreInfo": "<h3>Documentation</h3>\n<ul>\n  <li> Spring documentation - <a\n  href=\"https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/test/annotation/DirtiesContext.html\">@DirtiesContext</a>\n  </li>\n</ul>",
    "status": "READY",
    "name_ko": "적절한 @DirtiesContext 모드를 사용해야 합니다",
    "why_ko": "<p>Spring 애플리케이션에서 <code>@DirtiesContext</code> 어노테이션은 ApplicationContext를 더티(dirty)로 표시하고 지우고 다시 생성해야 함을 나타냅니다. 이것은 싱글톤 빈 또는 데이터베이스의 상태를 변경하는 것과 같이 컨텍스트를 수정하는 테스트에서 중요합니다.</p>\n<p>클래스 레벨에서 <code>methodMode</code>를 설정하거나 메서드 레벨에서 <code>classMode</code>를 설정하여 <code>@DirtiesContext</code>를 잘못 구성하면 어노테이션이 효과가 없게 됩니다.</p>\n<p>이 규칙은 다른 범위를 대상으로 하는 @DirtiesContext 어노테이션에 잘못된 모드가 구성될 때 문제를 발생시킵니다.</p>",
    "howToFix_ko": "<h4>규칙을 준수하지 않는 코드 예시</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\n@ContextConfiguration\n@DirtiesContext(methodMode = MethodMode.AFTER_METHOD) // 규칙 위반, 클래스 레벨 제어에는 classMode를 사용하세요.\npublic class TestClass {\n  @DirtiesContext(classMode = DirtiesContext.ClassMode.AFTER_CLASS) // 규칙 위반, 메서드 레벨 제어에는 methodMode를 사용하세요\n  public void test() {...}\n}\n</pre>\n<h4>규칙을 준수하는 해결책</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\n@ContextConfiguration\n@DirtiesContext(classMode = DirtiesContext.ClassMode.AFTER_CLASS)\npublic class TestClass {\n  @DirtiesContext(methodMode = MethodMode.AFTER_METHOD)\n  public void test() {...}\n}\n</pre>",
    "moreInfo_ko": "<h3>문서</h3>\n<ul>\n  <li> Spring 문서 - <a href=\"https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/test/annotation/DirtiesContext.html\">@DirtiesContext</a> </li>\n</ul>"
  },
  {
    "id": "S3972",
    "key": "java:S3972",
    "name": "Conditionals should start on new lines",
    "type": "code-smell",
    "severity": "critical",
    "tags": [
      "suspicious"
    ],
    "why": "<p>Placing an <code>if</code> statement on the same line as the closing <code>}</code> from a preceding <code>if</code>, <code>else</code>, or\n<code>else if</code> block can lead to confusion and potential errors. It may indicate a missing <code>else</code> statement or create ambiguity for\nmaintainers who might fail to understand that the two statements are unconnected.</p>\n<p>The following code snippet is confusing:</p>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\nif (condition1) {\n  // ...\n} if (condition2) {  // Noncompliant\n  //...\n}\n</pre>\n<p>Either the two conditions are unrelated and they should be visually separated:</p>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\nif (condition1) {\n  // ...\n}\n\nif (condition2) {\n  //...\n}\n</pre>\n<p>Or they were supposed to be exclusive and you should use <code>else if</code> instead:</p>\n<pre>\nif (condition1) {\n  // ...\n} else if (condition2) {\n  //...\n}\n</pre>",
    "howToFix": "",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "조건문은 새 줄에서 시작해야 합니다",
    "why_ko": "<p><code>if</code> 문을 이전 <code>if</code>, <code>else</code>, 또는 <code>else if</code> 블록의 닫는 <code>}</code>와 같은 줄에 배치하면 혼란과 잠재적인 오류가 발생할 수 있습니다. 누락된 <code>else</code> 문을 나타내거나 두 문이 연결되지 않았다는 것을 이해하지 못하는 유지보수 담당자에게 모호함을 줄 수 있습니다.</p>\n<p>다음 코드 스니펫은 혼란스럽습니다:</p>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\nif (condition1) {\n  // ...\n} if (condition2) {  // 규칙 위반\n  //...\n}\n</pre>\n<p>두 조건이 관련이 없다면 시각적으로 분리해야 합니다:</p>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\nif (condition1) {\n  // ...\n}\n\nif (condition2) {\n  //...\n}\n</pre>\n<p>또는 배타적이어야 했다면 <code>else if</code>를 사용해야 합니다:</p>\n<pre>\nif (condition1) {\n  // ...\n} else if (condition2) {\n  //...\n}\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": ""
  },
  {
    "id": "S2230",
    "key": "java:S2230",
    "name": "Methods with Spring proxying annotations should be public",
    "type": "bug",
    "severity": "major",
    "tags": [
      "spring"
    ],
    "why": "<p>Marking a non-public method <code>@Async</code> or <code>@Transactional</code> is misleading because, up to version 5, Spring does not recognize\nnon-public methods, and so makes no provision for their proper invocation. Nor does Spring make provision for the methods invoked by the method it\ncalled. Since Spring 6, protected and package-private methods can be handled, but the issue remains for private methods.</p>\n<p>Therefore, marking a private method, for instance, @Transactional gives a false sense of security, and can lead to incorrect assumptions and\npotential bugs.</p>\n<h2>Exceptions</h2>\n<p>The rule targets all non-public methods for project using Spring up to Spring 5, but only private methods for Spring 6 because Spring 6 takes into\naccount all non-private methods.</p>",
    "howToFix": "<p>Declare the method <code>public</code>. Note that this action alone does not resolve the issue of direct instance calls from within the same class\n(see rule <a href='/coding_rules#rule_key=java%3AS6809'>S6809</a>), but it is a required precondition to fix it.</p>\n\n<h4>Noncompliant code example</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\n@Async\nprivate Future&lt;String&gt; asyncMethodWithReturnType() { // Noncompliant, no proxy generated and\n    return \"Hellow, world!\";                         // can only be invoked from same class\n}\n</pre>\n<h4>Compliant solution</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\n@Async\npublic Future&lt;String&gt; asyncMethodWithReturnType() { // Compliant\n    return \"Hellow, world!\";\n}\n</pre>",
    "moreInfo": "<h3>Documentation</h3>\n<ul>\n  <li> <a href=\"https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/scheduling/annotation/Async.html\">Spring\n  Framework API - Annotation Interface Async</a> </li>\n  <li> <a href=\"https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/transaction/annotation/Transactional.html\">Spring\n  Framework API - Annotation Interface Transactional</a> </li>\n  <li> <a\n  href=\"https://docs.spring.io/spring-framework/reference/6.2.6/data-access/transaction/declarative/annotations.html#transaction-declarative-annotations-method-visibility\">Method visibility and @Transactional in proxy mode</a> </li>\n</ul>\n<h3>Articles &amp; blog posts</h3>\n<ul>\n  <li> <a href=\"https://www.baeldung.com/spring-async\">Baeldung - How To Do @Async in Spring</a> </li>\n  <li> <a href=\"https://stackoverflow.com/questions/22561775/spring-async-ignored\">Stack Overflow - Spring @Async ignored</a> </li>\n  <li> <a href=\"https://stackoverflow.com/questions/4396284/does-spring-transactional-attribute-work-on-a-private-method\">Stack Overflow - Does Spring\n  @Transactional attribute work on a private method?</a> </li>\n</ul>",
    "status": "READY",
    "name_ko": "Spring 프록시 어노테이션이 있는 메서드는 public이어야 합니다",
    "why_ko": "<p>비공개 메서드에 <code>@Async</code> 또는 <code>@Transactional</code>을 표시하는 것은 오해의 소지가 있습니다. 버전 5까지 Spring은 비공개 메서드를 인식하지 못하므로 적절한 호출을 위한 준비를 하지 않기 때문입니다. Spring이 호출한 메서드에 의해 호출되는 메서드에 대해서도 마찬가지입니다. Spring 6부터 protected 및 package-private 메서드를 처리할 수 있지만 private 메서드에 대한 문제는 여전히 남아 있습니다.</p>\n<p>따라서 예를 들어 private 메서드에 @Transactional을 표시하면 잘못된 안정감을 주고 잘못된 가정과 잠재적인 버그로 이어질 수 있습니다.</p>\n<h2>예외</h2>\n<p>이 규칙은 Spring 5까지 사용하는 프로젝트의 모든 비공개 메서드를 대상으로 하지만, Spring 6의 경우 모든 비private 메서드를 고려하므로 private 메서드만 대상으로 합니다.</p>",
    "howToFix_ko": "<p>메서드를 <code>public</code>으로 선언하세요. 이 조치만으로는 동일한 클래스 내에서의 직접 인스턴스 호출 문제가 해결되지 않지만(<a href='/coding_rules#rule_key=java%3AS6809'>S6809</a> 규칙 참조), 이를 해결하기 위한 필수 전제 조건입니다.</p>\n\n<h4>규칙을 준수하지 않는 코드 예시</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\n@Async\nprivate Future&lt;String&gt; asyncMethodWithReturnType() { // 규칙 위반, 프록시가 생성되지 않으며\n    return \"Hellow, world!\";                         // 동일한 클래스에서만 호출 가능\n}\n</pre>\n<h4>규칙을 준수하는 해결책</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\n@Async\npublic Future&lt;String&gt; asyncMethodWithReturnType() { // 규칙 준수\n    return \"Hellow, world!\";\n}\n</pre>",
    "moreInfo_ko": "<h3>문서</h3>\n<ul>\n  <li> <a href=\"https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/scheduling/annotation/Async.html\">Spring Framework API - Async 어노테이션 인터페이스</a> </li>\n  <li> <a href=\"https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/transaction/annotation/Transactional.html\">Spring Framework API - Transactional 어노테이션 인터페이스</a> </li>\n  <li> <a href=\"https://docs.spring.io/spring-framework/reference/6.2.6/data-access/transaction/declarative/annotations.html#transaction-declarative-annotations-method-visibility\">프록시 모드에서의 메서드 가시성과 @Transactional</a> </li>\n</ul>\n<h3>관련 문서 및 블로그 게시물</h3>\n<ul>\n  <li> <a href=\"https://www.baeldung.com/spring-async\">Baeldung - Spring에서 @Async 사용하기</a> </li>\n  <li> <a href=\"https://stackoverflow.com/questions/22561775/spring-async-ignored\">Stack Overflow - Spring @Async가 무시됨</a> </li>\n  <li> <a href=\"https://stackoverflow.com/questions/4396284/does-spring-transactional-attribute-work-on-a-private-method\">Stack Overflow - Spring @Transactional 속성이 private 메서드에서 작동하나요?</a> </li>\n</ul>"
  },
  {
    "id": "S2119",
    "key": "java:S2119",
    "name": "\"Random\" objects should be reused",
    "type": "bug",
    "severity": "critical",
    "tags": [],
    "why": "<p>Creating a new <code>Random</code> object each time a random value is needed is inefficient and may produce numbers that are not random, depending\non the JDK. For better efficiency and randomness, create a single <code>Random</code>, store it, and reuse it.</p>\n<p>The <code>Random()</code> constructor tries to set the seed with a distinct value every time. However, there is no guarantee that the seed will be\nrandomly or uniformly distributed. Some JDK will use the current time as seed, making the generated numbers not random.</p>\n<p>This rule finds cases where a new <code>Random</code> is created each time a method is invoked.</p>\n<h3>Exceptions</h3>\n<p>This rule doesn't apply to classes that use a <code>Random</code> in their constructors or the static <code>main</code> function and nowhere\nelse.</p>",
    "howToFix": "<p>Define and reuse the <code>Random</code> object.</p>\n\n<h4>Noncompliant code example</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\nclass MyClass {\n\n    public void doSomethingCommon() {\n      Random random = new Random();        // Noncompliant - new instance created with each invocation\n      int rValue = random.nextInt();\n    }\n}\n</pre>\n<h4>Compliant solution</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\nclass MyClass {\n    private Random random = new Random();  // Compliant\n\n    public void doSomethingCommon() {\n      int rValue = this.random.nextInt();\n    }\n}\n</pre>",
    "moreInfo": "<h3>Documentation</h3>\n<ul>\n  <li> <a href=\"https://docs.oracle.com/en/java/javase/20/docs/api/java.base/java/util/Random.html\">Oracle Java SE - Random</a> </li>\n</ul>\n<h3>Articles &amp; blog posts</h3>\n<ul>\n  <li> OWASP - <a href=\"https://owasp.org/www-project-top-ten/2017/A6_2017-Security_Misconfiguration\">Top 10 2017 Category A6 - Security\n  Misconfiguration</a> </li>\n  <li> <a href=\"https://www.baeldung.com/java-generating-random-numbers\">Baeldung - generating random number</a> </li>\n</ul>",
    "status": "READY",
    "name_ko": "\"Random\" 객체는 재사용해야 합니다",
    "why_ko": "<p>랜덤 값이 필요할 때마다 새로운 <code>Random</code> 객체를 생성하는 것은 비효율적이며 JDK에 따라 랜덤하지 않은 숫자를 생성할 수 있습니다. 더 나은 효율성과 무작위성을 위해 단일 <code>Random</code>을 생성하고 저장하여 재사용하세요.</p>\n<p><code>Random()</code> 생성자는 매번 고유한 값으로 시드를 설정하려고 합니다. 그러나 시드가 무작위로 또는 균일하게 분포될 것이라는 보장은 없습니다. 일부 JDK는 현재 시간을 시드로 사용하여 생성된 숫자가 랜덤하지 않게 됩니다.</p>\n<p>이 규칙은 메서드가 호출될 때마다 새로운 <code>Random</code>이 생성되는 경우를 찾습니다.</p>\n<h3>예외</h3>\n<p>이 규칙은 생성자나 static <code>main</code> 함수에서만 <code>Random</code>을 사용하고 다른 곳에서는 사용하지 않는 클래스에는 적용되지 않습니다.</p>",
    "howToFix_ko": "<p><code>Random</code> 객체를 정의하고 재사용하세요.</p>\n\n<h4>규칙을 준수하지 않는 코드 예시</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\nclass MyClass {\n\n    public void doSomethingCommon() {\n      Random random = new Random();        // 규칙 위반 - 호출될 때마다 새 인스턴스 생성\n      int rValue = random.nextInt();\n    }\n}\n</pre>\n<h4>규칙을 준수하는 해결책</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\nclass MyClass {\n    private Random random = new Random();  // 규칙 준수\n\n    public void doSomethingCommon() {\n      int rValue = this.random.nextInt();\n    }\n}\n</pre>",
    "moreInfo_ko": "<h3>문서</h3>\n<ul>\n  <li> <a href=\"https://docs.oracle.com/en/java/javase/20/docs/api/java.base/java/util/Random.html\">Oracle Java SE - Random</a> </li>\n</ul>\n<h3>관련 문서 및 블로그 게시물</h3>\n<ul>\n  <li> OWASP - <a href=\"https://owasp.org/www-project-top-ten/2017/A6_2017-Security_Misconfiguration\">Top 10 2017 카테고리 A6 - 보안 구성 오류</a> </li>\n  <li> <a href=\"https://www.baeldung.com/java-generating-random-numbers\">Baeldung - 랜덤 숫자 생성</a> </li>\n</ul>"
  },
  {
    "id": "S5776",
    "key": "java:S5776",
    "name": "Exception testing via JUnit ExpectedException rule should not be mixed with other assertions",
    "type": "code-smell",
    "severity": "major",
    "tags": [
      "junit",
      "tests"
    ],
    "why": "<p>When testing exception via <code>org.junit.rules.ExpectedException</code> any code after the raised exception will not be executed, so adding\nsubsequent assertions is wrong and misleading. This rule raises an issue when an assertion is done after the \"expect(…​)\" invocation, only the code\nthrowing the expected exception should be after \"expect(…​)\".</p>\n<p>You should consider using <a\nhref=\"https://github.com/junit-team/junit4/wiki/Exception-testing#using-assertthrows-method\">org.junit.Assert.assertThrows</a> instead, it's available\nsince JUnit 4.13 and it allows additional subsequent assertions.</p>\n<p>Alternatively, you could use <a href=\"https://github.com/junit-team/junit4/wiki/Exception-testing#trycatch-idiom\">try-catch idiom</a> for JUnit\nversion &lt; 4.13 or if your project does not support lambdas.</p>\n<h3>Noncompliant code example</h3>\n<pre>\n@Rule\npublic ExpectedException thrown = ExpectedException.none();\n\n@Test\npublic void test() throws IndexOutOfBoundsException {\n  thrown.expect(IndexOutOfBoundsException.class); // Noncompliant\n  Object o = get();\n  // This test pass since execution will never get past this line.\n  Assert.assertEquals(0, 1);\n}\n\nprivate Object get() {\n  throw new IndexOutOfBoundsException();\n}\n</pre>\n<h3>Compliant solution</h3>\n<ul>\n  <li> For JUnit &gt;= 4.13, use <a\n  href=\"https://github.com/junit-team/junit4/wiki/Exception-testing#using-assertthrows-method\">org.junit.Assert.assertThrows</a>: </li>\n</ul>\n<pre>\nAssert.assertThrows(IndexOutOfBoundsException.class, () -&gt; get());\n// This test correctly fails.\nAssert.assertEquals(0, 1);\n</pre>\n<ul>\n  <li> For JUnit &lt; 4.13, use the <a href=\"https://github.com/junit-team/junit4/wiki/Exception-testing#trycatch-idiom\">try-catch idiom</a>: </li>\n</ul>\n<pre>\ntry {\n  get();\n  Assert.fail(\"Expected an IndexOutOfBoundsException to be thrown\");\n} catch (IndexOutOfBoundsException e) {}\nAssert.assertEquals(0, 1); // Correctly fails.\n</pre>",
    "howToFix": "",
    "moreInfo": "<ul>\n  <li> <a href=\"https://github.com/junit-team/junit4/wiki/Exception-testing\">JUnit exception testing documentation</a> </li>\n</ul>",
    "status": "READY",
    "name_ko": "JUnit ExpectedException 규칙을 통한 예외 테스트는 다른 assertion과 혼합하면 안 됩니다",
    "why_ko": "<p><code>org.junit.rules.ExpectedException</code>을 통해 예외를 테스트할 때 발생한 예외 이후의 모든 코드는 실행되지 않으므로 후속 assertion을 추가하는 것은 잘못되었고 오해의 소지가 있습니다. 이 규칙은 \"expect(...)\" 호출 후에 assertion이 수행될 때 문제를 제기합니다. 예상되는 예외를 던지는 코드만 \"expect(...)\" 뒤에 있어야 합니다.</p>\n<p>대신 <a href=\"https://github.com/junit-team/junit4/wiki/Exception-testing#using-assertthrows-method\">org.junit.Assert.assertThrows</a>를 사용하는 것을 고려해야 합니다. JUnit 4.13부터 사용 가능하며 추가 후속 assertion을 허용합니다.</p>\n<p>또는 JUnit 버전 < 4.13이거나 프로젝트가 람다를 지원하지 않는 경우 <a href=\"https://github.com/junit-team/junit4/wiki/Exception-testing#trycatch-idiom\">try-catch 관용구</a>를 사용할 수 있습니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\n@Rule\npublic ExpectedException thrown = ExpectedException.none();\n\n@Test\npublic void test() throws IndexOutOfBoundsException {\n  thrown.expect(IndexOutOfBoundsException.class); // 규칙 위반\n  Object o = get();\n  // 실행이 이 줄을 지나지 않으므로 이 테스트는 통과합니다.\n  Assert.assertEquals(0, 1);\n}\n\nprivate Object get() {\n  throw new IndexOutOfBoundsException();\n}\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<ul>\n  <li> JUnit >= 4.13의 경우 <a href=\"https://github.com/junit-team/junit4/wiki/Exception-testing#using-assertthrows-method\">org.junit.Assert.assertThrows</a>를 사용하세요: </li>\n</ul>\n<pre>\nAssert.assertThrows(IndexOutOfBoundsException.class, () -&gt; get());\n// 이 테스트는 올바르게 실패합니다.\nAssert.assertEquals(0, 1);\n</pre>\n<ul>\n  <li> JUnit < 4.13의 경우 <a href=\"https://github.com/junit-team/junit4/wiki/Exception-testing#trycatch-idiom\">try-catch 관용구</a>를 사용하세요: </li>\n</ul>\n<pre>\ntry {\n  get();\n  Assert.fail(\"IndexOutOfBoundsException이 발생해야 합니다\");\n} catch (IndexOutOfBoundsException e) {}\nAssert.assertEquals(0, 1); // 올바르게 실패합니다.\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": "<ul>\n  <li> <a href=\"https://github.com/junit-team/junit4/wiki/Exception-testing\">JUnit 예외 테스트 문서</a> </li>\n</ul>"
  },
  {
    "id": "S3358",
    "key": "java:S3358",
    "name": "Ternary operators should not be nested",
    "type": "code-smell",
    "severity": "major",
    "tags": [
      "confusing"
    ],
    "why": "<p>Nested ternaries are hard to read and can make the order of operations complex to understand.</p>\n<pre>\npublic String getReadableStatus(Job j) {\n  return j.isRunning() ? \"Running\" : j.hasErrors() ? \"Failed\" : \"Succeeded\";  // Noncompliant\n}\n</pre>\n<p>Instead, use another line to express the nested operation in a separate statement.</p>\n<pre>\npublic String getReadableStatus(Job j) {\n  if (j.isRunning()) {\n    return \"Running\";\n  }\n  return j.hasErrors() ? \"Failed\" : \"Succeeded\";\n}\n</pre>",
    "howToFix": "",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "삼항 연산자를 중첩하면 안 됩니다",
    "why_ko": "<p>중첩된 삼항 연산자는 읽기 어렵고 연산 순서를 이해하기 복잡하게 만들 수 있습니다.</p>\n<pre>\npublic String getReadableStatus(Job j) {\n  return j.isRunning() ? \"Running\" : j.hasErrors() ? \"Failed\" : \"Succeeded\";  // 규칙 위반\n}\n</pre>\n<p>대신 별도의 문으로 중첩된 연산을 표현하세요.</p>\n<pre>\npublic String getReadableStatus(Job j) {\n  if (j.isRunning()) {\n    return \"Running\";\n  }\n  return j.hasErrors() ? \"Failed\" : \"Succeeded\";\n}\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": ""
  },
  {
    "id": "S1220",
    "key": "java:S1220",
    "name": "The default unnamed package should not be used",
    "type": "code-smell",
    "severity": "minor",
    "tags": [
      "convention"
    ],
    "why": "<p>Java packages serve two purposes:</p>\n<ol>\n  <li> Structure — Packages give a structure to the set of classes of your project. It is a bad practice to put all classes flat into the source\n  directory of a project without a package structure. A structure helps to mentally break down a project into smaller parts, simplifying readers'\n  understanding of how components are connected and how they interact. </li>\n  <li> Avoiding name clashes — a class part of the <em>default package</em> if no explicit package name is specified. This can easily cause name\n  collisions when other projects define a class of the same name. </li>\n</ol>\n<p>When no package is explicitly specified for the classes in your project, this makes the project harder to understand and may cause name collisions\nwith other projects. Also, classes located in the default package not be accessed from classes within named packages since Java 1.4.</p>",
    "howToFix": "<p>Move your class to a package directory and explicitly state the package's name at the top of the class. If your project does not have a package\nstructure, think of a structure that fits your needs. The package names should be unique to your project. You can find some best practices when\nchoosing package names in the Ressources section below.</p>\n\n<h4>Noncompliant code example</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\npublic class MyClass { /* ... */ } // Noncompliant, no package spacified\n</pre>\n<h4>Compliant solution</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\npackage org.example; // Compliant\n\npublic class MyClass{ /* ... */ }\n</pre>",
    "moreInfo": "<h3>Articles &amp; blog posts</h3>\n<ul>\n  <li> <a href=\"https://www.baeldung.com/java-packages\">Baeldung - Guide to Java Packages</a> </li>\n  <li> <a\n  href=\"https://www.tutorialspoint.com/what-are-the-best-practices-to-keep-in-mind-while-using-packages-in-java#:~:text=Naming%20conventions%20and%20best%20practices%20for%20packages\">tutorialspoint - What are the best practices to keep in mind while using packages in Java?</a> </li>\n</ul>",
    "status": "READY",
    "name_ko": "기본 이름 없는 패키지를 사용하면 안 됩니다",
    "why_ko": "<p>Java 패키지는 두 가지 목적을 제공합니다:</p>\n<ol>\n  <li> 구조 — 패키지는 프로젝트의 클래스 집합에 구조를 제공합니다. 패키지 구조 없이 프로젝트의 소스 디렉토리에 모든 클래스를 평평하게 넣는 것은 나쁜 관행입니다. 구조는 프로젝트를 더 작은 부분으로 정신적으로 분해하는 데 도움이 되어 독자가 구성 요소가 어떻게 연결되고 상호 작용하는지 이해하는 것을 단순화합니다. </li>\n  <li> 이름 충돌 방지 — 명시적인 패키지 이름이 지정되지 않으면 클래스는 <em>기본 패키지</em>의 일부가 됩니다. 이는 다른 프로젝트가 같은 이름의 클래스를 정의할 때 쉽게 이름 충돌을 일으킬 수 있습니다. </li>\n</ol>\n<p>프로젝트의 클래스에 패키지가 명시적으로 지정되지 않으면 프로젝트를 이해하기 어려워지고 다른 프로젝트와 이름 충돌이 발생할 수 있습니다. 또한 기본 패키지에 있는 클래스는 Java 1.4 이후로 명명된 패키지 내의 클래스에서 액세스할 수 없습니다.</p>",
    "howToFix_ko": "<p>클래스를 패키지 디렉토리로 이동하고 클래스 상단에 패키지 이름을 명시적으로 지정하세요. 프로젝트에 패키지 구조가 없다면 필요에 맞는 구조를 생각하세요. 패키지 이름은 프로젝트에 고유해야 합니다. 아래 리소스 섹션에서 패키지 이름을 선택할 때의 모범 사례를 찾을 수 있습니다.</p>\n\n<h4>규칙을 준수하지 않는 코드 예시</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\npublic class MyClass { /* ... */ } // 규칙 위반, 패키지가 지정되지 않음\n</pre>\n<h4>규칙을 준수하는 해결책</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\npackage org.example; // 규칙 준수\n\npublic class MyClass{ /* ... */ }\n</pre>",
    "moreInfo_ko": "<h3>관련 글 및 블로그 포스트</h3>\n<ul>\n  <li> <a href=\"https://www.baeldung.com/java-packages\">Baeldung - Java 패키지 가이드</a> </li>\n  <li> <a href=\"https://www.tutorialspoint.com/what-are-the-best-practices-to-keep-in-mind-while-using-packages-in-java#:~:text=Naming%20conventions%20and%20best%20practices%20for%20packages\">tutorialspoint - Java에서 패키지를 사용할 때 염두에 두어야 할 모범 사례는 무엇인가요?</a> </li>\n</ul>"
  },
  {
    "id": "S2699",
    "key": "java:S2699",
    "name": "Tests should include assertions",
    "type": "code-smell",
    "severity": "blocker",
    "tags": [
      "junit",
      "tests"
    ],
    "why": "<p>A test case without assertions ensures only that no exceptions are thrown. Beyond basic runnability, it ensures nothing about the behavior of the\ncode under test.</p>\n<p>This rule raises an exception when no assertions from any of the following known frameworks are found in a test:</p>\n<ul>\n  <li> AssertJ </li>\n  <li> Awaitility </li>\n  <li> EasyMock </li>\n  <li> Eclipse Vert.x </li>\n  <li> Fest 1.x and 2.x </li>\n  <li> Hamcrest </li>\n  <li> JMock </li>\n  <li> JMockit </li>\n  <li> JUnit </li>\n  <li> Mockito </li>\n  <li> Rest-assured 2.x, 3.x and 4.x </li>\n  <li> RxJava 1.x and 2.x </li>\n  <li> Selenide </li>\n  <li> Spring's <code>org.springframework.test.web.servlet.ResultActions.andExpect()</code> and\n  <code>org.springframework.test.web.servlet.ResultActions.andExpectAll()</code> </li>\n  <li> Truth Framework </li>\n  <li> WireMock </li>\n</ul>\n<p>Furthermore, as new or custom assertion frameworks may be used, the rule can be parametrized to define specific methods that will also be\nconsidered as assertions. No issue will be raised when such methods are found in test cases. The parameter value should have the following format\n<code>&lt;FullyQualifiedClassName&gt;#&lt;MethodName&gt;</code>, where <code>MethodName</code> can end with the wildcard character. For constructors,\nthe pattern should be <code>&lt;FullyQualifiedClassName&gt;#&lt;init&gt;</code>.</p>\n<p>Example:&nbsp;<code>com.company.CompareToTester#compare*,com.company.CustomAssert#customAssertMethod,com.company.CheckVerifier#&lt;init&gt;</code>.</p>\n<h3>Noncompliant code example</h3>\n<pre>\n@Test\npublic void testDoSomething() {  // Noncompliant\n  MyClass myClass = new MyClass();\n  myClass.doSomething();\n}\n</pre>\n<h3>Compliant solution</h3>\n<p>Example when <code>com.company.CompareToTester#compare*</code> is used as parameter to the rule.</p>\n<pre>\nimport com.company.CompareToTester;\n\n@Test\npublic void testDoSomething() {\n  MyClass myClass = new MyClass();\n  assertNull(myClass.doSomething());  // JUnit assertion\n  assertThat(myClass.doSomething()).isNull();  // Fest assertion\n}\n\n@Test\npublic void testDoSomethingElse() {\n  MyClass myClass = new MyClass();\n  new CompareToTester().compareWith(myClass);  // Compliant - custom assertion method defined as rule parameter\n  CompareToTester.compareStatic(myClass);  // Compliant\n}\n</pre>",
    "howToFix": "",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "테스트에는 assertion이 포함되어야 합니다",
    "why_ko": "<p>assertion이 없는 테스트 케이스는 예외가 발생하지 않는다는 것만 보장합니다. 기본적인 실행 가능성 외에 테스트 대상 코드의 동작에 대해서는 아무것도 보장하지 않습니다.</p>\n<p>이 규칙은 테스트에서 다음 알려진 프레임워크의 assertion이 발견되지 않을 때 문제를 제기합니다:</p>\n<ul>\n  <li> AssertJ </li>\n  <li> Awaitility </li>\n  <li> EasyMock </li>\n  <li> Eclipse Vert.x </li>\n  <li> Fest 1.x 및 2.x </li>\n  <li> Hamcrest </li>\n  <li> JMock </li>\n  <li> JMockit </li>\n  <li> JUnit </li>\n  <li> Mockito </li>\n  <li> Rest-assured 2.x, 3.x 및 4.x </li>\n  <li> RxJava 1.x 및 2.x </li>\n  <li> Selenide </li>\n  <li> Spring의 <code>org.springframework.test.web.servlet.ResultActions.andExpect()</code> 및\n  <code>org.springframework.test.web.servlet.ResultActions.andExpectAll()</code> </li>\n  <li> Truth Framework </li>\n  <li> WireMock </li>\n</ul>\n<p>또한 새로운 또는 사용자 정의 assertion 프레임워크가 사용될 수 있으므로 규칙은 assertion으로 간주될 특정 메서드를 정의하도록 매개변수화할 수 있습니다. 이러한 메서드가 테스트 케이스에서 발견되면 문제가 제기되지 않습니다. 매개변수 값은 <code>&lt;FullyQualifiedClassName&gt;#&lt;MethodName&gt;</code> 형식이어야 하며, <code>MethodName</code>은 와일드카드 문자로 끝날 수 있습니다. 생성자의 경우 패턴은 <code>&lt;FullyQualifiedClassName&gt;#&lt;init&gt;</code>이어야 합니다.</p>\n<p>예시:&nbsp;<code>com.company.CompareToTester#compare*,com.company.CustomAssert#customAssertMethod,com.company.CheckVerifier#&lt;init&gt;</code>.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\n@Test\npublic void testDoSomething() {  // 규칙 위반\n  MyClass myClass = new MyClass();\n  myClass.doSomething();\n}\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<p>규칙에 <code>com.company.CompareToTester#compare*</code>가 매개변수로 사용된 경우의 예시입니다.</p>\n<pre>\nimport com.company.CompareToTester;\n\n@Test\npublic void testDoSomething() {\n  MyClass myClass = new MyClass();\n  assertNull(myClass.doSomething());  // JUnit assertion\n  assertThat(myClass.doSomething()).isNull();  // Fest assertion\n}\n\n@Test\npublic void testDoSomethingElse() {\n  MyClass myClass = new MyClass();\n  new CompareToTester().compareWith(myClass);  // 규칙 준수 - 규칙 매개변수로 정의된 사용자 정의 assertion 메서드\n  CompareToTester.compareStatic(myClass);  // 규칙 준수\n}\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": ""
  },
  {
    "id": "S3437",
    "key": "java:S3437",
    "name": "Value-based objects should not be serialized",
    "type": "code-smell",
    "severity": "minor",
    "tags": [
      "serialization",
      "java8",
      "lock-in"
    ],
    "why": "<p>According to the documentation,</p>\n<blockquote>\n  <p>A program may produce unpredictable results if it attempts to distinguish two references to equal values of a value-based class, whether directly\n  via reference equality or indirectly via an appeal to synchronization, identity hashing, serialization…​</p>\n</blockquote>\n<p>For example (credit to Brian Goetz), imagine Foo is a value-based class:</p>\n<pre>\nFoo[] arr = new Foo[2];\narr[0] = new Foo(0);\narr[1] = new Foo(0);\n</pre>\n<p>Serialization promises that on deserialization of arr, elements 0 and 1 will not be aliased. Similarly, in:</p>\n<pre>\nFoo[] arr = new Foo[2];\narr[0] = new Foo(0);\narr[1] = arr[0];\n</pre>\n<p>Serialization promises that on deserialization of <code>arr</code>, elements 0 and 1 <strong>will</strong> be aliased.</p>\n<p>While these promises are coincidentally fulfilled in current implementations of Java, that is not guaranteed in the future, particularly when true\nvalue types are introduced in the language.</p>\n<p>This rule raises an issue when a <code>Serializable</code> class defines a non-transient, non-static field field whose type is a known serializable\nvalue-based class. Known serializable value-based classes are: all the classes in the <code>java.time</code> package except <code>Clock</code>; the\ndate classes for alternate calendars: <code>HijrahDate</code>, <code>JapaneseDate</code>, <code>MinguoDate</code>, <code>ThaiBuddhistDate</code>.</p>\n<h3>Noncompliant code example</h3>\n<pre>\nclass MyClass implements Serializable {\n  private HijrahDate date;  // Noncompliant; mark this transient\n  // ...\n}\n</pre>\n<h3>Compliant solution</h3>\n<pre>\nclass MyClass implements Serializable {\n  private transient HijrahDate date;\n  // ...\n}\n</pre>",
    "howToFix": "",
    "moreInfo": "<ul>\n  <li> <a href=\"https://docs.oracle.com/javase/8/docs/api/java/lang/doc-files/ValueBased.html\">Value-based classes</a> </li>\n</ul>",
    "status": "READY",
    "name_ko": "값 기반 객체는 직렬화하면 안 됩니다",
    "why_ko": "<p>문서에 따르면,</p>\n<blockquote>\n  <p>프로그램이 값 기반 클래스의 동일한 값에 대한 두 참조를 참조 동등성을 통해 직접적으로 또는 동기화, 동일성 해싱, 직렬화를 통해 간접적으로 구별하려고 하면 예측할 수 없는 결과가 발생할 수 있습니다…​</p>\n</blockquote>\n<p>예를 들어(Brian Goetz의 예시), Foo가 값 기반 클래스라고 가정합니다:</p>\n<pre>\nFoo[] arr = new Foo[2];\narr[0] = new Foo(0);\narr[1] = new Foo(0);\n</pre>\n<p>직렬화는 arr의 역직렬화 시 요소 0과 1이 앨리어싱되지 않을 것을 약속합니다. 마찬가지로:</p>\n<pre>\nFoo[] arr = new Foo[2];\narr[0] = new Foo(0);\narr[1] = arr[0];\n</pre>\n<p>직렬화는 <code>arr</code>의 역직렬화 시 요소 0과 1이 앨리어싱<strong>될 것</strong>을 약속합니다.</p>\n<p>이러한 약속은 현재 Java 구현에서 우연히 충족되지만, 특히 진정한 값 타입이 언어에 도입될 때 미래에 보장되지 않습니다.</p>\n<p>이 규칙은 <code>Serializable</code> 클래스가 알려진 직렬화 가능한 값 기반 클래스 타입의 non-transient, non-static 필드를 정의할 때 문제를 제기합니다. 알려진 직렬화 가능한 값 기반 클래스는 <code>Clock</code>을 제외한 <code>java.time</code> 패키지의 모든 클래스; 대체 달력의 날짜 클래스인 <code>HijrahDate</code>, <code>JapaneseDate</code>, <code>MinguoDate</code>, <code>ThaiBuddhistDate</code>입니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\nclass MyClass implements Serializable {\n  private HijrahDate date;  // 규칙 위반; transient로 표시해야 함\n  // ...\n}\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre>\nclass MyClass implements Serializable {\n  private transient HijrahDate date;\n  // ...\n}\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": "<ul>\n  <li> <a href=\"https://docs.oracle.com/javase/8/docs/api/java/lang/doc-files/ValueBased.html\">Value-based classes</a> </li>\n</ul>"
  },
  {
    "id": "S3067",
    "key": "java:S3067",
    "name": "\"getClass\" should not be used for synchronization",
    "type": "bug",
    "severity": "major",
    "tags": [
      "multi-threading",
      "cert"
    ],
    "why": "<p><code>getClass</code> should not be used for synchronization in non-<code>final</code> classes because child classes will synchronize on a\ndifferent object than the parent or each other, allowing multiple threads into the code block at once, despite the <code>synchronized</code>\nkeyword.</p>\n<p>Instead, hard code the name of the class on which to synchronize or make the class <code>final</code>.</p>\n<h3>Noncompliant code example</h3>\n<pre>\npublic class MyClass {\n  public void doSomethingSynchronized(){\n    synchronized (this.getClass()) {  // Noncompliant\n      // ...\n    }\n  }\n</pre>\n<h3>Compliant solution</h3>\n<pre>\npublic class MyClass {\n  public void doSomethingSynchronized(){\n    synchronized (MyClass.class) {\n      // ...\n    }\n  }\n</pre>",
    "howToFix": "",
    "moreInfo": "<ul>\n  <li> <a href=\"https://wiki.sei.cmu.edu/confluence/x/qTdGBQ\">CERT, LCK02-J.</a> - Do not synchronize on the class object returned by getClass() </li>\n</ul>",
    "status": "READY",
    "name_ko": "동기화에 \"getClass\"를 사용하면 안 됩니다",
    "why_ko": "<p><code>final</code>이 아닌 클래스에서 동기화에 <code>getClass</code>를 사용하면 안 됩니다. 자식 클래스는 부모나 서로 다른 객체에서 동기화되어, <code>synchronized</code> 키워드에도 불구하고 여러 스레드가 동시에 코드 블록에 진입할 수 있게 됩니다.</p>\n<p>대신, 동기화할 클래스 이름을 하드코딩하거나 클래스를 <code>final</code>로 만드세요.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\npublic class MyClass {\n  public void doSomethingSynchronized(){\n    synchronized (this.getClass()) {  // 규칙 위반\n      // ...\n    }\n  }\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre>\npublic class MyClass {\n  public void doSomethingSynchronized(){\n    synchronized (MyClass.class) {\n      // ...\n    }\n  }\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": "<ul>\n  <li> <a href=\"https://wiki.sei.cmu.edu/confluence/x/qTdGBQ\">CERT, LCK02-J.</a> - getClass()가 반환하는 클래스 객체에서 동기화하지 마세요 </li>\n</ul>"
  },
  {
    "id": "S2226",
    "key": "java:S2226",
    "name": "Servlets should not have mutable instance fields",
    "type": "bug",
    "severity": "major",
    "tags": [
      "multi-threading",
      "struts",
      "cert"
    ],
    "why": "<p>The <code>processHttpRequest</code> method and methods called from it can be executed by multiple threads within the same servlet instance, and\nstate changes to the instance caused by these methods are, therefore, not threadsafe.</p>\n<p>This is due to the servlet container creating only one instance of each servlet (<code>javax.servlet.http.HttpServlet</code>) and attaching a\ndedicated thread to each incoming HTTP request. The same problem exists for <code>org.apache.struts.action.Action</code> but with different\nmethods.</p>\n<p>To prevent unexpected behavior, avoiding mutable states in servlets is recommended. Mutable instance fields should either be refactored into local\nvariables or made immutable by declaring them <code>final</code>.</p>\n<h3>Exceptions</h3>\n<ul>\n  <li> Fields annotated with <code>@javax.inject.Inject</code>, <code>@javax.ejb.EJB</code>,\n  <code>@org.springframework.beans.factory.annotation.Autowired</code>, <code>@javax.annotation.Resource</code> </li>\n  <li> Fields initialized in <code>init()</code> or <code>init(ServletConfig config)</code> methods </li>\n</ul>",
    "howToFix": "<h4>Noncompliant code example</h4>\n<p>If the field is never modified, declare it <code>final</code>.</p>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\npublic class MyServlet extends HttpServlet {\n  String apiVersion = \"0.9.1\"; // Noncompliant, field changes are not thread-safe\n}\n</pre>\n<h4>Compliant solution</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\npublic class MyServlet extends HttpServlet {\n  final String apiVersion = \"0.9.1\"; // Compliant, field cannot be changed\n}\n</pre>\n<h4>Noncompliant code example</h4>\n<p>If a field is modified within instance methods, refactor it into a local variable. That variable can be passed as an argument to other functions if\nneeded.</p>\n<pre data-diff-id=\"2\" data-diff-type=\"noncompliant\">\npublic class MyServlet extends HttpServlet {\n\n  String userName; // Noncompliant, field changes are not thread-safe\n\n  @Override\n  public void doGet(HttpServletRequest req, HttpServletResponse resp) throws IOException {\n    userName = req.getParameter(\"userName\"); // Different threads may write concurrently to userName\n    resp.getOutputStream().print(getGreeting());\n  }\n\n  public String getGreeting() { // Unpredictable value in field userName\n    return \"Hello \"+userName+\"!\";\n  }\n}\n</pre>\n<h4>Compliant solution</h4>\n<pre data-diff-id=\"2\" data-diff-type=\"compliant\">\npublic class MyServlet extends HttpServlet {\n\n  @Override\n  public void doGet(HttpServletRequest req, HttpServletResponse resp) throws IOException {\n    String userName = req.getParameter(\"userName\"); // Compliant, local variable instead instance field\n    resp.getOutputStream().print(getGreeting(userName));\n  }\n\n  public String getGreeting(String userName) { // Compliant, method argument instead instance field\n    return \"Hello \"+userName+\"!\";\n  }\n}\n</pre>\n<h4>Noncompliant code example</h4>\n<p>If you still prefer instance state over local variables, consider using <code>ThreadLocal</code> fields. These fields provide a separate instance\nof their value for each thread.</p>\n<pre data-diff-id=\"3\" data-diff-type=\"noncompliant\">\npublic class MyServlet extends HttpServlet {\n\n  String userName; // Noncompliant, field changes are not thread-safe\n\n  @Override\n  public void doGet(HttpServletRequest req, HttpServletResponse resp) throws IOException {\n    userName = req.getParameter(\"userName\"); // Different threads may write concurrently to userName\n    resp.getOutputStream().print(getGreeting());\n  }\n\n  public String getGreeting() { // Unpredictable value in field userName\n    return \"Hello \"+userName+\"!\";\n  }\n}\n</pre>\n<h4>Compliant solution</h4>\n<pre data-diff-id=\"3\" data-diff-type=\"compliant\">\npublic class MyServlet extends HttpServlet {\n\n  final ThreadLocal&lt;String&gt; userName = new ThreadLocal&lt;&gt;(); // Compliant, field itself does not change\n\n  @Override\n  public void doGet(HttpServletRequest req, HttpServletResponse resp) throws IOException {\n    userName.set(req.getParameter(\"userName\")); // Compliant, own value provided for every thread\n    resp.getOutputStream().print(getGreeting());\n  }\n\n  public String getGreeting() {\n    return \"Hello \"+userName.get()+\"!\"; // Compliant, own value provided for every thread\n  }\n}\n</pre>\n<h4>Noncompliant code example</h4>\n<p>If you have a use case that requires a shared instance state between threads, declare the corresponding fields as <code>static</code> to indicate\nyour intention and awareness that there is only one instance of the servlet. However, the <code>static</code> modifier alone does not ensure thread\nsafety. Make sure also to take countermeasures against possible race conditions.</p>\n<pre data-diff-id=\"4\" data-diff-type=\"noncompliant\">\npublic class MyServlet extends HttpServlet {\n\n  public long timestampLastRequest; // Noncompliant, field changes are not thread-safe\n\n  @Override\n  public void doGet(HttpServletRequest req, HttpServletResponse resp) throws IOException {\n    timestampLastRequest = System.currentTimeMillis();\n    resp.getOutputStream().print(timestampLastRequest); // Race condition\n  }\n}\n</pre>\n<h4>Compliant solution</h4>\n<pre data-diff-id=\"4\" data-diff-type=\"compliant\">\npublic class MyServlet extends HttpServlet {\n\n  public static long timestampLastRequest; // Compliant, sharing state is our intention\n\n  @Override\n  public void doGet(HttpServletRequest req, HttpServletResponse resp) throws IOException {\n    long timestamp;\n    synchronized (this) {\n      timestamp = timestampLastRequest; // No race condition, synchronized get &amp; set\n      timestampLastRequest = System.currentTimeMillis();\n    }\n    resp.getOutputStream().print(timestamp);\n  }\n}\n</pre>",
    "moreInfo": "<h3>Articles &amp; blog posts</h3>\n<ul>\n  <li> <a href=\"https://www.devinline.com/2013/08/how-to-make-thread-safe-servlet.html\">Nikhil Ranjan: How to make thread safe servlet ?</a> </li>\n</ul>\n<h3>Standards</h3>\n<ul>\n  <li> STIG Viewer - <a href=\"https://stigviewer.com/stigs/application_security_and_development/2024-12-06/finding/V-222567\">Application Security and\n  Development: V-222567</a> - The application must not be vulnerable to race conditions. </li>\n</ul>",
    "status": "READY",
    "name_ko": "Servlet은 변경 가능한 인스턴스 필드를 가지면 안 됩니다",
    "why_ko": "<p><code>processHttpRequest</code> 메서드와 여기서 호출되는 메서드들은 동일한 서블릿 인스턴스 내에서 여러 스레드에 의해 실행될 수 있으며, 따라서 이러한 메서드들에 의한 인스턴스 상태 변경은 스레드 안전하지 않습니다.</p>\n<p>이는 서블릿 컨테이너가 각 서블릿(<code>javax.servlet.http.HttpServlet</code>)의 인스턴스를 하나만 생성하고 들어오는 각 HTTP 요청에 전용 스레드를 연결하기 때문입니다. <code>org.apache.struts.action.Action</code>에도 동일한 문제가 존재하지만 다른 메서드에서 발생합니다.</p>\n<p>예상치 못한 동작을 방지하려면 서블릿에서 변경 가능한 상태를 피하는 것이 좋습니다. 변경 가능한 인스턴스 필드는 지역 변수로 리팩토링하거나 <code>final</code>로 선언하여 불변으로 만들어야 합니다.</p>\n<h3>예외 사항</h3>\n<ul>\n  <li> <code>@javax.inject.Inject</code>, <code>@javax.ejb.EJB</code>, <code>@org.springframework.beans.factory.annotation.Autowired</code>, <code>@javax.annotation.Resource</code> 어노테이션이 붙은 필드 </li>\n  <li> <code>init()</code> 또는 <code>init(ServletConfig config)</code> 메서드에서 초기화된 필드 </li>\n</ul>",
    "howToFix_ko": "<h4>규칙을 준수하지 않는 코드 예시</h4>\n<p>필드가 절대 수정되지 않는다면 <code>final</code>로 선언하세요.</p>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\npublic class MyServlet extends HttpServlet {\n  String apiVersion = \"0.9.1\"; // 규칙 위반, 필드 변경이 스레드 안전하지 않음\n}\n</pre>\n<h4>규칙을 준수하는 해결책</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\npublic class MyServlet extends HttpServlet {\n  final String apiVersion = \"0.9.1\"; // 규칙 준수, 필드 변경 불가\n}\n</pre>\n<h4>규칙을 준수하지 않는 코드 예시</h4>\n<p>필드가 인스턴스 메서드 내에서 수정된다면 지역 변수로 리팩토링하세요. 필요하다면 해당 변수를 다른 함수에 인수로 전달할 수 있습니다.</p>\n<pre data-diff-id=\"2\" data-diff-type=\"noncompliant\">\npublic class MyServlet extends HttpServlet {\n\n  String userName; // 규칙 위반, 필드 변경이 스레드 안전하지 않음\n\n  @Override\n  public void doGet(HttpServletRequest req, HttpServletResponse resp) throws IOException {\n    userName = req.getParameter(\"userName\"); // 다른 스레드가 userName에 동시에 쓸 수 있음\n    resp.getOutputStream().print(getGreeting());\n  }\n\n  public String getGreeting() { // userName 필드의 예측 불가능한 값\n    return \"Hello \"+userName+\"!\";\n  }\n}\n</pre>\n<h4>규칙을 준수하는 해결책</h4>\n<pre data-diff-id=\"2\" data-diff-type=\"compliant\">\npublic class MyServlet extends HttpServlet {\n\n  @Override\n  public void doGet(HttpServletRequest req, HttpServletResponse resp) throws IOException {\n    String userName = req.getParameter(\"userName\"); // 규칙 준수, 인스턴스 필드 대신 지역 변수\n    resp.getOutputStream().print(getGreeting(userName));\n  }\n\n  public String getGreeting(String userName) { // 규칙 준수, 인스턴스 필드 대신 메서드 인수\n    return \"Hello \"+userName+\"!\";\n  }\n}\n</pre>\n<h4>규칙을 준수하지 않는 코드 예시</h4>\n<p>지역 변수보다 인스턴스 상태를 선호한다면 <code>ThreadLocal</code> 필드 사용을 고려하세요. 이 필드들은 각 스레드에 별도의 값 인스턴스를 제공합니다.</p>\n<pre data-diff-id=\"3\" data-diff-type=\"noncompliant\">\npublic class MyServlet extends HttpServlet {\n\n  String userName; // 규칙 위반, 필드 변경이 스레드 안전하지 않음\n\n  @Override\n  public void doGet(HttpServletRequest req, HttpServletResponse resp) throws IOException {\n    userName = req.getParameter(\"userName\"); // 다른 스레드가 userName에 동시에 쓸 수 있음\n    resp.getOutputStream().print(getGreeting());\n  }\n\n  public String getGreeting() { // userName 필드의 예측 불가능한 값\n    return \"Hello \"+userName+\"!\";\n  }\n}\n</pre>\n<h4>규칙을 준수하는 해결책</h4>\n<pre data-diff-id=\"3\" data-diff-type=\"compliant\">\npublic class MyServlet extends HttpServlet {\n\n  final ThreadLocal&lt;String&gt; userName = new ThreadLocal&lt;&gt;(); // 규칙 준수, 필드 자체는 변경되지 않음\n\n  @Override\n  public void doGet(HttpServletRequest req, HttpServletResponse resp) throws IOException {\n    userName.set(req.getParameter(\"userName\")); // 규칙 준수, 각 스레드에 고유한 값 제공\n    resp.getOutputStream().print(getGreeting());\n  }\n\n  public String getGreeting() {\n    return \"Hello \"+userName.get()+\"!\"; // 규칙 준수, 각 스레드에 고유한 값 제공\n  }\n}\n</pre>\n<h4>규칙을 준수하지 않는 코드 예시</h4>\n<p>스레드 간에 공유 인스턴스 상태가 필요한 사용 사례가 있다면, 해당 필드를 <code>static</code>으로 선언하여 서블릿 인스턴스가 하나뿐이라는 것을 인식하고 있음을 나타내세요. 그러나 <code>static</code> 수정자만으로는 스레드 안전성이 보장되지 않습니다. 가능한 경쟁 조건에 대한 대응책도 마련하세요.</p>\n<pre data-diff-id=\"4\" data-diff-type=\"noncompliant\">\npublic class MyServlet extends HttpServlet {\n\n  public long timestampLastRequest; // 규칙 위반, 필드 변경이 스레드 안전하지 않음\n\n  @Override\n  public void doGet(HttpServletRequest req, HttpServletResponse resp) throws IOException {\n    timestampLastRequest = System.currentTimeMillis();\n    resp.getOutputStream().print(timestampLastRequest); // 경쟁 조건\n  }\n}\n</pre>\n<h4>규칙을 준수하는 해결책</h4>\n<pre data-diff-id=\"4\" data-diff-type=\"compliant\">\npublic class MyServlet extends HttpServlet {\n\n  public static long timestampLastRequest; // 규칙 준수, 상태 공유가 의도임\n\n  @Override\n  public void doGet(HttpServletRequest req, HttpServletResponse resp) throws IOException {\n    long timestamp;\n    synchronized (this) {\n      timestamp = timestampLastRequest; // 경쟁 조건 없음, 동기화된 get &amp; set\n      timestampLastRequest = System.currentTimeMillis();\n    }\n    resp.getOutputStream().print(timestamp);\n  }\n}\n</pre>",
    "moreInfo_ko": "<h3>기사 및 블로그 포스트</h3>\n<ul>\n  <li> <a href=\"https://www.devinline.com/2013/08/how-to-make-thread-safe-servlet.html\">Nikhil Ranjan: 스레드 안전한 서블릿 만드는 방법</a> </li>\n</ul>\n<h3>표준</h3>\n<ul>\n  <li> STIG Viewer - <a href=\"https://stigviewer.com/stigs/application_security_and_development/2024-12-06/finding/V-222567\">애플리케이션 보안 및 개발: V-222567</a> - 애플리케이션은 경쟁 조건에 취약하면 안 됩니다. </li>\n</ul>"
  },
  {
    "id": "S119",
    "key": "java:S119",
    "name": "Type parameter names should comply with a naming convention",
    "type": "code-smell",
    "severity": "minor",
    "tags": [
      "convention"
    ],
    "why": "<p>Shared naming conventions make it possible for a team to collaborate efficiently. Following the established convention of single-letter type\nparameter names helps users and maintainers of your code quickly see the difference between a type parameter and a poorly named class.</p>\n<p>This rule check that all type parameter names match a provided regular expression. The following code snippets use the default regular\nexpression.</p>\n<h3>Noncompliant code example</h3>\n<pre>\npublic class MyClass&lt;TYPE&gt; { // Noncompliant\n  &lt;TYPE&gt; void method(TYPE t) { // Noncompliant\n  }\n}\n</pre>\n<h3>Compliant solution</h3>\n<pre>\npublic class MyClass&lt;T&gt; {\n  &lt;T&gt; void method(T t) {\n  }\n}\n</pre>",
    "howToFix": "",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "타입 매개변수 이름은 명명 규칙을 준수해야 합니다",
    "why_ko": "<p>공유된 명명 규칙은 팀이 효율적으로 협업할 수 있게 해줍니다. 단일 문자 타입 매개변수 이름의 확립된 규칙을 따르면 코드의 사용자와 유지 관리자가 타입 매개변수와 잘못 명명된 클래스의 차이를 빠르게 볼 수 있습니다.</p>\n<p>이 규칙은 모든 타입 매개변수 이름이 제공된 정규 표현식과 일치하는지 확인합니다. 다음 코드 스니펫은 기본 정규 표현식을 사용합니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\npublic class MyClass&lt;TYPE&gt; { // 규칙 위반\n  &lt;TYPE&gt; void method(TYPE t) { // 규칙 위반\n  }\n}\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre>\npublic class MyClass&lt;T&gt; {\n  &lt;T&gt; void method(T t) {\n  }\n}\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": ""
  },
  {
    "id": "S2676",
    "key": "java:S2676",
    "name": "\"Math.abs\" and negation should not be used on numbers that could be \"MIN_VALUE\"",
    "type": "bug",
    "severity": "minor",
    "tags": [
      "suspicious"
    ],
    "why": "<p>This rule involves the use of <code>Math.abs</code> and negation on numbers that could be <code>MIN_VALUE</code>. It is a problem because it can\nlead to incorrect results and unexpected behavior in the program.</p>\n<p>When <code>Math.abs</code> and negation are used on numbers that could be <code>MIN_VALUE</code>, the result can be incorrect due to integer\noverflow. Common methods that can return a <code>MIN_VALUE</code> and raise an issue when used together with <code>Math.abs</code> are:</p>\n<ul>\n  <li> <code>Random.nextInt()</code> and <code>Random.nextLong()</code> </li>\n  <li> <code>hashCode()</code> </li>\n  <li> <code>compareTo()</code> </li>\n</ul>\n<p>Alternatively, the <code>absExact()</code> method throws an <code>ArithmeticException</code> for <code>MIN_VALUE</code>.</p>\n<h3>Noncompliant code example</h3>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\npublic void doSomething(String str) {\n  if (Math.abs(str.hashCode()) &gt; 0) { // Noncompliant\n    // ...\n  }\n}\n</pre>\n<h3>Compliant solution</h3>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\npublic void doSomething(String str) {\n  if (str.hashCode() != 0) {\n    // ...\n  }\n}\n</pre>",
    "howToFix": "",
    "moreInfo": "<ul>\n  <li> <a href=\"https://docs.oracle.com/en/java/javase/20/docs/api/java.base/java/lang/Math.html#abs(int)\">Oracle SDK 20 - Math.abs(int)</a> </li>\n</ul>",
    "status": "READY",
    "name_ko": "MIN_VALUE가 될 수 있는 숫자에 Math.abs와 부정 연산을 사용하면 안 됩니다",
    "why_ko": "<p>이 규칙은 <code>MIN_VALUE</code>가 될 수 있는 숫자에 <code>Math.abs</code>와 부정 연산을 사용하는 것과 관련됩니다. 이는 프로그램에서 잘못된 결과와 예기치 않은 동작을 초래할 수 있기 때문에 문제가 됩니다.</p>\n<p><code>MIN_VALUE</code>가 될 수 있는 숫자에 <code>Math.abs</code>와 부정 연산을 사용하면 정수 오버플로로 인해 결과가 잘못될 수 있습니다. <code>MIN_VALUE</code>를 반환할 수 있고 <code>Math.abs</code>와 함께 사용될 때 문제를 제기하는 일반적인 메서드는 다음과 같습니다:</p>\n<ul>\n  <li> <code>Random.nextInt()</code>와 <code>Random.nextLong()</code> </li>\n  <li> <code>hashCode()</code> </li>\n  <li> <code>compareTo()</code> </li>\n</ul>\n<p>또는 <code>absExact()</code> 메서드는 <code>MIN_VALUE</code>에 대해 <code>ArithmeticException</code>을 던집니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\npublic void doSomething(String str) {\n  if (Math.abs(str.hashCode()) &gt; 0) { // 규칙 위반\n    // ...\n  }\n}\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\npublic void doSomething(String str) {\n  if (str.hashCode() != 0) {\n    // ...\n  }\n}\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": "<ul>\n  <li> <a href=\"https://docs.oracle.com/en/java/javase/20/docs/api/java.base/java/lang/Math.html#abs(int)\">Oracle SDK 20 - Math.abs(int)</a> </li>\n</ul>"
  },
  {
    "id": "S7474",
    "key": "java:S7474",
    "name": "Markdown, HTML and Javadoc tags should be consistent",
    "type": "code-smell",
    "severity": "minor",
    "tags": [
      "javadoc",
      "java23"
    ],
    "why": "<p>With the introduction of Markdown support in Javadoc comments in Java 23, developers should prefer Markdown syntax over legacy HTML tags (e.g.,\n<code>&lt;b&gt;</code>, <code>&lt;i&gt;</code>, <code>&lt;code&gt;</code>, <code>&lt;ul&gt;</code>, <code>&lt;li&gt;</code>, etc.) and legacy Javadoc\ntags (e.g. <code>{@link java.util.HashMap}</code>, <code>{@code Object}</code>).</p>\n<p>Mixing HTML and Markdown can lead to readability issues and inconsistencies in rendering across tools. Markdown is generally more readable, less\ncluttered and, should be preferred over HTML tags when possible.</p>\n<p>This rule will raise an issue when an HTML tag or a legacy Javadoc tag inside a markdown comment could be replaced with a slimmer, and more\ncohesive, syntax.</p>",
    "howToFix": "<p>Here is a list of tags that should be replaced with markdown syntax:</p>\n<ul>\n  <li> <code>&lt;p&gt;</code> should be replaced with 2 new lines </li>\n  <li> <code>&lt;code&gt;MyCode&lt;/code&gt;</code>, <code>{@code MyCode}</code> should be replaced with <code>`MyCode`</code> </li>\n  <li> <code>&lt;i&gt;italic text&lt;/i&gt;</code>, <code>&lt;em&gt;</code> should be replaced with <code>*italic text*</code> </li>\n  <li> <code>&lt;b&gt;bold text&lt;/b&gt;</code>, <code>&lt;strong&gt;</code> should be replaced with <code>**bold text**</code> </li>\n  <li> <code>&lt;ul&gt;&lt;li&gt;list item&lt;/li&gt;&lt;/ul&gt;</code>, <code>&lt;ol&gt;&lt;li&gt;</code> should be replaced with <code>* list\n  item</code> </li>\n  <li> <code>{@link some.java.Class}</code> should be replaced with <code>[some.java.Class]</code> </li>\n  <li> <code>{@link #equals(Object) equals}</code> should be replaced with <code>[equals][#equals(Object)]</code> </li>\n</ul>\n\n<h4>Noncompliant code example</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\n/// This is a markdown Javadoc comment\n/// &lt;b&gt;ExampleClass&lt;/b&gt; is a simple utility for &lt;i&gt;demonstration purposes&lt;/i&gt;.\n/// &lt;p&gt;\n///     Use &lt;code&gt;ExampleClass.run()&lt;/code&gt; to execute the example.\n/// &lt;/p&gt;\n/// {@link some.java.Class} for more details\npublic class ExampleClass {\n}\n</pre>\n<h4>Compliant solution</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\n/// This is a markdown Javadoc comment\n/// **ExampleClass** is a simple utility for *demonstration purposes*.\n///\n/// Use `ExampleClass.run()` to execute the example.\n/// [some.java.Class] for more details\npublic class ExampleClass {\n}\n</pre>",
    "moreInfo": "<h3>Documentation</h3>\n<ul>\n  <li> <a href=\"https://openjdk.org/jeps/467\">JEP 467: Markdown Documentation Comments</a> </li>\n</ul>",
    "status": "READY",
    "name_ko": "Markdown, HTML, Javadoc 태그는 일관성이 있어야 합니다",
    "why_ko": "<p>Java 23에서 Javadoc 주석에 Markdown 지원이 도입됨에 따라 개발자는 레거시 HTML 태그(예: <code>&lt;b&gt;</code>, <code>&lt;i&gt;</code>, <code>&lt;code&gt;</code>, <code>&lt;ul&gt;</code>, <code>&lt;li&gt;</code> 등)와 레거시 Javadoc 태그(예: <code>{@link java.util.HashMap}</code>, <code>{@code Object}</code>)보다 Markdown 구문을 선호해야 합니다.</p>\n<p>HTML과 Markdown을 혼합하면 가독성 문제와 도구 간 렌더링 불일치가 발생할 수 있습니다. Markdown은 일반적으로 더 읽기 쉽고 덜 복잡하며, 가능한 경우 HTML 태그보다 선호해야 합니다.</p>\n<p>이 규칙은 markdown 주석 내의 HTML 태그나 레거시 Javadoc 태그가 더 간결하고 일관된 구문으로 대체될 수 있을 때 이슈를 발생시킵니다.</p>",
    "howToFix_ko": "<p>다음은 markdown 구문으로 대체해야 하는 태그 목록입니다:</p>\n<ul>\n  <li> <code>&lt;p&gt;</code>는 2개의 새 줄로 대체해야 합니다 </li>\n  <li> <code>&lt;code&gt;MyCode&lt;/code&gt;</code>, <code>{@code MyCode}</code>는 <code>`MyCode`</code>로 대체해야 합니다 </li>\n  <li> <code>&lt;i&gt;italic text&lt;/i&gt;</code>, <code>&lt;em&gt;</code>은 <code>*italic text*</code>로 대체해야 합니다 </li>\n  <li> <code>&lt;b&gt;bold text&lt;/b&gt;</code>, <code>&lt;strong&gt;</code>은 <code>**bold text**</code>로 대체해야 합니다 </li>\n  <li> <code>&lt;ul&gt;&lt;li&gt;list item&lt;/li&gt;&lt;/ul&gt;</code>, <code>&lt;ol&gt;&lt;li&gt;</code>는 <code>* list item</code>으로 대체해야 합니다 </li>\n  <li> <code>{@link some.java.Class}</code>는 <code>[some.java.Class]</code>로 대체해야 합니다 </li>\n  <li> <code>{@link #equals(Object) equals}</code>는 <code>[equals][#equals(Object)]</code>로 대체해야 합니다 </li>\n</ul>\n\n<h4>규칙을 준수하지 않는 코드 예시</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\n/// This is a markdown Javadoc comment\n/// &lt;b&gt;ExampleClass&lt;/b&gt; is a simple utility for &lt;i&gt;demonstration purposes&lt;/i&gt;.\n/// &lt;p&gt;\n///     Use &lt;code&gt;ExampleClass.run()&lt;/code&gt; to execute the example.\n/// &lt;/p&gt;\n/// {@link some.java.Class} for more details\npublic class ExampleClass {\n}\n</pre>\n<h4>규칙을 준수하는 해결책</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\n/// This is a markdown Javadoc comment\n/// **ExampleClass** is a simple utility for *demonstration purposes*.\n///\n/// Use `ExampleClass.run()` to execute the example.\n/// [some.java.Class] for more details\npublic class ExampleClass {\n}\n</pre>",
    "moreInfo_ko": "<h3>문서</h3>\n<ul>\n  <li> <a href=\"https://openjdk.org/jeps/467\">JEP 467: Markdown 문서 주석</a> </li>\n</ul>"
  },
  {
    "id": "S4034",
    "key": "java:S4034",
    "name": "\"Stream\" call chains should be simplified when possible",
    "type": "code-smell",
    "severity": "minor",
    "tags": [
      "clumsy"
    ],
    "why": "<p>When using the <code>Stream</code> API, call chains should be simplified as much as possible. Not only does it make the code easier to read, it\nalso avoid creating unnecessary temporary objects.</p>\n<p>This rule raises an issue when one of the following substitution is possible:</p>\n<table>\n  <colgroup>\n    <col style=\"width: 50%;\">\n    <col style=\"width: 50%;\">\n  </colgroup>\n  <thead>\n    <tr>\n      <th>Original</th>\n      <th>Preferred</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td><p><code>stream.filter(predicate).findFirst().isPresent()</code></p></td>\n      <td><p><code>stream.anyMatch(predicate)</code></p></td>\n    </tr>\n    <tr>\n      <td><p><code>stream.filter(predicate).findAny().isPresent()</code></p></td>\n      <td><p><code>stream.anyMatch(predicate)</code></p></td>\n    </tr>\n    <tr>\n      <td><p><code>!stream.anyMatch(predicate)</code></p></td>\n      <td><p><code>stream.noneMatch(predicate)</code></p></td>\n    </tr>\n    <tr>\n      <td><p><code>!stream.anyMatch(x -&gt; !(...))</code></p></td>\n      <td><p><code>stream.allMatch(...)</code></p></td>\n    </tr>\n    <tr>\n      <td><p><code>stream.map(mapper).anyMatch(Boolean::booleanValue)</code></p></td>\n      <td><p><code>stream.anyMatch(predicate)</code></p></td>\n    </tr>\n  </tbody>\n</table>\n<h3>Noncompliant code example</h3>\n<pre>\nboolean hasRed = widgets.stream().filter(w -&gt; w.getColor() == RED).findFirst().isPresent(); // Noncompliant\n</pre>\n<h3>Compliant solution</h3>\n<pre>\nboolean hasRed = widgets.stream().anyMatch(w -&gt; w.getColor() == RED);\n</pre>",
    "howToFix": "",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "\"Stream\" 호출 체인은 가능한 경우 단순화해야 합니다",
    "why_ko": "<p><code>Stream</code> API를 사용할 때 호출 체인은 가능한 한 단순화해야 합니다. 코드를 읽기 쉽게 만들 뿐만 아니라 불필요한 임시 객체 생성도 방지합니다.</p>\n<p>이 규칙은 다음 대체 중 하나가 가능할 때 문제를 제기합니다:</p>\n<table>\n  <colgroup>\n    <col style=\"width: 50%;\">\n    <col style=\"width: 50%;\">\n  </colgroup>\n  <thead>\n    <tr>\n      <th>원본</th>\n      <th>권장</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td><p><code>stream.filter(predicate).findFirst().isPresent()</code></p></td>\n      <td><p><code>stream.anyMatch(predicate)</code></p></td>\n    </tr>\n    <tr>\n      <td><p><code>stream.filter(predicate).findAny().isPresent()</code></p></td>\n      <td><p><code>stream.anyMatch(predicate)</code></p></td>\n    </tr>\n    <tr>\n      <td><p><code>!stream.anyMatch(predicate)</code></p></td>\n      <td><p><code>stream.noneMatch(predicate)</code></p></td>\n    </tr>\n    <tr>\n      <td><p><code>!stream.anyMatch(x -&gt; !(...))</code></p></td>\n      <td><p><code>stream.allMatch(...)</code></p></td>\n    </tr>\n    <tr>\n      <td><p><code>stream.map(mapper).anyMatch(Boolean::booleanValue)</code></p></td>\n      <td><p><code>stream.anyMatch(predicate)</code></p></td>\n    </tr>\n  </tbody>\n</table>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\nboolean hasRed = widgets.stream().filter(w -&gt; w.getColor() == RED).findFirst().isPresent(); // 규칙 위반\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre>\nboolean hasRed = widgets.stream().anyMatch(w -&gt; w.getColor() == RED);\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": ""
  },
  {
    "id": "S6377",
    "key": "java:S6377",
    "name": "XML signatures should be validated securely",
    "type": "vulnerability",
    "severity": "major",
    "tags": [
      "symbolic-execution"
    ],
    "why": "<p>Before Java 17, XML Digital Signature API does not apply restrictions on XML signature validation unless the application runs with a security\nmanager, which is rare.</p>\n<h2>What is the potential impact</h2>\n<p>By not enforcing secure validation, the XML Digital Signature API is more susceptible to attacks such as signature spoofing and injections.</p>\n<h3>Increased Vulnerability to Signature Spoofing</h3>\n<p>By disabling secure validation, the application becomes more susceptible to signature spoofing attacks. Attackers can potentially manipulate the\nXML signature in a way that bypasses the validation process, allowing them to forge or tamper with the signature. This can lead to the acceptance of\ninvalid or maliciously modified signatures, compromising the integrity and authenticity of the XML documents.</p>\n<h3>Risk of Injection Attacks</h3>\n<p>Disabling secure validation can expose the application to injection attacks. Attackers can inject malicious code or entities into the XML document,\ntaking advantage of the weakened validation process. In some cases, it can also expose the application to denial-of-service attacks. Attackers can\nexploit vulnerabilities in the validation process to cause excessive resource consumption or system crashes, leading to service unavailability or\ndisruption.</p>",
    "howToFix": "<p>For versions of Java before 17, secure validation is disabled by default unless the application runs with a security manager, which is rare. It\nshould be enabled explicitly by setting the <code>org.jcp.xml.dsig.secureValidation</code> attribute to true with the\n<code>javax.xml.crypto.dsig.dom.DOMValidateContext.setProperty</code> method.</p>\n<p>For Java 17 and higher, secure validation is enabled by default.</p>\n<h4>Noncompliant code example</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\nNodeList signatureElement = doc.getElementsByTagNameNS(XMLSignature.XMLNS, \"Signature\");\n\nXMLSignatureFactory fac = XMLSignatureFactory.getInstance(\"DOM\");\nDOMValidateContext valContext = new DOMValidateContext(new KeyValueKeySelector(), signatureElement.item(0)); // Noncompliant\nXMLSignature signature = fac.unmarshalXMLSignature(valContext);\n\nboolean signatureValidity = signature.validate(valContext);\n</pre>\n<h4>Compliant solution</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\nNodeList signatureElement = doc.getElementsByTagNameNS(XMLSignature.XMLNS, \"Signature\");\n\nXMLSignatureFactory fac = XMLSignatureFactory.getInstance(\"DOM\");\nDOMValidateContext valContext = new DOMValidateContext(new KeyValueKeySelector(), signatureElement.item(0));\nvalContext.setProperty(\"org.jcp.xml.dsig.secureValidation\", Boolean.TRUE);\nXMLSignature signature = fac.unmarshalXMLSignature(valContext);\n\nboolean signatureValidity = signature.validate(valContext);\n</pre>\n<h3>How does this work?</h3>\n<p>When XML Signature secure validation mode is enabled, XML Signatures are processed more securely. It enforces a number of restrictionsto to protect\nfrom XML Documents that may contain hostile constructs that can cause denial-of-service or other types of security issues.</p>\n<p>These restrictions can protect you from XML Signatures that may contain potentially hostile constructs that can cause denial-of-service or other\ntypes of security issues.</p>",
    "moreInfo": "<h3>Documentation</h3>\n<ul>\n  <li> Oracle Java Documentation - <a\n  href=\"https://docs.oracle.com/en/java/javase/21/security/java-xml-digital-signature-api-overview-and-tutorial.html\">XML Digital Signature API\n  Overview and Tutorial</a> </li>\n</ul>\n<h3>Standards</h3>\n<ul>\n  <li> OWASP - <a href=\"https://owasp.org/Top10/A02_2021-Cryptographic_Failures/\">Top 10:2021 A02:2021 - Cryptographic Failures</a> </li>\n  <li> OWASP - <a href=\"https://owasp.org/www-project-top-ten/2017/A3_2017-Sensitive_Data_Exposure\">Top 10 2017 Category A3 - Sensitive Data\n  Exposure</a> </li>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/347\">CWE-347 - Improper Verification of Cryptographic Signature</a> </li>\n  <li> STIG Viewer - <a href=\"https://stigviewer.com/stig/application_security_and_development/2023-06-08/finding/V-222608\">Application Security and\n  Development: V-222608</a> - The application must not be vulnerable to XML-oriented attacks. </li>\n</ul>",
    "status": "READY",
    "name_ko": "XML 서명은 안전하게 검증해야 합니다",
    "why_ko": "<p>Java 17 이전에는 애플리케이션이 보안 관리자와 함께 실행되지 않는 한 XML 디지털 서명 API가 XML 서명 검증에 제한을 적용하지 않으며, 이는 드문 경우입니다.</p>\n<h2>잠재적 영향은 무엇인가요</h2>\n<p>보안 검증을 시행하지 않으면 XML 디지털 서명 API는 서명 스푸핑 및 인젝션과 같은 공격에 더 취약해집니다.</p>\n<h3>서명 스푸핑에 대한 취약성 증가</h3>\n<p>보안 검증을 비활성화하면 애플리케이션이 서명 스푸핑 공격에 더 취약해집니다. 공격자는 검증 프로세스를 우회하는 방식으로 XML 서명을 조작하여 서명을 위조하거나 변조할 수 있습니다. 이로 인해 유효하지 않거나 악의적으로 수정된 서명이 수락되어 XML 문서의 무결성과 진위가 손상될 수 있습니다.</p>\n<h3>인젝션 공격의 위험</h3>\n<p>보안 검증을 비활성화하면 애플리케이션이 인젝션 공격에 노출될 수 있습니다. 공격자는 약화된 검증 프로세스를 이용하여 XML 문서에 악성 코드나 엔티티를 삽입할 수 있습니다. 일부 경우 애플리케이션이 서비스 거부 공격에도 노출될 수 있습니다. 공격자는 검증 프로세스의 취약점을 악용하여 과도한 리소스 소비나 시스템 충돌을 유발하여 서비스 불가용이나 중단을 초래할 수 있습니다.</p>",
    "howToFix_ko": "<p>Java 17 이전 버전에서는 애플리케이션이 보안 관리자와 함께 실행되지 않는 한 보안 검증이 기본적으로 비활성화되어 있으며, 이는 드문 경우입니다. <code>javax.xml.crypto.dsig.dom.DOMValidateContext.setProperty</code> 메서드로 <code>org.jcp.xml.dsig.secureValidation</code> 속성을 true로 설정하여 명시적으로 활성화해야 합니다.</p>\n<p>Java 17 이상에서는 보안 검증이 기본적으로 활성화되어 있습니다.</p>\n<h4>규칙을 준수하지 않는 코드 예시</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\nNodeList signatureElement = doc.getElementsByTagNameNS(XMLSignature.XMLNS, \"Signature\");\n\nXMLSignatureFactory fac = XMLSignatureFactory.getInstance(\"DOM\");\nDOMValidateContext valContext = new DOMValidateContext(new KeyValueKeySelector(), signatureElement.item(0)); // 규칙 위반\nXMLSignature signature = fac.unmarshalXMLSignature(valContext);\n\nboolean signatureValidity = signature.validate(valContext);\n</pre>\n<h4>규칙을 준수하는 해결책</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\nNodeList signatureElement = doc.getElementsByTagNameNS(XMLSignature.XMLNS, \"Signature\");\n\nXMLSignatureFactory fac = XMLSignatureFactory.getInstance(\"DOM\");\nDOMValidateContext valContext = new DOMValidateContext(new KeyValueKeySelector(), signatureElement.item(0));\nvalContext.setProperty(\"org.jcp.xml.dsig.secureValidation\", Boolean.TRUE);\nXMLSignature signature = fac.unmarshalXMLSignature(valContext);\n\nboolean signatureValidity = signature.validate(valContext);\n</pre>\n<h3>어떻게 작동하나요?</h3>\n<p>XML 서명 보안 검증 모드가 활성화되면 XML 서명이 더 안전하게 처리됩니다. 서비스 거부나 기타 유형의 보안 문제를 일으킬 수 있는 적대적 구성을 포함할 수 있는 XML 문서로부터 보호하기 위해 여러 제한을 시행합니다.</p>\n<p>이러한 제한은 서비스 거부나 기타 유형의 보안 문제를 일으킬 수 있는 잠재적으로 적대적인 구성을 포함할 수 있는 XML 서명으로부터 보호할 수 있습니다.</p>",
    "moreInfo_ko": "<h3>문서</h3>\n<ul>\n  <li> Oracle Java Documentation - <a href=\"https://docs.oracle.com/en/java/javase/21/security/java-xml-digital-signature-api-overview-and-tutorial.html\">XML 디지털 서명 API 개요 및 튜토리얼</a> </li>\n</ul>\n<h3>표준</h3>\n<ul>\n  <li> OWASP - <a href=\"https://owasp.org/Top10/A02_2021-Cryptographic_Failures/\">Top 10:2021 A02:2021 - 암호화 실패</a> </li>\n  <li> OWASP - <a href=\"https://owasp.org/www-project-top-ten/2017/A3_2017-Sensitive_Data_Exposure\">Top 10 2017 Category A3 - 민감한 데이터 노출</a> </li>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/347\">CWE-347 - 암호화 서명의 부적절한 검증</a> </li>\n  <li> STIG Viewer - <a href=\"https://stigviewer.com/stig/application_security_and_development/2023-06-08/finding/V-222608\">Application Security and Development: V-222608</a> - 애플리케이션은 XML 기반 공격에 취약하면 안 됩니다. </li>\n</ul>"
  },
  {
    "id": "S5808",
    "key": "java:S5808",
    "name": "Authorizations should be based on strong decisions",
    "type": "vulnerability",
    "severity": "major",
    "tags": [
      "cwe"
    ],
    "why": "<p>Access control is a critical aspect of web frameworks that ensures proper authorization and restricts access to sensitive resources or actions. To\nenable access control, web frameworks offer components that are responsible for evaluating user permissions and making access control decisions. They\nmight examine the user's credentials, such as roles or privileges, and compare them against predefined rules or policies to determine whether the user\nshould be granted access to a specific resource or action.</p>\n<p>Conventionally, these checks should never grant access to every request received. If an endpoint or component is meant to be public, then it should\nbe ignored by access control components. Conversely, if an endpoint should deny some users from accessing it, then access control has to be configured\ncorrectly for this endpoint.</p>\n<p>Granting unrestricted access to all users can lead to security vulnerabilities and potential misuse of critical functionalities. It is important to\ncarefully assess access decisions based on factors such as user roles, resource sensitivity, and business requirements. Implementing a robust and\ngranular access control mechanism is crucial for the security and integrity of the web application itself and its surrounding environment.</p>\n<h3>What is the potential impact?</h3>\n<p>Not verifying user access strictly can introduce significant security risks. Some of the most prominent risks are listed below. Depending on the\nuse case, it is very likely that other risks are introduced on top of the ones listed.</p>\n<h4>Unauthorized access</h4>\n<p>As the access of users is not checked strictly, it becomes very easy for an attacker to gain access to restricted areas or functionalities,\npotentially compromising the confidentiality, integrity, and availability of sensitive resources. They may exploit this access to perform malicious\nactions, such as modifying or deleting data, impersonating legitimate users, or gaining administrative privileges, ultimately compromising the\nsecurity of the system.</p>\n<h4>Theft of sensitive data</h4>\n<p>Theft of sensitive data can result from incorrect access control if attackers manage to gain access to databases, file systems, or other storage\nmechanisms where sensitive data is stored. This can lead to the theft of personally identifiable information (PII), financial data, intellectual\nproperty, or other confidential information. The stolen data can be used for various malicious purposes, such as identity theft, financial fraud, or\nselling the data on the black market, causing significant harm to individuals and organizations affected by the breach.</p>",
    "howToFix": "<h4>Noncompliant code example</h4>\n<p>The <code>vote</code> method of an <a\nhref=\"https://docs.spring.io/spring-security/site/docs/6.1.x/api/org/springframework/security/access/AccessDecisionVoter.html\">AccessDecisionVoter</a>\nimplementation is not compliant when it returns only an affirmative decision (<code>ACCESS_GRANTED</code>) or abstains to make a decision\n(<code>ACCESS_ABSTAIN</code>):</p>\n<pre data-diff-id=\"101\" data-diff-type=\"noncompliant\">\npublic class WeakNightVoter implements AccessDecisionVoter {\n    @Override\n    public int vote(Authentication authentication, Object object, Collection collection) {\n        Calendar calendar = Calendar.getInstance();\n        int currentHour = calendar.get(Calendar.HOUR_OF_DAY);\n\n        if (currentHour &gt;= 8 &amp;&amp; currentHour &lt;= 19) {\n            return ACCESS_GRANTED;\n        }\n\n        return ACCESS_ABSTAIN; // Noncompliant: when users connect during the night, no decision is made\n    }\n}\n</pre>\n<p>The <code>hasPermission</code> method of a <a\nhref=\"https://docs.spring.io/spring-security/site/docs/6.1.x/api/org/springframework/security/access/PermissionEvaluator.html\">PermissionEvaluator</a>\nimplementation is not compliant when it doesn't return <code>false</code>:</p>\n<pre data-diff-id=\"102\" data-diff-type=\"noncompliant\">\npublic class MyPermissionEvaluator implements PermissionEvaluator {\n    @Override\n    public boolean hasPermission(Authentication authentication, Object targetDomainObject, Object permission) {\n        Object user = authentication.getPrincipal();\n\n        if (user.getRole().equals(permission)) {\n              return true;\n        }\n\n        return true; // Noncompliant\n    }\n}\n</pre>\n<h4>Compliant solution</h4>\n<p>The <code>vote</code> method of an <a\nhref=\"https://docs.spring.io/spring-security/site/docs/4.0.x/apidocs/org/springframework/security/access/AccessDecisionVoter.html\">AccessDecisionVoter</a>\nimplementation should return a negative decision (<code>ACCESS_DENIED</code>):</p>\n<pre data-diff-id=\"101\" data-diff-type=\"compliant\">\npublic class StrongNightVoter implements AccessDecisionVoter {\n    @Override\n    public int vote(Authentication authentication, Object object, Collection collection) {\n        Calendar calendar = Calendar.getInstance();\n        int currentHour = calendar.get(Calendar.HOUR_OF_DAY);\n\n        if (currentHour &gt;= 8 &amp;&amp; currentHour &lt;= 19) {\n            return ACCESS_GRANTED;\n        }\n\n        return ACCESS_DENIED; // Users are not allowed to connect during the night\n    }\n}\n</pre>\n<p>The <code>hasPermission</code> method of a <a\nhref=\"https://docs.spring.io/spring-security/site/docs/4.2.13.RELEASE/apidocs/org/springframework/security/access/PermissionEvaluator.html\">PermissionEvaluator</a>\nimplementation should return <code>false</code>:</p>\n<pre data-diff-id=\"102\" data-diff-type=\"compliant\">\npublic class MyPermissionEvaluator implements PermissionEvaluator {\n    @Override\n    public boolean hasPermission(Authentication authentication, Object targetDomainObject, Object permission) {\n        Object user = authentication.getPrincipal();\n\n        if (user.getRole().equals(permission)) {\n              return true;\n        }\n\n        return false;\n    }\n}\n</pre>",
    "moreInfo": "<h3>Standards</h3>\n<ul>\n  <li> OWASP - <a href=\"https://owasp.org/Top10/A01_2021-Broken_Access_Control/\">Top 10 2021 Category A1 - Broken Access Control</a> </li>\n  <li> OWASP - <a href=\"https://owasp.org/www-project-top-ten/2017/A5_2017-Broken_Access_Control\">Top 10 2017 Category A5 - Broken Access Control</a>\n  </li>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/285\">CWE-285 - Improper Authorization</a> </li>\n</ul>",
    "status": "READY",
    "name_ko": "권한 부여는 강력한 결정에 기반해야 합니다",
    "why_ko": "<p>접근 제어는 적절한 권한 부여를 보장하고 민감한 리소스나 작업에 대한 접근을 제한하는 웹 프레임워크의 중요한 측면입니다. 접근 제어를 활성화하기 위해 웹 프레임워크는 사용자 권한을 평가하고 접근 제어 결정을 내리는 컴포넌트를 제공합니다. 역할이나 권한과 같은 사용자 자격 증명을 검사하고 미리 정의된 규칙이나 정책과 비교하여 사용자에게 특정 리소스나 작업에 대한 접근 권한을 부여해야 하는지 결정할 수 있습니다.</p>\n<p>일반적으로 이러한 검사는 수신된 모든 요청에 접근 권한을 부여해서는 안 됩니다. 엔드포인트나 컴포넌트가 공개용이면 접근 제어 컴포넌트에서 무시해야 합니다. 반대로 엔드포인트가 일부 사용자의 접근을 거부해야 하면 해당 엔드포인트에 대해 접근 제어를 올바르게 구성해야 합니다.</p>\n<p>모든 사용자에게 무제한 접근 권한을 부여하면 보안 취약점과 중요한 기능의 잠재적 오용으로 이어질 수 있습니다. 사용자 역할, 리소스 민감도, 비즈니스 요구 사항과 같은 요소를 기반으로 접근 결정을 신중하게 평가하는 것이 중요합니다. 강력하고 세분화된 접근 제어 메커니즘을 구현하는 것은 웹 애플리케이션 자체와 주변 환경의 보안 및 무결성에 매우 중요합니다.</p>\n<h3>잠재적 영향은 무엇입니까?</h3>\n<p>사용자 접근을 엄격하게 확인하지 않으면 상당한 보안 위험이 발생할 수 있습니다. 가장 두드러진 위험 중 일부가 아래에 나열되어 있습니다. 사용 사례에 따라 나열된 위험 외에 다른 위험이 추가될 가능성이 매우 높습니다.</p>\n<h4>무단 접근</h4>\n<p>사용자의 접근이 엄격하게 확인되지 않으면 공격자가 제한된 영역이나 기능에 접근하기 매우 쉬워져 민감한 리소스의 기밀성, 무결성 및 가용성을 잠재적으로 손상시킬 수 있습니다. 이 접근을 악용하여 데이터 수정 또는 삭제, 합법적인 사용자 사칭, 관리 권한 획득과 같은 악의적인 작업을 수행하여 궁극적으로 시스템 보안을 손상시킬 수 있습니다.</p>\n<h4>민감한 데이터 도난</h4>\n<p>공격자가 민감한 데이터가 저장된 데이터베이스, 파일 시스템 또는 기타 저장 메커니즘에 접근하는 데 성공하면 잘못된 접근 제어로 인해 민감한 데이터 도난이 발생할 수 있습니다. 이로 인해 개인 식별 정보(PII), 금융 데이터, 지적 재산권 또는 기타 기밀 정보가 도난될 수 있습니다. 도난된 데이터는 신원 도용, 금융 사기 또는 암시장에서 데이터 판매와 같은 다양한 악의적인 목적에 사용될 수 있으며 침해의 영향을 받는 개인과 조직에 상당한 피해를 줄 수 있습니다.</p>",
    "howToFix_ko": "<h4>규칙을 준수하지 않는 코드 예시</h4>\n<p><a\nhref=\"https://docs.spring.io/spring-security/site/docs/6.1.x/api/org/springframework/security/access/AccessDecisionVoter.html\">AccessDecisionVoter</a> 구현의 <code>vote</code> 메서드는 긍정적인 결정(<code>ACCESS_GRANTED</code>)만 반환하거나 결정을 보류(<code>ACCESS_ABSTAIN</code>)할 때 규칙을 준수하지 않습니다:</p>\n<pre data-diff-id=\"101\" data-diff-type=\"noncompliant\">\npublic class WeakNightVoter implements AccessDecisionVoter {\n    @Override\n    public int vote(Authentication authentication, Object object, Collection collection) {\n        Calendar calendar = Calendar.getInstance();\n        int currentHour = calendar.get(Calendar.HOUR_OF_DAY);\n\n        if (currentHour &gt;= 8 &amp;&amp; currentHour &lt;= 19) {\n            return ACCESS_GRANTED;\n        }\n\n        return ACCESS_ABSTAIN; // 규칙 위반: 사용자가 야간에 연결할 때 결정이 내려지지 않음\n    }\n}\n</pre>\n<p><a\nhref=\"https://docs.spring.io/spring-security/site/docs/6.1.x/api/org/springframework/security/access/PermissionEvaluator.html\">PermissionEvaluator</a> 구현의 <code>hasPermission</code> 메서드는 <code>false</code>를 반환하지 않으면 규칙을 준수하지 않습니다:</p>\n<pre data-diff-id=\"102\" data-diff-type=\"noncompliant\">\npublic class MyPermissionEvaluator implements PermissionEvaluator {\n    @Override\n    public boolean hasPermission(Authentication authentication, Object targetDomainObject, Object permission) {\n        Object user = authentication.getPrincipal();\n\n        if (user.getRole().equals(permission)) {\n              return true;\n        }\n\n        return true; // 규칙 위반\n    }\n}\n</pre>\n<h4>규칙을 준수하는 해결책</h4>\n<p><a\nhref=\"https://docs.spring.io/spring-security/site/docs/4.0.x/apidocs/org/springframework/security/access/AccessDecisionVoter.html\">AccessDecisionVoter</a> 구현의 <code>vote</code> 메서드는 부정적인 결정(<code>ACCESS_DENIED</code>)을 반환해야 합니다:</p>\n<pre data-diff-id=\"101\" data-diff-type=\"compliant\">\npublic class StrongNightVoter implements AccessDecisionVoter {\n    @Override\n    public int vote(Authentication authentication, Object object, Collection collection) {\n        Calendar calendar = Calendar.getInstance();\n        int currentHour = calendar.get(Calendar.HOUR_OF_DAY);\n\n        if (currentHour &gt;= 8 &amp;&amp; currentHour &lt;= 19) {\n            return ACCESS_GRANTED;\n        }\n\n        return ACCESS_DENIED; // 사용자는 야간에 연결할 수 없습니다\n    }\n}\n</pre>\n<p><a\nhref=\"https://docs.spring.io/spring-security/site/docs/4.2.13.RELEASE/apidocs/org/springframework/security/access/PermissionEvaluator.html\">PermissionEvaluator</a> 구현의 <code>hasPermission</code> 메서드는 <code>false</code>를 반환해야 합니다:</p>\n<pre data-diff-id=\"102\" data-diff-type=\"compliant\">\npublic class MyPermissionEvaluator implements PermissionEvaluator {\n    @Override\n    public boolean hasPermission(Authentication authentication, Object targetDomainObject, Object permission) {\n        Object user = authentication.getPrincipal();\n\n        if (user.getRole().equals(permission)) {\n              return true;\n        }\n\n        return false;\n    }\n}\n</pre>",
    "moreInfo_ko": "<h3>표준</h3>\n<ul>\n  <li> OWASP - <a href=\"https://owasp.org/Top10/A01_2021-Broken_Access_Control/\">Top 10 2021 카테고리 A1 - 취약한 접근 제어</a> </li>\n  <li> OWASP - <a href=\"https://owasp.org/www-project-top-ten/2017/A5_2017-Broken_Access_Control\">Top 10 2017 카테고리 A5 - 취약한 접근 제어</a>\n  </li>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/285\">CWE-285 - 부적절한 권한 부여</a> </li>\n</ul>"
  },
  {
    "id": "S3030",
    "key": "java:S3030",
    "name": "Classes should not have too many \"static\" imports",
    "type": "code-smell",
    "severity": "major",
    "tags": [
      "brain-overload"
    ],
    "why": "<p>Importing a class statically allows you to use its <code>public static</code> members without qualifying them with the class name. That can be\nhandy, but if you import too many classes statically, your code can become confusing and difficult to maintain.</p>\n<h3>Noncompliant code example</h3>\n<p>With the default threshold value: 4</p>\n<pre>\nimport static java.lang.Math.*;\nimport static java.util.Collections.*;\nimport static com.myco.corporate.Constants.*;\nimport static com.myco.division.Constants.*;\nimport static com.myco.department.Constants.*;  // Noncompliant\n</pre>",
    "howToFix": "",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "클래스에 너무 많은 \"static\" import가 있으면 안 됩니다",
    "why_ko": "<p>클래스를 정적으로 import하면 클래스 이름으로 한정하지 않고 해당 <code>public static</code> 멤버를 사용할 수 있습니다. 이것은 편리할 수 있지만, 너무 많은 클래스를 정적으로 import하면 코드가 혼란스러워지고 유지 관리하기 어려워질 수 있습니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<p>기본 임계값: 4</p>\n<pre>\nimport static java.lang.Math.*;\nimport static java.util.Collections.*;\nimport static com.myco.corporate.Constants.*;\nimport static com.myco.division.Constants.*;\nimport static com.myco.department.Constants.*;  // 규칙 위반\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": ""
  },
  {
    "id": "S6818",
    "key": "java:S6818",
    "name": "\"@Autowired\" should only be used on a single constructor",
    "type": "bug",
    "severity": "critical",
    "tags": [
      "spring"
    ],
    "why": "<p><code>@Autowired</code> is an annotation in the Spring Framework for automatic dependency injection. It tells Spring to automatically provide the\nrequired dependencies (such as other beans or components) to a class's fields, methods, or constructors, allowing for easier and more flexible\nmanagement of dependencies in a Spring application. In other words, it is a way to wire up and inject dependencies into Spring components\nautomatically, reducing the need for manual configuration and enhancing modularity and maintainability.</p>\n<p>In any bean class, only one constructor is permitted to declare <code>@Autowired</code> with the <code>required</code> attribute set to true. This\nsignifies the constructor to be automatically wired when used as a Spring bean. Consequently, when the required attribute remains at its default value\n(true), only a singular constructor can bear the <code>@Autowired</code> annotation. In cases where multiple constructors have this annotation, they\nmust all specify <code>required=false</code> to be eligible as candidates for auto-wiring.</p>",
    "howToFix": "<p>To maintain code clarity and ensure that the Spring context can create beans correctly, have only one constructor annotated with\n<code>@Autowired</code> within a Spring component or set <code>required = false</code>.</p>\n\n<h4>Noncompliant code example</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\n@Component\npublic class MyComponent {\n  private final MyService myService;\n\n  @Autowired\n  public MyComponent(MyService myService) {\n    this.myService = myService;\n    // ...\n  }\n\n  @Autowired  // Noncompliant\n  public MyComponent(MyService myService, Integer i) {\n    this.myService = myService;\n    // ...\n  }\n\n  @Autowired  // Noncompliant\n  public MyComponent(MyService myService, Integer i, String s) {\n    this.myService = myService;\n    // ...\n  }\n}\n</pre>\n<h4>Compliant solution</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\n@Component\npublic class MyComponent {\n  private final MyService myService;\n\n  @Autowired\n  public MyComponent(MyService myService) {\n    this.myService = myService;\n    // ...\n  }\n\n  public MyComponent(MyService myService, Integer i) {\n    this.myService = myService;\n    // ...\n  }\n\n  public MyComponent(MyService myService, Integer i, String s) {\n    this.myService = myService;\n    // ...\n  }\n}\n</pre>\n<h4>Noncompliant code example</h4>\n<pre data-diff-id=\"2\" data-diff-type=\"noncompliant\">\n@Component\npublic class MyComponent {\n  private final MyService myService;\n\n  @Autowired\n  public MyComponent(MyService myService) {\n    this.myService = myService;\n    // ...\n  }\n\n  @Autowired  // Noncompliant\n  public MyComponent(MyService myService, Integer i) {\n    this.myService = myService;\n    // ...\n  }\n\n  @Autowired  // Noncompliant\n  public MyComponent(MyService myService, Integer i, String s) {\n    this.myService = myService;\n    // ...\n  }\n}\n</pre>\n<h4>Compliant solution</h4>\n<pre data-diff-id=\"2\" data-diff-type=\"compliant\">\n@Component\npublic class MyComponent {\n  private final MyService myService;\n\n  @Autowired\n  public MyComponent(MyService myService) {\n    this.myService = myService;\n    // ...\n  }\n\n  @Autowired(required=false)  // Compliant\n  public MyComponent(MyService myService, Integer i) {\n    this.myService = myService;\n    // ...\n  }\n\n  @Autowired(required=false)  // Compliant\n  public MyComponent(MyService myService, Integer i, String s) {\n    this.myService = myService;\n    // ...\n  }\n}\n</pre>",
    "moreInfo": "<h3>Documentation</h3>\n<ul>\n  <li> <a href=\"https://docs.spring.io/spring-framework/reference/core/beans/annotation-config/autowired.html\">Spring Framework - Using @Autowired</a>\n  </li>\n</ul>\n<h3>Articles &amp; blog posts</h3>\n<ul>\n  <li> <a href=\"https://www.baeldung.com/spring-autowire\">Baeldung - Guide to Spring @Autowired</a> </li>\n</ul>",
    "status": "READY",
    "name_ko": "\"@Autowired\"는 하나의 생성자에만 사용해야 합니다",
    "why_ko": "<p><code>@Autowired</code>는 자동 의존성 주입을 위한 Spring Framework의 어노테이션입니다. Spring에게 클래스의 필드, 메서드 또는 생성자에 필요한 의존성(다른 빈이나 컴포넌트 등)을 자동으로 제공하도록 지시하여 Spring 애플리케이션에서 의존성을 더 쉽고 유연하게 관리할 수 있게 합니다. 즉, 수동 구성의 필요성을 줄이고 모듈성 및 유지 관리성을 향상시키면서 Spring 컴포넌트에 의존성을 자동으로 연결하고 주입하는 방법입니다.</p>\n<p>모든 빈 클래스에서 <code>required</code> 속성이 true로 설정된 <code>@Autowired</code>를 선언하는 것은 하나의 생성자만 허용됩니다. 이는 Spring 빈으로 사용될 때 자동으로 연결될 생성자를 나타냅니다. 따라서 required 속성이 기본값(true)인 경우 단일 생성자만 <code>@Autowired</code> 어노테이션을 가질 수 있습니다. 여러 생성자에 이 어노테이션이 있는 경우 자동 연결 후보가 되려면 모두 <code>required=false</code>를 지정해야 합니다.</p>",
    "howToFix_ko": "<p>코드 명확성을 유지하고 Spring 컨텍스트가 빈을 올바르게 생성할 수 있도록 Spring 컴포넌트 내에서 <code>@Autowired</code>가 달린 생성자를 하나만 갖거나 <code>required = false</code>를 설정하세요.</p>\n\n<h4>규칙을 준수하지 않는 코드 예시</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\n@Component\npublic class MyComponent {\n  private final MyService myService;\n\n  @Autowired\n  public MyComponent(MyService myService) {\n    this.myService = myService;\n    // ...\n  }\n\n  @Autowired  // 규칙 위반\n  public MyComponent(MyService myService, Integer i) {\n    this.myService = myService;\n    // ...\n  }\n\n  @Autowired  // 규칙 위반\n  public MyComponent(MyService myService, Integer i, String s) {\n    this.myService = myService;\n    // ...\n  }\n}\n</pre>\n<h4>규칙을 준수하는 해결책</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\n@Component\npublic class MyComponent {\n  private final MyService myService;\n\n  @Autowired\n  public MyComponent(MyService myService) {\n    this.myService = myService;\n    // ...\n  }\n\n  public MyComponent(MyService myService, Integer i) {\n    this.myService = myService;\n    // ...\n  }\n\n  public MyComponent(MyService myService, Integer i, String s) {\n    this.myService = myService;\n    // ...\n  }\n}\n</pre>\n<h4>규칙을 준수하지 않는 코드 예시</h4>\n<pre data-diff-id=\"2\" data-diff-type=\"noncompliant\">\n@Component\npublic class MyComponent {\n  private final MyService myService;\n\n  @Autowired\n  public MyComponent(MyService myService) {\n    this.myService = myService;\n    // ...\n  }\n\n  @Autowired  // 규칙 위반\n  public MyComponent(MyService myService, Integer i) {\n    this.myService = myService;\n    // ...\n  }\n\n  @Autowired  // 규칙 위반\n  public MyComponent(MyService myService, Integer i, String s) {\n    this.myService = myService;\n    // ...\n  }\n}\n</pre>\n<h4>규칙을 준수하는 해결책</h4>\n<pre data-diff-id=\"2\" data-diff-type=\"compliant\">\n@Component\npublic class MyComponent {\n  private final MyService myService;\n\n  @Autowired\n  public MyComponent(MyService myService) {\n    this.myService = myService;\n    // ...\n  }\n\n  @Autowired(required=false)  // 규칙 준수\n  public MyComponent(MyService myService, Integer i) {\n    this.myService = myService;\n    // ...\n  }\n\n  @Autowired(required=false)  // 규칙 준수\n  public MyComponent(MyService myService, Integer i, String s) {\n    this.myService = myService;\n    // ...\n  }\n}\n</pre>",
    "moreInfo_ko": "<h3>문서</h3>\n<ul>\n  <li> <a href=\"https://docs.spring.io/spring-framework/reference/core/beans/annotation-config/autowired.html\">Spring Framework - @Autowired 사용하기</a> </li>\n</ul>\n<h3>기사 및 블로그 게시물</h3>\n<ul>\n  <li> <a href=\"https://www.baeldung.com/spring-autowire\">Baeldung - Spring @Autowired 가이드</a> </li>\n</ul>"
  },
  {
    "id": "S3749",
    "key": "java:S3749",
    "name": "Members of Spring components should be injected",
    "type": "code-smell",
    "severity": "critical",
    "tags": [
      "spring"
    ],
    "why": "<p>Spring <code>@Component</code>, <code>@Controller</code>, <code>@RestController</code>,<code>@Service</code>, and <code>@Repository</code> classes\nare singletons by default, meaning only one instance of the class is ever instantiated in the application. Typically such a class might have a few\n<code>static</code> members, such as a logger, but all non-<code>static</code> members should be managed by Spring.</p>\n<p>This rule raises an issue when a singleton <code>@Component</code>, <code>@Controller</code>, <code>@RestController</code>, <code>@Service</code>,\nor <code>@Repository</code>, not annotated with <code>@ConfigurationProperties</code>, has non-<code>static</code> members that are not annotated with\none of:</p>\n<ul>\n  <li> <code>org.springframework.beans.factory.annotation.Autowired</code> </li>\n  <li> <code>org.springframework.beans.factory.annotation.Value</code> </li>\n  <li> <code>javax.annotation.Inject</code> </li>\n  <li> <code>javax.annotation.Resource</code> </li>\n  <li> <code>javax.persistence.PersistenceContext</code> </li>\n  <li> <code>jakarta.annotation.Resource</code> </li>\n  <li> <code>jakarta.inject.Inject</code> </li>\n  <li> <code>jakarta.persistence.PersistenceContext</code> </li>\n</ul>",
    "howToFix": "<p>Add one of these annotations to all non-<code>static</code> members: <code>@Resource</code>, <code>@Inject</code>, <code>@Autowired</code> or\n<code>@Value</code>.</p>\n\n<h4>Noncompliant code example</h4>\n<pre>\n@Controller\npublic class HelloWorld {\n\n  private String name = null;\n\n  @RequestMapping(\"/greet\", method = GET)\n  public String greet(String greetee) {\n\n    if (greetee != null) {\n      this.name = greetee;\n    }\n\n    return \"Hello \" + this.name;  // if greetee is null, you see the previous user's data\n  }\n}\n</pre>",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "Spring 컴포넌트의 멤버는 주입되어야 합니다",
    "why_ko": "<p>Spring <code>@Component</code>, <code>@Controller</code>, <code>@RestController</code>, <code>@Service</code>, <code>@Repository</code> 클래스는 기본적으로 싱글톤입니다. 즉, 애플리케이션에서 클래스의 인스턴스가 하나만 생성됩니다. 일반적으로 이러한 클래스에는 로거와 같은 몇 개의 <code>static</code> 멤버가 있을 수 있지만, 모든 비<code>static</code> 멤버는 Spring에 의해 관리되어야 합니다.</p>\n<p>이 규칙은 <code>@ConfigurationProperties</code>로 어노테이션되지 않은 싱글톤 <code>@Component</code>, <code>@Controller</code>, <code>@RestController</code>, <code>@Service</code>, <code>@Repository</code>에 다음 어노테이션 중 하나로 어노테이션되지 않은 비<code>static</code> 멤버가 있을 때 문제를 제기합니다:</p>\n<ul>\n  <li> <code>org.springframework.beans.factory.annotation.Autowired</code> </li>\n  <li> <code>org.springframework.beans.factory.annotation.Value</code> </li>\n  <li> <code>javax.annotation.Inject</code> </li>\n  <li> <code>javax.annotation.Resource</code> </li>\n  <li> <code>javax.persistence.PersistenceContext</code> </li>\n  <li> <code>jakarta.annotation.Resource</code> </li>\n  <li> <code>jakarta.inject.Inject</code> </li>\n  <li> <code>jakarta.persistence.PersistenceContext</code> </li>\n</ul>",
    "howToFix_ko": "<p>모든 비<code>static</code> 멤버에 다음 어노테이션 중 하나를 추가하세요: <code>@Resource</code>, <code>@Inject</code>, <code>@Autowired</code> 또는 <code>@Value</code>.</p>\n\n<h4>규칙을 준수하지 않는 코드 예시</h4>\n<pre>\n@Controller\npublic class HelloWorld {\n\n  private String name = null;\n\n  @RequestMapping(\"/greet\", method = GET)\n  public String greet(String greetee) {\n\n    if (greetee != null) {\n      this.name = greetee;\n    }\n\n    return \"Hello \" + this.name;  // greetee가 null이면 이전 사용자의 데이터가 표시됩니다\n  }\n}\n</pre>",
    "moreInfo_ko": ""
  },
  {
    "id": "S1774",
    "key": "java:S1774",
    "name": "The ternary operator should not be used",
    "type": "code-smell",
    "severity": "major",
    "tags": [
      "brain-overload"
    ],
    "why": "<p>Ternary expressions, while concise, can often lead to code that is difficult to read and understand, especially when they are nested or complex.\nPrioritizing readability fosters maintainability and reduces the likelihood of bugs. Therefore, they should be removed in favor of more explicit\ncontrol structures, such as <code>if</code>/<code>else</code> statements, to improve the clarity and readability of the code.</p>\n\n<h4>Noncompliant code example</h4>\n<pre>\nSystem.out.println(i&gt;10?\"yes\":\"no\");  // Noncompliant\n</pre>\n<h4>Compliant solution</h4>\n<pre>\nif (i &gt; 10) {\n  System.out.println(\"yes\");\n} else {\n  System.out.println(\"no\");\n}\n</pre>",
    "howToFix": "",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "삼항 연산자를 사용하면 안 됩니다",
    "why_ko": "<p>삼항 표현식은 간결하지만, 특히 중첩되거나 복잡할 때 읽고 이해하기 어려운 코드로 이어질 수 있습니다. 가독성을 우선시하면 유지보수성이 향상되고 버그 발생 가능성이 줄어듭니다. 따라서 코드의 명확성과 가독성을 향상시키기 위해 <code>if</code>/<code>else</code> 문과 같은 보다 명시적인 제어 구조를 선호하여 삼항 연산자를 제거해야 합니다.</p>\n\n<h4>규칙을 준수하지 않는 코드 예시</h4>\n<pre>\nSystem.out.println(i&gt;10?\"yes\":\"no\");  // 규칙 위반\n</pre>\n<h4>규칙을 준수하는 해결책</h4>\n<pre>\nif (i &gt; 10) {\n  System.out.println(\"yes\");\n} else {\n  System.out.println(\"no\");\n}\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": ""
  },
  {
    "id": "S4433",
    "key": "java:S4433",
    "name": "LDAP connections should be authenticated",
    "type": "vulnerability",
    "severity": "critical",
    "tags": [
      "cwe"
    ],
    "why": "<p>When configured to accept the Anonymous or Unauthenticated authentication mechanism, an LDAP server will accept connections from clients that do\nnot provide a password or other authentication credentials. Such users will be able to read or modify part or all of the data contained in the hosted\ndirectory.</p>\n<h3>What is the potential impact?</h3>\n<p>An attacker exploiting unauthenticated access to an LDAP server can access the data that is stored in the corresponding directory. The impact\nvaries depending on the permission obtained on the directory and the type of data it stores.</p>\n<h4>Authentication bypass</h4>\n<p>If attackers get write access to the directory, they will be able to alter most of the data it stores. This might include sensitive technical data\nsuch as user passwords or asset configurations. Such an attack can typically lead to an authentication bypass on applications and systems that use the\naffected directory as an identity provider.</p>\n<p>In such a case, all users configured in the directory might see their identity and privileges taken over.</p>\n<h4>Sensitive information leak</h4>\n<p>If attackers get read-only access to the directory, they will be able to read the data it stores. That data might include security-sensitive pieces\nof information.</p>\n<p>Typically, attackers might get access to user account lists that they can use in further intrusion steps. For example, they could use such lists to\nperform password spraying, or related attacks, on all systems that rely on the affected directory as an identity provider.</p>\n<p>If the directory contains some Personally Identifiable Information, an attacker accessing it might represent a violation of regulatory requirements\nin some countries. For example, this kind of security event would go against the European GDPR law.</p>",
    "howToFix": "<p>The following code indicates an anonymous LDAP authentication vulnerability because it binds to a remote server using an Anonymous Simple\nauthentication mechanism.</p>\n<h4>Noncompliant code example</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\n// Set up the environment for creating the initial context\nHashtable&lt;String, Object&gt; env = new Hashtable&lt;String, Object&gt;();\nenv.put(Context.INITIAL_CONTEXT_FACTORY, \"com.sun.jndi.ldap.LdapCtxFactory\");\nenv.put(Context.PROVIDER_URL, \"ldap://localhost:389/o=JNDITutorial\");\n\n// Use anonymous authentication\nenv.put(Context.SECURITY_AUTHENTICATION, \"none\"); // Noncompliant\n\n// Create the initial context\nDirContext ctx = new InitialDirContext(env);\n</pre>\n<h4>Compliant solution</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\n// Set up the environment for creating the initial context\nHashtable&lt;String, Object&gt; env = new Hashtable&lt;String, Object&gt;();\nenv.put(Context.INITIAL_CONTEXT_FACTORY, \"com.sun.jndi.ldap.LdapCtxFactory\");\nenv.put(Context.PROVIDER_URL, \"ldap://localhost:389/o=Example\");\n\n// Use simple authentication\nenv.put(Context.SECURITY_AUTHENTICATION, \"simple\");\nenv.put(Context.SECURITY_PRINCIPAL, \"cn=local, ou=Unit, o=Example\");\nenv.put(Context.SECURITY_CREDENTIALS, getLDAPPassword());\n\n// Create the initial context\nDirContext ctx = new InitialDirContext(env);\n</pre>",
    "moreInfo": "<h3>Documentation</h3>\n<ul>\n  <li> <a href=\"https://datatracker.ietf.org/doc/html/rfc4513#section-5\">RFC 4513 - Lightweight Directory Access Protocol (LDAP): Authentication\n  Methods and Security Mechanisms</a> - Bind operations </li>\n</ul>\n<h3>Standards</h3>\n<ul>\n  <li> OWASP - <a href=\"https://owasp.org/Top10/A07_2021-Identification_and_Authentication_Failures/\">Top 10 2021 Category A7 - Identification and\n  Authentication Failures</a> </li>\n  <li> OWASP - <a href=\"https://owasp.org/www-project-top-ten/2017/A2_2017-Broken_Authentication\">Top 10 2017 Category A2 - Broken Authentication</a>\n  </li>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/521\">CWE-521 - Weak Password Requirements</a> </li>\n</ul>",
    "status": "READY",
    "name_ko": "LDAP 연결은 인증되어야 합니다",
    "why_ko": "<p>익명 또는 비인증 인증 메커니즘을 수락하도록 구성된 LDAP 서버는 비밀번호 또는 기타 인증 자격 증명을 제공하지 않는 클라이언트의 연결을 수락합니다. 이러한 사용자는 호스팅된 디렉토리에 포함된 데이터의 일부 또는 전부를 읽거나 수정할 수 있습니다.</p>\n<h3>잠재적 영향은 무엇인가요?</h3>\n<p>LDAP 서버에 대한 비인증 접근을 악용하는 공격자는 해당 디렉토리에 저장된 데이터에 접근할 수 있습니다. 영향은 디렉토리에 대해 획득한 권한과 저장하는 데이터 유형에 따라 다릅니다.</p>\n<h4>인증 우회</h4>\n<p>공격자가 디렉토리에 대한 쓰기 접근 권한을 얻으면 저장된 대부분의 데이터를 변경할 수 있습니다. 여기에는 사용자 비밀번호 또는 자산 구성과 같은 민감한 기술 데이터가 포함될 수 있습니다. 이러한 공격은 일반적으로 영향을 받는 디렉토리를 ID 제공자로 사용하는 애플리케이션 및 시스템에 대한 인증 우회로 이어질 수 있습니다.</p>\n<p>이러한 경우 디렉토리에 구성된 모든 사용자의 ID와 권한이 탈취될 수 있습니다.</p>\n<h4>민감한 정보 유출</h4>\n<p>공격자가 디렉토리에 대한 읽기 전용 접근 권한을 얻으면 저장된 데이터를 읽을 수 있습니다. 해당 데이터에는 보안에 민감한 정보가 포함될 수 있습니다.</p>\n<p>일반적으로 공격자는 추가 침입 단계에서 사용할 수 있는 사용자 계정 목록에 접근할 수 있습니다. 예를 들어, 영향을 받는 디렉토리를 ID 제공자로 사용하는 모든 시스템에서 비밀번호 스프레이 또는 관련 공격을 수행하는 데 이러한 목록을 사용할 수 있습니다.</p>\n<p>디렉토리에 개인 식별 정보가 포함되어 있는 경우 이에 접근하는 공격자는 일부 국가의 규제 요구 사항을 위반할 수 있습니다. 예를 들어, 이러한 종류의 보안 이벤트는 유럽 GDPR 법률에 위배됩니다.</p>",
    "howToFix_ko": "<p>다음 코드는 익명 단순 인증 메커니즘을 사용하여 원격 서버에 바인딩하기 때문에 익명 LDAP 인증 취약점을 나타냅니다.</p>\n<h4>규칙을 준수하지 않는 코드 예시</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\n// 초기 컨텍스트를 생성하기 위한 환경 설정\nHashtable&lt;String, Object&gt; env = new Hashtable&lt;String, Object&gt;();\nenv.put(Context.INITIAL_CONTEXT_FACTORY, \"com.sun.jndi.ldap.LdapCtxFactory\");\nenv.put(Context.PROVIDER_URL, \"ldap://localhost:389/o=JNDITutorial\");\n\n// 익명 인증 사용\nenv.put(Context.SECURITY_AUTHENTICATION, \"none\"); // 규칙 위반\n\n// 초기 컨텍스트 생성\nDirContext ctx = new InitialDirContext(env);\n</pre>\n<h4>규칙을 준수하는 해결책</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\n// 초기 컨텍스트를 생성하기 위한 환경 설정\nHashtable&lt;String, Object&gt; env = new Hashtable&lt;String, Object&gt;();\nenv.put(Context.INITIAL_CONTEXT_FACTORY, \"com.sun.jndi.ldap.LdapCtxFactory\");\nenv.put(Context.PROVIDER_URL, \"ldap://localhost:389/o=Example\");\n\n// 단순 인증 사용\nenv.put(Context.SECURITY_AUTHENTICATION, \"simple\");\nenv.put(Context.SECURITY_PRINCIPAL, \"cn=local, ou=Unit, o=Example\");\nenv.put(Context.SECURITY_CREDENTIALS, getLDAPPassword());\n\n// 초기 컨텍스트 생성\nDirContext ctx = new InitialDirContext(env);\n</pre>",
    "moreInfo_ko": "<h3>문서</h3>\n<ul>\n  <li> <a href=\"https://datatracker.ietf.org/doc/html/rfc4513#section-5\">RFC 4513 - LDAP(Lightweight Directory Access Protocol): 인증 방법 및 보안 메커니즘</a> - 바인드 작업 </li>\n</ul>\n<h3>표준</h3>\n<ul>\n  <li> OWASP - <a href=\"https://owasp.org/Top10/A07_2021-Identification_and_Authentication_Failures/\">Top 10 2021 카테고리 A7 - 식별 및 인증 실패</a> </li>\n  <li> OWASP - <a href=\"https://owasp.org/www-project-top-ten/2017/A2_2017-Broken_Authentication\">Top 10 2017 카테고리 A2 - 취약한 인증</a> </li>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/521\">CWE-521 - 취약한 비밀번호 요구 사항</a> </li>\n</ul>"
  },
  {
    "id": "S6880",
    "key": "java:S6880",
    "name": "Use switch instead of if-else chain to compare a variable against multiple cases",
    "type": "code-smell",
    "severity": "major",
    "tags": [
      "java21"
    ],
    "why": "<p>Comparing a variable to multiple cases is a frequent operation. This can be done using a sequence of if-else statements. However, for many cases\nlike enums or simple value comparisons, a <code>switch</code> statement is the better alternative. With Java 21, the <code>switch</code> statement has\nbeen significantly improved to support pattern matching and record pattern.</p>\n<p>Using a <code>switch</code> statement instead of an if-else chain provides benefits like clearer code, certainty of covering all cases, and may\neven improve performance.</p>\n<p>This rule raises an issue when an if-else chain should be replaced by a <code>switch</code> statement.</p>",
    "howToFix": "<p>Replace the chain of if-else with a switch expression.</p>\n\n<h4>Noncompliant code example</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\nsealed interface Expression {}\nrecord Plus(Expression left, Expression right) implements Expression {}\nrecord Minus(Expression left, Expression right) implements Expression {}\nrecord Div(Expression left, Expression right) implements Expression {}\n\nint eval(Expression expr){\n  if(expr instanceof Plus plus){ // Noncompliant; should be replaced by a switch expression\n    return eval(plus.left) + eval(plus.right);\n  }else if(expr instanceof Div div){\n    return eval(div.left) / eval(div.right);\n  }else if(expr instanceof Minus minus){\n    return eval(minus.left) - eval(minus.right);\n  } else {\n    throw new IllegalArgumentException(\"Unknown expression\");\n  }\n}\n</pre>\n<pre data-diff-id=\"2\" data-diff-type=\"noncompliant\">\nenum Color{RED,GREEN,YELLOW}\n\nString name(Color c){\n  if(c == Color.RED){ // Noncompliant; should be replaced by a switch expression\n    return \"red\";\n  }else if(c == Color.GREEN){\n    return \"green\";\n  }else if(c == Color.YELLOW){\n    return \"yellow\";\n  }else{\n    throw new IllegalArgumentException(\"Unknown color\");\n  }\n}\n</pre>\n<pre data-diff-id=\"3\" data-diff-type=\"noncompliant\">\nint points(int result){\n  if(result == 2){ // Noncompliant; should be replaced by a switch expression\n    return 10;\n  } else if(result == 3 || result==4 ){\n    return 20;\n  } else if (result == 5) {\n    return 50;\n  }else{\n    return 0;\n  }\n}\n</pre>\n<pre data-diff-id=\"4\" data-diff-type=\"noncompliant\">\nclass Circle{}\nclass Rectangle{}\nclass Square{}\n\nString name(Object shape){\n  if (shape instanceof Circle) { // Noncompliant; should be replaced by a switch expression\n    return \"circle\";\n  } else if (shape instanceof Rectangle) {\n     return \"rectangle\";\n  } else if (shape instanceof Square) {\n    return \"square\";\n  } else {\n    throw new IllegalArgumentException();\n  }\n}\n</pre>\n<h4>Compliant solution</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\nsealed interface Expression {}\nrecord Plus(Expression left, Expression right) implements Expression {}\nrecord Minus(Expression left, Expression right) implements Expression {}\nrecord Div(Expression left, Expression right) implements Expression {}\n\nint eval(Expression expr){\n  return switch(expr){\n    case Div(var left, var right) -&gt; eval(left) / eval(right);\n    case Plus(var left, var right) -&gt; eval(left) + eval(right);\n    case Minus(var left, var right) -&gt; eval(left) - eval(right);\n  };\n}\n</pre>\n<pre data-diff-id=\"2\" data-diff-type=\"compliant\">\nenum Color{RED,GREEN,YELLOW}\nString name(Color c){\n  return switch(c){\n    case RED -&gt; \"red\";\n    case GREEN -&gt; \"green\";\n    case YELLOW -&gt; \"yellow\";\n  };\n}\n</pre>\n<pre data-diff-id=\"3\" data-diff-type=\"compliant\">\nint points(int result){\n  return switch(result){\n    case 2 -&gt; 10;\n    case 3,4 -&gt; 20;\n    case 5 -&gt; 50;\n    default -&gt; 0;\n  };\n}\n</pre>\n<pre data-diff-id=\"4\" data-diff-type=\"compliant\">\nclass Circle{}\nclass Rectangle{}\nclass Square{}\n\nString name(Object shape){\n  return switch(shape){\n    case Circle c -&gt; \"circle\";\n    case Rectangle r -&gt; \"rectangle\";\n    case Square s -&gt; \"square\";\n    default -&gt; throw new IllegalArgumentException();\n  };\n}\n</pre>",
    "moreInfo": "<ul>\n  <li> <a href=\"https://openjdk.org/jeps/440\">Record Patterns</a> </li>\n  <li> <a href=\"https://openjdk.org/jeps/441\">Pattern Matching for switch</a> </li>\n  <li> <a href=\"https://docs.oracle.com/javase/tutorial/java/nutsandbolts/switch.html\">The switch Statement</a> </li>\n</ul>",
    "status": "READY",
    "name_ko": "변수를 여러 경우와 비교할 때는 if-else 체인 대신 switch를 사용하세요",
    "why_ko": "<p>변수를 여러 경우와 비교하는 것은 빈번한 작업입니다. 이는 일련의 if-else 문을 사용하여 수행할 수 있습니다. 그러나 enum이나 단순 값 비교와 같은 많은 경우에 <code>switch</code> 문이 더 나은 대안입니다. Java 21에서 <code>switch</code> 문은 패턴 매칭과 record 패턴을 지원하도록 크게 개선되었습니다.</p>\n<p>if-else 체인 대신 <code>switch</code> 문을 사용하면 더 명확한 코드, 모든 경우를 다루는 확실성, 성능 향상 등의 이점을 제공합니다.</p>\n<p>이 규칙은 if-else 체인을 <code>switch</code> 문으로 교체해야 할 때 문제를 발생시킵니다.</p>",
    "howToFix_ko": "<p>if-else 체인을 switch 표현식으로 교체하세요.</p>\n\n<h4>규칙을 준수하지 않는 코드 예시</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\nsealed interface Expression {}\nrecord Plus(Expression left, Expression right) implements Expression {}\nrecord Minus(Expression left, Expression right) implements Expression {}\nrecord Div(Expression left, Expression right) implements Expression {}\n\nint eval(Expression expr){\n  if(expr instanceof Plus plus){ // 규칙 위반; switch 표현식으로 교체해야 합니다\n    return eval(plus.left) + eval(plus.right);\n  }else if(expr instanceof Div div){\n    return eval(div.left) / eval(div.right);\n  }else if(expr instanceof Minus minus){\n    return eval(minus.left) - eval(minus.right);\n  } else {\n    throw new IllegalArgumentException(\"Unknown expression\");\n  }\n}\n</pre>\n<pre data-diff-id=\"2\" data-diff-type=\"noncompliant\">\nenum Color{RED,GREEN,YELLOW}\n\nString name(Color c){\n  if(c == Color.RED){ // 규칙 위반; switch 표현식으로 교체해야 합니다\n    return \"red\";\n  }else if(c == Color.GREEN){\n    return \"green\";\n  }else if(c == Color.YELLOW){\n    return \"yellow\";\n  }else{\n    throw new IllegalArgumentException(\"Unknown color\");\n  }\n}\n</pre>\n<pre data-diff-id=\"3\" data-diff-type=\"noncompliant\">\nint points(int result){\n  if(result == 2){ // 규칙 위반; switch 표현식으로 교체해야 합니다\n    return 10;\n  } else if(result == 3 || result==4 ){\n    return 20;\n  } else if (result == 5) {\n    return 50;\n  }else{\n    return 0;\n  }\n}\n</pre>\n<pre data-diff-id=\"4\" data-diff-type=\"noncompliant\">\nclass Circle{}\nclass Rectangle{}\nclass Square{}\n\nString name(Object shape){\n  if (shape instanceof Circle) { // 규칙 위반; switch 표현식으로 교체해야 합니다\n    return \"circle\";\n  } else if (shape instanceof Rectangle) {\n     return \"rectangle\";\n  } else if (shape instanceof Square) {\n    return \"square\";\n  } else {\n    throw new IllegalArgumentException();\n  }\n}\n</pre>\n<h4>규칙을 준수하는 해결책</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\nsealed interface Expression {}\nrecord Plus(Expression left, Expression right) implements Expression {}\nrecord Minus(Expression left, Expression right) implements Expression {}\nrecord Div(Expression left, Expression right) implements Expression {}\n\nint eval(Expression expr){\n  return switch(expr){\n    case Div(var left, var right) -&gt; eval(left) / eval(right);\n    case Plus(var left, var right) -&gt; eval(left) + eval(right);\n    case Minus(var left, var right) -&gt; eval(left) - eval(right);\n  };\n}\n</pre>\n<pre data-diff-id=\"2\" data-diff-type=\"compliant\">\nenum Color{RED,GREEN,YELLOW}\nString name(Color c){\n  return switch(c){\n    case RED -&gt; \"red\";\n    case GREEN -&gt; \"green\";\n    case YELLOW -&gt; \"yellow\";\n  };\n}\n</pre>\n<pre data-diff-id=\"3\" data-diff-type=\"compliant\">\nint points(int result){\n  return switch(result){\n    case 2 -&gt; 10;\n    case 3,4 -&gt; 20;\n    case 5 -&gt; 50;\n    default -&gt; 0;\n  };\n}\n</pre>\n<pre data-diff-id=\"4\" data-diff-type=\"compliant\">\nclass Circle{}\nclass Rectangle{}\nclass Square{}\n\nString name(Object shape){\n  return switch(shape){\n    case Circle c -&gt; \"circle\";\n    case Rectangle r -&gt; \"rectangle\";\n    case Square s -&gt; \"square\";\n    default -&gt; throw new IllegalArgumentException();\n  };\n}\n</pre>",
    "moreInfo_ko": "<ul>\n  <li> <a href=\"https://openjdk.org/jeps/440\">Record Patterns</a> </li>\n  <li> <a href=\"https://openjdk.org/jeps/441\">switch를 위한 패턴 매칭</a> </li>\n  <li> <a href=\"https://docs.oracle.com/javase/tutorial/java/nutsandbolts/switch.html\">switch 문</a> </li>\n</ul>"
  },
  {
    "id": "S3047",
    "key": "java:S3047",
    "name": "Multiple loops over the same set should be combined",
    "type": "code-smell",
    "severity": "minor",
    "tags": [
      "performance"
    ],
    "why": "<p>When a method loops multiple over the same set of data, whether it's a list or a set of numbers, it is highly likely that the method could be made\nmore efficient by combining the loops into a single set of iterations.</p>\n<h3>Noncompliant code example</h3>\n<pre>\npublic void doSomethingToAList(List&lt;String&gt; strings) {\n  for (String str : strings) {\n    doStep1(str);\n  }\n  for (String str : strings) {  // Noncompliant\n    doStep2(str);\n  }\n}\n</pre>\n<h3>Compliant solution</h3>\n<pre>\npublic void doSomethingToAList(List&lt;String&gt; strings) {\n  for (String str : strings) {\n    doStep1(str);\n    doStep2(str);\n  }\n}\n</pre>",
    "howToFix": "",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "동일한 집합에 대한 여러 반복문은 결합해야 합니다",
    "why_ko": "<p>메서드가 동일한 데이터 집합(리스트든 숫자 집합이든)에 대해 여러 번 반복할 때, 반복문을 단일 반복으로 결합하면 메서드를 더 효율적으로 만들 수 있는 가능성이 높습니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\npublic void doSomethingToAList(List&lt;String&gt; strings) {\n  for (String str : strings) {\n    doStep1(str);\n  }\n  for (String str : strings) {  // 규칙 위반\n    doStep2(str);\n  }\n}\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre>\npublic void doSomethingToAList(List&lt;String&gt; strings) {\n  for (String str : strings) {\n    doStep1(str);\n    doStep2(str);\n  }\n}\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": ""
  },
  {
    "id": "S139",
    "key": "java:S139",
    "name": "Comments should not be located at the end of lines of code",
    "type": "code-smell",
    "severity": "minor",
    "tags": [
      "convention"
    ],
    "why": "<p>This rule verifies that single-line comments are not located at the ends of lines of code. The main idea behind this rule is that in order to be\nreally readable, trailing comments would have to be properly written and formatted (correct alignment, no interference with the visual structure of\nthe code, not too long to be visible) but most often, automatic code formatters would not handle this correctly: the code would end up less readable.\nComments are far better placed on the previous empty line of code, where they will always be visible and properly formatted.</p>\n<h3>Noncompliant code example</h3>\n<pre>\nint a1 = b + c; // This is a trailing comment that can be very very long\n</pre>\n<h3>Compliant solution</h3>\n<pre>\n// This very long comment is better placed before the line of code\nint a2 = b + c;\n</pre>",
    "howToFix": "",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "주석은 코드 라인 끝에 위치하면 안 됩니다",
    "why_ko": "<p>이 규칙은 한 줄 주석이 코드 라인 끝에 위치하지 않는지 확인합니다. 이 규칙의 주요 아이디어는 정말 읽기 쉬우려면 후행 주석이 적절하게 작성되고 형식화되어야 한다는 것입니다(올바른 정렬, 코드의 시각적 구조에 대한 간섭 없음, 보이기에 너무 길지 않음). 하지만 대부분의 경우 자동 코드 포매터가 이를 올바르게 처리하지 못합니다: 코드는 결국 읽기 어려워집니다. 주석은 항상 보이고 적절하게 형식화되는 이전 빈 줄에 배치하는 것이 훨씬 좋습니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\nint a1 = b + c; // 이것은 매우 매우 길 수 있는 후행 주석입니다\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre>\n// 이 매우 긴 주석은 코드 라인 앞에 배치하는 것이 더 좋습니다\nint a2 = b + c;\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": ""
  },
  {
    "id": "S1996",
    "key": "java:S1996",
    "name": "Files should contain only one top-level class or interface each",
    "type": "code-smell",
    "severity": "major",
    "tags": [
      "brain-overload"
    ],
    "why": "<p>A file that grows too much tends to aggregate too many responsibilities and inevitably becomes harder to understand and therefore to maintain. This\nis doubly true for a file with multiple top-level classes and interfaces. It is strongly advised to divide the file into one top-level class or\ninterface per file.</p>",
    "howToFix": "",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "파일에는 하나의 최상위 클래스 또는 인터페이스만 포함해야 합니다",
    "why_ko": "<p>너무 많이 커진 파일은 너무 많은 책임을 모으는 경향이 있으며 필연적으로 이해하기 어려워지고 따라서 유지보수하기도 어려워집니다. 이것은 여러 최상위 클래스와 인터페이스가 있는 파일의 경우 두 배로 그렇습니다. 파일당 하나의 최상위 클래스 또는 인터페이스로 파일을 나누는 것이 강력히 권장됩니다.</p>",
    "howToFix_ko": "",
    "moreInfo_ko": ""
  },
  {
    "id": "S6300",
    "key": "java:S6300",
    "name": "Using unencrypted files in mobile applications is security-sensitive",
    "type": "security-hotspot",
    "severity": "major",
    "tags": [],
    "why": "<p>This rule is deprecated, and will eventually be removed.</p>\n<p>Storing files locally is a common task for mobile applications. Files that are stored unencrypted can be read out and modified by an attacker with\nphysical access to the device. Access to sensitive data can be harmful for the user of the application, for example when the device gets stolen.</p>\n",
    "howToFix": "<h2>Recommended Secure Coding Practices</h2>\n<p>It's recommended to password-encrypt local files that contain sensitive information. The class <a\nhref=\"https://developer.android.com/reference/androidx/security/crypto/EncryptedFile\">EncryptedFile</a> can be used to easily encrypt files.</p>\n<h2>Compliant Solution</h2>\n<pre>\nString masterKeyAlias = MasterKeys.getOrCreate(MasterKeys.AES256_GCM_SPEC);\n\nFile file = new File(context.getFilesDir(), \"secret_data\");\nEncryptedFile encryptedFile = EncryptedFile.Builder(\n    file,\n    context,\n    masterKeyAlias,\n    EncryptedFile.FileEncryptionScheme.AES256_GCM_HKDF_4KB\n).build();\n\n// write to the encrypted file\nFileOutputStream encryptedOutputStream = encryptedFile.openFileOutput();\n</pre>\n<h2>See</h2>\n<ul>\n  <li> OWASP - <a href=\"https://owasp.org/www-project-top-ten/2017/A3_2017-Sensitive_Data_Exposure\">Top 10 2017 Category A3 - Sensitive Data\n  Exposure</a> </li>\n  <li> OWASP - <a href=\"https://owasp.org/www-project-top-ten/2017/A6_2017-Security_Misconfiguration\">Top 10 2017 Category A6 - Security\n  Misconfiguration</a> </li>\n  <li> OWASP - <a href=\"https://owasp.org/Top10/A04_2021-Insecure_Design/\">Top 10 2021 Category A4 - Insecure Design</a> </li>\n  <li> OWASP - <a href=\"https://mas.owasp.org/checklists/MASVS-STORAGE/\">Mobile AppSec Verification Standard - Data Storage and Privacy\n  Requirements</a> </li>\n  <li> OWASP - <a href=\"https://owasp.org/www-project-mobile-top-10/2016-risks/m2-insecure-data-storage\">Mobile Top 10 2016 Category M2 - Insecure\n  Data Storage</a> </li>\n  <li> OWASP - <a href=\"https://owasp.org/www-project-mobile-top-10/2023-risks/m9-insecure-data-storage\">Mobile Top 10 2024 Category M9 - Insecure\n  Data Storage</a> </li>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/311\">CWE-311 - Missing Encryption of Sensitive Data</a> </li>\n</ul>",
    "moreInfo": "",
    "status": "DEPRECATED",
    "name_ko": "모바일 애플리케이션에서 암호화되지 않은 파일 사용은 보안에 민감합니다",
    "why_ko": "<p>이 규칙은 더 이상 사용되지 않으며 향후 제거될 예정입니다.</p>\n<p>로컬에 파일을 저장하는 것은 모바일 애플리케이션의 일반적인 작업입니다. 암호화되지 않은 상태로 저장된 파일은 기기에 물리적으로 접근할 수 있는 공격자가 읽거나 수정할 수 있습니다. 민감한 데이터에 대한 접근은 예를 들어 기기가 도난당했을 때 애플리케이션 사용자에게 해로울 수 있습니다.</p>\n",
    "howToFix_ko": "<h2>권장 보안 코딩 관행</h2>\n<p>민감한 정보가 포함된 로컬 파일은 비밀번호로 암호화하는 것이 권장됩니다. <a href=\"https://developer.android.com/reference/androidx/security/crypto/EncryptedFile\">EncryptedFile</a> 클래스를 사용하여 파일을 쉽게 암호화할 수 있습니다.</p>\n<h2>규칙을 준수하는 해결책</h2>\n<pre>\nString masterKeyAlias = MasterKeys.getOrCreate(MasterKeys.AES256_GCM_SPEC);\n\nFile file = new File(context.getFilesDir(), \"secret_data\");\nEncryptedFile encryptedFile = EncryptedFile.Builder(\n    file,\n    context,\n    masterKeyAlias,\n    EncryptedFile.FileEncryptionScheme.AES256_GCM_HKDF_4KB\n).build();\n\n// 암호화된 파일에 쓰기\nFileOutputStream encryptedOutputStream = encryptedFile.openFileOutput();\n</pre>\n<h2>참고</h2>\n<ul>\n  <li> OWASP - <a href=\"https://owasp.org/www-project-top-ten/2017/A3_2017-Sensitive_Data_Exposure\">Top 10 2017 Category A3 - 민감한 데이터 노출</a> </li>\n  <li> OWASP - <a href=\"https://owasp.org/www-project-top-ten/2017/A6_2017-Security_Misconfiguration\">Top 10 2017 Category A6 - 보안 구성 오류</a> </li>\n  <li> OWASP - <a href=\"https://owasp.org/Top10/A04_2021-Insecure_Design/\">Top 10 2021 Category A4 - 안전하지 않은 설계</a> </li>\n  <li> OWASP - <a href=\"https://mas.owasp.org/checklists/MASVS-STORAGE/\">Mobile AppSec Verification Standard - 데이터 저장소 및 개인정보 보호 요구사항</a> </li>\n  <li> OWASP - <a href=\"https://owasp.org/www-project-mobile-top-10/2016-risks/m2-insecure-data-storage\">Mobile Top 10 2016 Category M2 - 안전하지 않은 데이터 저장소</a> </li>\n  <li> OWASP - <a href=\"https://owasp.org/www-project-mobile-top-10/2023-risks/m9-insecure-data-storage\">Mobile Top 10 2024 Category M9 - 안전하지 않은 데이터 저장소</a> </li>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/311\">CWE-311 - 민감한 데이터의 암호화 누락</a> </li>\n</ul>",
    "moreInfo_ko": ""
  },
  {
    "id": "S1611",
    "key": "java:S1611",
    "name": "Parentheses should be removed from a single lambda parameter when its type is inferred",
    "type": "code-smell",
    "severity": "minor",
    "tags": [
      "java8"
    ],
    "why": "<p>Lambda expressions with only one argument with an inferred type (i.e., no explicit type declaration) can be written without parentheses around that\nsingle parameter. This syntax is simpler, more compact and readable than using parentheses and is therefore preferred.</p>\n<p>This rule is automatically disabled when the project's <code>sonar.java.source</code> is lower than <code>8</code>, as lambda expressions were\nintroduced in Java 8.</p>\n<h3>Noncompliant code example</h3>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\n(x) -&gt; x * 2\n</pre>\n<h3>Compliant solution</h3>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\nx -&gt; x * 2\n</pre>",
    "howToFix": "",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "타입이 추론되는 단일 Lambda 매개변수에서 괄호를 제거해야 합니다",
    "why_ko": "<p>추론된 타입(즉, 명시적 타입 선언이 없는)을 가진 하나의 인자만 있는 람다 표현식은 해당 단일 매개변수 주위에 괄호 없이 작성할 수 있습니다. 이 구문은 괄호를 사용하는 것보다 더 간단하고, 더 간결하며, 읽기 쉬우므로 선호됩니다.</p>\n<p>이 규칙은 프로젝트의 <code>sonar.java.source</code>가 <code>8</code>보다 낮으면 자동으로 비활성화됩니다. 람다 표현식이 Java 8에서 도입되었기 때문입니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\n(x) -&gt; x * 2\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\nx -&gt; x * 2\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": ""
  },
  {
    "id": "S2197",
    "key": "java:S2197",
    "name": "Modulus results should not be checked for direct equality",
    "type": "code-smell",
    "severity": "critical",
    "tags": [
      "cert",
      "suspicious"
    ],
    "why": "<p>When the modulus of a negative number is calculated, the result will either be negative or zero. Thus, comparing the modulus of a variable for\nequality with a positive number (or a negative one) could result in unexpected results.</p>\n<h3>Noncompliant code example</h3>\n<pre>\npublic boolean isOdd(int x) {\n  return x % 2 == 1;  // Noncompliant; if x is an odd negative, x % 2 == -1\n}\n</pre>\n<h3>Compliant solution</h3>\n<pre>\npublic boolean isOdd(int x) {\n  return x % 2 != 0;\n}\n</pre>",
    "howToFix": "",
    "moreInfo": "<ul>\n  <li> <a href=\"https://wiki.sei.cmu.edu/confluence/x/pDdGBQ\">CERT, NUM51-J.</a> - Do not assume that the remainder operator always returns a\n  nonnegative result for integral operands </li>\n  <li> <a href=\"https://wiki.sei.cmu.edu/confluence/x/_NUxBQ\">CERT, INT10-C</a> - Do not assume a positive remainder when using the % operator </li>\n</ul>",
    "status": "READY",
    "name_ko": "나머지 연산 결과는 직접 동등 비교하면 안 됩니다","why_ko": "<p>음수의 나머지 연산을 계산하면 결과는 음수 또는 0이 됩니다. 따라서 변수의 나머지 연산을 양수(또는 음수)와 동등 비교하면 예상치 못한 결과가 발생할 수 있습니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\npublic boolean isOdd(int x) {\n  return x % 2 == 1;  // 규칙 위반; x가 음수 홀수이면 x % 2 == -1\n}\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre>\npublic boolean isOdd(int x) {\n  return x % 2 != 0;\n}\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": "<ul>\n  <li> <a href=\"https://wiki.sei.cmu.edu/confluence/x/pDdGBQ\">CERT, NUM51-J.</a> - 나머지 연산자가 정수 피연산자에 대해 항상 음이 아닌 결과를 반환한다고 가정하지 마세요 </li>\n  <li> <a href=\"https://wiki.sei.cmu.edu/confluence/x/_NUxBQ\">CERT, INT10-C</a> - % 연산자를 사용할 때 양의 나머지를 가정하지 마세요 </li>\n</ul>"
  },
  {
    "id": "S2178",
    "key": "java:S2178",
    "name": "Short-circuit logic should be used in boolean contexts",
    "type": "code-smell",
    "severity": "blocker",
    "tags": [
      "cert"
    ],
    "why": "<p>The use of non-short-circuit logic in a boolean context is likely a mistake - one that could cause serious program errors as conditions are\nevaluated under the wrong circumstances.</p>\n<h3>Noncompliant code example</h3>\n<pre>\nif(getTrue() | getFalse()) { ... } // Noncompliant; both sides evaluated\n</pre>\n<h3>Compliant solution</h3>\n<pre>\nif(getTrue() || getFalse()) { ... } // true short-circuit logic\n</pre>",
    "howToFix": "",
    "moreInfo": "<ul>\n  <li> <a href=\"https://wiki.sei.cmu.edu/confluence/x/WNYxBQ\">CERT, EXP46-C.</a> - Do not use a bitwise operator with a Boolean-like operand </li>\n</ul>",
    "status": "READY",
    "name_ko": "boolean 컨텍스트에서는 단락 평가 논리를 사용해야 합니다",
    "why_ko": "<p>boolean 컨텍스트에서 비단락 평가 논리를 사용하는 것은 실수일 가능성이 높습니다 - 잘못된 상황에서 조건이 평가되어 심각한 프로그램 오류를 일으킬 수 있습니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\nif(getTrue() | getFalse()) { ... } // 규칙 위반; 양쪽 모두 평가됨\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre>\nif(getTrue() || getFalse()) { ... } // 진정한 단락 평가 논리\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": "<ul>\n  <li> <a href=\"https://wiki.sei.cmu.edu/confluence/x/WNYxBQ\">CERT, EXP46-C.</a> - Boolean과 유사한 피연산자와 함께 비트 연산자를 사용하지 마세요 </li>\n</ul>"
  },
  {
    "id": "S6838",
    "key": "java:S6838",
    "name": "\"@Bean\" methods for Singleton should not be invoked in \"@Configuration\" when proxyBeanMethods is false",
    "type": "bug",
    "severity": "major",
    "tags": [
      "spring"
    ],
    "why": "<p>When setting the <code>proxyBeanMethods</code> attribute to <code>false</code> the <code>@Bean</code> methods are not proxied and this is similar\nto removing the <code>@Configuration</code> stereotype. In this scenario, <code>@Bean</code> methods within the <code>@Configuration</code> annotated\nclass operate in <a href=\"https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/context/annotation/Bean.html\"><em>lite\nmode</em></a>, resulting in a new bean creation each time the method is invoked.</p>\n<p>For <code>Singleton</code> beans, this could cause unexpected outcomes as the bean is created multiple times instead of being created once and\ncached.</p>\n<p>The rule raises an issue when the <code>proxyBeanMethods</code> attribute is set to <code>false</code> and the <code>@Bean</code> method of a\n<code>Singleton</code> bean is directly invoked in the <code>@Configuration</code> annotated class code.</p>",
    "howToFix": "<p>The issue can be fixed in the following ways:</p>\n<ul>\n  <li> Not invoking the <code>@Bean</code> method directly, but rather injecting the bean in the context and using it, by means of <code>@Bean</code>\n  <a href=\"https://docs.spring.io/spring-framework/reference/core/beans/java/bean-annotation.html#beans-java-dependencies\">method parameters</a>.\n  </li>\n  <li> If the performance penalty is negligible, consider not disabling the <code>proxyBeanMethods</code> attribute, so that the <code>@Bean</code>\n  methods are proxied and the bean lifecycle is enforced. </li>\n</ul>\n\n<h4>Noncompliant code example</h4>\n<p>In the example below, every instance of <code>PrototypeBean</code> will have a different instance of <code>SingletonBean</code>, as\n<code>singletonBean()</code> is called directly from <code>prototypeBean()</code>.</p>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\n@Configuration(proxyBeanMethods = false)\nclass ConfigurationExample {\n  @Bean\n  public SingletonBean singletonBean() {\n    return new SingletonBean();\n  }\n\n  @Bean\n  @Scope(\"prototype\")\n  public PrototypeBean prototypeBean() {\n    return new PrototypeBean(singletonBean()); // Noncompliant: a \"singletonBean\" is created every time a prototypeBean is created\n  }\n\n  class SingletonBean {\n    // ...\n  }\n\n  class PrototypeBean {\n    // ...\n\n    public PrototypeBean(SingletonBean singletonBean) {\n      // ...\n    }\n\n    // ...\n  }\n}\n</pre>\n<h4>Compliant solution</h4>\n<p>The compliant solution relies on the <code>@Bean</code> method parameter to automatically inject the <code>SingletonBean</code> from the\n<code>ApplicationContext</code>. This way every instance of <code>PrototypeBean</code> will have the same instance of <code>SingletonBean</code>.</p>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\n@Configuration(proxyBeanMethods = false)\nclass ConfigurationExample {\n  @Bean\n  public SingletonBean singletonBean() {\n    return new SingletonBean();\n  }\n\n  @Bean\n  @Scope(\"prototype\")\n  public PrototypeBean prototypeBean(SingletonBean singletonBean) { // Compliant, the singletonBean is injected in the context and used by every prototypeBean\n    return new PrototypeBean(singletonBean);\n  }\n\n  class SingletonBean {\n    // ...\n  }\n\n  class PrototypeBean {\n    // ...\n\n    public PrototypeBean(SingletonBean singletonBean) {\n      // ...\n    }\n\n    // ...\n  }\n}\n</pre>",
    "moreInfo": "<h3>Documentation</h3>\n<ul>\n  <li> Spring - <a\n  href=\"https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/context/annotation/Configuration.html#proxyBeanMethods()\">Configuration - proxyBeanMethods</a> </li>\n  <li> Spring - <a href=\"https://docs.spring.io/spring-framework/reference/core/aop/proxying.html\">Proxying Mechanisms</a> </li>\n  <li> Spring - <a href=\"https://docs.spring.io/spring-framework/reference/core/beans/java/bean-annotation.html#beans-java-dependencies\">Bean\n  Annotation - Dependencies</a> </li>\n  <li> GitHub - <a href=\"https://github.com/cglib/cglib/wiki\">CGLIB</a> </li>\n</ul>\n<h3>Articles &amp; blog posts</h3>\n<ul>\n  <li> Medium - <a href=\"https://blog.devgenius.io/demystifying-proxy-in-spring-3ab536046b11\">Demystifying Proxy in Spring</a> </li>\n</ul>",
    "status": "READY",
    "name_ko": "proxyBeanMethods가 false일 때 \"@Configuration\"에서 Singleton용 \"@Bean\" 메서드를 호출하면 안 됩니다",
    "why_ko": "<p><code>proxyBeanMethods</code> 속성을 <code>false</code>로 설정하면 <code>@Bean</code> 메서드가 프록시되지 않으며 이는 <code>@Configuration</code> 스테레오타입을 제거하는 것과 유사합니다. 이 시나리오에서 <code>@Configuration</code> 어노테이션된 클래스 내의 <code>@Bean</code> 메서드는 <a href=\"https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/context/annotation/Bean.html\"><em>라이트 모드</em></a>로 작동하여 메서드가 호출될 때마다 새로운 빈이 생성됩니다.</p>\n<p><code>Singleton</code> 빈의 경우 빈이 한 번 생성되고 캐시되는 대신 여러 번 생성되므로 예상치 못한 결과가 발생할 수 있습니다.</p>\n<p>이 규칙은 <code>proxyBeanMethods</code> 속성이 <code>false</code>로 설정되어 있고 <code>Singleton</code> 빈의 <code>@Bean</code> 메서드가 <code>@Configuration</code> 어노테이션된 클래스 코드에서 직접 호출될 때 문제를 발생시킵니다.</p>",
    "howToFix_ko": "<p>이 문제는 다음 방법으로 해결할 수 있습니다:</p>\n<ul>\n  <li> <code>@Bean</code> 메서드를 직접 호출하지 않고 <code>@Bean</code> <a href=\"https://docs.spring.io/spring-framework/reference/core/beans/java/bean-annotation.html#beans-java-dependencies\">메서드 매개변수</a>를 통해 컨텍스트에서 빈을 주입받아 사용합니다. </li>\n  <li> 성능 저하가 무시할 수 있는 수준이라면 <code>proxyBeanMethods</code> 속성을 비활성화하지 않는 것을 고려하세요. 그러면 <code>@Bean</code> 메서드가 프록시되고 빈 생명주기가 적용됩니다. </li>\n</ul>\n\n<h4>규칙을 준수하지 않는 코드 예시</h4>\n<p>아래 예제에서 <code>prototypeBean()</code>에서 <code>singletonBean()</code>이 직접 호출되므로 모든 <code>PrototypeBean</code> 인스턴스는 서로 다른 <code>SingletonBean</code> 인스턴스를 갖게 됩니다.</p>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\n@Configuration(proxyBeanMethods = false)\nclass ConfigurationExample {\n  @Bean\n  public SingletonBean singletonBean() {\n    return new SingletonBean();\n  }\n\n  @Bean\n  @Scope(\"prototype\")\n  public PrototypeBean prototypeBean() {\n    return new PrototypeBean(singletonBean()); // 규칙 위반: prototypeBean이 생성될 때마다 \"singletonBean\"이 생성됩니다\n  }\n\n  class SingletonBean {\n    // ...\n  }\n\n  class PrototypeBean {\n    // ...\n\n    public PrototypeBean(SingletonBean singletonBean) {\n      // ...\n    }\n\n    // ...\n  }\n}\n</pre>\n<h4>규칙을 준수하는 해결책</h4>\n<p>규칙을 준수하는 해결책은 <code>@Bean</code> 메서드 매개변수를 사용하여 <code>ApplicationContext</code>에서 <code>SingletonBean</code>을 자동으로 주입받습니다. 이렇게 하면 모든 <code>PrototypeBean</code> 인스턴스가 동일한 <code>SingletonBean</code> 인스턴스를 갖게 됩니다.</p>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\n@Configuration(proxyBeanMethods = false)\nclass ConfigurationExample {\n  @Bean\n  public SingletonBean singletonBean() {\n    return new SingletonBean();\n  }\n\n  @Bean\n  @Scope(\"prototype\")\n  public PrototypeBean prototypeBean(SingletonBean singletonBean) { // 규칙 준수, singletonBean이 컨텍스트에 주입되어 모든 prototypeBean에서 사용됩니다\n    return new PrototypeBean(singletonBean);\n  }\n\n  class SingletonBean {\n    // ...\n  }\n\n  class PrototypeBean {\n    // ...\n\n    public PrototypeBean(SingletonBean singletonBean) {\n      // ...\n    }\n\n    // ...\n  }\n}\n</pre>",
    "moreInfo_ko": "<h3>문서</h3>\n<ul>\n  <li> Spring - <a href=\"https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/context/annotation/Configuration.html#proxyBeanMethods()\">Configuration - proxyBeanMethods</a> </li>\n  <li> Spring - <a href=\"https://docs.spring.io/spring-framework/reference/core/aop/proxying.html\">프록시 메커니즘</a> </li>\n  <li> Spring - <a href=\"https://docs.spring.io/spring-framework/reference/core/beans/java/bean-annotation.html#beans-java-dependencies\">Bean 어노테이션 - 의존성</a> </li>\n  <li> GitHub - <a href=\"https://github.com/cglib/cglib/wiki\">CGLIB</a> </li>\n</ul>\n<h3>기사 및 블로그 게시물</h3>\n<ul>\n  <li> Medium - <a href=\"https://blog.devgenius.io/demystifying-proxy-in-spring-3ab536046b11\">Spring의 프록시 이해하기</a> </li>\n</ul>"
  },
  {
    "id": "S2251",
    "key": "java:S2251",
    "name": "A \"for\" loop update clause should move the counter in the right direction",
    "type": "bug",
    "severity": "major",
    "tags": [
      "cert"
    ],
    "why": "<p>A <code>for</code> loop with a counter moving away from the end of the specified range is likely a programming mistake.</p>\n<p>If the intention is to iterate over the specified range, this differs from what the loop does because the counter moves in the wrong direction.</p>\n<p>If the intention is to have an infinite loop or a loop terminated only by a break statement, there are two problems:</p>\n<ol>\n  <li> The loop condition is not infinite because the counter variable will eventually overflow and fulfill the condition. This can take a long time,\n  depending on the data type of the counter. </li>\n  <li> An infinite loop terminated by a <code>break</code> statement should be implemented using a <code>while</code> or <code>do</code>\n  <code>while</code> loop to make the developer's intention clear to the reader. </li>\n</ol>",
    "howToFix": "<h4>Noncompliant code example</h4>\n<p>Change the direction of the counter.</p>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\nfor (int i = 10; i &gt; 0; i++) { // Noncompliant, wrong direction\n  System.out.println(\"Hello, world!\") // executed ca. 2 billion times\n}\n</pre>\n<pre data-diff-id=\"2\" data-diff-type=\"noncompliant\">\npublic void doSomething(String [] strings) {\n  for (int i = 0; i &lt; strings.length; i--) { // Noncompliant, wrong direction\n    String string = strings[i];  // ArrayIndexOutOfBoundsException when i reaches -1\n    // ...\n  }\n}\n</pre>\n<h4>Compliant solution</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\nfor (int i = 10; i &gt; 0; i--) { // Compliant\n  System.out.println(\"Hello, world!\") // executed 10 times\n}\n</pre>\n<pre data-diff-id=\"2\" data-diff-type=\"compliant\">\npublic void doSomething(String [] strings) {\n  for (int i = 0; i &lt; strings.length; i++) { // Compliant\n    String string = strings[i];\n    // ...\n  }\n}\n</pre>\n<h4>Noncompliant code example</h4>\n<p>If the intention is to have an infinite loop or a loop terminated only by a break statement, use a <code>while</code> or a <code>do</code>\n<code>while</code> statement instead.</p>\n<pre data-diff-id=\"3\" data-diff-type=\"noncompliant\">\nfor (int i = 0; i &lt; 0; i++) { // Noncompliant, loop is not infinite\n  String event = waitForNextEvent();\n  if (event == \"terminate\") break;\n  processEvent(event);\n}\n</pre>\n<h4>Compliant solution</h4>\n<pre data-diff-id=\"3\" data-diff-type=\"compliant\">\nwhile (true) { // Compliant\n  String event = waitForNextEvent();\n  if (event == \"terminate\") break;\n  processEvent(event);\n}\n</pre>",
    "moreInfo": "<h3>Documentation</h3>\n<ul>\n  <li> <a href=\"https://wiki.sei.cmu.edu/confluence/x/aTdGBQ\">CERT, MSC54-J.</a> - Avoid inadvertent wrapping of loop counters </li>\n</ul>\n<h3>Articles &amp; blog posts</h3>\n<ul>\n  <li> <a href=\"https://en.wikipedia.org/wiki/Integer_overflow\">Wikipedia - Integer overflow</a> </li>\n</ul>",
    "status": "READY",
    "name_ko": "for 루프의 증감절은 카운터를 올바른 방향으로 이동시켜야 합니다",
    "why_ko": "<p>지정된 범위의 끝에서 멀어지는 방향으로 카운터가 이동하는 <code>for</code> 루프는 프로그래밍 실수일 가능성이 높습니다.</p>\n<p>지정된 범위를 반복하려는 의도라면 카운터가 잘못된 방향으로 이동하기 때문에 루프가 수행하는 것과 다릅니다.</p>\n<p>무한 루프 또는 break 문으로만 종료되는 루프를 의도한 경우 두 가지 문제가 있습니다:</p>\n<ol>\n  <li> 카운터 변수가 결국 오버플로우되어 조건을 충족하기 때문에 루프 조건이 무한하지 않습니다. 이것은 카운터의 데이터 타입에 따라 오랜 시간이 걸릴 수 있습니다. </li>\n  <li> <code>break</code> 문으로 종료되는 무한 루프는 개발자의 의도를 독자에게 명확하게 하기 위해 <code>while</code> 또는 <code>do</code> <code>while</code> 루프를 사용하여 구현해야 합니다. </li>\n</ol>",
    "howToFix_ko": "<h4>규칙을 준수하지 않는 코드 예시</h4>\n<p>카운터의 방향을 변경하세요.</p>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\nfor (int i = 10; i &gt; 0; i++) { // 규칙 위반, 잘못된 방향\n  System.out.println(\"Hello, world!\") // 약 20억 번 실행됨\n}\n</pre>\n<pre data-diff-id=\"2\" data-diff-type=\"noncompliant\">\npublic void doSomething(String [] strings) {\n  for (int i = 0; i &lt; strings.length; i--) { // 규칙 위반, 잘못된 방향\n    String string = strings[i];  // i가 -1에 도달하면 ArrayIndexOutOfBoundsException\n    // ...\n  }\n}\n</pre>\n<h4>규칙을 준수하는 해결책</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\nfor (int i = 10; i &gt; 0; i--) { // 규칙 준수\n  System.out.println(\"Hello, world!\") // 10번 실행됨\n}\n</pre>\n<pre data-diff-id=\"2\" data-diff-type=\"compliant\">\npublic void doSomething(String [] strings) {\n  for (int i = 0; i &lt; strings.length; i++) { // 규칙 준수\n    String string = strings[i];\n    // ...\n  }\n}\n</pre>\n<h4>규칙을 준수하지 않는 코드 예시</h4>\n<p>무한 루프 또는 break 문으로만 종료되는 루프를 의도한 경우 대신 <code>while</code> 또는 <code>do</code> <code>while</code> 문을 사용하세요.</p>\n<pre data-diff-id=\"3\" data-diff-type=\"noncompliant\">\nfor (int i = 0; i &lt; 0; i++) { // 규칙 위반, 루프가 무한하지 않음\n  String event = waitForNextEvent();\n  if (event == \"terminate\") break;\n  processEvent(event);\n}\n</pre>\n<h4>규칙을 준수하는 해결책</h4>\n<pre data-diff-id=\"3\" data-diff-type=\"compliant\">\nwhile (true) { // 규칙 준수\n  String event = waitForNextEvent();\n  if (event == \"terminate\") break;\n  processEvent(event);\n}\n</pre>",
    "moreInfo_ko": "<h3>문서</h3>\n<ul>\n  <li> <a href=\"https://wiki.sei.cmu.edu/confluence/x/aTdGBQ\">CERT, MSC54-J.</a> - 루프 카운터의 의도치 않은 래핑 방지 </li>\n</ul>\n<h3>관련 문서 및 블로그 게시물</h3>\n<ul>\n  <li> <a href=\"https://en.wikipedia.org/wiki/Integer_overflow\">Wikipedia - 정수 오버플로우</a> </li>\n</ul>"
  },
  {
    "id": "S6212",
    "key": "java:S6212",
    "name": "Local-Variable Type Inference should be used",
    "type": "code-smell",
    "severity": "info",
    "tags": [
      "java10"
    ],
    "why": "<p>In Java 10 <a href=\"https://openjdk.java.net/jeps/286\">Local-Variable Type Inference</a> was introduced. It allows you to omit the expected type of\na variable by declaring it with the <code>var</code> keyword.</p>\n<p>While it is not always possible or cleaner to use this new way of declaring a variable, when the type on the left is the same as the one on the\nright in an assignment, using the <code>var</code> will result in a more concise code.</p>\n<p>This rule reports an issue when the expected type of the variable is the same as the returned type of assigned expression and the type can be\neasily inferred by the reader, either when the type is already mentioned in the name or the initializer, or when the expression is\nself-explanatory.</p>\n<h3>Noncompliant code example</h3>\n<pre>\nMyClass myClass = new MyClass();\n\nint i = 10; // Type is self-explanatory\n\nMyClass something = MyClass.getMyClass(); // Type is already mentioned in the initializer\n\nMyClass myClass = get(); // Type is already mentioned in the name\n</pre>\n<h3>Compliant solution</h3>\n<pre>\nvar myClass = new MyClass();\n\nvar i = 10;\n\nvar something = MyClass.getMyClass();\n\nvar myClass = get();\n</pre>",
    "howToFix": "",
    "moreInfo": "<ul>\n  <li> <a href=\"https://openjdk.java.net/jeps/286\">JEP 286: Local-Variable Type Inference</a> </li>\n</ul>",
    "status": "READY",
    "name_ko": "지역 변수 타입 추론을 사용해야 합니다",
    "why_ko": "<p>Java 10에서 <a href=\"https://openjdk.java.net/jeps/286\">지역 변수 타입 추론</a>이 도입되었습니다. <code>var</code> 키워드로 선언하여 변수의 예상 타입을 생략할 수 있습니다.</p>\n<p>이 새로운 변수 선언 방식을 사용하는 것이 항상 가능하거나 더 깔끔한 것은 아니지만, 할당에서 왼쪽의 타입이 오른쪽의 타입과 동일할 때 <code>var</code>를 사용하면 더 간결한 코드가 됩니다.</p>\n<p>이 규칙은 변수의 예상 타입이 할당된 표현식의 반환 타입과 동일하고 타입이 이름이나 초기화자에 이미 언급되어 있거나 표현식이 자명할 때 독자가 쉽게 타입을 추론할 수 있을 때 문제를 보고합니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\nMyClass myClass = new MyClass();\n\nint i = 10; // 타입이 자명함\n\nMyClass something = MyClass.getMyClass(); // 타입이 이미 초기화자에 언급됨\n\nMyClass myClass = get(); // 타입이 이미 이름에 언급됨\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre>\nvar myClass = new MyClass();\n\nvar i = 10;\n\nvar something = MyClass.getMyClass();\n\nvar myClass = get();\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": "<ul>\n  <li> <a href=\"https://openjdk.java.net/jeps/286\">JEP 286: 지역 변수 타입 추론</a> </li>\n</ul>"
  },
  {
    "id": "S3010",
    "key": "java:S3010",
    "name": "Static fields should not be updated in constructors",
    "type": "code-smell",
    "severity": "major",
    "tags": [],
    "why": "<p>Assigning a value to a <code>static</code> field in a constructor could cause unreliable behavior at runtime since it will change the value for all\ninstances of the class.</p>\n<p>Instead remove the field's <code>static</code> modifier, or initialize it statically.</p>\n<h3>Noncompliant code example</h3>\n<pre>\npublic class Person {\n  static Date dateOfBirth;\n  static int expectedFingers;\n\n  public Person(date birthday) {\n    dateOfBirth = birthday;  // Noncompliant; now everyone has this birthday\n    expectedFingers = 10;  // Noncompliant\n  }\n}\n</pre>\n<h3>Compliant solution</h3>\n<pre>\npublic class Person {\n  Date dateOfBirth;\n  static int expectedFingers = 10;\n\n  public Person(date birthday) {\n    dateOfBirth = birthday;\n  }\n}\n</pre>",
    "howToFix": "",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "생성자에서 static 필드를 업데이트하면 안 됩니다",
    "why_ko": "<p>생성자에서 <code>static</code> 필드에 값을 할당하면 클래스의 모든 인스턴스에 대한 값이 변경되므로 런타임에 신뢰할 수 없는 동작이 발생할 수 있습니다.</p>\n<p>대신 필드의 <code>static</code> 한정자를 제거하거나 정적으로 초기화하세요.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\npublic class Person {\n  static Date dateOfBirth;\n  static int expectedFingers;\n\n  public Person(date birthday) {\n    dateOfBirth = birthday;  // 규칙 위반; 이제 모든 사람이 이 생일을 갖습니다\n    expectedFingers = 10;  // 규칙 위반\n  }\n}\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre>\npublic class Person {\n  Date dateOfBirth;\n  static int expectedFingers = 10;\n\n  public Person(date birthday) {\n    dateOfBirth = birthday;\n  }\n}\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": ""
  },
  {
    "id": "S1168",
    "key": "java:S1168",
    "name": "Empty arrays and collections should be returned instead of null",
    "type": "code-smell",
    "severity": "major",
    "tags": [
      "cert"
    ],
    "why": "<p>Returning <code>null</code> instead of an actual array, collection or map forces callers of the method to explicitly test for nullity, making them\nmore complex and less readable.</p>\n<p>Moreover, in many cases, <code>null</code> is used as a synonym for empty.</p>\n<h3>Noncompliant code example</h3>\n<pre>\npublic static List&lt;Result&gt; getAllResults() {\n  return null;                             // Noncompliant\n}\n\npublic static Result[] getResults() {\n  return null;                             // Noncompliant\n}\n\npublic static Map&lt;String, Object&gt; getValues() {\n  return null;                             // Noncompliant\n}\n\npublic static void main(String[] args) {\n  Result[] results = getResults();\n  if (results != null) {                   // Nullity test required to prevent NPE\n    for (Result result: results) {\n      /* ... */\n    }\n  }\n\n  List&lt;Result&gt; allResults = getAllResults();\n  if (allResults != null) {                // Nullity test required to prevent NPE\n    for (Result result: allResults) {\n      /* ... */\n    }\n  }\n\n  Map&lt;String, Object&gt; values = getValues();\n  if (values != null) {                   // Nullity test required to prevent NPE\n    values.forEach((k, v) -&gt; doSomething(k, v));\n  }\n}\n</pre>\n<h3>Compliant solution</h3>\n<pre>\npublic static List&lt;Result&gt; getAllResults() {\n  return Collections.emptyList();          // Compliant\n}\n\npublic static Result[] getResults() {\n  return new Result[0];                    // Compliant\n}\n\npublic static Map&lt;String, Object&gt; getValues() {\n  return Collections.emptyMap();           // Compliant\n}\n\npublic static void main(String[] args) {\n  for (Result result: getAllResults()) {\n    /* ... */\n  }\n\n  for (Result result: getResults()) {\n    /* ... */\n  }\n\n  getValues().forEach((k, v) -&gt; doSomething(k, v));\n}\n</pre>",
    "howToFix": "",
    "moreInfo": "<ul>\n  <li> <a href=\"https://wiki.sei.cmu.edu/confluence/x/aNYxBQ\">CERT, MSC19-C.</a> - For functions that return an array, prefer returning an empty array\n  over a null value </li>\n  <li> <a href=\"https://wiki.sei.cmu.edu/confluence/x/JzZGBQ\">CERT, MET55-J.</a> - Return an empty array or collection instead of a null value for\n  methods that return an array or collection </li>\n</ul>",
    "status": "READY",
    "name_ko": "null 대신 빈 배열이나 컬렉션을 반환해야 합니다",
    "why_ko": "<p>실제 배열, 컬렉션 또는 맵 대신 <code>null</code>을 반환하면 메서드 호출자가 명시적으로 null 여부를 테스트해야 하므로 더 복잡하고 가독성이 떨어집니다.</p>\n<p>또한 많은 경우 <code>null</code>은 비어 있음의 동의어로 사용됩니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\npublic static List&lt;Result&gt; getAllResults() {\n  return null;                             // 규칙 위반\n}\n\npublic static Result[] getResults() {\n  return null;                             // 규칙 위반\n}\n\npublic static Map&lt;String, Object&gt; getValues() {\n  return null;                             // 규칙 위반\n}\n\npublic static void main(String[] args) {\n  Result[] results = getResults();\n  if (results != null) {                   // NPE 방지를 위해 null 테스트 필요\n    for (Result result: results) {\n      /* ... */\n    }\n  }\n\n  List&lt;Result&gt; allResults = getAllResults();\n  if (allResults != null) {                // NPE 방지를 위해 null 테스트 필요\n    for (Result result: allResults) {\n      /* ... */\n    }\n  }\n\n  Map&lt;String, Object&gt; values = getValues();\n  if (values != null) {                   // NPE 방지를 위해 null 테스트 필요\n    values.forEach((k, v) -&gt; doSomething(k, v));\n  }\n}\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre>\npublic static List&lt;Result&gt; getAllResults() {\n  return Collections.emptyList();          // 규칙 준수\n}\n\npublic static Result[] getResults() {\n  return new Result[0];                    // 규칙 준수\n}\n\npublic static Map&lt;String, Object&gt; getValues() {\n  return Collections.emptyMap();           // 규칙 준수\n}\n\npublic static void main(String[] args) {\n  for (Result result: getAllResults()) {\n    /* ... */\n  }\n\n  for (Result result: getResults()) {\n    /* ... */\n  }\n\n  getValues().forEach((k, v) -&gt; doSomething(k, v));\n}\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": "<ul>\n  <li> <a href=\"https://wiki.sei.cmu.edu/confluence/x/aNYxBQ\">CERT, MSC19-C.</a> - 배열을 반환하는 함수의 경우 null 값보다 빈 배열을 반환하는 것이 좋습니다 </li>\n  <li> <a href=\"https://wiki.sei.cmu.edu/confluence/x/JzZGBQ\">CERT, MET55-J.</a> - 배열이나 컬렉션을 반환하는 메서드의 경우 null 값 대신 빈 배열이나 컬렉션을 반환하세요 </li>\n</ul>"
  },
  {
    "id": "S6068",
    "key": "java:S6068",
    "name": "Call to Mockito method \"verify\", \"when\" or \"given\" should be simplified",
    "type": "code-smell",
    "severity": "minor",
    "tags": [
      "tests",
      "mockito",
      "clumsy"
    ],
    "why": "<p>Mockito provides <em>argument matchers</em> for flexibly stubbing or verifying method calls.</p>\n<p><code>Mockito.verify()</code>, <code>Mockito.when()</code>, <code>Stubber.when()</code> and <code>BDDMockito.given()</code> each have overloads\nwith and without argument matchers.</p>\n<p>However, the default matching behavior (i.e. without argument matchers) uses <code>equals()</code>. If only the matcher\n<code>org.mockito.ArgumentMatchers.eq()</code> is used, the call is equivalent to the call without matchers, i.e. the <code>eq()</code> is not\nnecessary and can be omitted. The resulting code is shorter and easier to read.</p>\n<h3>Noncompliant code example</h3>\n<pre>\n@Test\npublic void myTest() {\n  given(foo.bar(eq(v1), eq(v2), eq(v3))).willReturn(null);   // Noncompliant\n  when(foo.baz(eq(v4), eq(v5))).thenReturn(\"foo\");   // Noncompliant\n  doThrow(new RuntimeException()).when(foo).quux(eq(42));    // Noncompliant\n  verify(foo).bar(eq(v1), eq(v2), eq(v3));   // Noncompliant\n}\n</pre>\n<h3>Compliant solution</h3>\n<pre>\n@Test\npublic void myTest() {\n  given(foo.bar(v1, v2, v3)).willReturn(null);\n  when(foo.baz(v4, v5)).thenReturn(\"foo\");\n  doThrow(new RuntimeException()).when(foo).quux(42);\n  verify(foo).bar(v1, v2, v3);\n}\n</pre>",
    "howToFix": "",
    "moreInfo": "<ul>\n  <li> <a href=\"https://javadoc.io/doc/org.mockito/mockito-core/latest/org/mockito/Mockito.html#argument_matchers\">Mockito documentation</a> -\n  argument matchers </li>\n  <li> <a href='/coding_rules#rule_key=java%3AS6073'>S6073</a> - Mockito argument matchers should be used on all parameters </li>\n</ul>",
    "status": "READY",
    "name_ko": "Mockito 메서드 \"verify\", \"when\" 또는 \"given\" 호출은 단순화해야 합니다",
    "why_ko": "<p>Mockito는 메서드 호출을 유연하게 스텁하거나 검증하기 위한 <em>argument matcher</em>를 제공합니다.</p>\n<p><code>Mockito.verify()</code>, <code>Mockito.when()</code>, <code>Stubber.when()</code>, <code>BDDMockito.given()</code>은 각각 argument matcher가 있는 오버로드와 없는 오버로드가 있습니다.</p>\n<p>그러나 기본 매칭 동작(즉, argument matcher 없이)은 <code>equals()</code>를 사용합니다. <code>org.mockito.ArgumentMatchers.eq()</code> matcher만 사용하면 matcher 없이 호출하는 것과 동일합니다. 즉, <code>eq()</code>는 필요하지 않으며 생략할 수 있습니다. 결과 코드는 더 짧고 읽기 쉬워집니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\n@Test\npublic void myTest() {\n  given(foo.bar(eq(v1), eq(v2), eq(v3))).willReturn(null);   // 규칙 위반\n  when(foo.baz(eq(v4), eq(v5))).thenReturn(\"foo\");   // 규칙 위반\n  doThrow(new RuntimeException()).when(foo).quux(eq(42));    // 규칙 위반\n  verify(foo).bar(eq(v1), eq(v2), eq(v3));   // 규칙 위반\n}\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre>\n@Test\npublic void myTest() {\n  given(foo.bar(v1, v2, v3)).willReturn(null);\n  when(foo.baz(v4, v5)).thenReturn(\"foo\");\n  doThrow(new RuntimeException()).when(foo).quux(42);\n  verify(foo).bar(v1, v2, v3);\n}\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": "<ul>\n  <li> <a href=\"https://javadoc.io/doc/org.mockito/mockito-core/latest/org/mockito/Mockito.html#argument_matchers\">Mockito 문서</a> - argument matcher </li>\n  <li> <a href='/coding_rules#rule_key=java%3AS6073'>S6073</a> - Mockito argument matcher는 모든 매개변수에 사용해야 합니다 </li>\n</ul>"
  },
  {
    "id": "S1607",
    "key": "java:S1607",
    "name": "JUnit4 @Ignored and JUnit5 @Disabled annotations should be used to disable tests and should provide a rationale",
    "type": "code-smell",
    "severity": "major",
    "tags": [
      "junit",
      "tests",
      "bad-practice",
      "suspicious",
      "confusing"
    ],
    "why": "<p>When a test fails due, for example, to infrastructure issues, you might want to ignore it temporarily. But without some kind of notation about why\nthe test is being ignored, it may never be reactivated. Such tests are difficult to address without comprehensive knowledge of the project, and end up\npolluting their projects.</p>\n<p>This rule raises an issue for each ignored test that does not have any comment about why it is being skipped.</p>\n<ul>\n  <li> For Junit4, this rule targets the @Ignore annotation. </li>\n  <li> For Junit5, this rule targets the @Disabled annotation. </li>\n  <li> Cases where assumeTrue(false) or assumeFalse(true) are used to skip tests are targeted as well. </li>\n</ul>\n<h3>Noncompliant code example</h3>\n<pre>\n@Ignore  // Noncompliant\n@Test\npublic void testDoTheThing() {\n  // ...\n</pre>\n<p>or</p>\n<pre>\n@Test\npublic void testDoTheThing() {\n  Assume.assumeFalse(true); // Noncompliant\n  // ...\n</pre>\n<h3>Compliant solution</h3>\n<pre>\n@Test\n@Ignore(\"See Ticket #1234\")\npublic void testDoTheThing() {\n  // ...\n</pre>",
    "howToFix": "",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "JUnit4 @Ignored와 JUnit5 @Disabled 어노테이션으로 테스트를 비활성화할 때는 사유를 명시해야 합니다",
    "why_ko": "<p>예를 들어 인프라 문제로 인해 테스트가 실패하면 일시적으로 무시하고 싶을 수 있습니다. 그러나 테스트를 무시하는 이유에 대한 어떤 종류의 표기도 없으면 다시 활성화되지 않을 수 있습니다. 이러한 테스트는 프로젝트에 대한 포괄적인 지식 없이는 처리하기 어렵고 결국 프로젝트를 오염시킵니다.</p>\n<p>이 규칙은 건너뛰는 이유에 대한 주석이 없는 각 무시된 테스트에 대해 이슈를 발생시킵니다.</p>\n<ul>\n  <li> JUnit4의 경우 이 규칙은 @Ignore 어노테이션을 대상으로 합니다. </li>\n  <li> JUnit5의 경우 이 규칙은 @Disabled 어노테이션을 대상으로 합니다. </li>\n  <li> assumeTrue(false) 또는 assumeFalse(true)를 사용하여 테스트를 건너뛰는 경우도 대상입니다. </li>\n</ul>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\n@Ignore  // 규칙 위반\n@Test\npublic void testDoTheThing() {\n  // ...\n</pre>\n<p>또는</p>\n<pre>\n@Test\npublic void testDoTheThing() {\n  Assume.assumeFalse(true); // 규칙 위반\n  // ...\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre>\n@Test\n@Ignore(\"티켓 #1234 참조\")\npublic void testDoTheThing() {\n  // ...\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": ""
  },
  {
    "id": "S1312",
    "key": "java:S1312",
    "name": "Loggers should be \"private static final\" and should share a naming convention",
    "type": "code-smell",
    "severity": "minor",
    "tags": [
      "convention",
      "logging"
    ],
    "why": "<p>Regardless of the logging framework in use (logback, log4j, commons-logging, java.util.logging, …​), loggers should be:</p>\n<ul>\n  <li> <code>private</code>: never be accessible outside of its parent class. If another class needs to log something, it should instantiate its own\n  logger. </li>\n  <li> <code>static</code>: not be dependent on an instance of a class (an object). When logging something, contextual information can of course be\n  provided in the messages but the logger should be created at class level to prevent creating a logger along with each object. </li>\n  <li> <code>final</code>: be created once and only once per class. </li>\n</ul>\n<h3>Noncompliant code example</h3>\n<p>With a default regular expression of <code>LOG(?:GER)?</code>:</p>\n<pre>\npublic Logger logger = LoggerFactory.getLogger(Foo.class);  // Noncompliant\n</pre>\n<h3>Compliant solution</h3>\n<pre>\nprivate static final Logger LOGGER = LoggerFactory.getLogger(Foo.class);\n</pre>\n<h3>Exceptions</h3>\n<p>Variables of type <code>org.apache.maven.plugin.logging.Log</code> are ignored.</p>",
    "howToFix": "",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "Logger는 \"private static final\"이어야 하며 명명 규칙을 공유해야 합니다",
    "why_ko": "<p>사용 중인 로깅 프레임워크(logback, log4j, commons-logging, java.util.logging 등)에 관계없이 logger는 다음과 같아야 합니다:</p>\n<ul>\n  <li> <code>private</code>: 부모 클래스 외부에서 절대 접근할 수 없어야 합니다. 다른 클래스에서 로그를 기록해야 하는 경우 자체 logger를 인스턴스화해야 합니다. </li>\n  <li> <code>static</code>: 클래스의 인스턴스(객체)에 의존하지 않아야 합니다. 로그를 기록할 때 물론 메시지에 상황 정보를 제공할 수 있지만, 각 객체와 함께 logger를 생성하는 것을 방지하기 위해 logger는 클래스 수준에서 생성되어야 합니다. </li>\n  <li> <code>final</code>: 클래스당 한 번만 생성되어야 합니다. </li>\n</ul>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<p>기본 정규 표현식 <code>LOG(?:GER)?</code>의 경우:</p>\n<pre>\npublic Logger logger = LoggerFactory.getLogger(Foo.class);  // 규칙 위반\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre>\nprivate static final Logger LOGGER = LoggerFactory.getLogger(Foo.class);\n</pre>\n<h3>예외</h3>\n<p><code>org.apache.maven.plugin.logging.Log</code> 타입의 변수는 무시됩니다.</p>",
    "howToFix_ko": "",
    "moreInfo_ko": ""
  },
  {
    "id": "S1191",
    "key": "java:S1191",
    "name": "Classes from \"sun.*\" packages should not be used",
    "type": "code-smell",
    "severity": "major",
    "tags": [
      "lock-in",
      "pitfall"
    ],
    "why": "<p>The classes in the <code>sun.*</code> packages are not part of the official Java API and are not intended for public use. They are internal\nimplementation details specific to the Oracle JDK (Java Development Kit). Therefore, their availability, behavior, or compatibility is not guaranteed\nacross different Java implementations or versions.</p>\n<p>Since these classes are not part of the official Java API, they usually lack proper documentation and support. Finding comprehensive and up-to-date\ninformation about their usage, functionality, and potential limitations can be challenging. This lack of documentation can make it difficult to\nunderstand how to use these classes correctly.</p>\n<p>Classes in the <code>sun.*</code> packages are often platform-dependent and can vary between different operating systems or Java Virtual Machine\n(JVM) implementations. Relying on these classes may lead to code that works on one platform but fails on others, limiting your code's portability and\ncross-platform compatibility.</p>\n<h3>Noncompliant code example</h3>\n<pre>\nimport sun.misc.BASE64Encoder; // Noncompliant\n</pre>",
    "howToFix": "",
    "moreInfo": "<h3>Documentation</h3>\n<ul>\n  <li> <a href=\"https://www.oracle.com/java/technologies/faq-sun-packages.html\">Sun Packages</a> </li>\n</ul>",
    "status": "READY",
    "name_ko": "\"sun.*\" 패키지의 클래스는 사용하면 안 됩니다",
    "why_ko": "<p><code>sun.*</code> 패키지의 클래스는 공식 Java API의 일부가 아니며 공개 사용을 위한 것이 아닙니다. 이들은 Oracle JDK(Java Development Kit)에 특화된 내부 구현 세부 사항입니다. 따라서 다른 Java 구현이나 버전에서 가용성, 동작 또는 호환성이 보장되지 않습니다.</p>\n<p>이러한 클래스가 공식 Java API의 일부가 아니기 때문에 일반적으로 적절한 문서화와 지원이 부족합니다. 사용법, 기능 및 잠재적 제한 사항에 대한 포괄적이고 최신 정보를 찾는 것이 어려울 수 있습니다. 이러한 문서화 부족으로 인해 이러한 클래스를 올바르게 사용하는 방법을 이해하기 어려울 수 있습니다.</p>\n<p><code>sun.*</code> 패키지의 클래스는 종종 플랫폼에 의존적이며 다른 운영 체제나 JVM(Java Virtual Machine) 구현에 따라 다를 수 있습니다. 이러한 클래스에 의존하면 한 플랫폼에서는 작동하지만 다른 플랫폼에서는 실패하는 코드가 될 수 있으며, 코드의 이식성과 크로스 플랫폼 호환성이 제한됩니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\nimport sun.misc.BASE64Encoder; // 규칙 위반\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": "<h3>문서</h3>\n<ul>\n  <li> <a href=\"https://www.oracle.com/java/technologies/faq-sun-packages.html\">Sun 패키지</a> </li>\n</ul>"
  },
  {
    "id": "S6204",
    "key": "java:S6204",
    "name": "\"Stream.toList()\" method should be used instead of \"collectors\" when unmodifiable list needed",
    "type": "code-smell",
    "severity": "major",
    "tags": [
      "java16"
    ],
    "why": "<p>In Java 8 <code>Streams</code> were introduced to support chaining of operations over collections in a functional style. The most common way to\nsave a result of such chains is to save them to some collection (usually <code>List</code>). To do so there is a terminal method <code>collect</code>\nthat can be used with a library of <code>Collectors</code>. The key problem is that <code>.collect(Collectors.toList())</code> actually returns a\nmutable kind of <code>List</code> while in the majority of cases unmodifiable lists are preferred. In Java 10 a new collector appeared to return an\nunmodifiable list: <code>toUnmodifiableList()</code>. This does the trick but results in verbose code. Since Java 16 there is now a better variant to\nproduce an unmodifiable list directly from a stream: <code>Stream.toList()</code>.</p>\n<p>This rule raises an issue when \"collect\" is used to create a list from a stream.</p>\n<h3>Noncompliant code example</h3>\n<pre>\nList&lt;String&gt; list1 = Stream.of(\"A\", \"B\", \"C\")\n                           .collect(Collectors.toList()); // Noncompliant\n\nList&lt;String&gt; list2 = Stream.of(\"A\", \"B\", \"C\")\n                           .collect(Collectors.toUnmodifiableList()); // Noncompliant\n</pre>\n<h3>Compliant solution</h3>\n<pre>\nList&lt;String&gt; list1 = Stream.of(\"A\", \"B\", \"C\").toList(); // Compliant\n\nList&lt;String&gt; list2 = Stream.of(\"A\", \"B\", \"C\")\n                           .collect(Collectors.toList()); // Compliant, the list2 needs to be mutable\n\nlist2.add(\"X\");\n</pre>",
    "howToFix": "",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "불변 리스트가 필요할 때 \"collectors\" 대신 \"Stream.toList()\" 메서드를 사용해야 합니다",
    "why_ko": "<p>Java 8에서 <code>Streams</code>가 도입되어 함수형 스타일로 컬렉션에 대한 연산 체이닝을 지원합니다. 이러한 체인의 결과를 저장하는 가장 일반적인 방법은 컬렉션(보통 <code>List</code>)에 저장하는 것입니다. 이를 위해 <code>Collectors</code> 라이브러리와 함께 사용할 수 있는 터미널 메서드 <code>collect</code>가 있습니다. 핵심 문제는 <code>.collect(Collectors.toList())</code>가 실제로 가변 <code>List</code>를 반환하지만 대부분의 경우 불변 리스트가 선호된다는 것입니다. Java 10에서 불변 리스트를 반환하는 새 collector가 등장했습니다: <code>toUnmodifiableList()</code>. 이것은 문제를 해결하지만 코드가 장황해집니다. Java 16부터는 스트림에서 직접 불변 리스트를 생성하는 더 나은 변형이 있습니다: <code>Stream.toList()</code>.</p>\n<p>이 규칙은 스트림에서 리스트를 생성하기 위해 \"collect\"가 사용될 때 문제를 보고합니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\nList&lt;String&gt; list1 = Stream.of(\"A\", \"B\", \"C\")\n                           .collect(Collectors.toList()); // 규칙 위반\n\nList&lt;String&gt; list2 = Stream.of(\"A\", \"B\", \"C\")\n                           .collect(Collectors.toUnmodifiableList()); // 규칙 위반\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre>\nList&lt;String&gt; list1 = Stream.of(\"A\", \"B\", \"C\").toList(); // 규칙 준수\n\nList&lt;String&gt; list2 = Stream.of(\"A\", \"B\", \"C\")\n                           .collect(Collectors.toList()); // 규칙 준수, list2는 가변이어야 함\n\nlist2.add(\"X\");\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": ""
  },
  {
    "id": "S5994",
    "key": "java:S5994",
    "name": "Regex patterns following a possessive quantifier should not always fail",
    "type": "bug",
    "severity": "critical",
    "tags": [
      "regex"
    ],
    "why": "<p>Possessive quantifiers in Regex patterns like below improve performance by eliminating needless backtracking:</p>\n<pre>\n?+ , *+ , ++ , {n}+ , {n,}+ , {n,m}+\n</pre>\n<p>But because possessive quantifiers do not keep backtracking positions and never give back, the following sub-patterns should not match only similar\ncharacters. Otherwise, possessive quantifiers consume all characters that could have matched the following sub-patterns and nothing remains for the\nfollowing sub-patterns.</p>\n<h3>Noncompliant code example</h3>\n<pre>\nPattern pattern1 = Pattern.compile(\"a++abc\");       // Noncompliant, the second 'a' never matches\nPattern pattern2 = Pattern.compile(\"\\\\d*+[02468]\"); // Noncompliant, the sub-pattern \"[02468]\" never matches\n</pre>\n<h3>Compliant solution</h3>\n<pre>\nPattern pattern1 = Pattern.compile(\"aa++bc\");            // Compliant, for example it can match \"aaaabc\"\nPattern pattern2 = Pattern.compile(\"\\\\d*+(?&lt;=[02468])\"); // Compliant, for example it can match an even number like \"1234\"\n</pre>",
    "howToFix": "",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "소유 수량자 뒤의 정규식 패턴이 항상 실패하면 안 됩니다",
    "why_ko": "<p>아래와 같은 정규식 패턴의 소유 수량자는 불필요한 역추적을 제거하여 성능을 향상시킵니다:</p>\n<pre>\n?+ , *+ , ++ , {n}+ , {n,}+ , {n,m}+\n</pre>\n<p>그러나 소유 수량자는 역추적 위치를 유지하지 않고 절대 반환하지 않기 때문에 뒤따르는 하위 패턴은 유사한 문자만 일치시키면 안 됩니다. 그렇지 않으면 소유 수량자가 뒤따르는 하위 패턴과 일치할 수 있는 모든 문자를 소비하고 뒤따르는 하위 패턴에 아무것도 남지 않습니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\nPattern pattern1 = Pattern.compile(\"a++abc\");       // 규칙 위반, 두 번째 'a'는 절대 일치하지 않음\nPattern pattern2 = Pattern.compile(\"\\\\d*+[02468]\"); // 규칙 위반, 하위 패턴 \"[02468]\"은 절대 일치하지 않음\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre>\nPattern pattern1 = Pattern.compile(\"aa++bc\");            // 규칙 준수, 예를 들어 \"aaaabc\"와 일치 가능\nPattern pattern2 = Pattern.compile(\"\\\\d*+(?&lt;=[02468])\"); // 규칙 준수, 예를 들어 \"1234\"와 같은 짝수와 일치 가능\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": ""
  },
  {
    "id": "S1200",
    "key": "java:S1200",
    "name": "Classes should not be coupled to too many other classes",
    "type": "code-smell",
    "severity": "major",
    "tags": [
      "brain-overload"
    ],
    "why": "<p>According to the Single Responsibility Principle, introduced by Robert C. Martin in his book \"Principles of Object Oriented Design\", a class should\nhave only one responsibility:</p>\n<blockquote>\n  <p>If a class has more than one responsibility, then the responsibilities become coupled.</p>\n  <p>Changes to one responsibility may impair or inhibit the class' ability to meet the others.</p>\n  <p>This kind of coupling leads to fragile designs that break in unexpected ways when changed.</p>\n</blockquote>\n<p>Classes which rely on many other classes tend to aggregate too many responsibilities and should be split into several smaller ones.</p>\n<p>Nested classes dependencies are not counted as dependencies of the outer class.</p>\n<h3>Noncompliant code example</h3>\n<p>With a threshold of 5:</p>\n<pre>\nclass Foo {                        // Noncompliant - Foo depends on too many classes: T1, T2, T3, T4, T5, T6 and T7\n  T1 a1;                           // Foo is coupled to T1\n  T2 a2;                           // Foo is coupled to T2\n  T3 a3;                           // Foo is coupled to T3\n\n  public T4 compute(T5 a, T6 b) {  // Foo is coupled to T4, T5 and T6\n    T7 result = a.getResult(b);    // Foo is coupled to T7\n    return result;\n  }\n\n  public static class Bar {        // Compliant - Bar depends on 2 classes: T8 and T9\n    T8 a8;\n    T9 a9;\n  }\n}\n</pre>",
    "howToFix": "",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "클래스가 너무 많은 다른 클래스와 결합되면 안 됩니다",
    "why_ko": "<p>Robert C. Martin의 저서 \"Principles of Object Oriented Design\"에서 소개된 단일 책임 원칙에 따르면, 클래스는 하나의 책임만 가져야 합니다:</p>\n<blockquote>\n  <p>클래스가 둘 이상의 책임을 가지면 책임들이 결합됩니다.</p>\n  <p>한 책임에 대한 변경이 클래스가 다른 책임을 충족하는 능력을 손상시키거나 억제할 수 있습니다.</p>\n  <p>이러한 종류의 결합은 변경될 때 예상치 못한 방식으로 깨지는 취약한 설계로 이어집니다.</p>\n</blockquote>\n<p>많은 다른 클래스에 의존하는 클래스는 너무 많은 책임을 모으는 경향이 있으며 여러 개의 더 작은 클래스로 분할되어야 합니다.</p>\n<p>중첩 클래스 의존성은 외부 클래스의 의존성으로 계산되지 않습니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<p>임계값 5의 경우:</p>\n<pre>\nclass Foo {                        // 규칙 위반 - Foo가 너무 많은 클래스에 의존함: T1, T2, T3, T4, T5, T6, T7\n  T1 a1;                           // Foo가 T1과 결합됨\n  T2 a2;                           // Foo가 T2와 결합됨\n  T3 a3;                           // Foo가 T3과 결합됨\n\n  public T4 compute(T5 a, T6 b) {  // Foo가 T4, T5, T6과 결합됨\n    T7 result = a.getResult(b);    // Foo가 T7과 결합됨\n    return result;\n  }\n\n  public static class Bar {        // 규칙 준수 - Bar는 2개 클래스에 의존함: T8과 T9\n    T8 a8;\n    T9 a9;\n  }\n}\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": ""
  },
  {
    "id": "S2139",
    "key": "java:S2139",
    "name": "Exceptions should be either logged or rethrown but not both",
    "type": "code-smell",
    "severity": "major",
    "tags": [
      "error-handling",
      "logging"
    ],
    "why": "<p>In applications where the accepted practice is to log an <code>Exception</code> and then rethrow it, you end up with miles-long logs that contain\nmultiple instances of the same exception. In multi-threaded applications debugging this type of log can be particularly hellish because messages from\nother threads will be interwoven with the repetitions of the logged-and-thrown <code>Exception</code>. Instead, exceptions should be either logged or\nrethrown, not both.</p>\n<h3>Noncompliant code example</h3>\n<pre>\ncatch (SQLException e) {\n  ...\n  LOGGER.log(Level.ERROR,  contextInfo, e);\n  throw new MySQLException(contextInfo, e);\n}\n</pre>\n<h3>Compliant solution</h3>\n<pre>\ncatch (SQLException e) {\n  ...\n  throw new MySQLException(contextInfo, e);\n}\n</pre>\n<p>or</p>\n<pre>\ncatch (SQLException e) {\n  ...\n  LOGGER.log(Level.ERROR,  contextInfo, e);\n  // handle exception...\n}\n</pre>",
    "howToFix": "",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "Exception은 로깅하거나 다시 던지거나 둘 중 하나만 해야 합니다",
    "why_ko": "<p><code>Exception</code>을 로깅한 다음 다시 던지는 것이 허용된 관행인 애플리케이션에서는 동일한 예외의 여러 인스턴스를 포함하는 매우 긴 로그가 생성됩니다. 멀티스레드 애플리케이션에서 이러한 유형의 로그를 디버깅하는 것은 다른 스레드의 메시지가 로깅되고 던져진 <code>Exception</code>의 반복과 섞이기 때문에 특히 어려울 수 있습니다. 대신 예외는 로깅하거나 다시 던지거나 둘 중 하나만 해야 합니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\ncatch (SQLException e) {\n  ...\n  LOGGER.log(Level.ERROR,  contextInfo, e);\n  throw new MySQLException(contextInfo, e);\n}\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre>\ncatch (SQLException e) {\n  ...\n  throw new MySQLException(contextInfo, e);\n}\n</pre>\n<p>또는</p>\n<pre>\ncatch (SQLException e) {\n  ...\n  LOGGER.log(Level.ERROR,  contextInfo, e);\n  // 예외 처리...\n}\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": ""
  },
  {
    "id": "S2093",
    "key": "java:S2093",
    "name": "Try-with-resources should be used",
    "type": "code-smell",
    "severity": "critical",
    "tags": [
      "java8",
      "cert",
      "pitfall"
    ],
    "why": "<p>Many resources in Java need be closed after they have been used. If they are not, the garbage collector cannot reclaim the resources' memory, and\nthey are still considered to be in use by the operating system. Such resources are considered to be leaked, which can lead to performance issues.</p>\n<p>Java 7 introduced the try-with-resources statement, which guarantees that the resource in question will be closed.</p>\n<pre>\ntry (InputStream input = Files.newInputStream(path)) {\n  // \"input\" will be closed after the execution of this block\n}\n</pre>\n<p>This syntax is safer than the traditional method using <code>try</code>, <code>catch</code>, and <code>finally</code> and hence should be\npreferred.</p>\n<p>This rule raises an issue if a closeable resources is not opened using a try-with-resources statement.</p>\n<p>This rule is automatically disabled when the project's <code>sonar.java.source</code> is lower than <code>7</code> as the close-with-resources\nstatement was unavailable prior to Java 7.</p>",
    "howToFix": "<p>Use the try-with-resources syntax by moving the <code>Closable</code> variable declarations after the <code>try</code> keyword surrounded by\nparentheses and separated by <code>;</code>:</p>\n<pre>\ntry (/* resources declarations */) {\n  // resources usage ...\n}\n</pre>\n\n<h4>Noncompliant code example</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\nFileReader fr = null;\nBufferedReader br = null;\n\ntry { // Noncompliant, the FileReader and BufferedReader are instantiated without try-with-resources\n  fr = new FileReader(fileName);\n  br = new BufferedReader(fr);\n  return br.readLine();\n} catch (...) {\n  ...\n} finally {\n\n  if (br != null) { // br has to be closed manually\n    try {\n      br.close();\n    } catch(IOException e){...}\n  }\n\n  if (fr != null ) { // fr has to be closed manually\n    try {\n      br.close();\n    } catch(IOException e){...}\n  }\n\n}\n</pre>\n<h4>Compliant solution</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\ntry ( // Compliant, all resources are instantiated within a try-with-resources statement and hence automatically closed after use\n    FileReader fr = new FileReader(fileName);\n    BufferedReader br = new BufferedReader(fr)\n  ) {\n  return br.readLine();\n}\ncatch (...) {}\n</pre>",
    "moreInfo": "<ul>\n  <li> <a href=\"https://wiki.sei.cmu.edu/confluence/x/6DZGBQ\">CERT, ERR54-J.</a> - Use a try-with-resources statement to safely handle closeable\n  resources </li>\n  <li> <a href=\"https://docs.oracle.com/javase/tutorial/essential/exceptions/tryResourceClose.html\">The Java™ Tutorials - The try-with-resources\n  Statement</a> </li>\n</ul>",
    "status": "READY",
    "name_ko": "Try-with-resources를 사용해야 합니다",
    "why_ko": "<p>Java의 많은 리소스는 사용 후 닫아야 합니다. 닫지 않으면 가비지 컬렉터가 리소스의 메모리를 회수할 수 없으며 운영 체제에서 여전히 사용 중인 것으로 간주됩니다. 이러한 리소스는 누수된 것으로 간주되며 성능 문제로 이어질 수 있습니다.</p>\n<p>Java 7에서는 해당 리소스가 닫히는 것을 보장하는 try-with-resources 문을 도입했습니다.</p>\n<pre>\ntry (InputStream input = Files.newInputStream(path)) {\n  // \"input\"은 이 블록 실행 후 닫힙니다\n}\n</pre>\n<p>이 구문은 <code>try</code>, <code>catch</code>, <code>finally</code>를 사용하는 전통적인 방법보다 안전하므로 선호해야 합니다.</p>\n<p>이 규칙은 닫을 수 있는 리소스가 try-with-resources 문을 사용하여 열리지 않은 경우 문제를 제기합니다.</p>\n<p>이 규칙은 프로젝트의 <code>sonar.java.source</code>가 <code>7</code>보다 낮을 때 자동으로 비활성화됩니다. try-with-resources 문은 Java 7 이전에는 사용할 수 없었기 때문입니다.</p>",
    "howToFix_ko": "<p><code>Closable</code> 변수 선언을 <code>try</code> 키워드 뒤에 괄호로 둘러싸고 <code>;</code>로 구분하여 이동함으로써 try-with-resources 구문을 사용하세요:</p>\n<pre>\ntry (/* 리소스 선언 */) {\n  // 리소스 사용 ...\n}\n</pre>\n\n<h4>규칙을 준수하지 않는 코드 예시</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\nFileReader fr = null;\nBufferedReader br = null;\n\ntry { // 규칙 위반, FileReader와 BufferedReader가 try-with-resources 없이 인스턴스화됨\n  fr = new FileReader(fileName);\n  br = new BufferedReader(fr);\n  return br.readLine();\n} catch (...) {\n  ...\n} finally {\n\n  if (br != null) { // br을 수동으로 닫아야 함\n    try {\n      br.close();\n    } catch(IOException e){...}\n  }\n\n  if (fr != null ) { // fr을 수동으로 닫아야 함\n    try {\n      br.close();\n    } catch(IOException e){...}\n  }\n\n}\n</pre>\n<h4>규칙을 준수하는 해결책</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\ntry ( // 규칙 준수, 모든 리소스가 try-with-resources 문 내에서 인스턴스화되어 사용 후 자동으로 닫힙니다\n    FileReader fr = new FileReader(fileName);\n    BufferedReader br = new BufferedReader(fr)\n  ) {\n  return br.readLine();\n}\ncatch (...) {}\n</pre>",
    "moreInfo_ko": "<ul>\n  <li> <a href=\"https://wiki.sei.cmu.edu/confluence/x/6DZGBQ\">CERT, ERR54-J.</a> - Use a try-with-resources statement to safely handle closeable resources </li>\n  <li> <a href=\"https://docs.oracle.com/javase/tutorial/essential/exceptions/tryResourceClose.html\">The Java™ Tutorials - The try-with-resources Statement</a> </li>\n</ul>"
  },
  {
    "id": "S4517",
    "key": "java:S4517",
    "name": "InputSteam.read() implementation should not return a signed byte",
    "type": "bug",
    "severity": "major",
    "tags": [],
    "why": "<p>According to the Java documentation, any implementation of the <code>InputSteam.read()</code> method is supposed to read the next byte of data from\nthe input stream. The value byte must be an <code>int</code> in the range 0 to 255. If no byte is available because the end of the stream has been\nreached, the value -1 is returned.</p>\n<p>But in Java, the <code>byte</code> primitive data type is an 8-bit signed two's complement integer. It has a minimum value of -128 and a maximum\nvalue of 127. So by contract, the implementation of an <code>InputSteam.read()</code> method should never directly return a <code>byte</code>\nprimitive data type. A conversion into an unsigned byte must be done before by applying a bitmask.</p>\n<h3>Noncompliant code example</h3>\n<pre>\n@Override\npublic int read() throws IOException {\n  if (pos == buffer.length()) {\n    return -1;\n  }\n  return buffer.getByte(pos++); // Noncompliant, a signed byte value is returned\n}\n</pre>\n<h3>Compliant solution</h3>\n<pre>\n@Override\npublic int read() throws IOException {\n  if (pos == buffer.length()) {\n    return -1;\n  }\n  return buffer.getByte(pos++) &amp; 0xFF; // The 0xFF bitmask is applied\n}\n</pre>",
    "howToFix": "",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "InputStream.read() 구현은 부호 있는 바이트를 반환하면 안 됩니다",
    "why_ko": "<p>Java 문서에 따르면 <code>InputStream.read()</code> 메서드의 모든 구현은 입력 스트림에서 다음 데이터 바이트를 읽어야 합니다. 값 바이트는 0에서 255 사이의 <code>int</code>여야 합니다. 스트림의 끝에 도달하여 바이트를 사용할 수 없는 경우 값 -1이 반환됩니다.</p>\n<p>그러나 Java에서 <code>byte</code> 원시 데이터 타입은 8비트 부호 있는 2의 보수 정수입니다. 최솟값은 -128이고 최댓값은 127입니다. 따라서 계약상 <code>InputStream.read()</code> 메서드의 구현은 <code>byte</code> 원시 데이터 타입을 직접 반환해서는 안 됩니다. 비트마스크를 적용하여 부호 없는 바이트로 변환해야 합니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\n@Override\npublic int read() throws IOException {\n  if (pos == buffer.length()) {\n    return -1;\n  }\n  return buffer.getByte(pos++); // 규칙 위반, 부호 있는 바이트 값이 반환됨\n}\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre>\n@Override\npublic int read() throws IOException {\n  if (pos == buffer.length()) {\n    return -1;\n  }\n  return buffer.getByte(pos++) &amp; 0xFF; // 0xFF 비트마스크가 적용됨\n}\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": ""
  },
  {
    "id": "S1596",
    "key": "java:S1596",
    "name": "\"Collections.EMPTY_LIST\", \"EMPTY_MAP\", and \"EMPTY_SET\" should not be used",
    "type": "code-smell",
    "severity": "minor",
    "tags": [
      "obsolete",
      "pitfall"
    ],
    "why": "<p>Generic types (types with type parameters) have been introduced into Java with language version 1.5. If type parameters are specified for a class\nor method, it is still possible to ignore them to keep backward compatibility with older code, which is called the <em>raw type</em> of the class or\ninterface.</p>\n<p>Using raw type expressions is highly discouraged because the compiler cannot perform static type checking on them. This means that the compiler\nwill not report typing errors about them at compile time, but a <code>ClassCastException</code> will be thrown during runtime.</p>\n<p>In Java 1.5, generics were also added to the Java collections API, and the data structures in <code>java.util</code>, such as <code>List</code>,\n<code>Set</code>, or <code>Map</code>, now feature type parameters. <code>Collections.EMPTY_LIST</code>, <code>Collections.EMPTY_SET</code>, and\n<code>Collections.EMPTY_MAP</code> are relics from before generics, and they return raw lists, sets, or maps, with the limitations mentioned\nabove.</p>",
    "howToFix": "<p>Use:</p>\n<ul>\n  <li> <code>Collections.emptyList()</code> instead of <code>Collections.EMPTY_LIST</code> </li>\n  <li> <code>Collections.emptySet()</code> instead of <code>Collections.EMPTY_SET</code> </li>\n  <li> <code>Collections.emptyMap()</code> instead of <code>Collections.EMPTY_MAP</code> </li>\n</ul>\n<p>In addition, there are variants of <code>Collections.empty*()</code> available also for other collection interfaces, such as\n<code>Collections.emptyIterator()</code>, <code>Collections.emptyNavigableMap()</code>, <code>Collections.emptySortedSet()</code>.</p>\n\n<h4>Noncompliant code example</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\nList&lt;String&gt; collection1 = Collections.EMPTY_LIST;     // Noncompliant, raw List\nSet&lt;Float&gt; collection2 = Collections.EMPTY_SET;        // Noncompliant, raw Set\nMap&lt;Int, String&gt; collection3 = Collections.EMPTY_MAP;  // Noncompliant, raw Map\n</pre>\n<h4>Compliant solution</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\nList&lt;String&gt; collection1 = Collections.emptyList();    // Compliant, List&lt;String&gt;\nSet&lt;Float&gt; collection2 = Collections.emptySet();       // Compliant, Set&lt;Float&gt;\nMap&lt;Int, String&gt; collection3 = Collections.emptyMap(); // Compliant, Map&lt;Int, String&gt;\n</pre>",
    "moreInfo": "<h3>Documentation</h3>\n<ul>\n  <li> <a href=\"https://docs.oracle.com/javase/8/docs/api/java/util/Collections.html\">Oracle - Java™ Platform, Standard Edition 8 API Specification,\n  Class Collections</a> </li>\n  <li> <a href=\"https://docs.oracle.com/javase/tutorial/java/generics/rawTypes.html\">Oracle - The Java™ Tutorials - Raw Types</a> </li>\n</ul>\n<h3>Articles &amp; blog posts</h3>\n<ul>\n  <li> <a href=\"https://www.baeldung.com/java-generics\">Baeldung - The Basics of Java Generics</a> </li>\n</ul>",
    "status": "READY",
    "name_ko": "\"Collections.EMPTY_LIST\", \"EMPTY_MAP\", \"EMPTY_SET\"은 사용하면 안 됩니다",
    "why_ko": "<p>제네릭 타입(타입 파라미터가 있는 타입)은 Java 버전 1.5에서 도입되었습니다. 클래스나 메서드에 타입 파라미터가 지정된 경우에도 이전 코드와의 하위 호환성을 유지하기 위해 이를 무시할 수 있으며, 이를 클래스나 인터페이스의 <em>raw 타입</em>이라고 합니다.</p>\n<p>raw 타입 표현식을 사용하는 것은 컴파일러가 정적 타입 검사를 수행할 수 없기 때문에 매우 권장되지 않습니다. 이는 컴파일러가 컴파일 시점에 타이핑 오류를 보고하지 않지만 런타임에 <code>ClassCastException</code>이 발생한다는 것을 의미합니다.</p>\n<p>Java 1.5에서는 제네릭이 Java 컬렉션 API에도 추가되었으며, <code>java.util</code>의 <code>List</code>, <code>Set</code> 또는 <code>Map</code>과 같은 데이터 구조는 이제 타입 파라미터를 지원합니다. <code>Collections.EMPTY_LIST</code>, <code>Collections.EMPTY_SET</code> 및 <code>Collections.EMPTY_MAP</code>은 제네릭 이전의 유물이며, 위에서 언급한 제한 사항이 있는 raw 리스트, 세트 또는 맵을 반환합니다.</p>",
    "howToFix_ko": "<p>다음을 사용하세요:</p>\n<ul>\n  <li> <code>Collections.EMPTY_LIST</code> 대신 <code>Collections.emptyList()</code> </li>\n  <li> <code>Collections.EMPTY_SET</code> 대신 <code>Collections.emptySet()</code> </li>\n  <li> <code>Collections.EMPTY_MAP</code> 대신 <code>Collections.emptyMap()</code> </li>\n</ul>\n<p>또한 <code>Collections.emptyIterator()</code>, <code>Collections.emptyNavigableMap()</code>, <code>Collections.emptySortedSet()</code>와 같은 다른 컬렉션 인터페이스에도 <code>Collections.empty*()</code>의 변형이 있습니다.</p>\n\n<h4>규칙을 준수하지 않는 코드 예시</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\nList&lt;String&gt; collection1 = Collections.EMPTY_LIST;     // 규칙 위반, raw List\nSet&lt;Float&gt; collection2 = Collections.EMPTY_SET;        // 규칙 위반, raw Set\nMap&lt;Int, String&gt; collection3 = Collections.EMPTY_MAP;  // 규칙 위반, raw Map\n</pre>\n<h4>규칙을 준수하는 해결책</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\nList&lt;String&gt; collection1 = Collections.emptyList();    // 규칙 준수, List&lt;String&gt;\nSet&lt;Float&gt; collection2 = Collections.emptySet();       // 규칙 준수, Set&lt;Float&gt;\nMap&lt;Int, String&gt; collection3 = Collections.emptyMap(); // 규칙 준수, Map&lt;Int, String&gt;\n</pre>",
    "moreInfo_ko": "<h3>문서</h3>\n<ul>\n  <li> <a href=\"https://docs.oracle.com/javase/8/docs/api/java/util/Collections.html\">Oracle - Java™ Platform, Standard Edition 8 API 명세, Collections 클래스</a> </li>\n  <li> <a href=\"https://docs.oracle.com/javase/tutorial/java/generics/rawTypes.html\">Oracle - The Java™ Tutorials - Raw 타입</a> </li>\n</ul>\n<h3>기사 및 블로그 포스트</h3>\n<ul>\n  <li> <a href=\"https://www.baeldung.com/java-generics\">Baeldung - Java 제네릭 기초</a> </li>\n</ul>"
  },
  {
    "id": "S5869",
    "key": "java:S5869",
    "name": "Character classes in regular expressions should not contain the same character twice",
    "type": "code-smell",
    "severity": "major",
    "tags": [
      "regex"
    ],
    "why": "<p>Character classes in regular expressions are a convenient way to match one of several possible characters by listing the allowed characters or\nranges of characters. If the same character is listed twice in the same character class or if the character class contains overlapping ranges, this\nhas no effect.</p>\n<p>Thus duplicate characters in a character class are either a simple oversight or a sign that a range in the character class matches more than is\nintended or that the author misunderstood how character classes work and wanted to match more than one character. A common example of the latter\nmistake is trying to use a range like <code>[0-99]</code> to match numbers of up to two digits, when in fact it is equivalent to <code>[0-9]</code>.\nAnother common cause is forgetting to escape the <code>-</code> character, creating an unintended range that overlaps with other characters in the\ncharacter class.</p>\n<h3>Noncompliant code example</h3>\n<pre>\nstr.matches(\"[0-99]\") // Noncompliant, this won't actually match strings with two digits\nstr.matches(\"[0-9.-_]\") // Noncompliant, .-_ is a range that already contains 0-9 (as well as various other characters such as capital letters)\n</pre>\n<h3>Compliant solution</h3>\n<pre>\nstr.matches(\"[0-9]{1,2}\")\nstr.matches(\"[0-9.\\\\-_]\")\n</pre>",
    "howToFix": "",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "정규식의 문자 클래스에 같은 문자가 두 번 포함되면 안 됩니다",
    "why_ko": "<p>정규 표현식의 문자 클래스는 허용되는 문자 또는 문자 범위를 나열하여 여러 가능한 문자 중 하나를 일치시키는 편리한 방법입니다. 같은 문자 클래스에 같은 문자가 두 번 나열되거나 문자 클래스에 겹치는 범위가 포함되어 있으면 아무런 효과가 없습니다.</p>\n<p>따라서 문자 클래스의 중복 문자는 단순한 실수이거나 문자 클래스의 범위가 의도한 것보다 더 많이 일치하거나 작성자가 문자 클래스의 작동 방식을 오해하여 둘 이상의 문자를 일치시키려 했음을 나타내는 신호입니다. 후자의 일반적인 예는 <code>[0-99]</code>와 같은 범위를 사용하여 두 자리까지의 숫자를 일치시키려고 하는 것인데, 실제로는 <code>[0-9]</code>와 동일합니다. 또 다른 일반적인 원인은 <code>-</code> 문자를 이스케이프하는 것을 잊어 문자 클래스의 다른 문자와 겹치는 의도하지 않은 범위를 만드는 것입니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\nstr.matches(\"[0-99]\") // 규칙 위반, 이것은 실제로 두 자리 문자열과 일치하지 않음\nstr.matches(\"[0-9.-_]\") // 규칙 위반, .-_는 이미 0-9를 포함하는 범위(대문자와 같은 다양한 다른 문자도 포함)\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre>\nstr.matches(\"[0-9]{1,2}\")\nstr.matches(\"[0-9.\\\\-_]\")\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": ""
  },
  {
    "id": "S2142",
    "key": "java:S2142",
    "name": "\"InterruptedException\" and \"ThreadDeath\" should not be ignored",
    "type": "bug",
    "severity": "major",
    "tags": [
      "error-handling",
      "cwe",
      "multi-threading"
    ],
    "why": "<p>If an <code>InterruptedException</code> or a <code>ThreadDeath</code> error is not handled properly, the information that the thread was\ninterrupted will be lost. Handling this exception means either to re-throw it or manually re-interrupt the current thread by calling\n<code>Thread.interrupt()</code>. Simply logging the exception is not sufficient and counts as ignoring it. Between the moment the exception is caught\nand handled, is the right time to perform cleanup operations on the method's state, if needed.</p>\n<h3>What is the potential impact?</h3>\n<p>Failing to interrupt the thread (or to re-throw) risks delaying the thread shutdown and losing the information that the thread was interrupted -\nprobably without finishing its task.</p>\n<h3>Noncompliant code example</h3>\n<pre>\npublic void run () {\n  try {\n    /*...*/\n  } catch (InterruptedException e) { // Noncompliant; logging is not enough\n    LOGGER.log(Level.WARN, \"Interrupted!\", e);\n  }\n}\n</pre>\n<h3>Compliant solution</h3>\n<pre>\npublic void run () {\n  try {\n    /* ... */\n  } catch (InterruptedException e) { // Compliant; the interrupted state is restored\n    LOGGER.log(Level.WARN, \"Interrupted!\", e);\n    /* Clean up whatever needs to be handled before interrupting  */\n    Thread.currentThread().interrupt();\n  }\n}\n\npublic void run () {\n  try {\n    /* ... */\n  } catch (ThreadDeath e) { // Compliant; the error is being re-thrown\n    LOGGER.log(Level.WARN, \"Interrupted!\", e);\n    /* Clean up whatever needs to be handled before re-throwing  */\n    throw e;\n  }\n}\n</pre>",
    "howToFix": "",
    "moreInfo": "<ul>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/391\">CWE-391 - Unchecked Error Condition</a> </li>\n</ul>",
    "status": "READY",
    "name_ko": "\"InterruptedException\"과 \"ThreadDeath\"는 무시하면 안 됩니다",
    "why_ko": "<p><code>InterruptedException</code>이나 <code>ThreadDeath</code> 오류가 적절히 처리되지 않으면 스레드가 인터럽트되었다는 정보가 손실됩니다. 이 예외를 처리한다는 것은 다시 던지거나 <code>Thread.interrupt()</code>를 호출하여 현재 스레드를 수동으로 다시 인터럽트하는 것을 의미합니다. 단순히 예외를 로깅하는 것은 충분하지 않으며 무시하는 것으로 간주됩니다. 예외가 잡히고 처리되는 사이가 필요한 경우 메서드 상태에 대한 정리 작업을 수행하기에 적절한 시점입니다.</p>\n<h3>잠재적 영향은 무엇인가요?</h3>\n<p>스레드를 인터럽트하지 않거나 다시 던지지 않으면 스레드 종료가 지연되고 스레드가 인터럽트되었다는 정보가 손실될 위험이 있습니다 - 아마도 작업을 완료하지 못한 채로요.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\npublic void run () {\n  try {\n    /*...*/\n  } catch (InterruptedException e) { // 규칙 위반; 로깅만으로는 충분하지 않음\n    LOGGER.log(Level.WARN, \"Interrupted!\", e);\n  }\n}\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre>\npublic void run () {\n  try {\n    /* ... */\n  } catch (InterruptedException e) { // 규칙 준수; 인터럽트 상태가 복원됨\n    LOGGER.log(Level.WARN, \"Interrupted!\", e);\n    /* 인터럽트하기 전에 처리해야 할 정리 작업 */\n    Thread.currentThread().interrupt();\n  }\n}\n\npublic void run () {\n  try {\n    /* ... */\n  } catch (ThreadDeath e) { // 규칙 준수; 오류가 다시 던져짐\n    LOGGER.log(Level.WARN, \"Interrupted!\", e);\n    /* 다시 던지기 전에 처리해야 할 정리 작업 */\n    throw e;\n  }\n}\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": "<ul>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/391\">CWE-391 - 확인되지 않은 오류 조건</a> </li>\n</ul>"
  },
  {
    "id": "S3753",
    "key": "java:S3753",
    "name": "\"@Controller\" classes that use \"@SessionAttributes\" must call \"setComplete\" on their \"SessionStatus\" objects",
    "type": "bug",
    "severity": "blocker",
    "tags": [
      "spring"
    ],
    "why": "<p>A Spring <code>@Controller</code> that uses <code>@SessionAttributes</code> is designed to handle a stateful / multi-post form. Such\n<code>@Controller</code>s use the specified <code>@SessionAttributes</code> to store data on the server between requests. That data should be cleaned\nup when the session is over, but unless <code>setComplete()</code> is called on the <code>SessionStatus</code> object from a\n<code>@RequestMapping</code> method, neither Spring nor the JVM will know it's time to do that. Note that the <code>SessionStatus</code> object must\nbe passed to that method as a parameter.</p>\n<h3>Noncompliant code example</h3>\n<pre>\n@Controller\n@SessionAttributes(\"hello\")  // Noncompliant: this doesn't get cleaned up\npublic class HelloWorld {\n\n  @RequestMapping(\"/greet\", method = GET)\n  public String greet(String greetee) {\n\n    return \"Hello \" + greetee;\n  }\n}\n</pre>\n<h3>Compliant solution</h3>\n<pre>\n@Controller\n@SessionAttributes(\"hello\")\npublic class HelloWorld {\n\n  @RequestMapping(\"/greet\", method = GET)\n  public String greet(String greetee) {\n\n    return \"Hello \" + greetee;\n  }\n\n  @RequestMapping(\"/goodbye\", method = POST)\n  public String goodbye(SessionStatus status) {\n    //...\n    status.setComplete();\n  }\n\n}\n</pre>",
    "howToFix": "",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "@SessionAttributes를 사용하는 @Controller 클래스는 SessionStatus 객체의 setComplete를 호출해야 합니다",
    "why_ko": "<p><code>@SessionAttributes</code>를 사용하는 Spring <code>@Controller</code>는 상태가 있는 / 다중 포스트 폼을 처리하도록 설계되었습니다. 이러한 <code>@Controller</code>는 지정된 <code>@SessionAttributes</code>를 사용하여 요청 사이에 서버에 데이터를 저장합니다. 세션이 끝나면 해당 데이터를 정리해야 하지만, <code>@RequestMapping</code> 메서드에서 <code>SessionStatus</code> 객체에 대해 <code>setComplete()</code>가 호출되지 않으면 Spring도 JVM도 정리해야 할 때를 알 수 없습니다. <code>SessionStatus</code> 객체는 해당 메서드에 매개변수로 전달되어야 합니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\n@Controller\n@SessionAttributes(\"hello\")  // 규칙 위반: 정리되지 않습니다\npublic class HelloWorld {\n\n  @RequestMapping(\"/greet\", method = GET)\n  public String greet(String greetee) {\n\n    return \"Hello \" + greetee;\n  }\n}\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre>\n@Controller\n@SessionAttributes(\"hello\")\npublic class HelloWorld {\n\n  @RequestMapping(\"/greet\", method = GET)\n  public String greet(String greetee) {\n\n    return \"Hello \" + greetee;\n  }\n\n  @RequestMapping(\"/goodbye\", method = POST)\n  public String goodbye(SessionStatus status) {\n    //...\n    status.setComplete();\n  }\n\n}\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": ""
  },
  {
    "id": "S2115",
    "key": "java:S2115",
    "name": "A secure password should be used when connecting to a database",
    "type": "vulnerability",
    "severity": "blocker",
    "tags": [
      "cwe"
    ],
    "why": "<p>When a database does not require a password for authentication, it allows anyone to access and manipulate the data stored within it. Exploiting\nthis vulnerability typically involves identifying the target database and establishing a connection to it without the need for any authentication\ncredentials.</p>\n<h3>What is the potential impact?</h3>\n<p>Once connected, an attacker can perform various malicious actions, such as viewing, modifying, or deleting sensitive information, potentially\nleading to data breaches or unauthorized access to critical systems. It is crucial to address this vulnerability promptly to ensure the security and\nintegrity of the database and the data it contains.</p>\n<h4>Unauthorized Access to Sensitive Data</h4>\n<p>When a database lacks a password for authentication, it opens the door for unauthorized individuals to gain access to sensitive data. This can\ninclude personally identifiable information (PII), financial records, intellectual property, or any other confidential information stored in the\ndatabase. Without proper access controls in place, malicious actors can exploit this vulnerability to retrieve sensitive data, potentially leading to\nidentity theft, financial loss, or reputational damage.</p>\n<h4>Compromise of System Integrity</h4>\n<p>Without a password requirement, unauthorized individuals can gain unrestricted access to a database, potentially compromising the integrity of the\nentire system. Attackers can inject malicious code, alter configurations, or manipulate data within the database, leading to system malfunctions,\nunauthorized system access, or even complete system compromise. This can disrupt business operations, cause financial losses, and expose the\norganization to further security risks.</p>\n<h4>Unwanted Modifications or Deletions</h4>\n<p>The absence of a password for database access allows anyone to make modifications or deletions to the data stored within it. This poses a\nsignificant risk, as unauthorized changes can lead to data corruption, loss of critical information, or the introduction of malicious content. For\nexample, an attacker could modify financial records, tamper with customer orders, or delete important files, causing severe disruptions to business\nprocesses and potentially leading to financial and legal consequences.</p>\n<p>Overall, the lack of a password configured to access a database poses a serious security risk, enabling unauthorized access, data breaches, system\ncompromise, and unwanted modifications or deletions. It is essential to address this vulnerability promptly to safeguard sensitive data, maintain\nsystem integrity, and protect the organization from potential harm.</p>",
    "howToFix": "<p>The following code uses an empty password to connect to a Postgres database.</p>\n<p>The vulnerability can be fixed by using a strong password retrieved from Properties. This <code>database.password</code> property is set during\ndeployment. Its value should be strong and different for each database.</p>\n<h4>Noncompliant code example</h4>\n<pre data-diff-id=\"201\" data-diff-type=\"noncompliant\">\nConnection conn = DriverManager.getConnection(\"jdbc:derby:memory:myDB;create=true\", \"login\", \"\"); // Noncompliant\n</pre>\n<h4>Compliant solution</h4>\n<pre data-diff-id=\"201\" data-diff-type=\"compliant\">\nString password = System.getProperty(\"database.password\");\nConnection conn = DriverManager.getConnection(\"jdbc:derby:memory:myDB;create=true\", \"login\", password);\n</pre>\n<h3>Pitfalls</h3>\n<h4>Hard-coded passwords</h4>\n<p>It could be tempting to replace the empty password with a hard-coded one. Hard-coding passwords in the code can pose significant security risks.\nHere are a few reasons why it is not recommended:</p>\n<ol>\n  <li> Security Vulnerability: Hard-coded passwords can be easily discovered by anyone who has access to the code, such as other developers or\n  attackers. This can lead to unauthorized access to the database and potential data breaches. </li>\n  <li> Lack of Flexibility: Hard-coded passwords make it difficult to change the password without modifying the code. If the password needs to be\n  updated, it would require recompiling and redeploying the code, which can be time-consuming and error-prone. </li>\n  <li> Version Control Issues: Storing passwords in code can lead to version control issues. If the code is shared or stored in a version control\n  system, the password will be visible to anyone with access to the repository, which is a security risk. </li>\n</ol>\n<p>To mitigate these risks, it is recommended to use secure methods for storing and retrieving passwords, such as using environment variables,\nconfiguration files, or secure key management systems. These methods allow for better security, flexibility, and separation of sensitive information\nfrom the codebase.</p>",
    "moreInfo": "<ul>\n  <li> <a href=\"https://docs.oracle.com/javase/tutorial/essential/environment/properties.html\">Java Properties</a> </li>\n</ul>\n<h3>Standards</h3>\n<ul>\n  <li> OWASP - <a href=\"https://owasp.org/Top10/A07_2021-Identification_and_Authentication_Failures/\">Top 10 2021 Category A7 - Identification and\n  Authentication Failures</a> </li>\n  <li> OWASP - <a href=\"https://owasp.org/www-project-top-ten/2017/A2_2017-Broken_Authentication\">Top 10 2017 Category A2 - Broken Authentication</a>\n  </li>\n  <li> OWASP - <a href=\"https://owasp.org/www-project-top-ten/2017/A3_2017-Sensitive_Data_Exposure\">Top 10 2017 Category A3 - Sensitive Data\n  Exposure</a> </li>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/521\">CWE-521 - Weak Password Requirements</a> </li>\n</ul>",
    "status": "READY",
    "name_ko": "데이터베이스 연결 시 안전한 비밀번호를 사용해야 합니다",
    "why_ko": "<p>데이터베이스가 인증에 비밀번호를 요구하지 않으면 누구나 데이터베이스에 저장된 데이터에 접근하고 조작할 수 있습니다. 이 취약점을 악용하는 것은 일반적으로 대상 데이터베이스를 식별하고 인증 자격 증명 없이 연결을 설정하는 것을 포함합니다.</p>\n<h3>잠재적인 영향은 무엇인가요?</h3>\n<p>연결되면 공격자는 민감한 정보를 보거나 수정하거나 삭제하는 등 다양한 악의적인 행동을 수행할 수 있으며, 이는 잠재적으로 데이터 침해나 중요 시스템에 대한 무단 접근으로 이어질 수 있습니다. 데이터베이스와 그 안에 포함된 데이터의 보안과 무결성을 보장하기 위해 이 취약점을 신속하게 해결하는 것이 중요합니다.</p>\n<h4>민감한 데이터에 대한 무단 접근</h4>\n<p>데이터베이스에 인증용 비밀번호가 없으면 권한 없는 개인이 민감한 데이터에 접근할 수 있는 문이 열립니다. 여기에는 개인 식별 정보(PII), 재무 기록, 지적 재산 또는 데이터베이스에 저장된 기타 기밀 정보가 포함될 수 있습니다. 적절한 접근 제어가 없으면 악의적인 행위자가 이 취약점을 악용하여 민감한 데이터를 검색할 수 있으며, 이는 잠재적으로 신원 도용, 재정적 손실 또는 평판 손상으로 이어질 수 있습니다.</p>\n<h4>시스템 무결성 손상</h4>\n<p>비밀번호 요구 사항이 없으면 권한 없는 개인이 데이터베이스에 무제한으로 접근할 수 있어 전체 시스템의 무결성이 손상될 수 있습니다. 공격자는 악성 코드를 주입하거나 구성을 변경하거나 데이터베이스 내의 데이터를 조작하여 시스템 오작동, 무단 시스템 접근 또는 완전한 시스템 손상을 초래할 수 있습니다. 이는 비즈니스 운영을 방해하고 재정적 손실을 야기하며 조직을 추가적인 보안 위험에 노출시킬 수 있습니다.</p>\n<h4>원치 않는 수정 또는 삭제</h4>\n<p>데이터베이스 접근에 비밀번호가 없으면 누구나 저장된 데이터를 수정하거나 삭제할 수 있습니다. 이는 상당한 위험을 초래하는데, 무단 변경은 데이터 손상, 중요 정보 손실 또는 악성 콘텐츠 도입으로 이어질 수 있기 때문입니다. 예를 들어, 공격자는 재무 기록을 수정하거나 고객 주문을 변조하거나 중요한 파일을 삭제하여 비즈니스 프로세스에 심각한 중단을 야기하고 잠재적으로 재정적, 법적 결과를 초래할 수 있습니다.</p>\n<p>전반적으로 데이터베이스 접근에 비밀번호가 구성되지 않은 것은 심각한 보안 위험을 초래하며, 무단 접근, 데이터 침해, 시스템 손상 및 원치 않는 수정 또는 삭제를 가능하게 합니다. 민감한 데이터를 보호하고 시스템 무결성을 유지하며 조직을 잠재적인 피해로부터 보호하기 위해 이 취약점을 신속하게 해결하는 것이 필수적입니다.</p>",
    "howToFix_ko": "<p>다음 코드는 빈 비밀번호를 사용하여 Postgres 데이터베이스에 연결합니다.</p>\n<p>이 취약점은 Properties에서 검색한 강력한 비밀번호를 사용하여 수정할 수 있습니다. 이 <code>database.password</code> 속성은 배포 중에 설정됩니다. 그 값은 강력해야 하며 각 데이터베이스마다 달라야 합니다.</p>\n<h4>규칙을 준수하지 않는 코드 예시</h4>\n<pre data-diff-id=\"201\" data-diff-type=\"noncompliant\">\nConnection conn = DriverManager.getConnection(\"jdbc:derby:memory:myDB;create=true\", \"login\", \"\"); // 규칙 위반\n</pre>\n<h4>규칙을 준수하는 해결책</h4>\n<pre data-diff-id=\"201\" data-diff-type=\"compliant\">\nString password = System.getProperty(\"database.password\");\nConnection conn = DriverManager.getConnection(\"jdbc:derby:memory:myDB;create=true\", \"login\", password);\n</pre>\n<h3>주의사항</h3>\n<h4>하드코딩된 비밀번호</h4>\n<p>빈 비밀번호를 하드코딩된 비밀번호로 대체하고 싶을 수 있습니다. 코드에 비밀번호를 하드코딩하면 상당한 보안 위험을 초래할 수 있습니다. 권장하지 않는 몇 가지 이유는 다음과 같습니다:</p>\n<ol>\n  <li> 보안 취약점: 하드코딩된 비밀번호는 다른 개발자나 공격자와 같이 코드에 접근할 수 있는 누구나 쉽게 발견할 수 있습니다. 이는 데이터베이스에 대한 무단 접근과 잠재적인 데이터 침해로 이어질 수 있습니다. </li>\n  <li> 유연성 부족: 하드코딩된 비밀번호는 코드를 수정하지 않고는 비밀번호를 변경하기 어렵게 만듭니다. 비밀번호를 업데이트해야 하는 경우 코드를 다시 컴파일하고 재배포해야 하며, 이는 시간이 많이 걸리고 오류가 발생하기 쉽습니다. </li>\n  <li> 버전 관리 문제: 코드에 비밀번호를 저장하면 버전 관리 문제가 발생할 수 있습니다. 코드가 공유되거나 버전 관리 시스템에 저장되면 저장소에 접근할 수 있는 누구에게나 비밀번호가 보이게 되어 보안 위험이 됩니다. </li>\n</ol>\n<p>이러한 위험을 완화하려면 환경 변수, 구성 파일 또는 보안 키 관리 시스템 사용과 같은 비밀번호 저장 및 검색을 위한 안전한 방법을 사용하는 것이 좋습니다. 이러한 방법은 더 나은 보안, 유연성 및 코드베이스에서 민감한 정보의 분리를 가능하게 합니다.</p>",
    "moreInfo_ko": "<ul>\n  <li> <a href=\"https://docs.oracle.com/javase/tutorial/essential/environment/properties.html\">Java Properties</a> </li>\n</ul>\n<h3>표준</h3>\n<ul>\n  <li> OWASP - <a href=\"https://owasp.org/Top10/A07_2021-Identification_and_Authentication_Failures/\">Top 10 2021 카테고리 A7 - 식별 및 인증 실패</a> </li>\n  <li> OWASP - <a href=\"https://owasp.org/www-project-top-ten/2017/A2_2017-Broken_Authentication\">Top 10 2017 카테고리 A2 - 취약한 인증</a> </li>\n  <li> OWASP - <a href=\"https://owasp.org/www-project-top-ten/2017/A3_2017-Sensitive_Data_Exposure\">Top 10 2017 카테고리 A3 - 민감한 데이터 노출</a> </li>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/521\">CWE-521 - 취약한 비밀번호 요구사항</a> </li>\n</ul>"
  },
  {
    "id": "S7481",
    "key": "java:S7481",
    "name": "Gatherer.ofSequential() should be used to build sequential gathers",
    "type": "code-smell",
    "severity": "minor",
    "tags": [
      "java24"
    ],
    "why": "<p>When a method uses a <code>Gatherer.of(…​)</code> factory and provides a combiner function that always throws an exception, this implicitly signals\nthat the gatherer is designed for sequential processing. The <code>java.util.stream.Gatherer</code> API provides\n<code>Gatherer.ofSequential(…​)</code> factories which clearly indicates that the gatherer is intended for sequential streams. Using such a factory\nimproves code clarity, makes the intended processing model explicit, and avoids the need for a dummy or throwing combiner.</p>",
    "howToFix": "<p>Use <code>Gatherer.ofSequential</code> instead of <code>Gatherer.of</code>.</p>\n\n<h4>Noncompliant code example</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\n  public static List&lt;Integer&gt; diffWithFirstPositive(List&lt;Integer&gt; list) {\n    Gatherer&lt;Integer, AtomicInteger, Integer&gt; gatherer = Gatherer.of(\n      () -&gt; new AtomicInteger(-1),\n      (state, number, downstream) -&gt; {\n        if (state.get() &lt; 0) {\n          state.set(number);\n          return true;\n        }\n        return downstream.push(number - state.get());\n      },\n      (_, _) -&gt; {\n        throw new IllegalStateException();\n      },\n      Gatherer.defaultFinisher());\n    return list.stream().gather(gatherer).toList();\n  }\n</pre>\n<h4>Compliant solution</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\n  public static List&lt;Integer&gt; diffWithFirstPositive(List&lt;Integer&gt; list) {\n    Gatherer&lt;Integer, AtomicInteger, Integer&gt; gatherer = Gatherer.ofSequential(\n      () -&gt; new AtomicInteger(-1),\n      (state, number, downstream) -&gt; {\n        if (state.get() &lt; 0) {\n          state.set(number);\n          return true;\n        }\n        return downstream.push(number - state.get());\n      },\n      Gatherer.defaultFinisher());\n    return list.stream().gather(gatherer).toList();\n  }\n</pre>",
    "moreInfo": "<ul>\n  <li> <a href=\"https://docs.oracle.com/en/java/javase/24/docs/api/java.base/java/util/stream/Gatherer.html\">Gatherer API</a> </li>\n  <li> <a href=\"https://docs.oracle.com/en/java/javase/24/core/stream-gatherers.html\">Stream gatherers documentation</a> </li>\n</ul>",
    "status": "READY",
    "name_ko": "순차적 gather 생성에는 Gatherer.ofSequential()을 사용해야 합니다",
    "why_ko": "<p>메서드가 <code>Gatherer.of(…​)</code> 팩토리를 사용하고 항상 예외를 throw하는 combiner 함수를 제공하면 이는 gatherer가 순차 처리용으로 설계되었음을 암시적으로 나타냅니다. <code>java.util.stream.Gatherer</code> API는 gatherer가 순차 스트림용임을 명확히 나타내는 <code>Gatherer.ofSequential(…​)</code> 팩토리를 제공합니다. 이러한 팩토리를 사용하면 코드 명확성이 향상되고 의도한 처리 모델이 명시적으로 표현되며 더미 또는 예외를 throw하는 combiner가 필요 없게 됩니다.</p>",
    "howToFix_ko": "<p><code>Gatherer.of</code> 대신 <code>Gatherer.ofSequential</code>을 사용하세요.</p>\n\n<h4>규칙을 준수하지 않는 코드 예시</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\n  public static List&lt;Integer&gt; diffWithFirstPositive(List&lt;Integer&gt; list) {\n    Gatherer&lt;Integer, AtomicInteger, Integer&gt; gatherer = Gatherer.of(\n      () -&gt; new AtomicInteger(-1),\n      (state, number, downstream) -&gt; {\n        if (state.get() &lt; 0) {\n          state.set(number);\n          return true;\n        }\n        return downstream.push(number - state.get());\n      },\n      (_, _) -&gt; {\n        throw new IllegalStateException();\n      },\n      Gatherer.defaultFinisher());\n    return list.stream().gather(gatherer).toList();\n  }\n</pre>\n<h4>규칙을 준수하는 해결책</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\n  public static List&lt;Integer&gt; diffWithFirstPositive(List&lt;Integer&gt; list) {\n    Gatherer&lt;Integer, AtomicInteger, Integer&gt; gatherer = Gatherer.ofSequential(\n      () -&gt; new AtomicInteger(-1),\n      (state, number, downstream) -&gt; {\n        if (state.get() &lt; 0) {\n          state.set(number);\n          return true;\n        }\n        return downstream.push(number - state.get());\n      },\n      Gatherer.defaultFinisher());\n    return list.stream().gather(gatherer).toList();\n  }\n</pre>",
    "moreInfo_ko": "<ul>\n  <li> <a href=\"https://docs.oracle.com/en/java/javase/24/docs/api/java.base/java/util/stream/Gatherer.html\">Gatherer API</a> </li>\n  <li> <a href=\"https://docs.oracle.com/en/java/javase/24/core/stream-gatherers.html\">Stream gatherer 문서</a> </li>\n</ul>"
  },
  {
    "id": "S5845",
    "key": "java:S5845",
    "name": "Assertions comparing incompatible types should not be made",
    "type": "bug",
    "severity": "critical",
    "tags": [
      "tests"
    ],
    "why": "<p>Assertions comparing incompatible types always fail, and negative assertions always pass. At best, negative assertions are useless. At worst, the\ndeveloper loses time trying to fix his code logic before noticing wrong assertions.</p>\n<p>Dissimilar types are:</p>\n<ul>\n  <li> comparing a primitive with null </li>\n  <li> comparing an object with an unrelated primitive (E.G. a string with an int) </li>\n  <li> comparing unrelated classes </li>\n  <li> comparing an array to a non-array </li>\n  <li> comparing two arrays of dissimilar types </li>\n</ul>\n<p>This rule also raises issues for unrelated <code>class</code> and <code>interface</code> or unrelated <code>interface</code> types in negative\nassertions. Because except in some corner cases, those types are more likely to be dissimilar. And inside a negative assertion, there is no test\nfailure to inform the developer about this unusual comparison.</p>\n<p>Supported test frameworks:</p>\n<ul>\n  <li> JUnit4 </li>\n  <li> JUnit5 </li>\n  <li> AssertJ </li>\n</ul>\n<h3>Noncompliant code example</h3>\n<pre>\ninterface KitchenTool {}\ninterface Plant {}\nclass Spatula implements KitchenTool {}\nclass Tree implements Plant {}\n\nvoid assertValues(int size,\n                  Spatula spatula, KitchenTool tool,  KitchenTool[] tools,\n                  Tree    tree,    Plant       plant, Tree[]        trees) {\n\n  // Whatever the given values, those negative assertions will always pass due to dissimilar types:\n  assertThat(size).isNotNull();           // Noncompliant; primitives can not be null\n  assertThat(spatula).isNotEqualTo(tree); // Noncompliant; unrelated classes\n  assertThat(tool).isNotSameAs(tools);    // Noncompliant; array &amp; non-array\n  assertThat(trees).isNotEqualTo(tools);  // Noncompliant; incompatible arrays\n\n  // Those assertions will always fail\n  assertThat(size).isNull();                       // Noncompliant\n  assertThat(spatula).isEqualTo(tree);             // Noncompliant\n\n  // Those negative assertions are more likely to always pass\n  assertThat(spatula).isNotEqualTo(plant); // Noncompliant; unrelated class and interface\n  assertThat(tool).isNotEqualTo(plant);    // Noncompliant; unrelated interfaces\n}\n</pre>",
    "howToFix": "",
    "moreInfo": "<ul>\n  <li> <a href='/coding_rules#rule_key=java%3AS2159'>S2159</a> - Silly equality checks should not be made </li>\n</ul>",
    "status": "READY",
    "name_ko": "호환되지 않는 타입을 비교하는 assertion은 사용하면 안 됩니다",
    "why_ko": "<p>호환되지 않는 타입을 비교하는 assertion은 항상 실패하고 부정 assertion은 항상 통과합니다. 가장 좋은 경우 부정 assertion은 쓸모없습니다. 최악의 경우 개발자는 잘못된 assertion을 발견하기 전에 코드 로직을 수정하려고 시간을 낭비합니다.</p>\n<p>다른 타입은 다음과 같습니다:</p>\n<ul>\n  <li> primitive와 null 비교 </li>\n  <li> 객체와 관련 없는 primitive 비교 (예: 문자열과 int) </li>\n  <li> 관련 없는 클래스 비교 </li>\n  <li> 배열과 비배열 비교 </li>\n  <li> 다른 타입의 두 배열 비교 </li>\n</ul>\n<p>이 규칙은 부정 assertion에서 관련 없는 <code>class</code>와 <code>interface</code> 또는 관련 없는 <code>interface</code> 타입에 대해서도 문제를 제기합니다. 일부 코너 케이스를 제외하고 이러한 타입은 다를 가능성이 더 높기 때문입니다. 그리고 부정 assertion 내에서는 이 비정상적인 비교에 대해 개발자에게 알리는 테스트 실패가 없습니다.</p>\n<p>지원되는 테스트 프레임워크:</p>\n<ul>\n  <li> JUnit4 </li>\n  <li> JUnit5 </li>\n  <li> AssertJ </li>\n</ul>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\ninterface KitchenTool {}\ninterface Plant {}\nclass Spatula implements KitchenTool {}\nclass Tree implements Plant {}\n\nvoid assertValues(int size,\n                  Spatula spatula, KitchenTool tool,  KitchenTool[] tools,\n                  Tree    tree,    Plant       plant, Tree[]        trees) {\n\n  // 주어진 값이 무엇이든 다른 타입으로 인해 이러한 부정 assertion은 항상 통과합니다:\n  assertThat(size).isNotNull();           // 규칙 위반; primitive는 null이 될 수 없음\n  assertThat(spatula).isNotEqualTo(tree); // 규칙 위반; 관련 없는 클래스\n  assertThat(tool).isNotSameAs(tools);    // 규칙 위반; 배열 &amp; 비배열\n  assertThat(trees).isNotEqualTo(tools);  // 규칙 위반; 호환되지 않는 배열\n\n  // 이러한 assertion은 항상 실패합니다\n  assertThat(size).isNull();                       // 규칙 위반\n  assertThat(spatula).isEqualTo(tree);             // 규칙 위반\n\n  // 이러한 부정 assertion은 항상 통과할 가능성이 높습니다\n  assertThat(spatula).isNotEqualTo(plant); // 규칙 위반; 관련 없는 클래스와 인터페이스\n  assertThat(tool).isNotEqualTo(plant);    // 규칙 위반; 관련 없는 인터페이스\n}\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": "<ul>\n  <li> <a href='/coding_rules#rule_key=java%3AS2159'>S2159</a> - 의미 없는 동등성 검사를 사용하면 안 됩니다 </li>\n</ul>"
  },
  {
    "id": "S1105",
    "key": "java:S1105",
    "name": "An open curly brace should be located at the end of a line",
    "type": "code-smell",
    "severity": "minor",
    "tags": [
      "convention"
    ],
    "why": "<p>Shared naming conventions allow teams to collaborate effectively. This rule raises an issue when an open curly brace is not placed at the end of a\nline of code.</p>\n<h3>Noncompliant code example</h3>\n<pre>\nif(condition)\n{\n  doSomething();\n}\n</pre>\n<h3>Compliant solution</h3>\n<pre>\nif(condition) {\n  doSomething();\n}\n</pre>\n<h3>Exceptions</h3>\n<p>When blocks are inlined (left and right curly braces on the same line), no issue is triggered.</p>\n<pre>\nif(condition) {doSomething();}\n</pre>",
    "howToFix": "",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "여는 중괄호는 줄의 끝에 위치해야 합니다",
    "why_ko": "<p>공유된 명명 규칙은 팀이 효과적으로 협업할 수 있게 해줍니다. 이 규칙은 여는 중괄호가 코드 줄 끝에 배치되지 않으면 이슈를 발생시킵니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\nif(condition)\n{\n  doSomething();\n}\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre>\nif(condition) {\n  doSomething();\n}\n</pre>\n<h3>예외</h3>\n<p>블록이 인라인된 경우(왼쪽과 오른쪽 중괄호가 같은 줄에 있는 경우) 이슈가 트리거되지 않습니다.</p>\n<pre>\nif(condition) {doSomething();}\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": ""
  },
  {
    "id": "S103",
    "key": "java:S103",
    "name": "Lines should not be too long",
    "type": "code-smell",
    "severity": "major",
    "tags": [
      "convention"
    ],
    "why": "<p>Scrolling horizontally to see a full line of code lowers the code readability.</p>",
    "howToFix": "",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "코드 라인이 너무 길면 안 됩니다",
    "why_ko": "<p>전체 코드 라인을 보기 위해 가로로 스크롤하면 코드 가독성이 떨어집니다.</p>",
    "howToFix_ko": "",
    "moreInfo_ko": ""
  },
  {
    "id": "S1943",
    "key": "java:S1943",
    "name": "Classes and methods that rely on the default system encoding should not be used",
    "type": "code-smell",
    "severity": "minor",
    "tags": [
      "unpredictable",
      "cert",
      "i18n"
    ],
    "why": "<p>Using classes and methods that rely on the default system encoding can result in code that works fine in its \"home\" environment. But that code may\nbreak for customers who use different encodings in ways that are extremely difficult to diagnose and nearly, if not completely, impossible to\nreproduce when it's time to fix them.</p>\n<p>This rule detects uses of the following classes and methods:</p>\n<ul>\n  <li> <code>FileReader</code> </li>\n  <li> <code>FileWriter</code> </li>\n  <li> String constructors with a <code>byte[]</code> argument but no <code>Charset</code> argument\n    <ul>\n      <li> <code>String(byte[] bytes)</code> </li>\n      <li> <code>String(byte[] bytes, int offset, int length)</code> </li>\n    </ul>  </li>\n  <li> <code>String.getBytes()</code> </li>\n  <li> <code>String.getBytes(int srcBegin, int srcEnd, byte[] dst, int dstBegin)</code> </li>\n  <li> <code>InputStreamReader(InputStream in)</code> </li>\n  <li> <code>OutputStreamWriter(OutputStream out)</code> </li>\n  <li> <code>ByteArrayOutputStream.toString()</code> </li>\n  <li> Some <code>Formatter</code> constructors\n    <ul>\n      <li> <code>Formatter(String fileName)</code> </li>\n      <li> <code>Formatter(File file)</code> </li>\n      <li> <code>Formatter(OutputStream os)</code> </li>\n    </ul>  </li>\n  <li> Some <code>Scanner</code> constructors\n    <ul>\n      <li> <code>Scanner(File source)</code> </li>\n      <li> <code>Scanner(Path source)</code> </li>\n      <li> <code>Scanner(InputStream source)</code> </li>\n    </ul>  </li>\n  <li> Some <code>PrintStream</code> constructors\n    <ul>\n      <li> <code>PrintStream(File file)</code> </li>\n      <li> <code>PrintStream(OutputStream out)</code> </li>\n      <li> <code>PrintStream(OutputStream out, boolean autoFlush)</code> </li>\n      <li> <code>PrintStream(String fileName)</code> </li>\n    </ul>  </li>\n  <li> Some <code>PrintWriter</code> constructors\n    <ul>\n      <li> <code>PrintWriter(File file)</code> </li>\n      <li> <code>PrintWriter(OutputStream out)</code> </li>\n      <li> <code>PrintWriter(OutputStream out, boolean autoFlush)</code> </li>\n      <li> <code>PrintWriter(String fileName)</code> </li>\n    </ul>  </li>\n  <li> methods from Apache commons-io library which accept an encoding argument when that argument is null, and overloads of those methods that omit\n  the encoding argument\n    <ul>\n      <li> <code>IOUtils.copy(InputStream, Writer)</code> </li>\n      <li> <code>IOUtils.copy(Reader, OutputStream)</code> </li>\n      <li> <code>IOUtils.readLines(InputStream)</code> </li>\n      <li> <code>IOUtils.toByteArray(Reader)</code> </li>\n      <li> <code>IOUtils.toByteArray(String)</code> </li>\n      <li> <code>IOUtils.toCharArray(InputStream)</code> </li>\n      <li> <code>IOUtils.toInputStream(TypeCriteria.subtypeOf(CharSequence))</code> </li>\n      <li> <code>IOUtils.toString(byte[])</code> </li>\n      <li> <code>IOUtils.toString(URI)</code> </li>\n      <li> <code>IOUtils.toString(URL)</code> </li>\n      <li> <code>IOUtils.write(char[], OutputStream)</code> </li>\n      <li> <code>IOUtils.write(CharSequence, OutputStream)</code> </li>\n      <li> <code>IOUtils.writeLines(Collection, String, OutputStream)</code> </li>\n      <li> <code>FileUtils.readFileToString(File)</code> </li>\n      <li> <code>FileUtils.readLines(File)</code> </li>\n      <li> <code>FileUtils.write(File, CharSequence)</code> </li>\n      <li> <code>FileUtils.write(File, CharSequence, boolean)</code> </li>\n      <li> <code>FileUtils.writeStringToFile(File, String)</code> </li>\n    </ul>  </li>\n</ul>",
    "howToFix": "",
    "moreInfo": "<ul>\n  <li> <a href=\"https://wiki.sei.cmu.edu/confluence/x/pzdGBQ\">CERT, STR04-J.</a> - Use compatible character encodings when communicating string data\n  between JVMs </li>\n  <li> <a href=\"https://wiki.sei.cmu.edu/confluence/x/ujZGBQ\">CERT, STR50-J.</a> - Use the appropriate method for counting characters in a string\n  </li>\n</ul>",
    "status": "READY",
    "name_ko": "기본 시스템 인코딩에 의존하는 클래스와 메서드를 사용하면 안 됩니다",
    "why_ko": "<p>기본 시스템 인코딩에 의존하는 클래스와 메서드를 사용하면 \"홈\" 환경에서는 잘 작동하는 코드가 될 수 있습니다. 그러나 해당 코드는 다른 인코딩을 사용하는 고객에게서 진단하기 매우 어렵고, 수정할 때 재현하기가 거의 또는 완전히 불가능한 방식으로 깨질 수 있습니다.</p>\n<p>이 규칙은 다음 클래스와 메서드의 사용을 감지합니다:</p>\n<ul>\n  <li> <code>FileReader</code> </li>\n  <li> <code>FileWriter</code> </li>\n  <li> <code>byte[]</code> 인수는 있지만 <code>Charset</code> 인수가 없는 String 생성자\n    <ul>\n      <li> <code>String(byte[] bytes)</code> </li>\n      <li> <code>String(byte[] bytes, int offset, int length)</code> </li>\n    </ul>  </li>\n  <li> <code>String.getBytes()</code> </li>\n  <li> <code>String.getBytes(int srcBegin, int srcEnd, byte[] dst, int dstBegin)</code> </li>\n  <li> <code>InputStreamReader(InputStream in)</code> </li>\n  <li> <code>OutputStreamWriter(OutputStream out)</code> </li>\n  <li> <code>ByteArrayOutputStream.toString()</code> </li>\n  <li> 일부 <code>Formatter</code> 생성자\n    <ul>\n      <li> <code>Formatter(String fileName)</code> </li>\n      <li> <code>Formatter(File file)</code> </li>\n      <li> <code>Formatter(OutputStream os)</code> </li>\n    </ul>  </li>\n  <li> 일부 <code>Scanner</code> 생성자\n    <ul>\n      <li> <code>Scanner(File source)</code> </li>\n      <li> <code>Scanner(Path source)</code> </li>\n      <li> <code>Scanner(InputStream source)</code> </li>\n    </ul>  </li>\n  <li> 일부 <code>PrintStream</code> 생성자\n    <ul>\n      <li> <code>PrintStream(File file)</code> </li>\n      <li> <code>PrintStream(OutputStream out)</code> </li>\n      <li> <code>PrintStream(OutputStream out, boolean autoFlush)</code> </li>\n      <li> <code>PrintStream(String fileName)</code> </li>\n    </ul>  </li>\n  <li> 일부 <code>PrintWriter</code> 생성자\n    <ul>\n      <li> <code>PrintWriter(File file)</code> </li>\n      <li> <code>PrintWriter(OutputStream out)</code> </li>\n      <li> <code>PrintWriter(OutputStream out, boolean autoFlush)</code> </li>\n      <li> <code>PrintWriter(String fileName)</code> </li>\n    </ul>  </li>\n  <li> 인코딩 인수가 null일 때 인코딩 인수를 받는 Apache commons-io 라이브러리의 메서드와 인코딩 인수를 생략하는 해당 메서드의 오버로드\n    <ul>\n      <li> <code>IOUtils.copy(InputStream, Writer)</code> </li>\n      <li> <code>IOUtils.copy(Reader, OutputStream)</code> </li>\n      <li> <code>IOUtils.readLines(InputStream)</code> </li>\n      <li> <code>IOUtils.toByteArray(Reader)</code> </li>\n      <li> <code>IOUtils.toByteArray(String)</code> </li>\n      <li> <code>IOUtils.toCharArray(InputStream)</code> </li>\n      <li> <code>IOUtils.toInputStream(TypeCriteria.subtypeOf(CharSequence))</code> </li>\n      <li> <code>IOUtils.toString(byte[])</code> </li>\n      <li> <code>IOUtils.toString(URI)</code> </li>\n      <li> <code>IOUtils.toString(URL)</code> </li>\n      <li> <code>IOUtils.write(char[], OutputStream)</code> </li>\n      <li> <code>IOUtils.write(CharSequence, OutputStream)</code> </li>\n      <li> <code>IOUtils.writeLines(Collection, String, OutputStream)</code> </li>\n      <li> <code>FileUtils.readFileToString(File)</code> </li>\n      <li> <code>FileUtils.readLines(File)</code> </li>\n      <li> <code>FileUtils.write(File, CharSequence)</code> </li>\n      <li> <code>FileUtils.write(File, CharSequence, boolean)</code> </li>\n      <li> <code>FileUtils.writeStringToFile(File, String)</code> </li>\n    </ul>  </li>\n</ul>",
    "howToFix_ko": "",
    "moreInfo_ko": "<ul>\n  <li> <a href=\"https://wiki.sei.cmu.edu/confluence/x/pzdGBQ\">CERT, STR04-J.</a> - JVM 간 문자열 데이터 통신 시 호환 가능한 문자 인코딩 사용 </li>\n  <li> <a href=\"https://wiki.sei.cmu.edu/confluence/x/ujZGBQ\">CERT, STR50-J.</a> - 문자열의 문자 수를 세는 적절한 메서드 사용 </li>\n</ul>"
  },
  {
    "id": "S5783",
    "key": "java:S5783",
    "name": "Only one method invocation is expected when testing checked exceptions",
    "type": "bug",
    "severity": "critical",
    "tags": [
      "junit",
      "tests"
    ],
    "why": "<p>When verifying that code raises an exception, a good practice is to avoid having multiple method calls inside the tested code, to be explicit about\nwhat is exactly tested.</p>\n<p>When two of the methods can raise the same <strong>checked</strong> exception, not respecting this good practice is a bug, since it is not possible\nto know what is really tested.</p>\n<p>You should make sure that only one method can raise the expected checked exception in the tested code.</p>\n<h3>Noncompliant code example</h3>\n<pre>\n@Test\npublic void testG() {\n  // Do you expect g() or f() throwing the exception?\n  assertThrows(IOException.class, () -&gt; g(f(1)) ); // Noncompliant\n}\n\n@Test\npublic void testGTryCatchIdiom() {\n  try { // Noncompliant\n    g(f(1));\n    Assert.fail(\"Expected an IOException to be thrown\");\n  } catch (IOException e) {\n    // Test exception message...\n  }\n}\n\nint f(int x) throws IOException {\n  // ...\n}\n\nint g(int x) throws IOException {\n  // ...\n}\n</pre>\n<h3>Compliant solution</h3>\n<pre>\n@Test\npublic void testG() {\n  int y = f(1);\n  // It is explicit that we expect an exception from g() and not f()\n  assertThrows(IOException.class, () -&gt; g(y) );\n}\n\n@Test\npublic void testGTryCatchIdiom() {\n  int y = f(1);\n  try {\n    g(y);\n    Assert.fail(\"Expected an IOException to be thrown\");\n  } catch (IOException e) {\n    // Test exception message...\n  }\n}\n</pre>",
    "howToFix": "",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "체크 예외 테스트 시 하나의 메서드 호출만 있어야 합니다",
    "why_ko": "<p>코드가 예외를 발생시키는지 확인할 때 정확히 무엇이 테스트되는지 명시적으로 하기 위해 테스트되는 코드 내에 여러 메서드 호출이 있는 것을 피하는 것이 좋은 관행입니다.</p>\n<p>두 메서드가 동일한 <strong>체크</strong> 예외를 발생시킬 수 있을 때 이 좋은 관행을 따르지 않으면 버그입니다. 실제로 무엇이 테스트되는지 알 수 없기 때문입니다.</p>\n<p>테스트되는 코드에서 하나의 메서드만 예상되는 체크 예외를 발생시킬 수 있도록 해야 합니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\n@Test\npublic void testG() {\n  // g() 또는 f() 중 어느 것이 예외를 던질 것으로 예상합니까?\n  assertThrows(IOException.class, () -&gt; g(f(1)) ); // 규칙 위반\n}\n\n@Test\npublic void testGTryCatchIdiom() {\n  try { // 규칙 위반\n    g(f(1));\n    Assert.fail(\"IOException이 발생해야 합니다\");\n  } catch (IOException e) {\n    // 예외 메시지 테스트...\n  }\n}\n\nint f(int x) throws IOException {\n  // ...\n}\n\nint g(int x) throws IOException {\n  // ...\n}\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre>\n@Test\npublic void testG() {\n  int y = f(1);\n  // f()가 아닌 g()에서 예외를 예상한다는 것이 명시적입니다\n  assertThrows(IOException.class, () -&gt; g(y) );\n}\n\n@Test\npublic void testGTryCatchIdiom() {\n  int y = f(1);\n  try {\n    g(y);\n    Assert.fail(\"IOException이 발생해야 합니다\");\n  } catch (IOException e) {\n    // 예외 메시지 테스트...\n  }\n}\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": ""
  },
  {
    "id": "S6906",
    "key": "java:S6906",
    "name": "Virtual threads should not run tasks that include synchronized code",
    "type": "bug",
    "severity": "major",
    "tags": [
      "multi-threading",
      "java21"
    ],
    "why": "<p>Java virtual threads enable the JVM to optimize the use of OS threads by mounting and unmounting them as needed. This makes them more efficient\nwhen dealing with blocking operations such as I/O or HTTP requests.</p>\n<p>This rule applies only to code running on Java versions older than 24. Since Java 24, virtual threads are no longer pinned when executing\n<code>synchronized</code> code.</p>\n<p>For Java version 21 to 23, when code is executed inside a <code>synchronized</code> block or method, the virtual thread remains pinned to its\nunderlying OS thread and cannot be unmounted during a blocking operation. This causes the OS thread to be blocked, which can impact the scalability of\nthe application.</p>\n<p>Therefore, in environments running a Java version below 24, virtual threads should not execute code that contains <code>synchronized</code> blocks\nor invokes <code>synchronized</code> methods. Platform threads should be used in these cases instead.</p>\n<p>This rule raises an issue when a virtual thread contains <code>synchronized</code> blocks or invokes <code>synchronized</code> methods.</p>\n\n<h4>Noncompliant code example</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\nvoid enqueue(){\n    Thread.startVirtualThread(() -&gt; { // Noncompliant; use a platform thread instead\n            setupOperations();\n            dequeLogic();\n        }\n    });\n}\n</pre>\n<h4>Compliant solution</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\nvoid enqueue(){\n    new Thread(() -&gt; {\n        synchronized {\n            setupOperations();\n            dequeLogic();\n        }\n    }).start();\n}\n</pre>\n<h4>Noncompliant code example</h4>\n<pre data-diff-id=\"2\" data-diff-type=\"noncompliant\">\nvoid enqueue2(){\n    Thread.startVirtualThread(() -&gt; { // Noncompliant; use a platform thread instead of a virtual one\n        if(someCondition){\n            synchronizedMethod();\n        }else{\n            defaultLogic();\n        }\n    });\n}\nsynchronized void synchronizedMethod(){}\nvoid defaultLogic(){}\n</pre>\n<h4>Compliant solution</h4>\n<pre data-diff-id=\"2\" data-diff-type=\"compliant\">\nvoid enqueue2(){\n    new Thread(() -&gt; {\n        if(someCondition){\n            synchronizedMethod();\n        }else{\n            defaultLogic();\n        }\n    }).start();\n}\nsynchronized void synchronizedMethod(){}\nvoid defaultLogic(){}\n</pre>",
    "howToFix": "",
    "moreInfo": "<h3>Documentation</h3>\n<ul>\n  <li> Java Documentation - <a href=\"https://openjdk.org/jeps/444#:~:text=There%20are%20two,by%20capturing%20carriers\">Virtual threads, pinning\n  scenarios</a> </li>\n  <li> Java Documentation - <a href=\"https://openjdk.org/jeps/491\">Synchronize Virtual Threads without Pinning</a> </li>\n</ul>",
    "status": "READY",
    "name_ko": "가상 스레드에서 synchronized 코드를 포함한 작업을 실행하면 안 됩니다",
    "why_ko": "<p>Java 가상 스레드는 JVM이 필요에 따라 OS 스레드를 마운트 및 언마운트하여 OS 스레드 사용을 최적화할 수 있게 합니다. 이를 통해 I/O 또는 HTTP 요청과 같은 블로킹 작업을 처리할 때 더 효율적입니다.</p>\n<p>이 규칙은 Java 24 이전 버전에서 실행되는 코드에만 적용됩니다. Java 24부터 가상 스레드는 <code>synchronized</code> 코드를 실행할 때 더 이상 고정되지 않습니다.</p>\n<p>Java 버전 21에서 23의 경우 코드가 <code>synchronized</code> 블록이나 메서드 내에서 실행되면 가상 스레드는 기본 OS 스레드에 고정된 상태로 유지되며 블로킹 작업 중에 언마운트할 수 없습니다. 이로 인해 OS 스레드가 차단되어 애플리케이션의 확장성에 영향을 미칠 수 있습니다.</p>\n<p>따라서 Java 24 미만 버전을 실행하는 환경에서 가상 스레드는 <code>synchronized</code> 블록이 포함되거나 <code>synchronized</code> 메서드를 호출하는 코드를 실행해서는 안 됩니다. 이러한 경우에는 대신 플랫폼 스레드를 사용해야 합니다.</p>\n<p>이 규칙은 가상 스레드에 <code>synchronized</code> 블록이 포함되거나 <code>synchronized</code> 메서드를 호출할 때 문제를 발생시킵니다.</p>\n\n<h4>규칙을 준수하지 않는 코드 예시</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\nvoid enqueue(){\n    Thread.startVirtualThread(() -&gt; { // 규칙 위반; 대신 플랫폼 스레드를 사용하세요\n            setupOperations();\n            dequeLogic();\n        }\n    });\n}\n</pre>\n<h4>규칙을 준수하는 해결책</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\nvoid enqueue(){\n    new Thread(() -&gt; {\n        synchronized {\n            setupOperations();\n            dequeLogic();\n        }\n    }).start();\n}\n</pre>\n<h4>규칙을 준수하지 않는 코드 예시</h4>\n<pre data-diff-id=\"2\" data-diff-type=\"noncompliant\">\nvoid enqueue2(){\n    Thread.startVirtualThread(() -&gt; { // 규칙 위반; 가상 스레드 대신 플랫폼 스레드를 사용하세요\n        if(someCondition){\n            synchronizedMethod();\n        }else{\n            defaultLogic();\n        }\n    });\n}\nsynchronized void synchronizedMethod(){}\nvoid defaultLogic(){}\n</pre>\n<h4>규칙을 준수하는 해결책</h4>\n<pre data-diff-id=\"2\" data-diff-type=\"compliant\">\nvoid enqueue2(){\n    new Thread(() -&gt; {\n        if(someCondition){\n            synchronizedMethod();\n        }else{\n            defaultLogic();\n        }\n    }).start();\n}\nsynchronized void synchronizedMethod(){}\nvoid defaultLogic(){}\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": "<h3>문서</h3>\n<ul>\n  <li> Java 문서 - <a href=\"https://openjdk.org/jeps/444#:~:text=There%20are%20two,by%20capturing%20carriers\">Virtual threads, 고정 시나리오</a> </li>\n  <li> Java 문서 - <a href=\"https://openjdk.org/jeps/491\">고정 없이 Virtual Threads 동기화</a> </li>\n</ul>"
  },
  {
    "id": "S1113",
    "key": "java:S1113",
    "name": "The \"Object.finalize()\" method should not be overridden",
    "type": "code-smell",
    "severity": "critical",
    "tags": [
      "unpredictable",
      "cert"
    ],
    "why": "<p>Before it reclaims storage from an object that is no longer referenced, the garbage collector calls <code>finalize()</code> on the object.</p>\n<p>But there is no guarantee that this method will be called as soon as the last references to the object are removed.</p>\n<p>It can be few microseconds to few minutes later.</p>\n<p>For this reason relying on overriding the <code>finalize()</code> method to release resources or to update the state of the program is highly\ndiscouraged.</p>\n<h3>What is the potential impact?</h3>\n<p>More unexpected issues can be caused by relying on the <code>finalize()</code> method to perform important operations on the application state:</p>\n<ul>\n  <li> The JVM might terminate without ever calling this method on a particular object, leaving an unexpected or incomplete state of the program </li>\n  <li> Uncaught exceptions will be ignored inside this method, making it harder to detect issues that could have been logged otherwise </li>\n  <li> Finalizer methods can also be invoked concurrently, even on single-threaded applications, making it hard to maintain desired program invariants\n  </li>\n</ul>\n<h3>Noncompliant code example</h3>\n<pre>\npublic class MyClass {\n\n  @Override\n  protected void finalize() { // Noncompliant\n    releaseSomeResources();\n  }\n\n}\n</pre>\n<h3>Exceptions</h3>\n<p>It is allowed to override the <code>finalize()</code> method as <code>final</code> method with an empty body, to prevent the <em>finalizer\nattack</em> as described in <em>MET12-J-EX1</em>.</p>",
    "howToFix": "",
    "moreInfo": "<ul>\n  <li> <a href=\"https://docs.oracle.com/javase/specs/jls/se17/html/jls-12.html#jls-12.6\">docs.oracle.com</a> - Finalization of Class Instances </li>\n  <li> <a href=\"https://wiki.sei.cmu.edu/confluence/x/4jZGBQ\">CERT, MET12-J.</a> - Do not use finalizers </li>\n</ul>",
    "status": "READY",
    "name_ko": "\"Object.finalize()\" 메서드는 오버라이드하면 안 됩니다",
    "why_ko": "<p>가비지 컬렉터는 더 이상 참조되지 않는 객체에서 저장소를 회수하기 전에 해당 객체의 <code>finalize()</code>를 호출합니다.</p>\n<p>그러나 이 메서드가 객체에 대한 마지막 참조가 제거되자마자 호출된다는 보장은 없습니다.</p>\n<p>몇 마이크로초에서 몇 분 후에 호출될 수 있습니다.</p>\n<p>이러한 이유로 리소스를 해제하거나 프로그램 상태를 업데이트하기 위해 <code>finalize()</code> 메서드 오버라이드에 의존하는 것은 매우 권장되지 않습니다.</p>\n<h3>잠재적 영향은 무엇인가요?</h3>\n<p><code>finalize()</code> 메서드에 의존하여 애플리케이션 상태에서 중요한 작업을 수행하면 더 많은 예기치 않은 문제가 발생할 수 있습니다:</p>\n<ul>\n  <li> JVM이 특정 객체에서 이 메서드를 호출하지 않고 종료될 수 있어 프로그램이 예기치 않거나 불완전한 상태로 남을 수 있습니다 </li>\n  <li> 이 메서드 내부에서 잡히지 않은 예외는 무시되어 그렇지 않으면 로깅될 수 있었던 문제를 감지하기 어렵게 만듭니다 </li>\n  <li> Finalizer 메서드는 단일 스레드 애플리케이션에서도 동시에 호출될 수 있어 원하는 프로그램 불변성을 유지하기 어렵게 만듭니다 </li>\n</ul>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\npublic class MyClass {\n\n  @Override\n  protected void finalize() { // 규칙 위반\n    releaseSomeResources();\n  }\n\n}\n</pre>\n<h3>예외 사항</h3>\n<p><em>MET12-J-EX1</em>에 설명된 <em>finalizer 공격</em>을 방지하기 위해 빈 본문의 <code>final</code> 메서드로 <code>finalize()</code> 메서드를 오버라이드하는 것은 허용됩니다.</p>",
    "howToFix_ko": "",
    "moreInfo_ko": "<ul>\n  <li> <a href=\"https://docs.oracle.com/javase/specs/jls/se17/html/jls-12.html#jls-12.6\">docs.oracle.com</a> - 클래스 인스턴스의 종료화 </li>\n  <li> <a href=\"https://wiki.sei.cmu.edu/confluence/x/4jZGBQ\">CERT, MET12-J.</a> - finalizer를 사용하지 마세요 </li>\n</ul>"
  },
  {
    "id": "S5853",
    "key": "java:S5853",
    "name": "Consecutive AssertJ \"assertThat\" statements should be chained",
    "type": "code-smell",
    "severity": "minor",
    "tags": [
      "tests",
      "assertj"
    ],
    "why": "<p>AssertJ assertions methods targeting the same object can be chained instead of using multiple <code>assertThat</code>. It avoids duplication and\nincreases the clarity of the code.</p>\n<p>This rule raises an issue when multiples <code>assertThat</code> target the same tested value.</p>\n<h3>Noncompliant code example</h3>\n<pre>\nassertThat(someList).hasSize(3);\nassertThat(someList).contains(\"something\");\n</pre>\n<h3>Compliant solution</h3>\n<pre>\nassertThat(someList)\n  .hasSize(3)\n  .contains(\"something\");\n</pre>",
    "howToFix": "",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "연속된 AssertJ \"assertThat\" 문은 체이닝해야 합니다","why_ko": "<p>동일한 객체를 대상으로 하는 AssertJ assertion 메서드는 여러 <code>assertThat</code>을 사용하는 대신 체이닝할 수 있습니다. 이는 중복을 피하고 코드의 명확성을 높입니다.</p>\n<p>이 규칙은 여러 <code>assertThat</code>이 동일한 테스트 값을 대상으로 할 때 문제를 제기합니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\nassertThat(someList).hasSize(3);\nassertThat(someList).contains(\"something\");\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre>\nassertThat(someList)\n  .hasSize(3)\n  .contains(\"something\");\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": ""
  },
  {
    "id": "S2695",
    "key": "java:S2695",
    "name": "\"PreparedStatement\" and \"ResultSet\" methods should be called with valid indices",
    "type": "bug",
    "severity": "blocker",
    "tags": [
      "sql"
    ],
    "why": "<p><code>PreparedStatement</code> is an object that represents a precompiled SQL statement, that can be used to execute the statement multiple times\nefficiently.</p>\n<p><code>ResultSet</code> is the Java representation of the result set of a database query obtained from a <code>Statement</code> object. A default\n<code>ResultSet</code> object is not updatable and has a cursor that moves forward only.</p>\n<p>The parameters in <code>PreparedStatement</code> and <code>ResultSet</code> are indexed beginning at 1, not 0. When an invalid index is passed to\nthe <code>PreparedStatement</code> or <code>ResultSet</code> methods, an <code>IndexOutOfBoundsException</code> is thrown. This can cause the program\nto crash or behave unexpectedly, leading to a poor user experience.</p>\n<p>This rule raises an issue for the <code>get</code> methods in <code>PreparedStatement</code> and the <code>set</code> methods in\n<code>ResultSet</code>.</p>",
    "howToFix": "<p>Ensure the index passed to the <code>PreparedStatement</code> and <code>ResultSet</code> methods is valid.</p>\n\n<h4>Noncompliant code example</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\nPreparedStatement ps = con.prepareStatement(\"SELECT fname, lname FROM employees where hireDate &gt; ? and salary &lt; ?\");\nps.setDate(0, date);  // Noncompliant\nps.setDouble(3, salary);  // Noncompliant\n\nResultSet rs = ps.executeQuery();\nwhile (rs.next()) {\n  String fname = rs.getString(0);  // Noncompliant\n  // ...\n}\n</pre>\n<h4>Compliant solution</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\nPreparedStatement ps = con.prepareStatement(\"SELECT fname, lname FROM employees where hireDate &gt; ? and salary &lt; ?\");\nps.setDate(1, date);\nps.setDouble(2, salary);\n\nResultSet rs = ps.executeQuery();\nwhile (rs.next()) {\n  String fname = rs.getString(1);\n  // ...\n}\n</pre>",
    "moreInfo": "<h3>Documentation</h3>\n<ul>\n  <li> <a href=\"https://docs.oracle.com/en/java/javase/20/docs/api/java.sql/java/sql/PreparedStatement.html\">Oracle SDK 20 - PreparedStatement</a>\n  </li>\n  <li> <a href=\"https://docs.oracle.com/en/java/javase/20/docs/api/java.sql/java/sql/ResultSet.html\">Oracle SDK 20 - ResultSet</a> </li>\n  <li> <a href=\"https://docs.oracle.com/en/java/javase/20/docs/api/java.sql/java/sql/Connection.html#prepareStatement(java.lang.String)\">Oracle SDK 20\n  - Connection#prepareStatement</a> </li>\n</ul>",
    "status": "READY",
    "name_ko": "\"PreparedStatement\"와 \"ResultSet\" 메서드는 유효한 인덱스로 호출해야 합니다",
    "why_ko": "<p><code>PreparedStatement</code>는 미리 컴파일된 SQL 문을 나타내는 객체로, 문을 여러 번 효율적으로 실행하는 데 사용할 수 있습니다.</p>\n<p><code>ResultSet</code>은 <code>Statement</code> 객체에서 얻은 데이터베이스 쿼리 결과 집합의 Java 표현입니다. 기본 <code>ResultSet</code> 객체는 업데이트할 수 없으며 앞으로만 이동하는 커서를 가집니다.</p>\n<p><code>PreparedStatement</code>와 <code>ResultSet</code>의 매개변수는 0이 아닌 1부터 시작하는 인덱스를 가집니다. <code>PreparedStatement</code> 또는 <code>ResultSet</code> 메서드에 유효하지 않은 인덱스가 전달되면 <code>IndexOutOfBoundsException</code>이 발생합니다. 이는 프로그램이 충돌하거나 예기치 않게 동작하여 사용자 경험이 저하될 수 있습니다.</p>\n<p>이 규칙은 <code>PreparedStatement</code>의 <code>get</code> 메서드와 <code>ResultSet</code>의 <code>set</code> 메서드에 대해 문제를 제기합니다.</p>",
    "howToFix_ko": "<p><code>PreparedStatement</code> 및 <code>ResultSet</code> 메서드에 전달되는 인덱스가 유효한지 확인하세요.</p>\n\n<h4>규칙을 준수하지 않는 코드 예시</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\nPreparedStatement ps = con.prepareStatement(\"SELECT fname, lname FROM employees where hireDate &gt; ? and salary &lt; ?\");\nps.setDate(0, date);  // 규칙 위반\nps.setDouble(3, salary);  // 규칙 위반\n\nResultSet rs = ps.executeQuery();\nwhile (rs.next()) {\n  String fname = rs.getString(0);  // 규칙 위반\n  // ...\n}\n</pre>\n<h4>규칙을 준수하는 해결책</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\nPreparedStatement ps = con.prepareStatement(\"SELECT fname, lname FROM employees where hireDate &gt; ? and salary &lt; ?\");\nps.setDate(1, date);\nps.setDouble(2, salary);\n\nResultSet rs = ps.executeQuery();\nwhile (rs.next()) {\n  String fname = rs.getString(1);\n  // ...\n}\n</pre>",
    "moreInfo_ko": "<h3>문서</h3>\n<ul>\n  <li> <a href=\"https://docs.oracle.com/en/java/javase/20/docs/api/java.sql/java/sql/PreparedStatement.html\">Oracle SDK 20 - PreparedStatement</a>\n  </li>\n  <li> <a href=\"https://docs.oracle.com/en/java/javase/20/docs/api/java.sql/java/sql/ResultSet.html\">Oracle SDK 20 - ResultSet</a> </li>\n  <li> <a href=\"https://docs.oracle.com/en/java/javase/20/docs/api/java.sql/java/sql/Connection.html#prepareStatement(java.lang.String)\">Oracle SDK 20\n  - Connection#prepareStatement</a> </li>\n</ul>"
  },
  {
    "id": "S5445",
    "key": "java:S5445",
    "name": "Insecure temporary file creation methods should not be used",
    "type": "vulnerability",
    "severity": "critical",
    "tags": [
      "cwe"
    ],
    "why": "<p>Creating temporary files in a non-atomic way introduces race condition issues in the application's behavior. Indeed, a third party can create a\ngiven file between when the application chooses its name and when it creates it.</p>\n<p>In such a situation, the application might use a temporary file that it does not entirely control. In particular, this file's permissions might be\ndifferent than expected. This can lead to trust boundary issues.</p>\n<h3>What is the potential impact?</h3>\n<p>Attackers with control over a temporary file used by a vulnerable application will be able to modify it in a way that will affect the application's\nlogic. By changing this file's Access Control List or other operating system-level properties, they could prevent the file from being deleted or\nemptied. They may also alter the file's content before or while the application uses it.</p>\n<p>Depending on why and how the affected temporary files are used, the exploitation of a race condition in an application can have various\nconsequences. They can range from sensitive information disclosure to more serious application or hosting infrastructure compromise.</p>\n<h4>Information disclosure</h4>\n<p>Because attackers can control the permissions set on temporary files and prevent their removal, they can read what the application stores in them.\nThis might be especially critical if this information is sensitive.</p>\n<p>For example, an application might use temporary files to store users' session-related information. In such a case, attackers controlling those\nfiles can access session-stored information. This might allow them to take over authenticated users' identities and entitlements.</p>\n<h4>Attack surface extension</h4>\n<p>An application might use temporary files to store technical data for further reuse or as a communication channel between multiple components. In\nthat case, it might consider those files part of the trust boundaries and use their content without additional security validation or sanitation. In\nsuch a case, an attacker controlling the file content might use it as an attack vector for further compromise.</p>\n<p>For example, an application might store serialized data in temporary files for later use. In such a case, attackers controlling those files'\ncontent can change it in a way that will lead to an insecure deserialization exploitation. It might allow them to execute arbitrary code on the\napplication hosting server and take it over.</p>",
    "howToFix": "<p>The following code example is vulnerable to a race condition attack because it creates a temporary file using an unsafe API function.</p>\n<h4>Noncompliant code example</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\nimport java.io.File;\nimport java.io.IOException;\n\nprotected void Example() throws IOException {\n    File tempDir;\n    tempDir = File.createTempFile(\"\", \".\");\n    tempDir.delete();\n    tempDir.mkdir();  // Noncompliant\n}\n</pre>\n<h4>Compliant solution</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\nimport java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\n\nprotected void Example() throws IOException {\n    Path tempPath = Files.createTempDirectory(\"\");\n    File tempDir = tempPath.toFile();\n}\n</pre>\n<h3>How does this work?</h3>\n<p>Applications should create temporary files so that no third party can read or modify their content. It requires that the files' name, location, and\npermissions are carefully chosen and set. This can be achieved in multiple ways depending on the applications' technology stacks.</p>\n<h4>Use a secure API function</h4>\n<p>Temporary files handling APIs generally provide secure functions to create temporary files. In most cases, they operate in an atomical way,\ncreating and opening a file with a unique and unpredictable name in a single call. Those functions can often be used to replace less secure\nalternatives without requiring important development efforts.</p>\n<p>Here, the example compliant code uses the safer <code>Files.createTempDirectory</code> function to manage the creation of temporary\ndirectories.</p>\n<h4>Strong security controls</h4>\n<p>Temporary files can be created using unsafe functions and API as long as strong security controls are applied. Non-temporary file-handling\nfunctions and APIs can also be used for that purpose.</p>\n<p>In general, applications should ensure that attackers can not create a file before them. This turns into the following requirements when creating\nthe files:</p>\n<ul>\n  <li> Files should be created in a non-public directory. </li>\n  <li> File names should be unique. </li>\n  <li> File names should be unpredictable. They should be generated using a cryptographically secure random generator. </li>\n  <li> File creation should fail if a target file already exists. </li>\n</ul>\n<p>Moreover, when possible, it is recommended that applications destroy temporary files after they have finished using them.</p>",
    "moreInfo": "<h3>Documentation</h3>\n<ul>\n  <li> <a href=\"https://owasp.org/www-community/vulnerabilities/Insecure_Temporary_File\">OWASP</a> - Insecure Temporary File </li>\n</ul>\n<h3>Standards</h3>\n<ul>\n  <li> OWASP - <a href=\"https://owasp.org/Top10/A01_2021-Broken_Access_Control/\">Top 10 2021 Category A1 - Broken Access Control</a> </li>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/377\">CWE-377 - Insecure Temporary File</a> </li>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/379\">CWE-379 - Creation of Temporary File in Directory with Incorrect Permissions</a>\n  </li>\n  <li> STIG Viewer - <a href=\"https://stigviewer.com/stigs/application_security_and_development/2024-12-06/finding/V-222567\">Application Security and\n  Development: V-222567</a> - The application must not be vulnerable to race conditions. </li>\n</ul>",
    "status": "READY",
    "name_ko": "안전하지 않은 임시 파일 생성 메서드를 사용하면 안 됩니다",
    "why_ko": "<p>비원자적 방식으로 임시 파일을 생성하면 애플리케이션 동작에 경쟁 조건 문제가 발생합니다. 실제로 제3자가 애플리케이션이 이름을 선택하는 시점과 파일을 생성하는 시점 사이에 해당 파일을 생성할 수 있습니다.</p>\n<p>이러한 상황에서 애플리케이션은 완전히 제어하지 못하는 임시 파일을 사용할 수 있습니다. 특히 이 파일의 권한이 예상과 다를 수 있습니다. 이는 신뢰 경계 문제로 이어질 수 있습니다.</p>\n<h3>잠재적 영향은 무엇입니까?</h3>\n<p>취약한 애플리케이션에서 사용하는 임시 파일을 제어하는 공격자는 애플리케이션의 로직에 영향을 미치는 방식으로 파일을 수정할 수 있습니다. 이 파일의 접근 제어 목록이나 다른 운영 체제 수준 속성을 변경하여 파일이 삭제되거나 비워지는 것을 방지할 수 있습니다. 또한 애플리케이션이 사용하기 전이나 사용하는 동안 파일 내용을 변경할 수 있습니다.</p>\n<p>영향을 받는 임시 파일이 사용되는 이유와 방법에 따라 애플리케이션의 경쟁 조건 악용은 다양한 결과를 초래할 수 있습니다. 민감한 정보 노출부터 더 심각한 애플리케이션 또는 호스팅 인프라 침해까지 다양합니다.</p>\n<h4>정보 노출</h4>\n<p>공격자가 임시 파일에 설정된 권한을 제어하고 제거를 방지할 수 있으므로 애플리케이션이 저장하는 내용을 읽을 수 있습니다. 이 정보가 민감한 경우 특히 중요할 수 있습니다.</p>\n<p>예를 들어, 애플리케이션이 사용자의 세션 관련 정보를 저장하기 위해 임시 파일을 사용할 수 있습니다. 이러한 경우 해당 파일을 제어하는 공격자는 세션 저장 정보에 접근할 수 있습니다. 이를 통해 인증된 사용자의 신원과 권한을 탈취할 수 있습니다.</p>\n<h4>공격 표면 확장</h4>\n<p>애플리케이션은 기술 데이터를 추가로 재사용하기 위해 또는 여러 구성 요소 간의 통신 채널로 임시 파일을 사용할 수 있습니다. 이 경우 해당 파일을 신뢰 경계의 일부로 간주하고 추가 보안 검증이나 정제 없이 내용을 사용할 수 있습니다. 이러한 경우 파일 내용을 제어하는 공격자는 이를 추가 침해를 위한 공격 벡터로 사용할 수 있습니다.</p>\n<p>예를 들어, 애플리케이션이 나중에 사용하기 위해 직렬화된 데이터를 임시 파일에 저장할 수 있습니다. 이러한 경우 해당 파일의 내용을 제어하는 공격자는 안전하지 않은 역직렬화 악용으로 이어지는 방식으로 내용을 변경할 수 있습니다. 이를 통해 애플리케이션 호스팅 서버에서 임의의 코드를 실행하고 탈취할 수 있습니다.</p>",
    "howToFix_ko": "<p>다음 코드 예시는 안전하지 않은 API 함수를 사용하여 임시 파일을 생성하기 때문에 경쟁 조건 공격에 취약합니다.</p>\n<h4>규칙을 준수하지 않는 코드 예시</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\nimport java.io.File;\nimport java.io.IOException;\n\nprotected void Example() throws IOException {\n    File tempDir;\n    tempDir = File.createTempFile(\"\", \".\");\n    tempDir.delete();\n    tempDir.mkdir();  // 규칙 위반\n}\n</pre>\n<h4>규칙을 준수하는 해결책</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\nimport java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\n\nprotected void Example() throws IOException {\n    Path tempPath = Files.createTempDirectory(\"\");\n    File tempDir = tempPath.toFile();\n}\n</pre>\n<h3>어떻게 작동합니까?</h3>\n<p>애플리케이션은 제3자가 내용을 읽거나 수정할 수 없도록 임시 파일을 생성해야 합니다. 이를 위해서는 파일의 이름, 위치 및 권한을 신중하게 선택하고 설정해야 합니다. 이는 애플리케이션의 기술 스택에 따라 여러 방법으로 달성할 수 있습니다.</p>\n<h4>안전한 API 함수 사용</h4>\n<p>임시 파일 처리 API는 일반적으로 임시 파일을 생성하기 위한 안전한 함수를 제공합니다. 대부분의 경우 원자적으로 작동하여 단일 호출로 고유하고 예측 불가능한 이름을 가진 파일을 생성하고 엽니다. 이러한 함수는 중요한 개발 노력 없이 덜 안전한 대안을 대체하는 데 자주 사용될 수 있습니다.</p>\n<p>여기서 규칙을 준수하는 코드 예시는 임시 디렉토리 생성을 관리하기 위해 더 안전한 <code>Files.createTempDirectory</code> 함수를 사용합니다.</p>\n<h4>강력한 보안 제어</h4>\n<p>강력한 보안 제어가 적용되는 한 안전하지 않은 함수와 API를 사용하여 임시 파일을 생성할 수 있습니다. 비임시 파일 처리 함수와 API도 해당 목적으로 사용할 수 있습니다.</p>\n<p>일반적으로 애플리케이션은 공격자가 자신보다 먼저 파일을 생성할 수 없도록 해야 합니다. 이는 파일 생성 시 다음 요구 사항으로 전환됩니다:</p>\n<ul>\n  <li> 파일은 비공개 디렉토리에 생성되어야 합니다. </li>\n  <li> 파일 이름은 고유해야 합니다. </li>\n  <li> 파일 이름은 예측 불가능해야 합니다. 암호학적으로 안전한 난수 생성기를 사용하여 생성해야 합니다. </li>\n  <li> 대상 파일이 이미 존재하면 파일 생성이 실패해야 합니다. </li>\n</ul>\n<p>또한 가능하면 애플리케이션이 사용을 마친 후 임시 파일을 삭제하는 것이 좋습니다.</p>",
    "moreInfo_ko": "<h3>문서</h3>\n<ul>\n  <li> <a href=\"https://owasp.org/www-community/vulnerabilities/Insecure_Temporary_File\">OWASP</a> - 안전하지 않은 임시 파일 </li>\n</ul>\n<h3>표준</h3>\n<ul>\n  <li> OWASP - <a href=\"https://owasp.org/Top10/A01_2021-Broken_Access_Control/\">Top 10 2021 Category A1 - Broken Access Control</a> </li>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/377\">CWE-377 - 안전하지 않은 임시 파일</a> </li>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/379\">CWE-379 - 잘못된 권한을 가진 디렉토리에서 임시 파일 생성</a> </li>\n  <li> STIG Viewer - <a href=\"https://stigviewer.com/stigs/application_security_and_development/2024-12-06/finding/V-222567\">Application Security and Development: V-222567</a> - 애플리케이션은 경쟁 조건에 취약하지 않아야 합니다. </li>\n</ul>"
  },
  {
    "id": "S7478",
    "key": "java:S7478",
    "name": "\"transformClass\" method should be used instead of \"build\" when transforming a class",
    "type": "code-smell",
    "severity": "minor",
    "tags": [
      "java24"
    ],
    "why": "<p>The common pattern of taking a class-file entity, obtaining a corresponding builder, examining each element of the entity and possibly replacing it\nwith other elements can be expressed by transforms. Using the <code>transformClass</code> method in that case instead of <code>build</code> removes\nall that boilerplate and makes the intent clearer.</p>",
    "howToFix": "<p>Use the <code>ClassFile.transformClass</code> method instead of <code>ClassFile.build</code>.</p>\n\n<h4>Noncompliant code example</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\npublic static void transformClassFile(Path path) throws IOException {\n  ClassFile classFile = ClassFile.of();\n  ClassModel classModel = classFile.parse(path);\n  byte[] newBytes = classFile.build( // Noncompliant\n    classModel.thisClass().asSymbol(), classBuilder -&gt; {\n        for (ClassElement classElement : classModel) {\n          if (!(classElement instanceof MethodModel methodModel &amp;&amp;\n              methodModel.methodName().stringValue().startsWith(\"debug\"))) {\n            classBuilder.with(classElement);\n\n          }\n        }\n    });\n  Files.write(path, newBytes);\n}\n</pre>\n<h4>Compliant solution</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\npublic static void transformClassFile(Path path) throws IOException {\n  ClassFile classFile = ClassFile.of();\n  ClassModel classModel = classFile.parse(path);\n  byte[] newBytes = classFile.transformClass(\n    classModel, (classBuilder, classElement) -&gt; {\n      if (!(classElement instanceof MethodModel methodModel &amp;&amp;\n            methodModel.methodName().stringValue().startsWith(\"debug\"))) {\n          classBuilder.with(classElement);\n        }\n      });\n  Files.write(path, newBytes);\n}\n</pre>",
    "moreInfo": "<ul>\n  <li> <a href=\"https://openjdk.org/jeps/484\">JEP 484: Class-File API</a> </li>\n  <li> <a\n  href=\"https://docs.oracle.com/en/java/javase/24/docs/api/java.base/java/lang/classfile/ClassFile.html#transformClass(java.lang.classfile.ClassModel,java.lang.classfile.ClassTransform)\">ClassFile API</a> </li>\n</ul>",
    "status": "READY",
    "name_ko": "클래스 변환 시 \"build\" 대신 \"transformClass\" 메서드를 사용해야 합니다",
    "why_ko": "<p>class-file 엔티티를 가져와서 해당 빌더를 얻고, 엔티티의 각 요소를 검사하여 다른 요소로 교체할 수 있는 일반적인 패턴은 변환으로 표현할 수 있습니다. 이 경우 <code>build</code> 대신 <code>transformClass</code> 메서드를 사용하면 모든 보일러플레이트 코드가 제거되고 의도가 더 명확해집니다.</p>",
    "howToFix_ko": "<p><code>ClassFile.build</code> 대신 <code>ClassFile.transformClass</code> 메서드를 사용하세요.</p>\n\n<h4>규칙을 준수하지 않는 코드 예시</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\npublic static void transformClassFile(Path path) throws IOException {\n  ClassFile classFile = ClassFile.of();\n  ClassModel classModel = classFile.parse(path);\n  byte[] newBytes = classFile.build( // 규칙 위반\n    classModel.thisClass().asSymbol(), classBuilder -&gt; {\n        for (ClassElement classElement : classModel) {\n          if (!(classElement instanceof MethodModel methodModel &amp;&amp;\n              methodModel.methodName().stringValue().startsWith(\"debug\"))) {\n            classBuilder.with(classElement);\n\n          }\n        }\n    });\n  Files.write(path, newBytes);\n}\n</pre>\n<h4>규칙을 준수하는 해결책</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\npublic static void transformClassFile(Path path) throws IOException {\n  ClassFile classFile = ClassFile.of();\n  ClassModel classModel = classFile.parse(path);\n  byte[] newBytes = classFile.transformClass(\n    classModel, (classBuilder, classElement) -&gt; {\n      if (!(classElement instanceof MethodModel methodModel &amp;&amp;\n            methodModel.methodName().stringValue().startsWith(\"debug\"))) {\n          classBuilder.with(classElement);\n        }\n      });\n  Files.write(path, newBytes);\n}\n</pre>",
    "moreInfo_ko": "<ul>\n  <li> <a href=\"https://openjdk.org/jeps/484\">JEP 484: Class-File API</a> </li>\n  <li> <a href=\"https://docs.oracle.com/en/java/javase/24/docs/api/java.base/java/lang/classfile/ClassFile.html#transformClass(java.lang.classfile.ClassModel,java.lang.classfile.ClassTransform)\">ClassFile API</a> </li>\n</ul>"
  },
  {
    "id": "S115",
    "key": "java:S115",
    "name": "Constant names should comply with a naming convention",
    "type": "code-smell",
    "severity": "critical",
    "tags": [
      "convention"
    ],
    "why": "<p>Constants are variables whose value does not change during the runtime of a program after initialization. Oftentimes, constants are used in\nmultiple locations across different subroutines.</p>\n<p>It is important that the names of constants follow a consistent and easily recognizable pattern. This way, readers immediately understand that the\nreferenced value does not change, which simplifies debugging.</p>\n<p>Or, in the case of primitive constants, that accessing the constant is thread-safe.</p>\n<p>This rule checks that all constant names match a given regular expression.</p>\n<h3>What is the potential impact?</h3>\n<p>Ignoring the naming convention for constants makes the code less readable since constants and variables are harder to tell apart. Code that is hard\nto understand is also difficult to maintain between different team members.</p>",
    "howToFix": "<p>First, familiarize yourself with the particular naming convention of the project in question. Then, update the name of the constant to match the\nconvention, as well as all usages of the name. For many IDEs, you can use built-in renaming and refactoring features to update all usages of a\nconstant at once.</p>\n\n<h4>Noncompliant code example</h4>\n<p>The following example assumes that constant names should match the default regular expression <code>^[A-Z][A-Z0-9]*(_[A-Z0-9]+)*$</code>:</p>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\npublic class MyClass {\n  public static final float pi = 3.14159f; // Noncompliant: Constant is not capitalized\n\n  void myMethod() {\n    System.out.println(pi);\n  }\n}\n\npublic enum MyEnum {\n  optionOne, // Noncompliant\n  optionTwo; // Noncompliant\n}\n</pre>\n<h4>Compliant solution</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\npublic class MyClass {\n  public static final float PI = 3.14159f;\n\n  void myMethod() {\n    System.out.println(PI);\n  }\n}\n\npublic enum MyEnum {\n  OPTION_ONE,\n  OPTION_TWO;\n}\n</pre>\n<h3>Exceptions</h3>\n<p>The rule applies to fields of primitive types (for example, <code>float</code>), boxed primitives (<code>Float</code>), and Strings. We do not\napply it to other types, which can be mutated, or have methods with side effects.</p>\n<pre>\npublic static final Logger log = getLogger(MyClass.class);\npublic static final List&lt;Integer&gt; myList = new ArrayList&lt;&gt;();\n\n// call with side-effects\nlog.info(\"message\")\n\n// mutating an object\nmyList.add(28);\n</pre>",
    "moreInfo": "<h3>External coding guidelines</h3>\n<ul>\n  <li> <a href=\"https://google.github.io/styleguide/javaguide.html#s5.2.4-constant-names\">The Google Java Style Guide on Constant Names</a>. </li>\n</ul>",
    "status": "READY",
    "name_ko": "상수 이름은 명명 규칙을 준수해야 합니다",
    "why_ko": "<p>상수는 초기화 후 프로그램 런타임 동안 값이 변경되지 않는 변수입니다. 종종 상수는 다른 서브루틴에 걸쳐 여러 위치에서 사용됩니다.</p>\n<p>상수의 이름이 일관되고 쉽게 인식할 수 있는 패턴을 따르는 것이 중요합니다. 이렇게 하면 독자가 참조된 값이 변경되지 않는다는 것을 즉시 이해하여 디버깅이 간단해집니다.</p>\n<p>또는 기본 타입 상수의 경우 상수에 접근하는 것이 스레드 안전합니다.</p>\n<p>이 규칙은 모든 상수 이름이 주어진 정규 표현식과 일치하는지 확인합니다.</p>\n<h3>잠재적 영향은 무엇인가요?</h3>\n<p>상수에 대한 명명 규칙을 무시하면 상수와 변수를 구별하기 어려워지므로 코드를 읽기 어려워집니다. 이해하기 어려운 코드는 서로 다른 팀원 간에 유지 관리하기도 어렵습니다.</p>",
    "howToFix_ko": "<p>먼저 해당 프로젝트의 특정 명명 규칙을 숙지하세요. 그런 다음 상수의 이름과 이름의 모든 사용을 규칙에 맞게 업데이트하세요. 많은 IDE에서 내장된 이름 바꾸기 및 리팩터링 기능을 사용하여 상수의 모든 사용을 한 번에 업데이트할 수 있습니다.</p>\n\n<h4>규칙을 준수하지 않는 코드 예시</h4>\n<p>다음 예시는 상수 이름이 기본 정규 표현식 <code>^[A-Z][A-Z0-9]*(_[A-Z0-9]+)*$</code>와 일치해야 한다고 가정합니다:</p>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\npublic class MyClass {\n  public static final float pi = 3.14159f; // 규칙 위반: 상수가 대문자화되지 않음\n\n  void myMethod() {\n    System.out.println(pi);\n  }\n}\n\npublic enum MyEnum {\n  optionOne, // 규칙 위반\n  optionTwo; // 규칙 위반\n}\n</pre>\n<h4>규칙을 준수하는 해결책</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\npublic class MyClass {\n  public static final float PI = 3.14159f;\n\n  void myMethod() {\n    System.out.println(PI);\n  }\n}\n\npublic enum MyEnum {\n  OPTION_ONE,\n  OPTION_TWO;\n}\n</pre>\n<h3>예외</h3>\n<p>규칙은 기본 타입 필드(예: <code>float</code>), 박싱된 기본 타입(<code>Float</code>), 문자열에 적용됩니다. 변경될 수 있거나 부작용이 있는 메서드가 있는 다른 타입에는 적용하지 않습니다.</p>\n<pre>\npublic static final Logger log = getLogger(MyClass.class);\npublic static final List&lt;Integer&gt; myList = new ArrayList&lt;&gt;();\n\n// 부작용이 있는 호출\nlog.info(\"message\")\n\n// 객체 변경\nmyList.add(28);\n</pre>",
    "moreInfo_ko": "<h3>외부 코딩 가이드라인</h3>\n<ul>\n  <li> <a href=\"https://google.github.io/styleguide/javaguide.html#s5.2.4-constant-names\">Google Java 스타일 가이드 - 상수 이름</a>. </li>\n</ul>"
  },
  {
    "id": "S4604",
    "key": "java:S4604",
    "name": "\"@EnableAutoConfiguration\" should be fine-tuned",
    "type": "code-smell",
    "severity": "major",
    "tags": [],
    "why": "<p>\"@EnableAutoConfiguration\" is a convenient feature to configure the Spring Application Context by attempting to guess the beans that you are likely\nto need. The drawback is that it may load and configure beans the application will never use and therefore consume more CPU and RAM than really\nrequired. <code>@EnableAutoConfiguration</code> should be configured to exclude all the beans not required by the application. Alternatively, use the\n<code>@Import</code> annotation instead of <code>@EnableAutoConfiguration</code>, to explicitly import the useful AutoConfiguration classes.</p>\n<p>This rule applies for <code>@SpringBootApplication</code> as well.</p>\n<h3>Noncompliant code example</h3>\n<pre>\n@SpringBootApplication\npublic class MyApplication {\n...\n}\n</pre>\n<pre>\n@Configuration\n@EnableAutoConfiguration\npublic class MyApplication {\n...\n}\n</pre>\n<h3>Compliant solution</h3>\n<pre>\n@SpringBootApplication(exclude = {\n  MultipartAutoConfiguration.class,\n  JmxAutoConfiguration.class,\n})\npublic class MyApplication {\n...\n}\n</pre>\n<pre>\n@Configuration\n@EnableAutoConfiguration(exclude = {\n  MultipartAutoConfiguration.class,\n  JmxAutoConfiguration.class,\n})\npublic class MyApplication {\n...\n}\n</pre>\n<pre>\n@Configuration\n@Import({\n        DispatcherServletAutoConfiguration.class,\n        EmbeddedServletContainerAutoConfiguration.class,\n        ErrorMvcAutoConfiguration.class,\n        HttpEncodingAutoConfiguration.class,\n        HttpMessageConvertersAutoConfiguration.class,\n        JacksonAutoConfiguration.class,\n        ServerPropertiesAutoConfiguration.class,\n        PropertyPlaceholderAutoConfiguration.class,\n        ThymeleafAutoConfiguration.class,\n        WebMvcAutoConfiguration.class\n})\npublic class MyApplication {\n...\n}\n</pre>",
    "howToFix": "",
    "moreInfo": "",
    "status": "DEPRECATED",
    "name_ko": "@EnableAutoConfiguration은 세밀하게 조정해야 합니다",
    "why_ko": "<p>\"@EnableAutoConfiguration\"은 필요할 것으로 추정되는 빈을 추측하여 Spring Application Context를 구성하는 편리한 기능입니다. 단점은 애플리케이션이 사용하지 않을 빈을 로드하고 구성할 수 있어 실제로 필요한 것보다 더 많은 CPU와 RAM을 소비할 수 있다는 것입니다. <code>@EnableAutoConfiguration</code>은 애플리케이션에 필요하지 않은 모든 빈을 제외하도록 구성해야 합니다. 또는 <code>@EnableAutoConfiguration</code> 대신 <code>@Import</code> 어노테이션을 사용하여 유용한 AutoConfiguration 클래스를 명시적으로 가져올 수 있습니다.</p>\n<p>이 규칙은 <code>@SpringBootApplication</code>에도 적용됩니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\n@SpringBootApplication\npublic class MyApplication {\n...\n}\n</pre>\n<pre>\n@Configuration\n@EnableAutoConfiguration\npublic class MyApplication {\n...\n}\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre>\n@SpringBootApplication(exclude = {\n  MultipartAutoConfiguration.class,\n  JmxAutoConfiguration.class,\n})\npublic class MyApplication {\n...\n}\n</pre>\n<pre>\n@Configuration\n@EnableAutoConfiguration(exclude = {\n  MultipartAutoConfiguration.class,\n  JmxAutoConfiguration.class,\n})\npublic class MyApplication {\n...\n}\n</pre>\n<pre>\n@Configuration\n@Import({\n        DispatcherServletAutoConfiguration.class,\n        EmbeddedServletContainerAutoConfiguration.class,\n        ErrorMvcAutoConfiguration.class,\n        HttpEncodingAutoConfiguration.class,\n        HttpMessageConvertersAutoConfiguration.class,\n        JacksonAutoConfiguration.class,\n        ServerPropertiesAutoConfiguration.class,\n        PropertyPlaceholderAutoConfiguration.class,\n        ThymeleafAutoConfiguration.class,\n        WebMvcAutoConfiguration.class\n})\npublic class MyApplication {\n...\n}\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": ""
  },
  {
    "id": "S6814",
    "key": "java:S6814",
    "name": "Optional REST parameters should have an object type",
    "type": "code-smell",
    "severity": "critical",
    "tags": [],
    "why": "<p>Spring provides two options to mark a REST parameter as optional:</p>\n<ol>\n  <li> Use <code>required = false</code> in the <code>@PathVariable</code> or <code>@RequestParam</code> annotation of the respective method parameter\n  or </li>\n  <li> Use type <code>java.util.Optional&lt;T&gt;</code> for the method parameter </li>\n</ol>\n<p>When using 1., the absence of the parameter, when the REST function is called, is encoded by <code>null</code>, which can only be used for object\ntypes. If <code>required = false</code> is used for a parameter with a primitive and the REST function is called without the parameter, a runtime\nexception occurs because the Spring data mapper cannot map the <code>null</code> value to the parameter.</p>",
    "howToFix": "<p>Replace primitive types, such as <code>boolean</code>, <code>char</code>, <code>int</code>, with the corresponding wrapper type, such as\n<code>Boolean</code>, <code>Character</code>, <code>Integer</code>.</p>\n<p>Alternatively, you might choose to remove <code>required = false</code> from the annotation and use an <code>Optional&lt;T&gt;</code> type for the\nparameter, such as <code>Optional&lt;Boolean&gt;</code> or <code>Optional&lt;String&gt;</code>, which automatically makes the REST parameter optional.\nThis is the preferred approach because it enforces the proper handling of <code>null</code> in the method implementation.</p>\n\n<h4>Noncompliant code example</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\n@RequestMapping(value = {\"/article\", \"/article/{id}\"})\npublic Article getArticle(@PathVariable(required = false) int articleId) { // Noncompliant, null cannot be mapped to int\n   //...\n}\n</pre>\n<h4>Compliant solution</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\n@RequestMapping(value = {\"/article\", \"/article/{id}\"})\npublic Article getArticle(@PathVariable(required = false) Integer articleId) { // Compliant\n   //...\n}\n</pre>\n<h4>Noncompliant code example</h4>\n<pre data-diff-id=\"2\" data-diff-type=\"noncompliant\">\n@RequestMapping(value = {\"/article\", \"/article/{id}\"})\npublic Article getArticle(@PathVariable(required = false) int articleId) { // Noncompliant, null cannot be mapped to int\n   //...\n}\n</pre>\n<h4>Compliant solution</h4>\n<pre data-diff-id=\"2\" data-diff-type=\"compliant\">\n@RequestMapping(value = {\"/article\", \"/article/{id}\"})\npublic Article getArticle(@PathVariable Optional&lt;Integer&gt; articleId) { // Compliant and preferred approach\n   //...\n}\n</pre>",
    "moreInfo": "<h3>Documentation</h3>\n<ul>\n  <li> <a href=\"https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/web/bind/annotation/PathVariable.html\">Spring\n  Framework API - Annotation Interface PathVariable</a> </li>\n</ul>\n<h3>Articles &amp; blog posts</h3>\n<ul>\n  <li> <a href=\"https://www.baeldung.com/spring-optional-path-variables\">Baeldung - Spring Optional Path Variables</a> </li>\n</ul>",
    "status": "READY",
    "name_ko": "선택적 REST 파라미터는 객체 타입이어야 합니다",
    "why_ko": "<p>Spring은 REST 파라미터를 선택적으로 표시하기 위한 두 가지 옵션을 제공합니다:</p>\n<ol>\n  <li> 해당 메서드 파라미터의 <code>@PathVariable</code> 또는 <code>@RequestParam</code> 어노테이션에서 <code>required = false</code>를 사용하거나 </li>\n  <li> 메서드 파라미터에 <code>java.util.Optional&lt;T&gt;</code> 타입을 사용 </li>\n</ol>\n<p>1.을 사용할 때 REST 함수가 호출될 때 파라미터가 없으면 <code>null</code>로 인코딩되며, 이는 객체 타입에만 사용할 수 있습니다. 기본 타입의 파라미터에 <code>required = false</code>를 사용하고 파라미터 없이 REST 함수를 호출하면 Spring 데이터 매퍼가 <code>null</code> 값을 파라미터에 매핑할 수 없어 런타임 예외가 발생합니다.</p>",
    "howToFix_ko": "<p><code>boolean</code>, <code>char</code>, <code>int</code>와 같은 기본 타입을 <code>Boolean</code>, <code>Character</code>, <code>Integer</code>와 같은 해당 래퍼 타입으로 교체하세요.</p>\n<p>또는 어노테이션에서 <code>required = false</code>를 제거하고 파라미터에 <code>Optional&lt;Boolean&gt;</code> 또는 <code>Optional&lt;String&gt;</code>과 같은 <code>Optional&lt;T&gt;</code> 타입을 사용할 수 있으며, 이렇게 하면 REST 파라미터가 자동으로 선택적이 됩니다. 이것이 메서드 구현에서 <code>null</code>의 적절한 처리를 강제하기 때문에 선호되는 접근 방식입니다.</p>\n\n<h4>규칙을 준수하지 않는 코드 예시</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\n@RequestMapping(value = {\"/article\", \"/article/{id}\"})\npublic Article getArticle(@PathVariable(required = false) int articleId) { // 규칙 위반, null은 int에 매핑될 수 없습니다\n   //...\n}\n</pre>\n<h4>규칙을 준수하는 해결책</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\n@RequestMapping(value = {\"/article\", \"/article/{id}\"})\npublic Article getArticle(@PathVariable(required = false) Integer articleId) { // 규칙 준수\n   //...\n}\n</pre>\n<h4>규칙을 준수하지 않는 코드 예시</h4>\n<pre data-diff-id=\"2\" data-diff-type=\"noncompliant\">\n@RequestMapping(value = {\"/article\", \"/article/{id}\"})\npublic Article getArticle(@PathVariable(required = false) int articleId) { // 규칙 위반, null은 int에 매핑될 수 없습니다\n   //...\n}\n</pre>\n<h4>규칙을 준수하는 해결책</h4>\n<pre data-diff-id=\"2\" data-diff-type=\"compliant\">\n@RequestMapping(value = {\"/article\", \"/article/{id}\"})\npublic Article getArticle(@PathVariable Optional&lt;Integer&gt; articleId) { // 규칙 준수, 선호되는 접근 방식\n   //...\n}\n</pre>",
    "moreInfo_ko": "<h3>문서</h3>\n<ul>\n  <li> <a href=\"https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/web/bind/annotation/PathVariable.html\">Spring Framework API - 어노테이션 인터페이스 PathVariable</a> </li>\n</ul>\n<h3>기사 및 블로그 게시물</h3>\n<ul>\n  <li> <a href=\"https://www.baeldung.com/spring-optional-path-variables\">Baeldung - Spring 선택적 경로 변수</a> </li>\n</ul>"
  },
  {
    "id": "S2154",
    "key": "java:S2154",
    "name": "Dissimilar primitive wrappers should not be used with the ternary operator without explicit casting",
    "type": "bug",
    "severity": "major",
    "tags": [],
    "why": "<p>Using boxed values in a ternary operator does not simply return one operand or the other based on the condition. Instead, the values are unboxed\nand coerced to a common type, which can result in a loss of precision when converting one operand from <code>int</code> to <code>float</code> or from\n<code>long</code> to <code>double</code>.</p>\n<p>While this behavior is expected for arithmetic operations, it may be unexpected for the ternary operator. To avoid confusion or unexpected\nbehavior, cast to a compatible type explicitly.</p>",
    "howToFix": "<h4>Noncompliant code example</h4>\n<p>Cast one of both operands to a common supertype (e.g., <code>Number</code>) to prevent auto-unboxing and, thus, type coercion.</p>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\nInteger i = 123456789;\nFloat f = 1.0f;\nNumber n1 = condition ? i : f;  // Noncompliant, unexpected precision loss, n1 = 1.23456792E8\n</pre>\n<h4>Compliant solution</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\nInteger i = 123456789;\nFloat f = 1.0f;\nNumber n1 = condition ? (Number) i : f; // Compliant, cast to Number prevents unboxing\nNumber n2 = condition ? i : (Number) f; // Compliant, cast to Number prevents unboxing\n</pre>\n<h4>Noncompliant code example</h4>\n<p>If type coercion was your intention, clarify this by casting the operand that would be coerced to the corresponding type explicitly.</p>\n<pre data-diff-id=\"2\" data-diff-type=\"noncompliant\">\nInteger i = 123456789;\nFloat f = 1.0f;\nNumber n1 = condition ? i : f;  // Noncompliant, unexpected precision loss, n1 = 1.23456792E8\n</pre>\n<h4>Compliant solution</h4>\n<pre data-diff-id=\"2\" data-diff-type=\"compliant\">\nInteger i = 123456789;\nFloat f = 1.0f;\nNumber n = condition ? (float) i : f; // Compliant, intentional type coercion with precision loss\n</pre>",
    "moreInfo": "<h3>Documentation</h3>\n<ul>\n  <li> <a href=\"https://docs.oracle.com/javase/tutorial/java/nutsandbolts/op2.html\">The Java Tutorials: Equality, Relational, and Conditional\n  Operators</a> </li>\n  <li> <a href=\"https://docs.oracle.com/javase/tutorial/java/data/autoboxing.html\">The Java Tutorials: Autoboxing and Unboxing</a> </li>\n  <li> <a href=\"https://docs.oracle.com/javase/specs/jls/se7/html/jls-5.html\">The Java® Language Specification Java SE 7 Edition: Chapter 5.\n  Conversions and Promotions</a> </li>\n</ul>\n<h3>Articles &amp; blog posts</h3>\n<ul>\n  <li> <a href=\"https://www.geeksforgeeks.org/coercion-in-java/\">GeeksforGeeks: Coercion in Java</a> </li>\n</ul>",
    "status": "READY",
    "name_ko": "서로 다른 primitive wrapper는 명시적 캐스팅 없이 삼항 연산자에서 사용하면 안 됩니다",
    "why_ko": "<p>삼항 연산자에서 boxed 값을 사용하면 조건에 따라 단순히 하나의 피연산자 또는 다른 피연산자를 반환하지 않습니다. 대신 값이 unbox되고 공통 타입으로 강제 변환되어 <code>int</code>에서 <code>float</code>로 또는 <code>long</code>에서 <code>double</code>로 변환할 때 정밀도 손실이 발생할 수 있습니다.</p>\n<p>이 동작은 산술 연산에서는 예상되는 것이지만 삼항 연산자에서는 예상치 못한 것일 수 있습니다. 혼란이나 예상치 못한 동작을 피하려면 호환 가능한 타입으로 명시적으로 캐스팅하세요.</p>",
    "howToFix_ko": "<h4>규칙을 준수하지 않는 코드 예시</h4>\n<p>자동 unboxing과 타입 강제 변환을 방지하려면 두 피연산자 중 하나를 공통 상위 타입(예: <code>Number</code>)으로 캐스팅하세요.</p>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\nInteger i = 123456789;\nFloat f = 1.0f;\nNumber n1 = condition ? i : f;  // 규칙 위반, 예상치 못한 정밀도 손실, n1 = 1.23456792E8\n</pre>\n<h4>규칙을 준수하는 해결책</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\nInteger i = 123456789;\nFloat f = 1.0f;\nNumber n1 = condition ? (Number) i : f; // 규칙 준수, Number로 캐스팅하면 unboxing 방지\nNumber n2 = condition ? i : (Number) f; // 규칙 준수, Number로 캐스팅하면 unboxing 방지\n</pre>\n<h4>규칙을 준수하지 않는 코드 예시</h4>\n<p>타입 강제 변환이 의도한 것이라면 강제 변환될 피연산자를 해당 타입으로 명시적으로 캐스팅하여 이를 명확히 하세요.</p>\n<pre data-diff-id=\"2\" data-diff-type=\"noncompliant\">\nInteger i = 123456789;\nFloat f = 1.0f;\nNumber n1 = condition ? i : f;  // 규칙 위반, 예상치 못한 정밀도 손실, n1 = 1.23456792E8\n</pre>\n<h4>규칙을 준수하는 해결책</h4>\n<pre data-diff-id=\"2\" data-diff-type=\"compliant\">\nInteger i = 123456789;\nFloat f = 1.0f;\nNumber n = condition ? (float) i : f; // 규칙 준수, 정밀도 손실이 있는 의도적인 타입 강제 변환\n</pre>","moreInfo_ko": "<h3>문서</h3>\n<ul>\n  <li> <a href=\"https://docs.oracle.com/javase/tutorial/java/nutsandbolts/op2.html\">Java 튜토리얼: 동등성, 관계형 및 조건 연산자</a> </li>\n  <li> <a href=\"https://docs.oracle.com/javase/tutorial/java/data/autoboxing.html\">Java 튜토리얼: Autoboxing과 Unboxing</a> </li>\n  <li> <a href=\"https://docs.oracle.com/javase/specs/jls/se7/html/jls-5.html\">Java® 언어 명세 Java SE 7 에디션: 5장. 변환 및 프로모션</a> </li>\n</ul>\n<h3>관련 문서 및 블로그 게시물</h3>\n<ul>\n  <li> <a href=\"https://www.geeksforgeeks.org/coercion-in-java/\">GeeksforGeeks: Java의 Coercion</a> </li>\n</ul>"
  },
  {
    "id": "S2441",
    "key": "java:S2441",
    "name": "Non-serializable objects should not be stored in \"javax.servlet.http.HttpSession\" instances",
    "type": "bug",
    "severity": "major",
    "tags": [
      "cwe"
    ],
    "why": "<p><code>HttpSession</code> s are managed by web servers and can be serialized and stored on disk as the server manages its memory use in a process\ncalled \"passivation\" (and later restored during \"activation\").</p>\n<p>Even though <code>HttpSession</code> does not extend <code>Serializable</code>, you must nonetheless assume that it will be serialized. If\nnon-serializable objects are stored in the session, serialization might fail.</p>\n<h3>Noncompliant code example</h3>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\npublic class Address {\n  //...\n}\n\nHttpSession session = request.getSession();\nsession.setAttribute(\"address\", new Address());  // Noncompliant; Address isn't serializable\n</pre>\n<h3>Compliant solution</h3>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\npublic class Address implements Serializable {\n  //...\n}\n\nHttpSession session = request.getSession();\nsession.setAttribute(\"address\", new Address());\n</pre>",
    "howToFix": "",
    "moreInfo": "<ul>\n  <li> OWASP - <a href=\"https://owasp.org/Top10/A04_2021-Insecure_Design/\">Top 10 2021 Category A4 - Insecure Design</a> </li>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/579\">CWE-579 - J2EE Bad Practices: Non-serializable Object Stored in Session</a> </li>\n</ul>",
    "status": "READY",
    "name_ko": "Serializable하지 않은 객체를 \"HttpSession\"에 저장하면 안 됩니다",
    "why_ko": "<p><code>HttpSession</code>은 웹 서버에 의해 관리되며, 서버가 \"비활성화(passivation)\"라는 프로세스에서 메모리 사용을 관리할 때 직렬화되어 디스크에 저장될 수 있습니다(나중에 \"활성화(activation)\" 중에 복원됨).</p>\n<p><code>HttpSession</code>이 <code>Serializable</code>을 확장하지 않더라도, 직렬화될 것이라고 가정해야 합니다. 세션에 직렬화 불가능한 객체가 저장되면 직렬화가 실패할 수 있습니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\npublic class Address {\n  //...\n}\n\nHttpSession session = request.getSession();\nsession.setAttribute(\"address\", new Address());  // 규칙 위반; Address가 serializable하지 않음\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\npublic class Address implements Serializable {\n  //...\n}\n\nHttpSession session = request.getSession();\nsession.setAttribute(\"address\", new Address());\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": "<ul>\n  <li> OWASP - <a href=\"https://owasp.org/Top10/A04_2021-Insecure_Design/\">Top 10 2021 Category A4 - 안전하지 않은 설계</a> </li>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/579\">CWE-579 - J2EE 나쁜 관행: 세션에 저장된 Serializable하지 않은 객체</a> </li>\n</ul>"
  },
  {
    "id": "S5804",
    "key": "java:S5804",
    "name": "Allowing user enumeration is security-sensitive",
    "type": "security-hotspot",
    "severity": "major",
    "tags": [
      "spring",
      "cwe"
    ],
    "why": "<p>User enumeration refers to the ability to guess existing usernames in a web application database. This can happen, for example, when using\n\"sign-in/sign-on/forgot password\" functionalities of a website.</p>\n<p>When an user tries to \"sign-in\" to a website with an incorrect username/login, the web application should not disclose that the username doesn't\nexist with a message similar to \"this username is incorrect\", instead a generic message should be used like \"bad credentials\", this way it's not\npossible to guess whether the username or password was incorrect during the authentication.</p>\n<p>If a user-management feature discloses information about the existence of a username, attackers can use brute force attacks to retrieve a large\namount of valid usernames that will impact the privacy of corresponding users and facilitate other attacks (phishing, password guessing etc …​).</p>\n",
    "howToFix": "<h2>Recommended Secure Coding Practices</h2>\n<p>When a user performs a request involving a username, it should not be possible to spot differences between a valid and incorrect username:</p>\n<ul>\n  <li> Error messages should be generic and not disclose if the username is valid or not. </li>\n  <li> The response time must be similar for a valid username or not. </li>\n  <li> CAPTCHA and other rate limiting solutions should be implemented. </li>\n</ul>\n<h2>Compliant Solution</h2>\n<p>In a Spring-security web application:</p>\n<ul>\n  <li> the same message should be used regardless of whether it is the wrong user or password: </li>\n</ul>\n<pre>\npublic String authenticate(String username, String password) throws AuthenticationException {\n  Details user = null;\n  try {\n    user = loadUserByUsername(username);\n  } catch (UsernameNotFoundException | DataAccessException e) {\n    // Hide this exception reason to not disclose that the username doesn't exist\n  }\n  if (user == null || !user.isPasswordCorrect(password)) {\n     // User should not be able to guess if the bad credentials message is related to the username or the password\n    throw new BadCredentialsException(\"Bad credentials\");\n  }\n}\n</pre>\n<ul>\n  <li> <a\n  href=\"https://docs.spring.io/spring-security/site/docs/4.0.x/apidocs/org/springframework/security/authentication/dao/AbstractUserDetailsAuthenticationProvider.html#setHideUserNotFoundExceptions-boolean-\">HideUserNotFoundExceptions</a> should be set to true: </li>\n</ul>\n<pre>\nDaoAuthenticationProvider daoauth = new DaoAuthenticationProvider();\ndaoauth.setUserDetailsService(new MyUserDetailsService());\ndaoauth.setPasswordEncoder(new BCryptPasswordEncoder());\ndaoauth.setHideUserNotFoundExceptions(true); // Compliant\nbuilder.authenticationProvider(daoauth);\n</pre>\n<h2>See</h2>\n<ul>\n  <li> OWASP - <a href=\"https://owasp.org/Top10/A01_2021-Broken_Access_Control/\">Top 10 2021 Category A1 - Broken Access Control</a> </li>\n  <li> OWASP - <a href=\"https://owasp.org/www-project-top-ten/2017/A2_2017-Broken_Authentication\">Top 10 2017 Category A2 - Broken Authentication</a>\n  </li>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/200\">CWE-200 - Exposure of Sensitive Information to an Unauthorized Actor</a> </li>\n</ul>",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "사용자 열거 허용은 보안에 민감합니다",
    "why_ko": "<p>사용자 열거는 웹 애플리케이션 데이터베이스에서 기존 사용자 이름을 추측할 수 있는 능력을 말합니다. 이는 예를 들어 웹사이트의 \"로그인/가입/비밀번호 찾기\" 기능을 사용할 때 발생할 수 있습니다.</p>\n<p>사용자가 잘못된 사용자 이름/로그인으로 웹사이트에 \"로그인\"하려고 할 때 웹 애플리케이션은 \"이 사용자 이름이 올바르지 않습니다\"와 같은 메시지로 사용자 이름이 존재하지 않음을 공개해서는 안 됩니다. 대신 \"잘못된 자격 증명\"과 같은 일반적인 메시지를 사용해야 합니다. 이렇게 하면 인증 중에 사용자 이름이 틀렸는지 비밀번호가 틀렸는지 추측할 수 없습니다.</p>\n<p>사용자 관리 기능이 사용자 이름의 존재에 대한 정보를 공개하면 공격자는 무차별 대입 공격을 사용하여 많은 양의 유효한 사용자 이름을 검색할 수 있으며, 이는 해당 사용자의 개인 정보에 영향을 미치고 다른 공격(피싱, 비밀번호 추측 등)을 용이하게 합니다.</p>\n",
    "howToFix_ko": "<h2>권장 보안 코딩 관행</h2>\n<p>사용자가 사용자 이름과 관련된 요청을 수행할 때 유효한 사용자 이름과 잘못된 사용자 이름 사이의 차이를 발견할 수 없어야 합니다:</p>\n<ul>\n  <li> 오류 메시지는 일반적이어야 하며 사용자 이름이 유효한지 여부를 공개해서는 안 됩니다. </li>\n  <li> 응답 시간은 유효한 사용자 이름이든 아니든 비슷해야 합니다. </li>\n  <li> CAPTCHA 및 기타 속도 제한 솔루션을 구현해야 합니다. </li>\n</ul>\n<h2>규칙을 준수하는 해결책</h2>\n<p>Spring-security 웹 애플리케이션에서:</p>\n<ul>\n  <li> 잘못된 사용자인지 비밀번호인지에 관계없이 동일한 메시지를 사용해야 합니다: </li>\n</ul>\n<pre>\npublic String authenticate(String username, String password) throws AuthenticationException {\n  Details user = null;\n  try {\n    user = loadUserByUsername(username);\n  } catch (UsernameNotFoundException | DataAccessException e) {\n    // 사용자 이름이 존재하지 않음을 공개하지 않도록 이 예외 이유를 숨깁니다\n  }\n  if (user == null || !user.isPasswordCorrect(password)) {\n     // 사용자는 잘못된 자격 증명 메시지가 사용자 이름과 관련이 있는지 비밀번호와 관련이 있는지 추측할 수 없어야 합니다\n    throw new BadCredentialsException(\"Bad credentials\");\n  }\n}\n</pre>\n<ul>\n  <li> <a\n  href=\"https://docs.spring.io/spring-security/site/docs/4.0.x/apidocs/org/springframework/security/authentication/dao/AbstractUserDetailsAuthenticationProvider.html#setHideUserNotFoundExceptions-boolean-\">HideUserNotFoundExceptions</a>를 true로 설정해야 합니다: </li>\n</ul>\n<pre>\nDaoAuthenticationProvider daoauth = new DaoAuthenticationProvider();\ndaoauth.setUserDetailsService(new MyUserDetailsService());\ndaoauth.setPasswordEncoder(new BCryptPasswordEncoder());\ndaoauth.setHideUserNotFoundExceptions(true); // 규칙 준수\nbuilder.authenticationProvider(daoauth);\n</pre>\n<h2>참고</h2>\n<ul>\n  <li> OWASP - <a href=\"https://owasp.org/Top10/A01_2021-Broken_Access_Control/\">Top 10 2021 카테고리 A1 - 취약한 접근 제어</a> </li>\n  <li> OWASP - <a href=\"https://owasp.org/www-project-top-ten/2017/A2_2017-Broken_Authentication\">Top 10 2017 카테고리 A2 - 취약한 인증</a>\n  </li>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/200\">CWE-200 - 권한 없는 행위자에게 민감한 정보 노출</a> </li>\n</ul>",
    "moreInfo_ko": ""
  },
  {
    "id": "S1144",
    "key": "java:S1144",
    "name": "Unused \"private\" methods should be removed",
    "type": "code-smell",
    "severity": "major",
    "tags": [
      "unused"
    ],
    "why": "<p>A method that is never called is dead code, and should be removed. Cleaning out dead code decreases the size of the maintained codebase, making it\neasier to understand the program and preventing bugs from being introduced.</p>\n<p>This rule detects methods that are never referenced from inside a translation unit, and cannot be referenced from the outside.</p>\n\n<h3>Noncompliant code example</h3>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\npublic class Foo implements Serializable\n{\n  public static void doSomething() {\n    Foo foo = new Foo();\n    ...\n  }\n\n  private void unusedPrivateMethod() {...}\n  private void writeObject(ObjectOutputStream s) {...}  //Compliant, relates to the java serialization mechanism\n  private void readObject(ObjectInputStream in) {...}  //Compliant, relates to the java serialization mechanism\n}\n</pre>\n<h3>Compliant solution</h3>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\npublic class Foo implements Serializable\n{\n  public static void doSomething(){\n    Foo foo = new Foo();\n    ...\n  }\n\n  private void writeObject(ObjectOutputStream s) {...}  //Compliant, relates to the java serialization mechanism\n  private void readObject(ObjectInputStream in) {...}  //Compliant, relates to the java serialization mechanism\n}\n</pre>\n<h3>Exceptions</h3>\n<p>This rule doesn't raise issues for:</p>\n<ul>\n  <li> annotated methods </li>\n  <li> methods with parameters that are annotated with one of the following: </li>\n  <li> <code>@javax.enterprise.event.Observes</code> </li>\n  <li> <code>@javax.enterprise.event.ObservesAsync</code> </li>\n  <li> <code>@jakarta.enterprise.event.Observes</code> </li>\n  <li> <code>@jakarta.enterprise.event.ObservesAsync</code> </li>\n</ul>\n<p>The rule does not take reflection into account, which means that issues will be raised on <code>private</code> methods that are only accessed using\nthe reflection API.</p>",
    "howToFix": "",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "사용되지 않는 \"private\" 메서드는 제거해야 합니다",
    "why_ko": "<p>호출되지 않는 메서드는 죽은 코드이며 제거해야 합니다. 죽은 코드를 정리하면 유지보수해야 하는 코드베이스의 크기가 줄어들어 프로그램을 이해하기 쉬워지고 버그가 도입되는 것을 방지합니다.</p>\n<p>이 규칙은 번역 단위 내부에서 참조되지 않고 외부에서도 참조될 수 없는 메서드를 탐지합니다.</p>\n\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\npublic class Foo implements Serializable\n{\n  public static void doSomething() {\n    Foo foo = new Foo();\n    ...\n  }\n\n  private void unusedPrivateMethod() {...}\n  private void writeObject(ObjectOutputStream s) {...}  //규칙 준수, Java 직렬화 메커니즘과 관련됨\n  private void readObject(ObjectInputStream in) {...}  //규칙 준수, Java 직렬화 메커니즘과 관련됨\n}\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\npublic class Foo implements Serializable\n{\n  public static void doSomething(){\n    Foo foo = new Foo();\n    ...\n  }\n\n  private void writeObject(ObjectOutputStream s) {...}  //규칙 준수, Java 직렬화 메커니즘과 관련됨\n  private void readObject(ObjectInputStream in) {...}  //규칙 준수, Java 직렬화 메커니즘과 관련됨\n}\n</pre>\n<h3>예외 사항</h3>\n<p>이 규칙은 다음에 대해 이슈를 제기하지 않습니다:</p>\n<ul>\n  <li> 어노테이션이 있는 메서드 </li>\n  <li> 다음 어노테이션 중 하나가 있는 매개변수를 가진 메서드: </li>\n  <li> <code>@javax.enterprise.event.Observes</code> </li>\n  <li> <code>@javax.enterprise.event.ObservesAsync</code> </li>\n  <li> <code>@jakarta.enterprise.event.Observes</code> </li>\n  <li> <code>@jakarta.enterprise.event.ObservesAsync</code> </li>\n</ul>\n<p>이 규칙은 리플렉션을 고려하지 않으므로, 리플렉션 API를 통해서만 접근하는 <code>private</code> 메서드에 대해서도 이슈가 발생합니다.</p>",
    "howToFix_ko": "",
    "moreInfo_ko": ""
  },
  {
    "id": "S1451",
    "key": "java:S1451",
    "name": "Track lack of copyright and license headers",
    "type": "code-smell",
    "severity": "blocker",
    "tags": [
      "convention"
    ],
    "why": "<p>Each source file should start with a header stating file ownership and the license which must be used to distribute the application.</p>\n<p>This rule must be fed with the header text that is expected at the beginning of every file.</p>\n<h3>Compliant solution</h3>\n<pre>\n/*\n * SonarQube, open source software quality management tool.\n * Copyright (C) 2008-2013 SonarSource\n * mailto:contact AT sonarsource DOT com\n *\n * SonarQube is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 3 of the License, or (at your option) any later version.\n *\n * SonarQube is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public License\n * along with this program; if not, write to the Free Software Foundation,\n * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\n */\n</pre>",
    "howToFix": "",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "저작권 및 라이선스 헤더 누락을 추적합니다",
    "why_ko": "<p>각 소스 파일은 파일 소유권과 애플리케이션 배포에 사용해야 하는 라이선스를 명시하는 헤더로 시작해야 합니다.</p>\n<p>이 규칙에는 모든 파일의 시작 부분에 예상되는 헤더 텍스트를 제공해야 합니다.</p>\n<h3>규칙을 준수하는 해결책</h3>\n<pre>\n/*\n * SonarQube, open source software quality management tool.\n * Copyright (C) 2008-2013 SonarSource\n * mailto:contact AT sonarsource DOT com\n *\n * SonarQube is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 3 of the License, or (at your option) any later version.\n *\n * SonarQube is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public License\n * along with this program; if not, write to the Free Software Foundation,\n * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\n */\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": ""
  },
  {
    "id": "S5042",
    "key": "java:S5042",
    "name": "Expanding archive files without controlling resource consumption is security-sensitive",
    "type": "security-hotspot",
    "severity": "critical",
    "tags": [
      "cwe",
      "cert"
    ],
    "why": "<p>Successful Zip Bomb attacks occur when an application expands untrusted archive files without controlling the size of the expanded data, which can\nlead to denial of service. A Zip bomb is usually a malicious archive file of a few kilobytes of compressed data but turned into gigabytes of\nuncompressed data. To achieve this extreme <a href=\"https://en.wikipedia.org/wiki/Data_compression_ratio\">compression ratio</a>, attackers will\ncompress irrelevant data (eg: a long string of repeated bytes).</p>\n",
    "howToFix": "<h2>Recommended Secure Coding Practices</h2>\n<ul>\n  <li> Define and control the ratio between compressed and uncompressed data, in general the data compression ratio for most of the legit archives is\n  1 to 3. </li>\n  <li> Define and control the threshold for maximum total size of the uncompressed data. </li>\n  <li> Count the number of file entries extracted from the archive and abort the extraction if their number is greater than a predefined threshold, in\n  particular it's not recommended to recursively expand archives (an entry of an archive could be also an archive). </li>\n</ul>\n<h2>Compliant Solution</h2>\n<p>Do not rely on <a href=\"https://docs.oracle.com/javase/7/docs/api/java/util/zip/ZipEntry.html#getSize()\">getsize</a> to retrieve the size of an\nuncompressed entry because this method returns what is defined in the archive headers which can be forged by attackers, instead calculate the actual\nentry size when unzipping it:</p>\n<pre>\nFile f = new File(\"ZipBomb.zip\");\nZipFile zipFile = new ZipFile(f);\nEnumeration&lt;? extends ZipEntry&gt; entries = zipFile.entries();\n\nint THRESHOLD_ENTRIES = 10000;\nint THRESHOLD_SIZE = 1000000000; // 1 GB\ndouble THRESHOLD_RATIO = 10;\nint totalSizeArchive = 0;\nint totalEntryArchive = 0;\n\nwhile(entries.hasMoreElements()) {\n  ZipEntry ze = entries.nextElement();\n  InputStream in = new BufferedInputStream(zipFile.getInputStream(ze));\n  OutputStream out = new BufferedOutputStream(new FileOutputStream(\"./output_onlyfortesting.txt\"));\n\n  totalEntryArchive ++;\n\n  int nBytes = -1;\n  byte[] buffer = new byte[2048];\n  int totalSizeEntry = 0;\n\n  while((nBytes = in.read(buffer)) &gt; 0) { // Compliant\n      out.write(buffer, 0, nBytes);\n      totalSizeEntry += nBytes;\n      totalSizeArchive += nBytes;\n\n      double compressionRatio = totalSizeEntry / ze.getCompressedSize();\n      if(compressionRatio &gt; THRESHOLD_RATIO) {\n        // ratio between compressed and uncompressed data is highly suspicious, looks like a Zip Bomb Attack\n        break;\n      }\n  }\n\n  if(totalSizeArchive &gt; THRESHOLD_SIZE) {\n      // the uncompressed data size is too much for the application resource capacity\n      break;\n  }\n\n  if(totalEntryArchive &gt; THRESHOLD_ENTRIES) {\n      // too much entries in this archive, can lead to inodes exhaustion of the system\n      break;\n  }\n}\n</pre>\n<h2>See</h2>\n<ul>\n  <li> OWASP - <a href=\"https://owasp.org/Top10/A01_2021-Broken_Access_Control/\">Top 10 2021 Category A1 - Broken Access Control</a> </li>\n  <li> OWASP - <a href=\"https://owasp.org/Top10/A05_2021-Security_Misconfiguration/\">Top 10 2021 Category A5 - Security Misconfiguration</a> </li>\n  <li> OWASP - <a href=\"https://owasp.org/www-project-top-ten/2017/A5_2017-Broken_Access_Control\">Top 10 2017 Category A5 - Broken Access Control</a>\n  </li>\n  <li> OWASP - <a href=\"https://owasp.org/www-project-top-ten/2017/A6_2017-Security_Misconfiguration\">Top 10 2017 Category A6 - Security\n  Misconfiguration</a> </li>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/409\">CWE-409 - Improper Handling of Highly Compressed Data (Data Amplification)</a> </li>\n  <li> <a href=\"https://wiki.sei.cmu.edu/confluence/display/java/IDS04-J.+Safely+extract+files+from+ZipInputStream\">CERT, IDS04-J.</a> - Safely\n  extract files from ZipInputStream </li>\n  <li> <a href=\"https://www.bamsoftware.com/hacks/zipbomb/\">bamsoftware.com</a> - A better Zip Bomb </li>\n</ul>",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "리소스 소비를 제어하지 않고 아카이브 파일을 확장하는 것은 보안에 민감합니다",
    "why_ko": "<p>성공적인 Zip 폭탄 공격은 애플리케이션이 확장된 데이터의 크기를 제어하지 않고 신뢰할 수 없는 아카이브 파일을 확장할 때 발생하며, 이는 서비스 거부로 이어질 수 있습니다. Zip 폭탄은 일반적으로 몇 킬로바이트의 압축 데이터로 된 악성 아카이브 파일이지만 압축을 풀면 기가바이트의 데이터가 됩니다. 이러한 극단적인 <a href=\"https://en.wikipedia.org/wiki/Data_compression_ratio\">압축률</a>을 달성하기 위해 공격자는 관련 없는 데이터(예: 반복되는 바이트의 긴 문자열)를 압축합니다.</p>\n",
    "howToFix_ko": "<h2>권장 보안 코딩 방법</h2>\n<ul>\n  <li> 압축된 데이터와 압축 해제된 데이터 사이의 비율을 정의하고 제어하세요. 일반적으로 대부분의 합법적인 아카이브의 데이터 압축률은 1:3입니다. </li>\n  <li> 압축 해제된 데이터의 최대 총 크기에 대한 임계값을 정의하고 제어하세요. </li>\n  <li> 아카이브에서 추출된 파일 항목 수를 세고 그 수가 미리 정의된 임계값보다 크면 추출을 중단하세요. 특히 아카이브를 재귀적으로 확장하는 것은 권장되지 않습니다(아카이브의 항목이 또 다른 아카이브일 수 있음). </li>\n</ul>\n<h2>규칙을 준수하는 해결책</h2>\n<p>압축 해제된 항목의 크기를 가져오기 위해 <a href=\"https://docs.oracle.com/javase/7/docs/api/java/util/zip/ZipEntry.html#getSize()\">getsize</a>에 의존하지 마세요. 이 메서드는 공격자가 위조할 수 있는 아카이브 헤더에 정의된 것을 반환하기 때문입니다. 대신 압축 해제할 때 실제 항목 크기를 계산하세요:</p>\n<pre>\nFile f = new File(\"ZipBomb.zip\");\nZipFile zipFile = new ZipFile(f);\nEnumeration&lt;? extends ZipEntry&gt; entries = zipFile.entries();\n\nint THRESHOLD_ENTRIES = 10000;\nint THRESHOLD_SIZE = 1000000000; // 1 GB\ndouble THRESHOLD_RATIO = 10;\nint totalSizeArchive = 0;\nint totalEntryArchive = 0;\n\nwhile(entries.hasMoreElements()) {\n  ZipEntry ze = entries.nextElement();\n  InputStream in = new BufferedInputStream(zipFile.getInputStream(ze));\n  OutputStream out = new BufferedOutputStream(new FileOutputStream(\"./output_onlyfortesting.txt\"));\n\n  totalEntryArchive ++;\n\n  int nBytes = -1;\n  byte[] buffer = new byte[2048];\n  int totalSizeEntry = 0;\n\n  while((nBytes = in.read(buffer)) &gt; 0) { // 규칙 준수\n      out.write(buffer, 0, nBytes);\n      totalSizeEntry += nBytes;\n      totalSizeArchive += nBytes;\n\n      double compressionRatio = totalSizeEntry / ze.getCompressedSize();\n      if(compressionRatio &gt; THRESHOLD_RATIO) {\n        // 압축 데이터와 비압축 데이터 사이의 비율이 매우 의심스러움, Zip 폭탄 공격으로 보임\n        break;\n      }\n  }\n\n  if(totalSizeArchive &gt; THRESHOLD_SIZE) {\n      // 압축 해제된 데이터 크기가 애플리케이션 리소스 용량에 비해 너무 큼\n      break;\n  }\n\n  if(totalEntryArchive &gt; THRESHOLD_ENTRIES) {\n      // 이 아카이브에 항목이 너무 많음, 시스템의 inode 고갈로 이어질 수 있음\n      break;\n  }\n}\n</pre>\n<h2>참고</h2>\n<ul>\n  <li> OWASP - <a href=\"https://owasp.org/Top10/A01_2021-Broken_Access_Control/\">상위 10가지 2021 카테고리 A1 - 취약한 접근 제어</a> </li>\n  <li> OWASP - <a href=\"https://owasp.org/Top10/A05_2021-Security_Misconfiguration/\">상위 10가지 2021 카테고리 A5 - 보안 구성 오류</a> </li>\n  <li> OWASP - <a href=\"https: //owasp.org/www-project-top-ten/2017/A5_2017-Broken_Access_Control\">상위 10가지 2017 카테고리 A5 - 취약한 접근 제어</a> </li>\n  <li> OWASP - <a href=\"https://owasp.org/www-project-top-ten/2017/A6_2017-Security_Misconfiguration\">상위 10가지 2017 카테고리 A6 - 보안 구성 오류</a> </li>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/409\">CWE-409 - 고압축 데이터의 부적절한 처리(데이터 증폭)</a> </li>\n  <li> <a href=\"https://wiki.sei.cmu.edu/confluence/display/java/IDS04-J.+Safely+extract+files+from+ZipInputStream\">CERT, IDS04-J.</a> - ZipInputStream에서 안전하게 파일 추출 </li>\n  <li> <a href=\"https://www.bamsoftware.com/hacks/zipbomb/\">bamsoftware.com</a> - 더 나은 Zip 폭탄 </li>\n</ul>",
    "moreInfo_ko": ""
  },
  {
    "id": "S1700",
    "key": "java:S1700",
    "name": "A field should not duplicate the name of its containing class",
    "type": "code-smell",
    "severity": "major",
    "tags": [
      "brain-overload"
    ],
    "why": "<p>It's confusing to have a class member with the same name (case differences aside) as its enclosing class. This is particularly so when you consider\nthe common practice of naming a class instance for the class itself.</p>\n<p>Best practice dictates that any field or member with the same name as the enclosing class be renamed to be more descriptive of the particular\naspect of the class it represents or holds.</p>\n<h3>Noncompliant code example</h3>\n<pre>\npublic class Foo {\n  private String foo;\n\n  public String getFoo() { }\n}\n\nFoo foo = new Foo();\nfoo.getFoo() // what does this return?\n</pre>\n<h3>Compliant solution</h3>\n<pre>\npublic class Foo {\n  private String name;\n\n  public String getName() { }\n}\n\n//...\n\nFoo foo = new Foo();\nfoo.getName()\n</pre>\n<h3>Exceptions</h3>\n<p>When the type of the field is the containing class and that field is static, no issue is raised to allow singletons named like the type.</p>\n<pre>\npublic class Foo {\n  ...\n  private static Foo foo;\n  public Foo getInstance() {\n    if(foo==null) {\n      foo = new Foo();\n    }\n    return foo;\n  }\n  ...\n}\n</pre>",
    "howToFix": "",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "필드 이름이 포함된 클래스 이름과 중복되면 안 됩니다",
    "why_ko": "<p>클래스 멤버가 해당 클래스와 동일한 이름(대소문자 차이 제외)을 가지면 혼란스럽습니다. 클래스 인스턴스의 이름을 클래스 자체의 이름으로 짓는 일반적인 관행을 고려하면 특히 그렇습니다.</p>\n<p>모범 사례에 따르면, 포함하는 클래스와 동일한 이름을 가진 필드나 멤버는 해당 클래스가 나타내거나 보유하는 특정 측면을 더 잘 설명하도록 이름을 변경해야 합니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\npublic class Foo {\n  private String foo;\n\n  public String getFoo() { }\n}\n\nFoo foo = new Foo();\nfoo.getFoo() // 이것은 무엇을 반환하나요?\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre>\npublic class Foo {\n  private String name;\n\n  public String getName() { }\n}\n\n//...\n\nFoo foo = new Foo();\nfoo.getName()\n</pre>\n<h3>예외</h3>\n<p>필드의 타입이 포함하는 클래스이고 해당 필드가 static인 경우, 타입과 동일한 이름의 싱글톤을 허용하기 위해 이슈가 발생하지 않습니다.</p>\n<pre>\npublic class Foo {\n  ...\n  private static Foo foo;\n  public Foo getInstance() {\n    if(foo==null) {\n      foo = new Foo();\n    }\n    return foo;\n  }\n  ...\n}\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": ""
  },
  {
    "id": "S4502",
    "key": "java:S4502",
    "name": "Disabling CSRF protections is security-sensitive",
    "type": "security-hotspot",
    "severity": "critical",
    "tags": [
      "spring",
      "cwe"
    ],
    "why": "<p>A cross-site request forgery (CSRF) attack occurs when a trusted user of a web application can be forced, by an attacker, to perform sensitive\nactions that he didn't intend, such as updating his profile or sending a message, more generally anything that can change the state of the\napplication.</p>\n<p>The attacker can trick the user/victim to click on a link, corresponding to the privileged action, or to visit a malicious web site that embeds a\nhidden web request and as web browsers automatically include cookies, the actions can be authenticated and sensitive.</p>\n",
    "howToFix": "<h2>Recommended Secure Coding Practices</h2>\n<ul>\n  <li> Protection against CSRF attacks is strongly recommended:\n    <ul>\n      <li> to be activated by default for all <a href=\"https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol#Safe_methods\">unsafe HTTP\n      methods</a>. </li>\n      <li> implemented, for example, with an unguessable CSRF token </li>\n    </ul>  </li>\n  <li> Of course all sensitive operations should not be performed with <a\n  href=\"https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol#Safe_methods\">safe HTTP</a> methods like <code>GET</code> which are designed to be\n  used only for information retrieval. </li>\n</ul>\n<h2>Compliant Solution</h2>\n<p><a href=\"https://docs.spring.io/spring-security/site/docs/5.0.x/reference/html/csrf.html#csrf-using\">Spring Security</a> CSRF protection is enabled\nby default, do not disable it:</p>\n<pre>\n@EnableWebSecurity\npublic class WebSecurityConfig extends WebSecurityConfigurerAdapter {\n\n  @Override\n  protected void configure(HttpSecurity http) throws Exception {\n    // http.csrf().disable(); // Compliant\n  }\n}\n</pre>\n<h2>See</h2>\n<ul>\n  <li> OWASP - <a href=\"https://owasp.org/Top10/A01_2021-Broken_Access_Control/\">Top 10 2021 Category A1 - Broken Access Control</a> </li>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/352\">CWE-352 - Cross-Site Request Forgery (CSRF)</a> </li>\n  <li> OWASP - <a href=\"https://owasp.org/www-project-top-ten/2017/A6_2017-Security_Misconfiguration\">Top 10 2017 Category A6 - Security\n  Misconfiguration</a> </li>\n  <li> OWASP - <a href=\"https://owasp.org/www-community/attacks/csrf\">Cross-Site Request Forgery</a> </li>\n  <li> STIG Viewer - <a href=\"https://stigviewer.com/stigs/application_security_and_development/2024-12-06/finding/V-222603\">Application Security and\n  Development: V-222603</a> - The application must protect from Cross-Site Request Forgery (CSRF) vulnerabilities. </li>\n  <li> PortSwigger - <a href=\"https://portswigger.net/research/web-storage-the-lesser-evil-for-session-tokens\">Web storage: the lesser evil for\n  session tokens</a> </li>\n</ul>",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "CSRF 보호 비활성화는 보안에 민감합니다",
    "why_ko": "<p>크로스 사이트 요청 위조(CSRF) 공격은 웹 애플리케이션의 신뢰할 수 있는 사용자가 공격자에 의해 프로필 업데이트나 메시지 전송과 같이 의도하지 않은 민감한 작업을 수행하도록 강제당할 때 발생합니다. 더 일반적으로 애플리케이션의 상태를 변경할 수 있는 모든 것이 해당됩니다.</p>\n<p>공격자는 사용자/피해자를 속여 권한 있는 작업에 해당하는 링크를 클릭하게 하거나 숨겨진 웹 요청을 포함하는 악성 웹 사이트를 방문하게 할 수 있습니다. 웹 브라우저가 자동으로 쿠키를 포함하기 때문에 이러한 작업은 인증되고 민감할 수 있습니다.</p>\n",
    "howToFix_ko": "<h2>권장 보안 코딩 방법</h2>\n<ul>\n  <li> CSRF 공격에 대한 보호가 강력히 권장됩니다:\n    <ul>\n      <li> 모든 <a href=\"https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol#Safe_methods\">안전하지 않은 HTTP 메서드</a>에 대해 기본적으로 활성화되어야 합니다. </li>\n      <li> 예를 들어 추측할 수 없는 CSRF 토큰으로 구현합니다. </li>\n    </ul>  </li>\n  <li> 물론 모든 민감한 작업은 정보 검색에만 사용되도록 설계된 <code>GET</code>과 같은 <a href=\"https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol#Safe_methods\">안전한 HTTP</a> 메서드로 수행되어서는 안 됩니다. </li>\n</ul>\n<h2>규칙을 준수하는 해결책</h2>\n<p><a href=\"https://docs.spring.io/spring-security/site/docs/5.0.x/reference/html/csrf.html#csrf-using\">Spring Security</a> CSRF 보호는 기본적으로 활성화되어 있으므로 비활성화하지 마세요:</p>\n<pre>\n@EnableWebSecurity\npublic class WebSecurityConfig extends WebSecurityConfigurerAdapter {\n\n  @Override\n  protected void configure(HttpSecurity http) throws Exception {\n    // http.csrf().disable(); // 규칙 준수\n  }\n}\n</pre>\n<h2>참고</h2>\n<ul>\n  <li> OWASP - <a href=\"https://owasp.org/Top10/A01_2021-Broken_Access_Control/\">Top 10 2021 Category A1 - Broken Access Control</a> </li>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/352\">CWE-352 - Cross-Site Request Forgery (CSRF)</a> </li>\n  <li> OWASP - <a href=\"https://owasp.org/www-project-top-ten/2017/A6_2017-Security_Misconfiguration\">Top 10 2017 Category A6 - Security Misconfiguration</a> </li>\n  <li> OWASP - <a href=\"https://owasp.org/www-community/attacks/csrf\">Cross-Site Request Forgery</a> </li>\n  <li> STIG Viewer - <a href=\"https://stigviewer.com/stigs/application_security_and_development/2024-12-06/finding/V-222603\">Application Security and Development: V-222603</a> - The application must protect from Cross-Site Request Forgery (CSRF) vulnerabilities. </li>\n  <li> PortSwigger - <a href=\"https://portswigger.net/research/web-storage-the-lesser-evil-for-session-tokens\">Web storage: the lesser evil for session tokens</a> </li>\n</ul>",
    "moreInfo_ko": ""
  },
  {
    "id": "S1215",
    "key": "java:S1215",
    "name": "Execution of the Garbage Collector should be triggered only by the JVM",
    "type": "code-smell",
    "severity": "critical",
    "tags": [
      "unpredictable",
      "bad-practice"
    ],
    "why": "<p>Calling <code>System.gc()</code> or <code>Runtime.getRuntime().gc()</code> is a bad idea for a simple reason: there is no way to know exactly what\nwill be done under the hood by the JVM because the behavior will depend on its vendor, version and options:</p>\n<ul>\n  <li> Will the whole application be frozen during the call? </li>\n  <li> Is the <code>-XX:DisableExplicitGC</code> option activated? </li>\n  <li> Will the JVM simply ignore the call? </li>\n  <li> …​ </li>\n</ul>\n<p>Like for <code>System.gc()</code>, there is no reason to manually call <code>runFinalization()</code> to force the call of finalization methods of\nany objects pending finalization.</p>\n<p>An application relying on these unpredictable methods is also unpredictable and therefore broken. The task of running the garbage collector and\ncalling <code>finalize()</code> methods should be left exclusively to the JVM.</p>",
    "howToFix": "",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "Garbage Collector 실행은 JVM에 의해서만 트리거되어야 합니다",
    "why_ko": "<p><code>System.gc()</code> 또는 <code>Runtime.getRuntime().gc()</code>를 호출하는 것은 간단한 이유로 나쁜 아이디어입니다: JVM이 내부에서 정확히 무엇을 할지 알 수 없기 때문입니다. 동작은 벤더, 버전 및 옵션에 따라 달라집니다:</p>\n<ul>\n  <li> 호출 중에 전체 애플리케이션이 정지될까요? </li>\n  <li> <code>-XX:DisableExplicitGC</code> 옵션이 활성화되어 있나요? </li>\n  <li> JVM이 단순히 호출을 무시할까요? </li>\n  <li> …​ </li>\n</ul>\n<p><code>System.gc()</code>와 마찬가지로, 대기 중인 객체의 finalization 메서드 호출을 강제하기 위해 수동으로 <code>runFinalization()</code>을 호출할 이유가 없습니다.</p>\n<p>이러한 예측 불가능한 메서드에 의존하는 애플리케이션도 예측 불가능하며 따라서 결함이 있습니다. 가비지 컬렉터를 실행하고 <code>finalize()</code> 메서드를 호출하는 작업은 전적으로 JVM에 맡겨야 합니다.</p>",
    "howToFix_ko": "",
    "moreInfo_ko": ""
  },
  {
    "id": "S3551",
    "key": "java:S3551",
    "name": "Overrides should match their parent class methods in synchronization",
    "type": "bug",
    "severity": "major",
    "tags": [
      "multi-threading",
      "cert"
    ],
    "why": "<p>When <code>@Overrides</code> of <code>synchronized</code> methods are not themselves <code>synchronized</code>, the result can be improper\nsynchronization as callers rely on the thread-safety promised by the parent class.</p>\n<h3>Noncompliant code example</h3>\n<pre>\npublic class Parent {\n\n  synchronized void foo() {\n    //...\n  }\n}\n\npublic class Child extends Parent {\n\n @Override\n  public void foo () {  // Noncompliant\n    // ...\n    super.foo();\n  }\n}\n</pre>\n<h3>Compliant solution</h3>\n<pre>\npublic class Parent {\n\n  synchronized void foo() {\n    //...\n  }\n}\n\npublic class Child extends Parent {\n\n  @Override\n  synchronized void foo () {\n    // ...\n    super.foo();\n  }\n}\n</pre>",
    "howToFix": "",
    "moreInfo": "<ul>\n  <li> <a href=\"https://wiki.sei.cmu.edu/confluence/x/gzdGBQ\">CERT, TSM00-J</a> - Do not override thread-safe methods with methods that are not\n  thread-safe </li>\n</ul>",
    "status": "READY",
    "name_ko": "오버라이드된 메서드는 부모 클래스 메서드와 동기화 방식이 일치해야 합니다",
    "why_ko": "<p><code>synchronized</code> 메서드의 <code>@Override</code>가 자체적으로 <code>synchronized</code>가 아닐 때, 호출자가 부모 클래스에서 약속한 스레드 안전성에 의존하므로 부적절한 동기화가 발생할 수 있습니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\npublic class Parent {\n\n  synchronized void foo() {\n    //...\n  }\n}\n\npublic class Child extends Parent {\n\n @Override\n  public void foo () {  // 규칙 위반\n    // ...\n    super.foo();\n  }\n}\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre>\npublic class Parent {\n\n  synchronized void foo() {\n    //...\n  }\n}\n\npublic class Child extends Parent {\n\n  @Override\n  synchronized void foo () {\n    // ...\n    super.foo();\n  }\n}\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": "<ul>\n  <li> <a href=\"https://wiki.sei.cmu.edu/confluence/x/gzdGBQ\">CERT, TSM00-J</a> - 스레드 안전한 메서드를 스레드 안전하지 않은 메서드로 오버라이드하지 마세요 </li>\n</ul>"
  },
  {
    "id": "S3414",
    "key": "java:S3414",
    "name": "Tests should be kept in a dedicated source directory",
    "type": "code-smell",
    "severity": "major",
    "tags": [
      "tests",
      "suspicious"
    ],
    "why": "<p>It is a good practice to isolate test classes in a separate package so that what is shipped to production is neither polluted by nor bloated with\nthem. Further, including unit tests in code assemblies could affect build processes.</p>\n<p>This rule raises an issue when test classes are found in projects containing non-test-related code.</p>",
    "howToFix": "",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "테스트는 전용 소스 디렉토리에 보관해야 합니다",
    "why_ko": "<p>프로덕션에 배포되는 것이 테스트 클래스로 오염되거나 비대해지지 않도록 별도의 패키지에 테스트 클래스를 격리하는 것이 좋은 관행입니다. 또한 코드 어셈블리에 단위 테스트를 포함하면 빌드 프로세스에 영향을 줄 수 있습니다.</p>\n<p>이 규칙은 테스트와 관련되지 않은 코드가 포함된 프로젝트에서 테스트 클래스가 발견될 때 문제를 제기합니다.</p>",
    "howToFix_ko": "",
    "moreInfo_ko": ""
  },
  {
    "id": "S6246",
    "key": "java:S6246",
    "name": "Lambdas should not invoke other lambdas synchronously",
    "type": "code-smell",
    "severity": "minor",
    "tags": [
      "aws"
    ],
    "why": "<p>Invoking other Lambdas synchronously from a Lambda is a scalability anti-pattern. Lambdas have a maximum execution time before they timeout (15\nminutes as of June 2025). Having to wait for another Lambda to finish its execution could lead to a timeout.</p>\n<p>A better solution is to generate&nbsp;events that can be consumed asynchronously by other Lambdas.</p>\n<h3>Noncompliant code example</h3>\n<p>With AWS SDKv1</p>\n<pre>\nInvokeRequest invokeRequest = new InvokeRequest()\n         .withFunctionName(\"myFunction\");\n\nAWSLambda awsLambda = AWSLambdaClientBuilder.standard()\n\t\t.withCredentials(new ProfileCredentialsProvider())\n\t\t.withRegion(Regions.US_WEST_2).build();\n\nawsLambda.invoke(invokeRequest); // Noncompliant\n</pre>",
    "howToFix": "",
    "moreInfo": "<ul>\n  <li> <a href=\"https://docs.aws.amazon.com/lambda/latest/dg/best-practices.html\">Best practices for working with AWS Lambda functions</a> </li>\n</ul>",
    "status": "READY",
    "name_ko": "Lambda는 다른 Lambda를 동기적으로 호출하면 안 됩니다",
    "why_ko": "<p>Lambda에서 다른 Lambda를 동기적으로 호출하는 것은 확장성 안티패턴입니다. Lambda는 타임아웃되기 전에 최대 실행 시간(2025년 6월 기준 15분)이 있습니다. 다른 Lambda가 실행을 완료할 때까지 기다리면 타임아웃이 발생할 수 있습니다.</p>\n<p>더 나은 해결책은 다른 Lambda가 비동기적으로 소비할 수 있는 이벤트를 생성하는 것입니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<p>AWS SDKv1 사용 시</p>\n<pre>\nInvokeRequest invokeRequest = new InvokeRequest()\n         .withFunctionName(\"myFunction\");\n\nAWSLambda awsLambda = AWSLambdaClientBuilder.standard()\n\t\t.withCredentials(new ProfileCredentialsProvider())\n\t\t.withRegion(Regions.US_WEST_2).build();\n\nawsLambda.invoke(invokeRequest); // 규칙 위반\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": "<ul>\n  <li> <a href=\"https://docs.aws.amazon.com/lambda/latest/dg/best-practices.html\">AWS Lambda 함수 작업 모범 사례</a> </li>\n</ul>"
  },
  {
    "id": "S5344",
    "key": "java:S5344",
    "name": "Passwords should not be stored in plaintext or with a fast hashing algorithm",
    "type": "vulnerability",
    "severity": "critical",
    "tags": [
      "cwe",
      "spring"
    ],
    "why": "<p>Attackers who would get access to the stored passwords could reuse them without further attacks or with little additional effort.<br> Obtaining the\nplaintext passwords, they could then gain unauthorized access to user accounts, potentially leading to various malicious activities.</p>\n<h3>What is the potential impact?</h3>\n<p>Plaintext or weakly hashed password storage poses a significant security risk to software applications.</p>\n<h4>Unauthorized Access</h4>\n<p>When passwords are stored in plaintext or with weak hashing algorithms, an attacker who gains access to the password database can easily retrieve\nand use the passwords to gain unauthorized access to user accounts. This can lead to various malicious activities, such as unauthorized data access,\nidentity theft, or even financial fraud.</p>\n<h4>Credential Reuse</h4>\n<p>Many users tend to reuse passwords across multiple platforms. If an attacker obtains plaintext or weakly hashed passwords, they can potentially use\nthese credentials to gain unauthorized access to other accounts held by the same user. This can have far-reaching consequences, as sensitive personal\ninformation or critical systems may be compromised.</p>\n<h4>Regulatory Compliance</h4>\n<p>Many industries and jurisdictions have specific regulations and standards to protect user data and ensure its confidentiality. Storing passwords in\nplaintext or with weak hashing algorithms can lead to non-compliance with these regulations, potentially resulting in legal consequences, financial\npenalties, and damage to the reputation of the software application and its developers.</p>",
    "howToFix": "<h4>Noncompliant code example</h4>\n<p>The following code is vulnerable because it uses a legacy digest-based password encoding that is not considered secure.</p>\n<pre data-diff-id=\"12\" data-diff-type=\"noncompliant\">\n@Autowired\npublic void configureGlobal(AuthenticationManagerBuilder auth, DataSource dataSource) throws Exception {\n  auth.jdbcAuthentication()\n    .dataSource(dataSource)\n    .usersByUsernameQuery(\"SELECT * FROM users WHERE username = ?\")\n    .passwordEncoder(new StandardPasswordEncoder()); // Noncompliant\n}\n</pre>\n<h4>Compliant solution</h4>\n<pre data-diff-id=\"12\" data-diff-type=\"compliant\">\n@Autowired\npublic void configureGlobal(AuthenticationManagerBuilder auth, DataSource dataSource) throws Exception {\n  auth.jdbcAuthentication()\n    .dataSource(dataSource)\n    .usersByUsernameQuery(\"SELECT * FROM users WHERE username = ?\")\n    .passwordEncoder(new BCryptPasswordEncoder());\n}\n</pre>\n<h3>How does this work?</h3>\n<h4>Use secure password hashing algorithms</h4>\n<p>In general, you should rely on an algorithm that has no known security vulnerabilities. The MD5 and SHA-1 algorithms should not be used.</p>\n<p>Some algorithms, such as the SHA family functions, are considered strong for some use cases, but are too fast in computation and therefore\nvulnerable to brute force attacks, especially with bruteforce-attack-oriented hardware.</p>\n<p>To protect passwords, it is therefore important to choose modern, slow password-hashing algorithms. The following algorithms are, in order of\nstrength, the most secure password hashing algorithms to date:</p>\n<ol>\n  <li> Argon2 </li>\n  <li> scrypt </li>\n  <li> bcrypt </li>\n  <li> PBKDF2 </li>\n</ol>\n<p>Argon2 should be the best choice, and others should be used when the previous one is not available. For systems that must use FIPS-140-certified\nalgorithms, PBKDF2 should be used.</p>\n<p>Whenever possible, choose the strongest algorithm available. If the algorithm currently used by your system should be upgraded, OWASP documents\npossible upgrade methods here: <a\nhref=\"https://cheatsheetseries.owasp.org/cheatsheets/Password_Storage_Cheat_Sheet.html#upgrading-legacy-hashes\">Upgrading Legacy Hashes</a>.</p>\n<p>In the previous example, the <code>BCryptPasswordEncoder</code> is a password hashing function in Java that is designed to be secure and resistant\nto various types of attacks, including brute-force and rainbow table attacks. It is slow, adaptative, and automatically implements a salt.</p>\n<h4>Never store passwords in plaintext</h4>\n<p>A user password should never be stored in plaintext. Instead, a hash should be produced from it using a secure algorithm. When dealing with\npassword storage security, best practices recommend relying on a slow hashing algorithm, that will make brute force attacks more difficult. Using a\nhashing function with adaptable computation and memory complexity also is recommended to be able to increase the security level with time.</p>\n<p>Adding a salt to the digest computation is also recommended to prevent pre-computed table attacks (see rule <a href='/coding_rules#rule_key=java%3AS2053'>S2053</a>).</p>\n<h3>Pitfalls</h3>\n<h4>Pre-hashing passwords</h4>\n<p>As bcrypt has a maximum length input length of 72 bytes for most implementations, some developers may be tempted to pre-hash the password with a\nstronger algorithm before hashing it with bcrypt.</p>\n<p>Pre-hashing passwords with bcrypt is not recommended as it can lead to a specific range of issues. Using a strong salt and a high number of rounds\nis enough to protect the password.</p>\n<p>More information about this can be found here: <a\nhref=\"https://cheatsheetseries.owasp.org/cheatsheets/Password_Storage_Cheat_Sheet.html#pre-hashing-passwords-with-bcrypt\">Pre-hashing Passwords with\nBcrypt</a>.</p>",
    "moreInfo": "<h3>Documentation</h3>\n<ul>\n  <li> Spring Framework Security Documentation - <a\n  href=\"https://docs.spring.io/spring-security/site/docs/current/api/org/springframework/security/crypto/bcrypt/BCryptPasswordEncoder.html\">Class\n  BCryptPasswordEncoder</a> </li>\n  <li> OWASP CheatSheet - <a href=\"https://cheatsheetseries.owasp.org/cheatsheets/Password_Storage_Cheat_Sheet.html\">Password Storage Cheat Sheet</a>\n  </li>\n</ul>\n<h3>Standards</h3>\n<ul>\n  <li> OWASP - <a href=\"https://owasp.org/Top10/A02_2021-Cryptographic_Failures/\">Top 10 2021 Category A2 - Cryptographic Failures</a> </li>\n  <li> OWASP - <a href=\"https://owasp.org/Top10/A04_2021-Insecure_Design/\">Top 10 2021 Category A4 - Insecure Design</a> </li>\n  <li> OWASP - <a href=\"https://owasp.org/www-project-top-ten/2017/A3_2017-Sensitive_Data_Exposure\">Top 10 2017 Category A3 - Sensitive Data\n  Exposure</a> </li>\n  <li> OWASP - <a href=\"https://owasp.org/www-project-mobile-top-10/2023-risks/m10-insufficient-cryptography\">Mobile Top 10 2024 Category M10 -\n  Insufficient Cryptography</a> </li>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/256\">CWE-256 - Plaintext Storage of a Password</a> </li>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/916\">CWE-916 - Use of Password Hash With Insufficient Computational Effort</a> </li>\n</ul>",
    "status": "READY",
    "name_ko": "비밀번호는 평문이나 빠른 해싱 알고리즘으로 저장하면 안 됩니다",
    "why_ko": "<p>저장된 비밀번호에 접근할 수 있는 공격자는 추가 공격 없이 또는 약간의 추가 노력으로 비밀번호를 재사용할 수 있습니다.<br> 평문 비밀번호를 얻으면 사용자 계정에 대한 무단 접근 권한을 얻어 다양한 악의적인 활동으로 이어질 수 있습니다.</p>\n<h3>잠재적 영향은 무엇입니까?</h3>\n<p>평문 또는 약하게 해시된 비밀번호 저장은 소프트웨어 애플리케이션에 상당한 보안 위험을 초래합니다.</p>\n<h4>무단 접근</h4>\n<p>비밀번호가 평문이나 약한 해싱 알고리즘으로 저장되면 비밀번호 데이터베이스에 접근한 공격자가 쉽게 비밀번호를 검색하여 사용자 계정에 대한 무단 접근 권한을 얻을 수 있습니다. 이는 무단 데이터 접근, 신원 도용 또는 금융 사기와 같은 다양한 악의적인 활동으로 이어질 수 있습니다.</p>\n<h4>자격 증명 재사용</h4>\n<p>많은 사용자는 여러 플랫폼에서 비밀번호를 재사용하는 경향이 있습니다. 공격자가 평문이나 약하게 해시된 비밀번호를 얻으면 이러한 자격 증명을 사용하여 동일한 사용자가 보유한 다른 계정에 대한 무단 접근 권한을 얻을 수 있습니다. 이는 민감한 개인 정보나 중요한 시스템이 손상될 수 있으므로 광범위한 결과를 초래할 수 있습니다.</p>\n<h4>규정 준수</h4>\n<p>많은 산업과 관할권에는 사용자 데이터를 보호하고 기밀성을 보장하기 위한 특정 규정과 표준이 있습니다. 평문이나 약한 해싱 알고리즘으로 비밀번호를 저장하면 이러한 규정을 준수하지 않아 법적 결과, 재정적 벌금, 소프트웨어 애플리케이션 및 개발자의 평판 손상으로 이어질 수 있습니다.</p>",
    "howToFix_ko": "<h4>규칙을 준수하지 않는 코드 예시</h4>\n<p>다음 코드는 안전하지 않은 것으로 간주되는 레거시 다이제스트 기반 비밀번호 인코딩을 사용하므로 취약합니다.</p>\n<pre data-diff-id=\"12\" data-diff-type=\"noncompliant\">\n@Autowired\npublic void configureGlobal(AuthenticationManagerBuilder auth, DataSource dataSource) throws Exception {\n  auth.jdbcAuthentication()\n    .dataSource(dataSource)\n    .usersByUsernameQuery(\"SELECT * FROM users WHERE username = ?\")\n    .passwordEncoder(new StandardPasswordEncoder()); // 규칙 위반\n}\n</pre>\n<h4>규칙을 준수하는 해결책</h4>\n<pre data-diff-id=\"12\" data-diff-type=\"compliant\">\n@Autowired\npublic void configureGlobal(AuthenticationManagerBuilder auth, DataSource dataSource) throws Exception {\n  auth.jdbcAuthentication()\n    .dataSource(dataSource)\n    .usersByUsernameQuery(\"SELECT * FROM users WHERE username = ?\")\n    .passwordEncoder(new BCryptPasswordEncoder());\n}\n</pre>\n<h3>작동 원리</h3>\n<h4>안전한 비밀번호 해싱 알고리즘 사용</h4>\n<p>일반적으로 알려진 보안 취약점이 없는 알고리즘에 의존해야 합니다. MD5 및 SHA-1 알고리즘은 사용하면 안 됩니다.</p>\n<p>SHA 계열 함수와 같은 일부 알고리즘은 일부 사용 사례에서는 강력한 것으로 간주되지만 계산 속도가 너무 빠르므로 무차별 대입 공격에 취약합니다. 특히 무차별 대입 공격 지향 하드웨어에서 더욱 그렇습니다.</p>\n<p>비밀번호를 보호하려면 현대적이고 느린 비밀번호 해싱 알고리즘을 선택하는 것이 중요합니다. 다음 알고리즘은 강도 순으로 현재까지 가장 안전한 비밀번호 해싱 알고리즘입니다:</p>\n<ol>\n  <li> Argon2 </li>\n  <li> scrypt </li>\n  <li> bcrypt </li>\n  <li> PBKDF2 </li>\n</ol>\n<p>Argon2가 최선의 선택이어야 하며, 이전 것을 사용할 수 없을 때 다른 것을 사용해야 합니다. FIPS-140 인증 알고리즘을 사용해야 하는 시스템의 경우 PBKDF2를 사용해야 합니다.</p>\n<p>가능하면 사용 가능한 가장 강력한 알고리즘을 선택하세요. 시스템에서 현재 사용하는 알고리즘을 업그레이드해야 하는 경우 OWASP에서 가능한 업그레이드 방법을 문서화했습니다: <a href=\"https://cheatsheetseries.owasp.org/cheatsheets/Password_Storage_Cheat_Sheet.html#upgrading-legacy-hashes\">레거시 해시 업그레이드</a>.</p>\n<p>이전 예제에서 <code>BCryptPasswordEncoder</code>는 무차별 대입 및 레인보우 테이블 공격을 포함한 다양한 유형의 공격에 안전하고 저항하도록 설계된 Java의 비밀번호 해싱 함수입니다. 느리고 적응적이며 자동으로 솔트를 구현합니다.</p>\n<h4>비밀번호를 평문으로 저장하지 마세요</h4>\n<p>사용자 비밀번호는 절대 평문으로 저장하면 안 됩니다. 대신 안전한 알고리즘을 사용하여 해시를 생성해야 합니다. 비밀번호 저장 보안을 다룰 때 모범 사례는 무차별 대입 공격을 더 어렵게 만드는 느린 해싱 알고리즘에 의존하는 것을 권장합니다. 조정 가능한 계산 및 메모리 복잡성을 가진 해싱 함수를 사용하는 것도 시간이 지남에 따라 보안 수준을 높일 수 있으므로 권장됩니다.</p>\n<p>사전 계산된 테이블 공격을 방지하기 위해 다이제스트 계산에 솔트를 추가하는 것도 권장됩니다(<a href='/coding_rules#rule_key=java%3AS2053'>S2053</a> 규칙 참조).</p>\n<h3>함정</h3>\n<h4>비밀번호 사전 해싱</h4>\n<p>bcrypt는 대부분의 구현에서 최대 입력 길이가 72바이트이므로 일부 개발자는 bcrypt로 해싱하기 전에 더 강력한 알고리즘으로 비밀번호를 사전 해싱하려고 할 수 있습니다.</p>\n<p>bcrypt로 비밀번호를 사전 해싱하는 것은 특정 범위의 문제로 이어질 수 있으므로 권장되지 않습니다. 강력한 솔트와 높은 라운드 수를 사용하는 것만으로 비밀번호를 보호할 수 있습니다.</p>\n<p>이에 대한 자세한 정보는 여기에서 찾을 수 있습니다: <a href=\"https://cheatsheetseries.owasp.org/cheatsheets/Password_Storage_Cheat_Sheet.html#pre-hashing-passwords-with-bcrypt\">Bcrypt로 비밀번호 사전 해싱</a>.</p>",
    "moreInfo_ko": "<h3>문서</h3>\n<ul>\n  <li> Spring Framework 보안 문서 - <a href=\"https://docs.spring.io/spring-security/site/docs/current/api/org/springframework/security/crypto/bcrypt/BCryptPasswordEncoder.html\">BCryptPasswordEncoder 클래스</a> </li>\n  <li> OWASP 치트 시트 - <a href=\"https://cheatsheetseries.owasp.org/cheatsheets/Password_Storage_Cheat_Sheet.html\">비밀번호 저장 치트 시트</a> </li>\n</ul>\n<h3>표준</h3>\n<ul>\n  <li> OWASP - <a href=\"https://owasp.org/Top10/A02_2021-Cryptographic_Failures/\">상위 10가지 2021 카테고리 A2 - 암호화 실패</a> </li>\n  <li> OWASP - <a href=\"https://owasp.org/Top10/A04_2021-Insecure_Design/\">상위 10가지 2021 카테고리 A4 - 안전하지 않은 설계</a> </li>\n  <li> OWASP - <a href=\"https://owasp.org/www-project-top-ten/2017/A3_2017-Sensitive_Data_Exposure\">상위 10가지 2017 카테고리 A3 - 민감한 데이터 노출</a> </li>\n  <li> OWASP - <a href=\"https://owasp.org/www-project-mobile-top-10/2023-risks/m10-insufficient-cryptography\">모바일 상위 10가지 2024 카테고리 M10 - 불충분한 암호화</a> </li>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/256\">CWE-256 - 비밀번호의 평문 저장</a> </li>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/916\">CWE-916 - 불충분한 계산 노력으로 비밀번호 해시 사용</a> </li>\n</ul>"
  },
  {
    "id": "S1612",
    "key": "java:S1612",
    "name": "Lambdas should be replaced with method references",
    "type": "code-smell",
    "severity": "minor",
    "tags": [
      "java8"
    ],
    "why": "<p>Method or constructor references are more readable than lambda expressions in many situations, and may therefore be preferred.</p>\n<p>However, method references are sometimes less concise than lambdas. In such cases, it might be preferrable to keep the lambda expression for better\nreadability. Therefore, this rule only raises issues on lambda expressions where the replacement method reference is shorter.</p>\n<p>This rule is automatically disabled when the project's <code>sonar.java.source</code> is lower than <code>8</code>, as lambda expressions were\nintroduced in Java 8.</p>",
    "howToFix": "<p>Refer to the called method by its reference instead of wrapping it in a lambda expression.</p>\n<p>For instance:</p>\n<ul>\n  <li> <code>null</code> checks can be replaced with references to <code>Objects::isNull</code> and <code>Objects::nonNull</code> </li>\n  <li> Casts can be replaced with <code>SomeClass.class::cast</code> </li>\n  <li> <code>instanceof</code> can be replaced with <code>SomeClass.class::isInstance</code> </li>\n</ul>\n\n<h4>Noncompliant code example</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\nclass A {\n  void process(List&lt;A&gt; list) {\n    list.stream()\n      .filter(myListValue -&gt; myListValue instanceof B)     // Noncompliant\n      .map(listValueToMap -&gt; (B) listValueToMap)           // Noncompliant\n      .map(bValueToMap -&gt; bValueToMap.&lt;String&gt;getObject()) // Noncompliant\n      .forEach(o -&gt; System.out.println(o));                // Noncompliant\n  }\n}\n\nclass B extends A {\n  &lt;T&gt; T getObject() {\n    return null;\n  }\n}\n</pre>\n<h4>Compliant solution</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\nclass A {\n  void process(List&lt;A&gt; list) {\n    list.stream()\n      .filter(B.class::isInstance)   // Compliant\n      .map(B.class::cast)            // Compliant\n      .map(B::&lt;String&gt;getObject)     // Compliant\n      .forEach(System.out::println); // Compliant\n  }\n}\n\nclass B extends A {\n  &lt;T&gt; T getObject() {\n    return null;\n  }\n}\n</pre>",
    "moreInfo": "<ul>\n  <li> <a href=\"https://docs.oracle.com/javase/tutorial/java/javaOO/methodreferences.html\">Method References - The Java™ Tutorials</a> </li>\n</ul>",
    "status": "READY",
    "name_ko": "Lambda는 메서드 참조로 대체해야 합니다",
    "why_ko": "<p>메서드 또는 생성자 참조는 많은 상황에서 람다 표현식보다 더 읽기 쉬우므로 선호될 수 있습니다.</p>\n<p>그러나 메서드 참조가 람다보다 덜 간결한 경우도 있습니다. 이러한 경우에는 더 나은 가독성을 위해 람다 표현식을 유지하는 것이 더 나을 수 있습니다. 따라서 이 규칙은 대체 메서드 참조가 더 짧은 람다 표현식에 대해서만 이슈를 발생시킵니다.</p>\n<p>이 규칙은 프로젝트의 <code>sonar.java.source</code>가 <code>8</code>보다 낮으면 자동으로 비활성화됩니다. 람다 표현식이 Java 8에서 도입되었기 때문입니다.</p>",
    "howToFix_ko": "<p>호출된 메서드를 람다 표현식으로 감싸는 대신 참조로 참조하세요.</p>\n<p>예를 들어:</p>\n<ul>\n  <li> <code>null</code> 검사는 <code>Objects::isNull</code> 및 <code>Objects::nonNull</code>에 대한 참조로 대체할 수 있습니다 </li>\n  <li> 캐스트는 <code>SomeClass.class::cast</code>로 대체할 수 있습니다 </li>\n  <li> <code>instanceof</code>는 <code>SomeClass.class::isInstance</code>로 대체할 수 있습니다 </li>\n</ul>\n\n<h4>규칙을 준수하지 않는 코드 예시</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\nclass A {\n  void process(List&lt;A&gt; list) {\n    list.stream()\n      .filter(myListValue -&gt; myListValue instanceof B)     // 규칙 위반\n      .map(listValueToMap -&gt; (B) listValueToMap)           // 규칙 위반\n      .map(bValueToMap -&gt; bValueToMap.&lt;String&gt;getObject()) // 규칙 위반\n      .forEach(o -&gt; System.out.println(o));                // 규칙 위반\n  }\n}\n\nclass B extends A {\n  &lt;T&gt; T getObject() {\n    return null;\n  }\n}\n</pre>\n<h4>규칙을 준수하는 해결책</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\nclass A {\n  void process(List&lt;A&gt; list) {\n    list.stream()\n      .filter(B.class::isInstance)   // 규칙 준수\n      .map(B.class::cast)            // 규칙 준수\n      .map(B::&lt;String&gt;getObject)     // 규칙 준수\n      .forEach(System.out::println); // 규칙 준수\n  }\n}\n\nclass B extends A {\n  &lt;T&gt; T getObject() {\n    return null;\n  }\n}\n</pre>",
    "moreInfo_ko": "<ul>\n  <li> <a href=\"https://docs.oracle.com/javase/tutorial/java/javaOO/methodreferences.html\">메서드 참조 - The Java™ Tutorials</a> </li>\n</ul>"
  },
  {
    "id": "S5128",
    "key": "java:S5128",
    "name": "\"Bean Validation\" (JSR 380) should be properly configured",
    "type": "code-smell",
    "severity": "critical",
    "tags": [],
    "why": "<p><code>Bean Validation</code> as per defined by JSR 380 can be triggered programmatically or also executed by the <code>Bean Validation</code>\nproviders. However something should tell the <code>Bean Validation</code> provider that a variable must be validated otherwise no validation will\nhappen. This can be achieved by annotating a variable with <code>javax.validation.Valid</code> and unfortunally it's easy to forget to add this\nannotation on complex Beans.</p>\n<p>Not annotating a variable with <code>@Valid</code> means <code>Bean Validation</code> will not be triggered for this variable, but readers may\noverlook this omission and assume the variable will be validated.</p>\n<p>This rule will run by default on all <code>Class</code>'es and therefore can generate a lot of noise. This rule should be restricted to run only on\ncertain layers. For this reason, the \"Restrict Scope of Coding Rules\" feature should be used to check for missing <code>@Valid</code> annotations only\non some packages of the application.</p>\n<h3>Noncompliant code example</h3>\n<pre>\nimport javax.validation.Valid;\nimport javax.validation.constraints.NotNull;\n\npublic class User {\n  @NotNull\n  private String name;\n}\n\npublic class Group {\n  @NotNull\n  private List&lt;User&gt; users; // Noncompliant; User instances are not validated\n}\n\npublic class MyService {\n  public void login(User user) { // Noncompliant; parameter \"user\" is not validated\n  }\n}\n</pre>\n<h3>Compliant solution</h3>\n<pre>\nimport javax.validation.Valid;\nimport javax.validation.constraints.NotNull;\n\npublic class User {\n  @NotNull\n  private String name;\n}\n\npublic class Group {\n  @Valid\n  @NotNull\n  private List&lt;User&gt; users; // Compliant; User instances are validated\n\n  @NotNull\n  // preferred style as of Bean Validation 2.0\n  private List&lt;@Valid User&gt; users2; // Compliant; User instances are validated\n}\n\npublic class MyService {\n  public void login(@Valid User user) { // Compliant\n  }\n}\n</pre>",
    "howToFix": "",
    "moreInfo": "<ul>\n  <li> <a href=\"https://beanvalidation.org/2.0/spec/\">Bean Validation 2.0 (JSR 380)</a> </li>\n</ul>",
    "status": "READY",
    "name_ko": "\"Bean Validation\" (JSR 380)을 올바르게 구성해야 합니다",
    "why_ko": "<p>JSR 380에 정의된 <code>Bean Validation</code>은 프로그래밍 방식으로 트리거되거나 <code>Bean Validation</code> 제공자에 의해 실행될 수 있습니다. 그러나 <code>Bean Validation</code> 제공자에게 변수가 유효성 검사를 받아야 한다고 알려주는 무언가가 있어야 합니다. 그렇지 않으면 유효성 검사가 수행되지 않습니다. 이는 변수에 <code>javax.validation.Valid</code>를 어노테이션하여 달성할 수 있으며, 복잡한 Bean에서는 이 어노테이션을 추가하는 것을 잊기 쉽습니다.</p>\n<p>변수에 <code>@Valid</code>를 어노테이션하지 않으면 해당 변수에 대해 <code>Bean Validation</code>이 트리거되지 않지만, 독자는 이 누락을 간과하고 변수가 유효성 검사를 받을 것이라고 가정할 수 있습니다.</p>\n<p>이 규칙은 기본적으로 모든 <code>Class</code>에서 실행되므로 많은 노이즈를 생성할 수 있습니다. 이 규칙은 특정 레이어에서만 실행되도록 제한해야 합니다. 이러한 이유로 \"코딩 규칙 범위 제한\" 기능을 사용하여 애플리케이션의 일부 패키지에서만 누락된 <code>@Valid</code> 어노테이션을 확인해야 합니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\nimport javax.validation.Valid;\nimport javax.validation.constraints.NotNull;\n\npublic class User {\n  @NotNull\n  private String name;\n}\n\npublic class Group {\n  @NotNull\n  private List&lt;User&gt; users; // 규칙 위반; User 인스턴스가 유효성 검사되지 않음\n}\n\npublic class MyService {\n  public void login(User user) { // 규칙 위반; 매개변수 \"user\"가 유효성 검사되지 않음\n  }\n}\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre>\nimport javax.validation.Valid;\nimport javax.validation.constraints.NotNull;\n\npublic class User {\n  @NotNull\n  private String name;\n}\n\npublic class Group {\n  @Valid\n  @NotNull\n  private List&lt;User&gt; users; // 규칙 준수; User 인스턴스가 유효성 검사됨\n\n  @NotNull\n  // Bean Validation 2.0 기준 선호되는 스타일\n  private List&lt;@Valid User&gt; users2; // 규칙 준수; User 인스턴스가 유효성 검사됨\n}\n\npublic class MyService {\n  public void login(@Valid User user) { // 규칙 준수\n  }\n}\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": "<ul>\n  <li> <a href=\"https://beanvalidation.org/2.0/spec/\">Bean Validation 2.0 (JSR 380)</a> </li>\n</ul>"
  },
  {
    "id": "S881",
    "key": "java:S881",
    "name": "Increment (++) and decrement (--) operators should not be used in a method call or mixed with other operators in an expression",
    "type": "code-smell",
    "severity": "major",
    "tags": [
      "cert"
    ],
    "why": "<p>The use of increment and decrement operators in method calls or in combination with other arithmetic operators is not recommended, because:</p>\n<ul>\n  <li> It can significantly impair the readability of the code. </li>\n  <li> It introduces additional side effects into a statement, with the potential for undefined behavior. </li>\n  <li> It is safer to use these operators in isolation from any other arithmetic operators. </li>\n</ul>\n<h3>Noncompliant code example</h3>\n<pre>\nu8a = ++u8b + u8c--;\nfoo = bar++ / 4;\n</pre>\n<h3>Compliant solution</h3>\n<p>The following sequence is clearer and therefore safer:</p>\n<pre>\n++u8b;\nu8a = u8b + u8c;\nu8c--;\nfoo = bar / 4;\nbar++;\n</pre>",
    "howToFix": "",
    "moreInfo": "<ul>\n  <li> <a href=\"https://wiki.sei.cmu.edu/confluence/x/StYxBQ\">CERT, EXP30-C.</a> - Do not depend on the order of evaluation for side effects </li>\n  <li> <a href=\"https://wiki.sei.cmu.edu/confluence/x/IXw-BQ\">CERT, EXP50-CPP.</a> - Do not depend on the order of evaluation for side effects </li>\n  <li> <a href=\"https://wiki.sei.cmu.edu/confluence/x/NDdGBQ\">CERT, EXP05-J.</a> - Do not follow a write by a subsequent write or read of the same\n  object within an expression </li>\n</ul>",
    "status": "READY",
    "name_ko": "증가(++) 및 감소(--) 연산자는 메서드 호출이나 다른 연산자와 혼합된 표현식에서 사용하면 안 됩니다",
    "why_ko": "<p>메서드 호출에서 또는 다른 산술 연산자와 조합하여 증가 및 감소 연산자를 사용하는 것은 권장되지 않습니다. 왜냐하면:</p>\n<ul>\n  <li> 코드의 가독성을 크게 저하시킬 수 있습니다. </li>\n  <li> 정의되지 않은 동작의 가능성과 함께 문에 추가적인 부작용을 도입합니다. </li>\n  <li> 이러한 연산자는 다른 산술 연산자와 분리하여 사용하는 것이 더 안전합니다. </li>\n</ul>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\nu8a = ++u8b + u8c--;\nfoo = bar++ / 4;\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<p>다음 순서가 더 명확하고 따라서 더 안전합니다:</p>\n<pre>\n++u8b;\nu8a = u8b + u8c;\nu8c--;\nfoo = bar / 4;\nbar++;\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": "<ul>\n  <li> <a href=\"https://wiki.sei.cmu.edu/confluence/x/StYxBQ\">CERT, EXP30-C.</a> - 부작용에 대해 평가 순서에 의존하지 마세요 </li>\n  <li> <a href=\"https://wiki.sei.cmu.edu/confluence/x/IXw-BQ\">CERT, EXP50-CPP.</a> - 부작용에 대해 평가 순서에 의존하지 마세요 </li>\n  <li> <a href=\"https://wiki.sei.cmu.edu/confluence/x/NDdGBQ\">CERT, EXP05-J.</a> - 표현식 내에서 동일한 객체에 대한 쓰기 후에 후속 쓰기나 읽기를 하지 마세요 </li>\n</ul>"
  },
  {
    "id": "S6211",
    "key": "java:S6211",
    "name": "Custom getter method should not be used to override record's getter behavior",
    "type": "code-smell",
    "severity": "major",
    "tags": [
      "java16"
    ],
    "why": "<p>Before records appeared in Java 16, there was a common way to represent getters for private fields of a class:&nbsp; a method named \"get\" with a\ncapitalized field name. For example, for a&nbsp;<code>String</code> field named \"myField\" the signature of the getter method will be: <code>public\nString getMyField()</code></p>\n<p>In records, getters are named differently. Getters created by default do not contain the \"get\" prefix. So for a record's <code>String</code> field\n\"myField\" the getter method will be: <code>public String myField()</code></p>\n<p>This means that if you want to override the default getter behavior it is better to use the method provided by records instead of creating a new\none. Otherwise, this will bring confusion to the users of the record as two getters will be available and even leads to bugs if the behavior is\ndifferent from the default one.</p>\n<p>This rule raises an issue when a record contains a getter named \"get\" with a capitalized field name that is not behaving the same as the default\none.</p>\n<h3>Noncompliant code example</h3>\n<pre>\nrecord Person(String name, int age) {\n    public String getName() { // Noncompliant\n        return name.toUpperCase(Locale.ROOT);\n    }\n}\n</pre>\n<h3>Compliant solution</h3>\n<pre>\nrecord Person(String name, int age) {\n    @Override\n    public String name() { // Compliant\n        return name.toUpperCase(Locale.ROOT);\n    }\n}\n\nrecord Person(String name, int age) {\n    public String getNameUpperCase() { // Compliant\n        return name.toUpperCase(Locale.ROOT);\n    }\n}\nrecord Person(String name, int age) {\n    public String getName() { // Compliant, is equivalent to 'name()'\n        return name;\n    }\n}\nrecord Person(String name, int age) {\n    @Override\n    public String name() { // Compliant\n        return name.toUpperCase(Locale.ROOT);\n    }\n    public String getName() { // Compliant, equal to 'name()'\n        return name.toUpperCase(Locale.ROOT);\n    }\n}\n</pre>\n<h3>Exceptions</h3>\n<p>If the implementations of <code>getMyField()</code> and <code>myField()</code> methods are equivalent, the issue should not be raised as this was\nprobably done to support compatibility with the previous convention.</p>",
    "howToFix": "",
    "moreInfo": "<ul>\n  <li> <a href=\"https://docs.oracle.com/javase/specs/jls/se16/html/jls-8.html#jls-8.10\">Records specification</a> </li>\n</ul>",
    "status": "READY",
    "name_ko": "Record의 getter 동작을 오버라이드하기 위해 커스텀 getter 메서드를 사용하면 안 됩니다",
    "why_ko": "<p>Java 16에서 record가 등장하기 전에는 클래스의 private 필드에 대한 getter를 나타내는 일반적인 방법이 있었습니다: 대문자화된 필드 이름이 있는 \"get\"으로 명명된 메서드. 예를 들어, \"myField\"라는 이름의 <code>String</code> 필드에 대해 getter 메서드의 시그니처는 <code>public String getMyField()</code>입니다.</p>\n<p>Record에서는 getter의 이름이 다릅니다. 기본적으로 생성된 getter에는 \"get\" 접두사가 포함되지 않습니다. 따라서 record의 <code>String</code> 필드 \"myField\"에 대한 getter 메서드는 <code>public String myField()</code>입니다.</p>\n<p>이는 기본 getter 동작을 오버라이드하려면 새 메서드를 만드는 대신 record에서 제공하는 메서드를 사용하는 것이 좋다는 것을 의미합니다. 그렇지 않으면 두 개의 getter를 사용할 수 있어 record 사용자에게 혼란을 주고, 동작이 기본 동작과 다르면 버그로 이어질 수 있습니다.</p>\n<p>이 규칙은 record에 대문자화된 필드 이름이 있는 \"get\"으로 명명된 getter가 있고 기본 동작과 다르게 동작할 때 문제를 보고합니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\nrecord Person(String name, int age) {\n    public String getName() { // 규칙 위반\n        return name.toUpperCase(Locale.ROOT);\n    }\n}\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre>\nrecord Person(String name, int age) {\n    @Override\n    public String name() { // 규칙 준수\n        return name.toUpperCase(Locale.ROOT);\n    }\n}\n\nrecord Person(String name, int age) {\n    public String getNameUpperCase() { // 규칙 준수\n        return name.toUpperCase(Locale.ROOT);\n    }\n}\nrecord Person(String name, int age) {\n    public String getName() { // 규칙 준수, 'name()'과 동등함\n        return name;\n    }\n}\nrecord Person(String name, int age) {\n    @Override\n    public String name() { // 규칙 준수\n        return name.toUpperCase(Locale.ROOT);\n    }\n    public String getName() { // 규칙 준수, 'name()'과 동일함\n        return name.toUpperCase(Locale.ROOT);\n    }\n}\n</pre>\n<h3>예외</h3>\n<p><code>getMyField()</code>와 <code>myField()</code> 메서드의 구현이 동등하면, 이전 규칙과의 호환성을 지원하기 위해 수행되었을 가능성이 높으므로 문제를 보고하지 않습니다.</p>",
    "howToFix_ko": "",
    "moreInfo_ko": "<ul>\n  <li> <a href=\"https://docs.oracle.com/javase/specs/jls/se16/html/jls-8.html#jls-8.10\">Record 명세</a> </li>\n</ul>"
  },
  {
    "id": "S2252",
    "key": "java:S2252",
    "name": "Loop conditions should be true at least once",
    "type": "bug",
    "severity": "major",
    "tags": [],
    "why": "<p>A <a href=\"https://docs.oracle.com/javase/tutorial/java/nutsandbolts/for.html\"><code>for</code></a> loop is a fundamental programming construct\nused to execute a block of code repeatedly. However, if the loop's condition is false before the first iteration, the loop will never execute.</p>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\nfor (int i = 0; i &lt; 0; i++) {  // Noncompliant: the condition is always false, and the loop will never execute\n    // ...\n}\n</pre>\n<p>Rewrite the loop to ensure the condition evaluates to <code>true</code> at least once.</p>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\nfor (int i = 0; i &lt; 10; i++) {  // Compliant: the condition is true at least once, the loop will execute\n    // ...\n}\n</pre>\n<p>This bug has the potential to cause unexpected outcomes as the loop might contain critical code that needs to be executed.</p>",
    "howToFix": "",
    "moreInfo": "<h3>Documentation</h3>\n<ul>\n  <li> Java Documentation - <a href=\"https://docs.oracle.com/javase/tutorial/java/nutsandbolts/for.html\">The <code>for</code> statement</a> </li>\n</ul>",
    "status": "READY",
    "name_ko": "루프 조건은 최소 한 번은 참이어야 합니다",
    "why_ko": "<p><a href=\"https://docs.oracle.com/javase/tutorial/java/nutsandbolts/for.html\"><code>for</code></a> 루프는 코드 블록을 반복적으로 실행하는 데 사용되는 기본적인 프로그래밍 구문입니다. 그러나 루프의 조건이 첫 번째 반복 전에 거짓이면 루프는 절대 실행되지 않습니다.</p>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\nfor (int i = 0; i &lt; 0; i++) {  // 규칙 위반: 조건이 항상 거짓이므로 루프가 실행되지 않음\n    // ...\n}\n</pre>\n<p>조건이 최소 한 번은 <code>true</code>로 평가되도록 루프를 다시 작성하세요.</p>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\nfor (int i = 0; i &lt; 10; i++) {  // 규칙 준수: 조건이 최소 한 번은 참이므로 루프가 실행됨\n    // ...\n}\n</pre>\n<p>이 버그는 실행해야 하는 중요한 코드가 루프에 포함되어 있을 수 있으므로 예상치 못한 결과를 초래할 수 있습니다.</p>",
    "howToFix_ko": "",
    "moreInfo_ko": "<h3>문서</h3>\n<ul>\n  <li> Java Documentation - <a href=\"https://docs.oracle.com/javase/tutorial/java/nutsandbolts/for.html\"><code>for</code> 문</a> </li>\n</ul>"
  },
  {
    "id": "S1604",
    "key": "java:S1604",
    "name": "Anonymous inner classes containing only one method should become lambdas",
    "type": "code-smell",
    "severity": "major",
    "tags": [
      "java8"
    ],
    "why": "<p>Before Java 8, the only way to partially support closures in Java was by using anonymous inner classes. Java 8 introduced lambdas, which are\nsignificantly more readable and should be used instead.</p>\n<p>This rule is automatically disabled when the project's <code>sonar.java.source</code> is lower than <code>8</code>, as lambda expressions were\nintroduced in Java 8.</p>\n\n<h4>Noncompliant code example</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\nmyCollection.stream().map(new Function&lt;String,String&gt;() { // Noncompliant, use a lambda expression instead\n  @Override\n  public String apply(String input) {\n    return new StringBuilder(input).reverse().toString();\n  }\n})\n  ...\n</pre>\n<h4>Compliant solution</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\nmyCollection.stream()\n  .map(input -&gt; new StringBuilder(input).reverse().toString()) // Compliant\n    ...\n</pre>\n<h4>Noncompliant code example</h4>\n<pre data-diff-id=\"2\" data-diff-type=\"noncompliant\">\nPredicate&lt;String&gt; isEmpty = new Predicate&lt;String&gt;() { // Noncompliant, use a lambda expression instead\n  @Override\n  public boolean test(String myString) {\n    return myString.isEmpty();\n  }\n};\n</pre>\n<h4>Compliant solution</h4>\n<pre data-diff-id=\"2\" data-diff-type=\"compliant\">\nPredicate&lt;String&gt; isEmpty = myString -&gt; myString.isEmpty(); // Compliant\n</pre>",
    "howToFix": "",
    "moreInfo": "<ul>\n  <li> <a href=\"https://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html\">Lambda Expressions - The Java™ Tutorials</a> </li>\n</ul>",
    "status": "READY",
    "name_ko": "하나의 메서드만 포함하는 익명 내부 클래스는 Lambda로 변환해야 합니다",
    "why_ko": "<p>Java 8 이전에는 Java에서 클로저를 부분적으로 지원하는 유일한 방법이 익명 내부 클래스를 사용하는 것이었습니다. Java 8에서 람다가 도입되었으며, 이는 훨씬 더 읽기 쉬우므로 대신 사용해야 합니다.</p>\n<p>이 규칙은 프로젝트의 <code>sonar.java.source</code>가 <code>8</code>보다 낮으면 자동으로 비활성화됩니다. 람다 표현식이 Java 8에서 도입되었기 때문입니다.</p>\n\n<h4>규칙을 준수하지 않는 코드 예시</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\nmyCollection.stream().map(new Function&lt;String,String&gt;() { // 규칙 위반, 대신 람다 표현식을 사용하세요\n  @Override\n  public String apply(String input) {\n    return new StringBuilder(input).reverse().toString();\n  }\n})\n  ...\n</pre>\n<h4>규칙을 준수하는 해결책</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\nmyCollection.stream()\n  .map(input -&gt; new StringBuilder(input).reverse().toString()) // 규칙 준수\n    ...\n</pre>\n<h4>규칙을 준수하지 않는 코드 예시</h4>\n<pre data-diff-id=\"2\" data-diff-type=\"noncompliant\">\nPredicate&lt;String&gt; isEmpty = new Predicate&lt;String&gt;() { // 규칙 위반, 대신 람다 표현식을 사용하세요\n  @Override\n  public boolean test(String myString) {\n    return myString.isEmpty();\n  }\n};\n</pre>\n<h4>규칙을 준수하는 해결책</h4>\n<pre data-diff-id=\"2\" data-diff-type=\"compliant\">\nPredicate&lt;String&gt; isEmpty = myString -&gt; myString.isEmpty(); // 규칙 준수\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": "<ul>\n  <li> <a href=\"https://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html\">람다 표현식 - The Java™ Tutorials</a> </li>\n</ul>"
  },
  {
    "id": "S2301",
    "key": "java:S2301",
    "name": "Public methods should not contain selector arguments",
    "type": "code-smell",
    "severity": "major",
    "tags": [
      "design"
    ],
    "why": "<p>A selector argument is a <code>boolean</code> argument that's used to determine which of two paths to take through a method. Specifying such a\nparameter may seem innocuous, particularly if it's well named.</p>\n<p>Unfortunately, the maintainers of the code calling the method won't see the parameter name, only its value. They'll be forced either to guess at\nthe meaning or to take extra time to look the method up.</p>\n<p>Instead, separate methods should be written.</p>\n<p>This rule finds methods with a <code>boolean</code> that's used to determine which path to take through the method.</p>\n<h3>Noncompliant code example</h3>\n<pre>\npublic String tempt(String name, boolean ofAge) {\n  if (ofAge) {\n    offerLiquor(name);\n  } else {\n    offerCandy(name);\n  }\n}\n\n// ...\npublic void corrupt() {\n  tempt(\"Joe\", false); // does this mean not to temp Joe?\n}\n</pre>\n<h3>Compliant solution</h3>\n<pre>\npublic void temptAdult(String name) {\n  offerLiquor(name);\n}\n\npublic void temptChild(String name) {\n    offerCandy(name);\n}\n\n// ...\npublic void corrupt() {\n  age &lt; legalAge ? temptChild(\"Joe\") : temptAdult(\"Joe\");\n}\n</pre>",
    "howToFix": "",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "public 메서드에 선택자 인수를 포함하면 안 됩니다",
    "why_ko": "<p>선택자 인수는 메서드에서 두 경로 중 어느 것을 취할지 결정하는 데 사용되는 <code>boolean</code> 인수입니다. 이러한 매개변수를 지정하는 것은 특히 잘 명명된 경우 해롭지 않아 보일 수 있습니다.</p>\n<p>불행히도 메서드를 호출하는 코드의 유지보수자는 매개변수 이름이 아닌 값만 볼 수 있습니다. 그들은 의미를 추측하거나 메서드를 찾아보는 데 추가 시간을 들여야 합니다.</p>\n<p>대신 별도의 메서드를 작성해야 합니다.</p>\n<p>이 규칙은 메서드에서 어떤 경로를 취할지 결정하는 데 사용되는 <code>boolean</code>이 있는 메서드를 찾습니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\npublic String tempt(String name, boolean ofAge) {\n  if (ofAge) {\n    offerLiquor(name);\n  } else {\n    offerCandy(name);\n  }\n}\n\n// ...\npublic void corrupt() {\n  tempt(\"Joe\", false); // Joe를 유혹하지 말라는 뜻인가요?\n}\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre>\npublic void temptAdult(String name) {\n  offerLiquor(name);\n}\n\npublic void temptChild(String name) {\n    offerCandy(name);\n}\n\n// ...\npublic void corrupt() {\n  age &lt; legalAge ? temptChild(\"Joe\") : temptAdult(\"Joe\");\n}\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": ""
  },
  {
    "id": "S1192",
    "key": "java:S1192",
    "name": "String literals should not be duplicated",
    "type": "code-smell",
    "severity": "critical",
    "tags": [
      "design"
    ],
    "why": "<p>Duplicated string literals make the process of refactoring complex and error-prone, as any change would need to be propagated on all\noccurrences.</p>\n<h3>Exceptions</h3>\n<p>To prevent generating some false-positives, literals having less than 5 characters are excluded.</p>",
    "howToFix": "<p>Use constants to replace the duplicated string literals. Constants can be referenced from many places, but only need to be updated in a single\nplace.</p>\n\n<h4>Noncompliant code example</h4>\n<p>With the default threshold of 3:</p>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\npublic void run() {\n  prepare(\"action1\");                              // Noncompliant - \"action1\" is duplicated 3 times\n  execute(\"action1\");\n  release(\"action1\");\n}\n\n@SuppressWarning(\"all\")                            // Compliant - annotations are excluded\nprivate void method1() { /* ... */ }\n@SuppressWarning(\"all\")\nprivate void method2() { /* ... */ }\n\npublic String printInQuotes(String a, String b) {\n  return \"'\" + a + \"'\" + b + \"'\";               // Compliant - literal \"'\" has less than 5 characters and is excluded\n}\n</pre>\n<h4>Compliant solution</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\nprivate static final String ACTION_1 = \"action1\";  // Compliant\n\npublic void run() {\n  prepare(ACTION_1);                               // Compliant\n  execute(ACTION_1);\n  release(ACTION_1);\n}\n</pre>",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "String 리터럴은 중복되면 안 됩니다",
    "why_ko": "<p>중복된 문자열 리터럴은 모든 발생 위치에 변경 사항을 전파해야 하므로 리팩토링 프로세스를 복잡하고 오류가 발생하기 쉽게 만듭니다.</p>\n<h3>예외 사항</h3>\n<p>일부 오탐을 방지하기 위해 5자 미만의 리터럴은 제외됩니다.</p>",
    "howToFix_ko": "<p>중복된 문자열 리터럴을 대체하기 위해 상수를 사용하세요. 상수는 많은 곳에서 참조될 수 있지만, 한 곳에서만 업데이트하면 됩니다.</p>\n\n<h4>규칙을 준수하지 않는 코드 예시</h4>\n<p>기본 임계값 3의 경우:</p>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\npublic void run() {\n  prepare(\"action1\");                              // 규칙 위반 - \"action1\"이 3번 중복됨\n  execute(\"action1\");\n  release(\"action1\");\n}\n\n@SuppressWarning(\"all\")                            // 규칙 준수 - 어노테이션은 제외됨\nprivate void method1() { /* ... */ }\n@SuppressWarning(\"all\")\nprivate void method2() { /* ... */ }\n\npublic String printInQuotes(String a, String b) {\n  return \"'\" + a + \"'\" + b + \"'\";               // 규칙 준수 - 리터럴 \"'\"는 5자 미만이므로 제외됨\n}\n</pre>\n<h4>규칙을 준수하는 해결책</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\nprivate static final String ACTION_1 = \"action1\";  // 규칙 준수\n\npublic void run() {\n  prepare(ACTION_1);                               // 규칙 준수\n  execute(ACTION_1);\n  release(ACTION_1);\n}\n</pre>",
    "moreInfo_ko": ""
  },
  {
    "id": "S6207",
    "key": "java:S6207",
    "name": "Redundant constructors/methods should be avoided in records",
    "type": "code-smell",
    "severity": "major",
    "tags": [
      "java16"
    ],
    "why": "<p>In Java 16 records represent a brief notation for immutable data structures. Records have autogenerated implementations for constructors with all\nparameters, <code>getters</code>, <code>equals</code>, <code>hashcode</code> and <code>toString</code>. Although these methods can still be overridden\ninside records, there is no use to do so if no special logic is required.</p>\n<p>This rule reports an issue on empty compact constructors, trivial canonical constructors and simple getter methods with no additional logic.</p>\n<h3>Noncompliant code example</h3>\n<pre>\nrecord Person(String name, int age) {\n  Person(String name, int age) { // Noncompliant, already autogenerated\n    this.name = name;\n    this.age = age;\n  }\n}\n\nrecord Person(String name, int age) {\n  Person { // Noncompliant, no need for empty compact constructor\n  }\n  public String name() { // Noncompliant, already autogenerated\n    return name;\n  }\n}\n</pre>\n<h3>Compliant solution</h3>\n<pre>\nrecord Person(String name, int age) { } // Compliant\n\nrecord Person(String name, int age) {\n  Person(String name, int age) { // Compliant\n    this.name = name.toLowerCase(Locale.ROOT);\n    this.age = age;\n  }\n}\n\nrecord Person(String name, int age) {\n  Person { // Compliant\n    if (age &lt; 0) {\n      throw new IllegalArgumentException(\"Negative age\");\n    }\n  }\n  public String name() { // Compliant\n    return name.toUpperCase(Locale.ROOT);\n  }\n}\n</pre>",
    "howToFix": "",
    "moreInfo": "<ul>\n  <li> <a href=\"https://docs.oracle.com/javase/specs/jls/se16/html/jls-8.html#jls-8.10\">Records specification</a> </li>\n</ul>",
    "status": "READY",
    "name_ko": "Record에서 중복된 생성자/메서드를 피해야 합니다",
    "why_ko": "<p>Java 16에서 record는 불변 데이터 구조를 위한 간결한 표기법을 나타냅니다. Record는 모든 매개변수가 있는 생성자, <code>getter</code>, <code>equals</code>, <code>hashcode</code>, <code>toString</code>에 대해 자동 생성된 구현을 갖습니다. 이러한 메서드는 record 내에서 여전히 오버라이드할 수 있지만, 특별한 로직이 필요하지 않으면 그렇게 할 필요가 없습니다.</p>\n<p>이 규칙은 빈 컴팩트 생성자, 단순한 정규 생성자, 추가 로직이 없는 간단한 getter 메서드에 대해 문제를 보고합니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\nrecord Person(String name, int age) {\n  Person(String name, int age) { // 규칙 위반, 이미 자동 생성됨\n    this.name = name;\n    this.age = age;\n  }\n}\n\nrecord Person(String name, int age) {\n  Person { // 규칙 위반, 빈 컴팩트 생성자는 필요 없음\n  }\n  public String name() { // 규칙 위반, 이미 자동 생성됨\n    return name;\n  }\n}\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre>\nrecord Person(String name, int age) { } // 규칙 준수\n\nrecord Person(String name, int age) {\n  Person(String name, int age) { // 규칙 준수\n    this.name = name.toLowerCase(Locale.ROOT);\n    this.age = age;\n  }\n}\n\nrecord Person(String name, int age) {\n  Person { // 규칙 준수\n    if (age &lt; 0) {\n      throw new IllegalArgumentException(\"Negative age\");\n    }\n  }\n  public String name() { // 규칙 준수\n    return name.toUpperCase(Locale.ROOT);\n  }\n}\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": "<ul>\n  <li> <a href=\"https://docs.oracle.com/javase/specs/jls/se16/html/jls-8.html#jls-8.10\">Record 명세</a> </li>\n</ul>"
  },
  {
    "id": "S4144",
    "key": "java:S4144",
    "name": "Methods should not have identical implementations",
    "type": "code-smell",
    "severity": "major",
    "tags": [
      "suspicious",
      "duplicate",
      "confusing"
    ],
    "why": "<p>Two methods having the same implementation are suspicious. It might be that something else was intended. Or the duplication is intentional, which\nbecomes a maintenance burden.</p>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\nprivate final static String CODE = \"bounteous\";\n\npublic String calculateCode() {\n  doTheThing();\n  return CODE;\n}\n\npublic String getName() {  // Noncompliant: duplicates calculateCode\n  doTheThing();\n  return CODE;\n}\n</pre>\n<p>If the identical logic is intentional, the code should be refactored to avoid duplication. For example, by having both methods call the same method\nor by having one implementation invoke the other.</p>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\nprivate final static String CODE = \"bounteous\";\n\npublic String getCode() {\n  doTheThing();\n  return CODE;\n}\n\npublic String getName() { // The intent is clear\n  return getCode();\n}\n</pre>\n<h3>Exceptions</h3>\n<p>Methods that are not accessors (getters and setters), with fewer than 2 statements are ignored.</p>",
    "howToFix": "",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "메서드는 동일한 구현을 가지면 안 됩니다",
    "why_ko": "<p>동일한 구현을 가진 두 메서드는 의심스럽습니다. 다른 것이 의도되었을 수 있습니다. 또는 중복이 의도적인 경우 유지보수 부담이 됩니다.</p>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\nprivate final static String CODE = \"bounteous\";\n\npublic String calculateCode() {\n  doTheThing();\n  return CODE;\n}\n\npublic String getName() {  // 규칙 위반: calculateCode와 중복\n  doTheThing();\n  return CODE;\n}\n</pre>\n<p>동일한 로직이 의도적인 경우 중복을 피하기 위해 코드를 리팩토링해야 합니다. 예를 들어, 두 메서드가 같은 메서드를 호출하거나 한 구현이 다른 것을 호출하도록 합니다.</p>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\nprivate final static String CODE = \"bounteous\";\n\npublic String getCode() {\n  doTheThing();\n  return CODE;\n}\n\npublic String getName() { // 의도가 명확합니다\n  return getCode();\n}\n</pre>\n<h3>예외</h3>\n<p>접근자(getter 및 setter)가 아닌 메서드로 2개 미만의 문이 있는 경우 무시됩니다.</p>",
    "howToFix_ko": "",
    "moreInfo_ko": ""
  },
  {
    "id": "S3052",
    "key": "java:S3052",
    "name": "Fields should not be initialized to default values",
    "type": "code-smell",
    "severity": "minor",
    "tags": [
      "convention",
      "finding"
    ],
    "why": "<p>The compiler automatically initializes class fields to their default values before setting them with any initialization values, so there is no need\nto explicitly set a field to its default value. Further, under the logic that cleaner code is better code, it's considered poor style to do so.</p>\n<h3>Noncompliant code example</h3>\n<pre>\npublic class MyClass {\n\n  int count = 0;  // Noncompliant\n  // ...\n\n}\n</pre>\n<h3>Compliant solution</h3>\n<pre>\npublic class MyClass {\n\n  int count;\n  // ...\n\n}\n</pre>\n<h3>Exceptions</h3>\n<p><code>final</code> fields are ignored.</p>",
    "howToFix": "",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "필드를 기본값으로 초기화하면 안 됩니다",
    "why_ko": "<p>컴파일러는 클래스 필드를 초기화 값으로 설정하기 전에 자동으로 기본값으로 초기화하므로, 필드를 기본값으로 명시적으로 설정할 필요가 없습니다. 또한, 깔끔한 코드가 더 좋은 코드라는 논리 하에, 이렇게 하는 것은 좋지 않은 스타일로 간주됩니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\npublic class MyClass {\n\n  int count = 0;  // 규칙 위반\n  // ...\n\n}\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre>\npublic class MyClass {\n\n  int count;\n  // ...\n\n}\n</pre>\n<h3>예외</h3>\n<p><code>final</code> 필드는 무시됩니다.</p>",
    "howToFix_ko": "",
    "moreInfo_ko": ""
  },
  {
    "id": "S3750",
    "key": "java:S3750",
    "name": "Spring \"@Controller\" classes should not use \"@Scope\"",
    "type": "bug",
    "severity": "major",
    "tags": [
      "spring"
    ],
    "why": "<p>Spring <code>@Controller</code>s, <code>@Service</code>s, and <code>@Repository</code>s have <code>singleton</code> scope by default, meaning only\none instance of the class is ever instantiated in the application. Defining any other scope for one of these class types will result in needless churn\nas new instances are created and destroyed. In a busy web application, this could cause a significant amount of needless additional load on the\nserver.</p>\n<p>This rule raises an issue when the <code>@Scope</code> annotation is applied to a <code>@Controller</code>, <code>@Service</code>, or\n<code>@Repository</code> with any value but \"singleton\". <code>@Scope(\"singleton\")</code> is redundant, but ignored.</p>\n<h3>Noncompliant code example</h3>\n<pre>\n@Scope(\"prototype\")  // Noncompliant\n@Controller\npublic class HelloWorld {\n</pre>\n<h3>Compliant solution</h3>\n<pre>\n@Controller\npublic class HelloWorld {\n</pre>",
    "howToFix": "",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "Spring @Controller 클래스에 @Scope를 사용하면 안 됩니다",
    "why_ko": "<p>Spring <code>@Controller</code>, <code>@Service</code>, <code>@Repository</code>는 기본적으로 <code>singleton</code> 스코프를 가지며, 이는 애플리케이션에서 클래스의 인스턴스가 하나만 생성된다는 것을 의미합니다. 이러한 클래스 유형에 다른 스코프를 정의하면 새 인스턴스가 생성되고 소멸되면서 불필요한 교체가 발생합니다. 바쁜 웹 애플리케이션에서 이는 서버에 상당한 양의 불필요한 추가 부하를 유발할 수 있습니다.</p>\n<p>이 규칙은 <code>@Scope</code> 어노테이션이 \"singleton\"이 아닌 다른 값으로 <code>@Controller</code>, <code>@Service</code>, <code>@Repository</code>에 적용될 때 문제를 제기합니다. <code>@Scope(\"singleton\")</code>은 중복이지만 무시됩니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\n@Scope(\"prototype\")  // 규칙 위반\n@Controller\npublic class HelloWorld {\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre>\n@Controller\npublic class HelloWorld {\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": ""
  },
  {
    "id": "S2141",
    "key": "java:S2141",
    "name": "Classes that don't define \"hashCode()\" should not be used in hashes",
    "type": "bug",
    "severity": "major",
    "tags": [],
    "why": "<p>Because <code>Object</code> implements <code>hashCode</code>, any Java class can be put into a hash structure. However, classes that define\n<code>equals(Object)</code> but not <code>hashCode()</code> aren't truly hash-able because instances that are equivalent according to the\n<code>equals</code> method can return different hashes.</p>\n<h3>Noncompliant code example</h3>\n<pre>\npublic class Student {  // no hashCode() method; not hash-able\n  // ...\n\n  public boolean equals(Object o) {\n    // ...\n  }\n}\n\npublic class School {\n  private Map&lt;Student, Integer&gt; studentBody = // okay so far\n          new HashTable&lt;Student, Integer&gt;(); // Noncompliant\n\n  // ...\n</pre>\n<h3>Compliant solution</h3>\n<pre>\npublic class Student {  // has hashCode() method; hash-able\n  // ...\n\n  public boolean equals(Object o) {\n    // ...\n  }\n  public int hashCode() {\n    // ...\n  }\n}\n\npublic class School {\n  private Map&lt;Student, Integer&gt; studentBody = new HashTable&lt;Student, Integer&gt;();\n\n  // ...\n</pre>",
    "howToFix": "",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "\"hashCode()\"를 정의하지 않은 클래스는 해시에서 사용하면 안 됩니다",
    "why_ko": "<p><code>Object</code>가 <code>hashCode</code>를 구현하기 때문에 모든 Java 클래스는 해시 구조에 넣을 수 있습니다. 그러나 <code>equals(Object)</code>는 정의하지만 <code>hashCode()</code>는 정의하지 않는 클래스는 <code>equals</code> 메서드에 따라 동등한 인스턴스가 다른 해시를 반환할 수 있기 때문에 진정으로 해시 가능하지 않습니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\npublic class Student {  // hashCode() 메서드 없음; 해시 불가능\n  // ...\n\n  public boolean equals(Object o) {\n    // ...\n  }\n}\n\npublic class School {\n  private Map&lt;Student, Integer&gt; studentBody = // 여기까지는 괜찮음\n          new HashTable&lt;Student, Integer&gt;(); // 규칙 위반\n\n  // ...\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre>\npublic class Student {  // hashCode() 메서드 있음; 해시 가능\n  // ...\n\n  public boolean equals(Object o) {\n    // ...\n  }\n  public int hashCode() {\n    // ...\n  }\n}\n\npublic class School {\n  private Map&lt;Student, Integer&gt; studentBody = new HashTable&lt;Student, Integer&gt;();\n\n  // ...\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": ""
  },
  {
    "id": "S1444",
    "key": "java:S1444",
    "name": "\"public static\" fields should be constant",
    "type": "code-smell",
    "severity": "minor",
    "tags": [
      "cwe",
      "cert"
    ],
    "why": "<p>There is no good reason to declare a field \"public\" and \"static\" without also declaring it \"final\". Most of the time this is a kludge to share a\nstate among several objects. But with this approach, any object can do whatever it wants with the shared state, such as setting it to\n<code>null</code>.</p>\n<h3>Noncompliant code example</h3>\n<pre>\npublic class Greeter {\n  public static Foo foo = new Foo();\n  ...\n}\n</pre>\n<h3>Compliant solution</h3>\n<pre>\npublic class Greeter {\n  public static final Foo FOO = new Foo();\n  ...\n}\n</pre>",
    "howToFix": "",
    "moreInfo": "<ul>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/500\">CWE-500 - Public Static Field Not Marked Final</a> </li>\n  <li> <a href=\"https://wiki.sei.cmu.edu/confluence/x/WjdGBQ\">CERT OBJ10-J.</a> - Do not use public static nonfinal fields </li>\n</ul>",
    "status": "READY",
    "name_ko": "\"public static\" 필드는 상수여야 합니다",
    "why_ko": "<p>필드를 \"public\"과 \"static\"으로 선언하면서 \"final\"로도 선언하지 않을 좋은 이유가 없습니다. 대부분의 경우 이는 여러 객체 간에 상태를 공유하기 위한 임시방편입니다. 그러나 이 접근 방식을 사용하면 모든 객체가 공유 상태를 <code>null</code>로 설정하는 등 원하는 대로 할 수 있습니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\npublic class Greeter {\n  public static Foo foo = new Foo();\n  ...\n}\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre>\npublic class Greeter {\n  public static final Foo FOO = new Foo();\n  ...\n}\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": "<ul>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/500\">CWE-500 - Final로 표시되지 않은 Public Static 필드</a> </li>\n  <li> <a href=\"https://wiki.sei.cmu.edu/confluence/x/WjdGBQ\">CERT OBJ10-J.</a> - public static nonfinal 필드를 사용하지 마세요 </li>\n</ul>"
  },
  {
    "id": "S2638",
    "key": "java:S2638",
    "name": "Method overrides should not change contracts",
    "type": "code-smell",
    "severity": "critical",
    "tags": [
      "suspicious"
    ],
    "why": "<p>Because a subclass instance may be cast to and treated as an instance of the superclass, overriding methods should uphold the aspects of the\nsuperclass contract that relate to the Liskov Substitution Principle. Specifically, if the parameters or return type of the superclass method are\nmarked with any of the following: <code>@Nullable</code>, <code>@CheckForNull</code>, <code>@NotNull</code>, <code>@NonNull</code>, and\n<code>@Nonnull</code>, then subclass parameters are not allowed to tighten the contract, and return values are not allowed to loosen it.</p>\n\n<h4>Noncompliant code example</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\npublic class Fruit {\n\n  private Season ripe;\n  private String color;\n\n  public void setRipe(@Nullable Season ripe) {\n    this.ripe = ripe;\n  }\n\n  public @NotNull Integer getProtein() {\n    return 12;\n  }\n}\n\npublic class Raspberry extends Fruit {\n\n  public void setRipe(@NotNull Season ripe) {  // Noncompliant: the ripe argument annotated as @Nullable in parent class\n    this.ripe = ripe;\n  }\n\n  public @Nullable Integer getProtein() {  // Noncompliant: the return type annotated as @NotNull in parent class\n    return null;\n  }\n}\n</pre>\n<h4>Compliant solution</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\npublic class Fruit {\n\n  private Season ripe;\n  private String color;\n\n  public void setRipe(@Nullable Season ripe) {\n    this.ripe = ripe;\n  }\n\n  public @NotNull Integer getProtein() {\n    return 12;\n  }\n}\n\npublic class Raspberry extends Fruit {\n\n  public void setRipe(@Nullable Season ripe) {\n    this.ripe = ripe;\n  }\n\n  public @NotNull Integer getProtein() {\n    return 12;\n  }\n}\n</pre>",
    "howToFix": "",
    "moreInfo": "<h3>Documentation</h3>\n<ul>\n  <li> SOLID - <a href=\"https://en.wikipedia.org/wiki/Liskov_substitution_principle\">Wikipedia - Liskov substitution principle</a> </li>\n</ul>",
    "status": "READY",
    "name_ko": "메서드 오버라이드 시 계약을 변경하면 안 됩니다",
    "why_ko": "<p>하위 클래스 인스턴스는 상위 클래스의 인스턴스로 캐스팅되고 처리될 수 있으므로, 오버라이딩 메서드는 리스코프 치환 원칙과 관련된 상위 클래스 계약의 측면을 유지해야 합니다. 구체적으로, 상위 클래스 메서드의 매개변수 또는 반환 타입이 <code>@Nullable</code>, <code>@CheckForNull</code>, <code>@NotNull</code>, <code>@NonNull</code>, <code>@Nonnull</code> 중 하나로 표시된 경우, 하위 클래스 매개변수는 계약을 강화할 수 없고 반환 값은 완화할 수 없습니다.</p>\n\n<h4>규칙을 준수하지 않는 코드 예시</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\npublic class Fruit {\n\n  private Season ripe;\n  private String color;\n\n  public void setRipe(@Nullable Season ripe) {\n    this.ripe = ripe;\n  }\n\n  public @NotNull Integer getProtein() {\n    return 12;\n  }\n}\n\npublic class Raspberry extends Fruit {\n\n  public void setRipe(@NotNull Season ripe) {  // 규칙 위반: ripe 인수가 부모 클래스에서 @Nullable로 어노테이션됨\n    this.ripe = ripe;\n  }\n\n  public @Nullable Integer getProtein() {  // 규칙 위반: 반환 타입이 부모 클래스에서 @NotNull로 어노테이션됨\n    return null;\n  }\n}\n</pre>\n<h4>규칙을 준수하는 해결책</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\npublic class Fruit {\n\n  private Season ripe;\n  private String color;\n\n  public void setRipe(@Nullable Season ripe) {\n    this.ripe = ripe;\n  }\n\n  public @NotNull Integer getProtein() {\n    return 12;\n  }\n}\n\npublic class Raspberry extends Fruit {\n\n  public void setRipe(@Nullable Season ripe) {\n    this.ripe = ripe;\n  }\n\n  public @NotNull Integer getProtein() {\n    return 12;\n  }\n}\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": "<h3>문서</h3>\n<ul>\n  <li> SOLID - <a href=\"https://en.wikipedia.org/wiki/Liskov_substitution_principle\">Wikipedia - 리스코프 치환 원칙</a> </li>\n</ul>"
  },
  {
    "id": "S5542",
    "key": "java:S5542",
    "name": "Encryption algorithms should be used with secure mode and padding scheme",
    "type": "vulnerability",
    "severity": "critical",
    "tags": [
      "cwe",
      "privacy"
    ],
    "why": "<p>Encryption algorithms are essential for protecting sensitive information and ensuring secure communications in a variety of domains. They are used\nfor several important reasons:</p>\n<ul>\n  <li> Confidentiality, privacy, and intellectual property protection </li>\n  <li> Security during transmission or on storage devices </li>\n  <li> Data integrity, general trust, and authentication </li>\n</ul>\n<p>When selecting encryption algorithms, tools, or combinations, you should also consider two things:</p>\n<ol>\n  <li> No encryption is unbreakable. </li>\n  <li> The strength of an encryption algorithm is usually measured by the effort required to crack it within a reasonable time frame. </li>\n</ol>\n<p>For these reasons, as soon as cryptography is included in a project, it is important to choose encryption algorithms that are considered strong and\nsecure by the cryptography community.</p>\n<p>For AES, the weakest mode is ECB (Electronic Codebook). Repeated blocks of data are encrypted to the same value, making them easy to identify and\nreducing the difficulty of recovering the original cleartext.</p>\n<p>Unauthenticated modes such as CBC (Cipher Block Chaining) may be used but are prone to attacks that manipulate the ciphertext. They must be used\nwith caution.</p>\n<p>For RSA, the weakest algorithms are either using it without padding or using the PKCS1v1.5 padding scheme.</p>\n<h3>What is the potential impact?</h3>\n<p>The cleartext of an encrypted message might be recoverable. Additionally, it might be possible to modify the cleartext of an encrypted message.</p>\n<p>Below are some real-world scenarios that illustrate possible impacts of an attacker exploiting the vulnerability.</p>\n<h4>Theft of sensitive data</h4>\n<p>The encrypted message might contain data that is considered sensitive and should not be known to third parties.</p>\n<p>By using a weak algorithm the likelihood that an attacker might be able to recover the cleartext drastically increases.</p>\n<h4>Additional attack surface</h4>\n<p>By modifying the cleartext of the encrypted message it might be possible for an attacker to trigger other vulnerabilities in the code. Encrypted\nvalues are often considered trusted, since under normal circumstances it would not be possible for a third party to modify them.</p>",
    "howToFix": "<h4>Noncompliant code example</h4>\n<p>Example with a symmetric cipher, AES:</p>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\nimport javax.crypto.Cipher;\nimport java.security.NoSuchAlgorithmException;\nimport javax.crypto.NoSuchPaddingException;\n\npublic static void main(String[] args) {\n    try {\n        Cipher.getInstance(\"AES/CBC/PKCS5Padding\"); // Noncompliant\n    } catch(NoSuchAlgorithmException|NoSuchPaddingException e) {\n        // ...\n    }\n}\n</pre>\n<p>Example with an asymmetric cipher, RSA:</p>\n<pre data-diff-id=\"2\" data-diff-type=\"noncompliant\">\nimport javax.crypto.Cipher;\nimport java.security.NoSuchAlgorithmException;\nimport javax.crypto.NoSuchPaddingException;\n\npublic static void main(String[] args) {\n    try {\n        Cipher.getInstance(\"RSA/None/NoPadding\"); // Noncompliant\n    } catch(NoSuchAlgorithmException|NoSuchPaddingException e) {\n        // ...\n    }\n}\n</pre>\n<h4>Compliant solution</h4>\n<p>For the AES symmetric cipher, use the GCM mode:</p>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\nimport javax.crypto.Cipher;\nimport java.security.NoSuchAlgorithmException;\nimport javax.crypto.NoSuchPaddingException;\n\npublic static void main(String[] args) {\n    try {\n        Cipher.getInstance(\"AES/GCM/NoPadding\");\n    } catch(NoSuchAlgorithmException|NoSuchPaddingException e) {\n        // ...\n    }\n}\n</pre>\n<p>For the RSA asymmetric cipher, use the Optimal Asymmetric Encryption Padding (OAEP):</p>\n<pre data-diff-id=\"2\" data-diff-type=\"compliant\">\nimport javax.crypto.Cipher;\nimport java.security.NoSuchAlgorithmException;\nimport javax.crypto.NoSuchPaddingException;\n\npublic static void main(String[] args) {\n    try {\n        Cipher.getInstance(\"RSA/ECB/OAEPWITHSHA-256ANDMGF1PADDING\");\n    } catch(NoSuchAlgorithmException|NoSuchPaddingException e) {\n        // ...\n    }\n}\n</pre>\n<h3>How does this work?</h3>\n<p>As a rule of thumb, use the cryptographic algorithms and mechanisms that are considered strong by the cryptographic community.</p>\n<p>Appropriate choices are currently the following.</p>\n<h4>For AES: use authenticated encryption modes</h4>\n<p>The best-known authenticated encryption mode for AES is Galois/Counter mode (GCM).</p>\n<p>GCM mode combines encryption with authentication and integrity checks using a cryptographic hash function and provides both confidentiality and\nauthenticity of data.</p>\n<p>Other similar modes are:</p>\n<ul>\n  <li> CCM: <code>Counter with CBC-MAC</code> </li>\n  <li> CWC: <code>Cipher Block Chaining with Message Authentication Code</code> </li>\n  <li> EAX: <code>Encrypt-and-Authenticate</code> </li>\n  <li> IAPM: <code>Integer Authenticated Parallelizable Mode</code> </li>\n  <li> OCB: <code>Offset Codebook Mode</code> </li>\n</ul>\n<p>It is also possible to use AES-CBC with HMAC for integrity checks. However, it is considered more straightforward to use AES-GCM directly\ninstead.</p>\n<h4>For RSA: use the OAEP scheme</h4>\n<p>The Optimal Asymmetric Encryption Padding scheme (OAEP) adds randomness and a secure hash function that strengthens the regular inner workings of\nRSA.</p>",
    "moreInfo": "<h3>Articles &amp; blog posts</h3>\n<ul>\n  <li> <a href=\"https://learn.microsoft.com/en-us/dotnet/standard/security/vulnerabilities-cbc-mode\">Microsoft, Timing vulnerabilities with CBC-mode\n  symmetric decryption using padding</a> </li>\n  <li> <a href=\"https://en.wikipedia.org/wiki/Padding_oracle_attack\">Wikipedia, Padding Oracle Attack</a> </li>\n  <li> <a href=\"https://en.wikipedia.org/wiki/Chosen-ciphertext_attack\">Wikipedia, Chosen-Ciphertext Attack</a> </li>\n  <li> <a href=\"https://en.wikipedia.org/wiki/Chosen-plaintext_attack\">Wikipedia, Chosen-Plaintext Attack</a> </li>\n  <li> <a href=\"https://en.wikipedia.org/wiki/Semantic_security\">Wikipedia, Semantically Secure Cryptosystems</a> </li>\n  <li> <a href=\"https://en.wikipedia.org/wiki/Optimal_asymmetric_encryption_padding\">Wikipedia, OAEP</a> </li>\n  <li> <a href=\"https://en.wikipedia.org/wiki/Galois/Counter_Mode\">Wikipedia, Galois/Counter Mode</a> </li>\n</ul>\n<h3>Standards</h3>\n<ul>\n  <li> OWASP - <a href=\"https://owasp.org/Top10/A02_2021-Cryptographic_Failures/\">Top 10 2021 Category A2 - Cryptographic Failures</a> </li>\n  <li> OWASP - <a href=\"https://owasp.org/www-project-top-ten/2017/A3_2017-Sensitive_Data_Exposure\">Top 10 2017 Category A3 - Sensitive Data\n  Exposure</a> </li>\n  <li> OWASP - <a href=\"https://owasp.org/www-project-top-ten/2017/A6_2017-Security_Misconfiguration\">Top 10 2017 Category A6 - Security\n  Misconfiguration</a> </li>\n  <li> OWASP - <a href=\"https://mas.owasp.org/checklists/MASVS-CRYPTO/\">Mobile AppSec Verification Standard - Cryptography Requirements</a> </li>\n  <li> OWASP - <a href=\"https://owasp.org/www-project-mobile-top-10/2016-risks/m5-insufficient-cryptography\">Mobile Top 10 2016 Category M5 -\n  Insufficient Cryptography</a> </li>\n  <li> OWASP - <a href=\"https://owasp.org/www-project-mobile-top-10/2023-risks/m10-insufficient-cryptography\">Mobile Top 10 2024 Category M10 -\n  Insufficient Cryptography</a> </li>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/327\">CWE-327 - Use of a Broken or Risky Cryptographic Algorithm</a> </li>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/780\">CWE-780 - Use of RSA Algorithm without OAEP</a> </li>\n  <li> <a href=\"https://wiki.sei.cmu.edu/confluence/x/hDdGBQ\">CERT, MSC61-J.</a> - Do not use insecure or weak cryptographic algorithms </li>\n</ul>",
    "status": "READY",
    "name_ko": "암호화 알고리즘은 안전한 모드와 패딩 방식으로 사용해야 합니다",
    "why_ko": "<p>암호화 알고리즘은 다양한 도메인에서 민감한 정보를 보호하고 안전한 통신을 보장하는 데 필수적입니다. 여러 가지 중요한 이유로 사용됩니다:</p>\n<ul>\n  <li> 기밀성, 개인정보 보호 및 지적 재산권 보호 </li>\n  <li> 전송 중 또는 저장 장치에서의 보안 </li>\n  <li> 데이터 무결성, 일반적인 신뢰 및 인증 </li>\n</ul>\n<p>암호화 알고리즘, 도구 또는 조합을 선택할 때 두 가지를 고려해야 합니다:</p>\n<ol>\n  <li> 어떤 암호화도 깨지지 않는 것은 없습니다. </li>\n  <li> 암호화 알고리즘의 강도는 일반적으로 합리적인 시간 내에 해독하는 데 필요한 노력으로 측정됩니다. </li>\n</ol>\n<p>이러한 이유로 프로젝트에 암호화가 포함되면 암호학 커뮤니티에서 강력하고 안전하다고 여기는 암호화 알고리즘을 선택하는 것이 중요합니다.</p>\n<p>AES의 경우 가장 약한 모드는 ECB(Electronic Codebook)입니다. 반복되는 데이터 블록은 동일한 값으로 암호화되어 식별하기 쉽고 원본 평문을 복구하는 어려움이 줄어듭니다.</p>\n<p>CBC(Cipher Block Chaining)와 같은 인증되지 않은 모드는 사용할 수 있지만 암호문을 조작하는 공격에 취약합니다. 주의해서 사용해야 합니다.</p>\n<p>RSA의 경우 가장 약한 알고리즘은 패딩 없이 사용하거나 PKCS1v1.5 패딩 체계를 사용하는 것입니다.</p>\n<h3>잠재적 영향은 무엇입니까?</h3>\n<p>암호화된 메시지의 평문이 복구될 수 있습니다. 또한 암호화된 메시지의 평문을 수정할 수 있을 수 있습니다.</p>\n<p>아래는 공격자가 취약점을 악용할 때 가능한 영향을 설명하는 실제 시나리오입니다.</p>\n<h4>민감한 데이터 도난</h4>\n<p>암호화된 메시지에는 민감하고 제3자에게 알려지면 안 되는 데이터가 포함될 수 있습니다.</p>\n<p>약한 알고리즘을 사용하면 공격자가 평문을 복구할 수 있는 가능성이 크게 증가합니다.</p>\n<h4>추가 공격 표면</h4>\n<p>암호화된 메시지의 평문을 수정하면 공격자가 코드의 다른 취약점을 트리거할 수 있을 수 있습니다. 암호화된 값은 정상적인 상황에서는 제3자가 수정할 수 없으므로 종종 신뢰할 수 있는 것으로 간주됩니다.</p>",
    "howToFix_ko": "<h4>규칙을 준수하지 않는 코드 예시</h4>\n<p>대칭 암호 AES를 사용한 예시:</p>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\nimport javax.crypto.Cipher;\nimport java.security.NoSuchAlgorithmException;\nimport javax.crypto.NoSuchPaddingException;\n\npublic static void main(String[] args) {\n    try {\n        Cipher.getInstance(\"AES/CBC/PKCS5Padding\"); // 규칙 위반\n    } catch(NoSuchAlgorithmException|NoSuchPaddingException e) {\n        // ...\n    }\n}\n</pre>\n<p>비대칭 암호 RSA를 사용한 예시:</p>\n<pre data-diff-id=\"2\" data-diff-type=\"noncompliant\">\nimport javax.crypto.Cipher;\nimport java.security.NoSuchAlgorithmException;\nimport javax.crypto.NoSuchPaddingException;\n\npublic static void main(String[] args) {\n    try {\n        Cipher.getInstance(\"RSA/None/NoPadding\"); // 규칙 위반\n    } catch(NoSuchAlgorithmException|NoSuchPaddingException e) {\n        // ...\n    }\n}\n</pre>\n<h4>규칙을 준수하는 해결책</h4>\n<p>AES 대칭 암호의 경우 GCM 모드를 사용하세요:</p>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\nimport javax.crypto.Cipher;\nimport java.security.NoSuchAlgorithmException;\nimport javax.crypto.NoSuchPaddingException;\n\npublic static void main(String[] args) {\n    try {\n        Cipher.getInstance(\"AES/GCM/NoPadding\");\n    } catch(NoSuchAlgorithmException|NoSuchPaddingException e) {\n        // ...\n    }\n}\n</pre>\n<p>RSA 비대칭 암호의 경우 최적 비대칭 암호화 패딩(OAEP)을 사용하세요:</p>\n<pre data-diff-id=\"2\" data-diff-type=\"compliant\">\nimport javax.crypto.Cipher;\nimport java.security.NoSuchAlgorithmException;\nimport javax.crypto.NoSuchPaddingException;\n\npublic static void main(String[] args) {\n    try {\n        Cipher.getInstance(\"RSA/ECB/OAEPWITHSHA-256ANDMGF1PADDING\");\n    } catch(NoSuchAlgorithmException|NoSuchPaddingException e) {\n        // ...\n    }\n}\n</pre>\n<h3>어떻게 작동합니까?</h3>\n<p>경험적으로 암호학 커뮤니티에서 강력하다고 여기는 암호화 알고리즘과 메커니즘을 사용하세요.</p>\n<p>현재 적절한 선택은 다음과 같습니다.</p>\n<h4>AES의 경우: 인증된 암호화 모드 사용</h4>\n<p>AES에 대해 가장 잘 알려진 인증된 암호화 모드는 갈루아/카운터 모드(GCM)입니다.</p>\n<p>GCM 모드는 암호화 해시 함수를 사용하여 암호화와 인증 및 무결성 검사를 결합하고 데이터의 기밀성과 진정성을 모두 제공합니다.</p>\n<p>다른 유사한 모드는:</p>\n<ul>\n  <li> CCM: <code>Counter with CBC-MAC</code> </li>\n  <li> CWC: <code>Cipher Block Chaining with Message Authentication Code</code> </li>\n  <li> EAX: <code>Encrypt-and-Authenticate</code> </li>\n  <li> IAPM: <code>Integer Authenticated Parallelizable Mode</code> </li>\n  <li> OCB: <code>Offset Codebook Mode</code> </li>\n</ul>\n<p>무결성 검사를 위해 HMAC과 함께 AES-CBC를 사용할 수도 있습니다. 그러나 대신 AES-GCM을 직접 사용하는 것이 더 간단합니다.</p>\n<h4>RSA의 경우: OAEP 체계 사용</h4>\n<p>최적 비대칭 암호화 패딩 체계(OAEP)는 RSA의 일반적인 내부 작동을 강화하는 임의성과 안전한 해시 함수를 추가합니다.</p>",
    "moreInfo_ko": "<h3>기사 및 블로그 게시물</h3>\n<ul>\n  <li> <a href=\"https://learn.microsoft.com/en-us/dotnet/standard/security/vulnerabilities-cbc-mode\">Microsoft, 패딩을 사용한 CBC 모드 대칭 복호화의 타이밍 취약점</a> </li>\n  <li> <a href=\"https://en.wikipedia.org/wiki/Padding_oracle_attack\">Wikipedia, 패딩 오라클 공격</a> </li>\n  <li> <a href=\"https://en.wikipedia.org/wiki/Chosen-ciphertext_attack\">Wikipedia, 선택 암호문 공격</a> </li>\n  <li> <a href=\"https://en.wikipedia.org/wiki/Chosen-plaintext_attack\">Wikipedia, 선택 평문 공격</a> </li>\n  <li> <a href=\"https://en.wikipedia.org/wiki/Semantic_security\">Wikipedia, 의미론적으로 안전한 암호 시스템</a> </li>\n  <li> <a href=\"https://en.wikipedia.org/wiki/Optimal_asymmetric_encryption_padding\">Wikipedia, OAEP</a> </li>\n  <li> <a href=\"https://en.wikipedia.org/wiki/Galois/Counter_Mode\">Wikipedia, 갈루아/카운터 모드</a> </li>\n</ul>\n<h3>표준</h3>\n<ul>\n  <li> OWASP - <a href=\"https://owasp.org/Top10/A02_2021-Cryptographic_Failures/\">Top 10 2021 Category A2 - Cryptographic Failures</a> </li>\n  <li> OWASP - <a href=\"https://owasp.org/www-project-top-ten/2017/A3_2017-Sensitive_Data_Exposure\">Top 10 2017 Category A3 - Sensitive Data Exposure</a> </li>\n  <li> OWASP - <a href=\"https://owasp.org/www-project-top-ten/2017/A6_2017-Security_Misconfiguration\">Top 10 2017 Category A6 - Security Misconfiguration</a> </li>\n  <li> OWASP - <a href=\"https://mas.owasp.org/checklists/MASVS-CRYPTO/\">Mobile AppSec Verification Standard - Cryptography Requirements</a> </li>\n  <li> OWASP - <a href=\"https://owasp.org/www-project-mobile-top-10/2016-risks/m5-insufficient-cryptography\">Mobile Top 10 2016 Category M5 - Insufficient Cryptography</a> </li>\n  <li> OWASP - <a href=\"https://owasp.org/www-project-mobile-top-10/2023-risks/m10-insufficient-cryptography\">Mobile Top 10 2024 Category M10 - Insufficient Cryptography</a> </li>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/327\">CWE-327 - 손상되거나 위험한 암호화 알고리즘 사용</a> </li>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/780\">CWE-780 - OAEP 없이 RSA 알고리즘 사용</a> </li>\n  <li> <a href=\"https://wiki.sei.cmu.edu/confluence/x/hDdGBQ\">CERT, MSC61-J.</a> - 안전하지 않거나 약한 암호화 알고리즘을 사용하지 마세요 </li>\n</ul>"
  },
  {
    "id": "S1151",
    "key": "java:S1151",
    "name": "\"switch case\" clauses should not have too many lines of code",
    "type": "code-smell",
    "severity": "major",
    "tags": [
      "brain-overload"
    ],
    "why": "<p>The <code>switch</code> statement should be used only to clearly define some new branches in the control flow. As soon as a <code>case</code>\nclause contains too many statements this highly decreases the readability of the overall control flow statement. In such case, the content of the\n<code>case</code> clause should be extracted into a dedicated method.</p>\n<h3>Noncompliant code example</h3>\n<p>With the default threshold of 5:</p>\n<pre>\nswitch (myVariable) {\n  case 0: // Noncompliant: 6 lines till next case\n    methodCall1(\"\");\n    methodCall2(\"\");\n    methodCall3(\"\");\n    methodCall4(\"\");\n    break;\n  case 1:\n  ...\n}\n</pre>\n<h3>Compliant solution</h3>\n<pre>\nswitch (myVariable) {\n  case 0:\n    doSomething()\n    break;\n  case 1:\n  ...\n}\n...\nprivate void doSomething(){\n    methodCall1(\"\");\n    methodCall2(\"\");\n    methodCall3(\"\");\n    methodCall4(\"\");\n}\n</pre>",
    "howToFix": "",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "\"switch case\" 절에 너무 많은 코드 줄이 있으면 안 됩니다",
    "why_ko": "<p><code>switch</code> 문은 제어 흐름에서 새로운 분기를 명확하게 정의하는 데만 사용해야 합니다. <code>case</code> 절에 너무 많은 문장이 포함되면 전체 제어 흐름 문의 가독성이 크게 저하됩니다. 이러한 경우 <code>case</code> 절의 내용을 전용 메서드로 추출해야 합니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<p>기본 임계값 5의 경우:</p>\n<pre>\nswitch (myVariable) {\n  case 0: // 규칙 위반: 다음 case까지 6줄\n    methodCall1(\"\");\n    methodCall2(\"\");\n    methodCall3(\"\");\n    methodCall4(\"\");\n    break;\n  case 1:\n  ...\n}\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre>\nswitch (myVariable) {\n  case 0:\n    doSomething()\n    break;\n  case 1:\n  ...\n}\n...\nprivate void doSomething(){\n    methodCall1(\"\");\n    methodCall2(\"\");\n    methodCall3(\"\");\n    methodCall4(\"\");\n}\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": ""
  },
  {
    "id": "S6913",
    "key": "java:S6913",
    "name": "\"Math.clamp\" should be used with correct ranges",
    "type": "bug",
    "severity": "major",
    "tags": [
      "java21"
    ],
    "why": "<p>Java 21 introduces the new method <code>Math.clamp(value, min, max)</code> that fits a value within a specified interval. Before Java 21, this\nbehavior required explicit calls to the <code>Math.min</code> and <code>Math.max</code> methods, as in <code>Math.min(max, Math.max(value,\nmin))</code>.</p>\n<p>If <code>min &gt; max</code>, <code>Math.clamp</code> throws an <code>IllegalArgumentException</code>, indicating an invalid interval. This can\noccur if the <code>min</code> and <code>max</code> arguments are mistakenly reversed.</p>\n<p>Note that <code>Math.clamp</code> is not a general substitute for <code>Math.min</code> or <code>Math.max</code>, but for the combination of both.\nIf <code>value</code> is the same as <code>min</code> or <code>max</code>, using <code>Math.clamp</code> is unnecessary and <code>Math.min</code> or\n<code>Math.max</code> should be used instead.</p>",
    "howToFix": "<ul>\n  <li> If 2nd argument &gt; 3rd argument, use <code>Math.clamp(value, min, max)</code> instead of <code>Math.clamp(value, max, min)</code>. </li>\n  <li> If <code>value</code> is the same as <code>min</code>, fix the logic or use <code>Math.min(value, max)</code> instead. </li>\n  <li> If <code>value</code> is the same as <code>max</code>, fix the logic or use <code>Math.max(min, value)</code> instead. </li>\n  <li> If <code>min</code> is the same as <code>max</code>, fix the logic because <code>Math.clamp(value, x, x)</code> will always return\n  <code>x</code>. </li>\n</ul>\n\n<h4>Noncompliant code example</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\nMath.clamp(red, 255, 0); // Noncompliant, [255,0] is not a valid range\n</pre>\n<h4>Compliant solution</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\nMath.clamp(red, 0, 255); // Compliant\n</pre>\n<h4>Noncompliant code example</h4>\n<pre data-diff-id=\"2\" data-diff-type=\"noncompliant\">\nMath.clamp(red, red, 255); // Noncompliant, use Math.min(red, 255)\n</pre>\n<h4>Compliant solution</h4>\n<pre data-diff-id=\"2\" data-diff-type=\"compliant\">\nMath.min(red, 255); // Compliant\n</pre>\n<h4>Noncompliant code example</h4>\n<pre data-diff-id=\"3\" data-diff-type=\"noncompliant\">\nMath.clamp(red, 0, red); // Noncompliant, use Math.max(red, 0)\n</pre>\n<h4>Compliant solution</h4>\n<pre data-diff-id=\"3\" data-diff-type=\"compliant\">\nMath.max(red, 0); // Compliant\n</pre>",
    "moreInfo": "<ul>\n  <li> Java Documentation - <a\n  href=\"https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/Math.html#clamp(long,int,int)\">Math.clamp</a> </li>\n</ul>",
    "status": "READY",
    "name_ko": "Math.clamp는 올바른 범위와 함께 사용해야 합니다",
    "why_ko": "<p>Java 21에서는 값을 지정된 구간 내에 맞추는 새로운 메서드 <code>Math.clamp(value, min, max)</code>가 도입되었습니다. Java 21 이전에는 이 동작을 위해 <code>Math.min(max, Math.max(value, min))</code>과 같이 <code>Math.min</code>과 <code>Math.max</code> 메서드를 명시적으로 호출해야 했습니다.</p>\n<p><code>min &gt; max</code>인 경우 <code>Math.clamp</code>는 유효하지 않은 구간을 나타내는 <code>IllegalArgumentException</code>을 발생시킵니다. 이는 <code>min</code>과 <code>max</code> 인수가 실수로 뒤바뀐 경우 발생할 수 있습니다.</p>\n<p><code>Math.clamp</code>는 <code>Math.min</code> 또는 <code>Math.max</code>의 일반적인 대체가 아니라 둘의 조합에 대한 대체입니다. <code>value</code>가 <code>min</code> 또는 <code>max</code>와 같으면 <code>Math.clamp</code>를 사용할 필요가 없으며 대신 <code>Math.min</code> 또는 <code>Math.max</code>를 사용해야 합니다.</p>",
    "howToFix_ko": "<ul>\n  <li> 2번째 인수 &gt; 3번째 인수인 경우 <code>Math.clamp(value, max, min)</code> 대신 <code>Math.clamp(value, min, max)</code>를 사용하세요. </li>\n  <li> <code>value</code>가 <code>min</code>과 같으면 로직을 수정하거나 대신 <code>Math.min(value, max)</code>를 사용하세요. </li>\n  <li> <code>value</code>가 <code>max</code>와 같으면 로직을 수정하거나 대신 <code>Math.max(min, value)</code>를 사용하세요. </li>\n  <li> <code>min</code>이 <code>max</code>와 같으면 <code>Math.clamp(value, x, x)</code>가 항상 <code>x</code>를 반환하므로 로직을 수정하세요. </li>\n</ul>\n\n<h4>규칙을 준수하지 않는 코드 예시</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\nMath.clamp(red, 255, 0); // 규칙 위반, [255,0]은 유효한 범위가 아닙니다\n</pre>\n<h4>규칙을 준수하는 해결책</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\nMath.clamp(red, 0, 255); // 규칙 준수\n</pre>\n<h4>규칙을 준수하지 않는 코드 예시</h4>\n<pre data-diff-id=\"2\" data-diff-type=\"noncompliant\">\nMath.clamp(red, red, 255); // 규칙 위반, Math.min(red, 255)를 사용하세요\n</pre>\n<h4>규칙을 준수하는 해결책</h4>\n<pre data-diff-id=\"2\" data-diff-type=\"compliant\">\nMath.min(red, 255); // 규칙 준수\n</pre>\n<h4>규칙을 준수하지 않는 코드 예시</h4>\n<pre data-diff-id=\"3\" data-diff-type=\"noncompliant\">\nMath.clamp(red, 0, red); // 규칙 위반, Math.max(red, 0)를 사용하세요\n</pre>\n<h4>규칙을 준수하는 해결책</h4>\n<pre data-diff-id=\"3\" data-diff-type=\"compliant\">\nMath.max(red, 0); // 규칙 준수\n</pre>",
    "moreInfo_ko": "<ul>\n  <li> Java 문서 - <a href=\"https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/Math.html#clamp(long,int,int)\">Math.clamp</a> </li>\n</ul>"
  },
  {
    "id": "S2053",
    "key": "java:S2053",
    "name": "Password hashing functions should use an unpredictable salt",
    "type": "vulnerability",
    "severity": "critical",
    "tags": [
      "cwe"
    ],
    "why": "<p>During the process of password hashing, an additional component, known as a \"salt,\" is often integrated to bolster the overall security. This salt,\nacting as a defensive measure, primarily wards off certain types of attacks that leverage pre-computed tables to crack passwords.</p>\n<p>However, potential risks emerge when the salt is deemed insecure. This can occur when the salt is consistently the same across all users or when it\nis too short or predictable. In scenarios where users share the same password and salt, their password hashes will inevitably mirror each other.\nSimilarly, a short salt heightens the probability of multiple users unintentionally having identical salts, which can potentially lead to identical\npassword hashes. These identical hashes streamline the process for potential attackers to recover clear-text passwords. Thus, the emphasis on\nimplementing secure, unique, and sufficiently lengthy salts in password-hashing functions is vital.</p>\n<h3>What is the potential impact?</h3>\n<p>Despite best efforts, even well-guarded systems might have vulnerabilities that could allow an attacker to gain access to the hashed passwords.\nThis could be due to software vulnerabilities, insider threats, or even successful phishing attempts that give attackers the access they need.</p>\n<p>Once the attacker has these hashes, they will likely attempt to crack them using a couple of methods. One is brute force, which entails trying\nevery possible combination until the correct password is found. While this can be time-consuming, having the same salt for all users or a short salt\ncan make the task significantly easier and faster.</p>\n<p>If multiple users have the same password and the same salt, their password hashes would be identical. This means that if an attacker successfully\ncracks one hash, they have effectively cracked all identical ones, granting them access to multiple accounts at once.</p>\n<p>A short salt, while less critical than a shared one, still increases the odds of different users having the same salt. This might create clusters\nof password hashes with identical salt that can then be attacked as explained before.</p>\n<p>With short salts, the probability of a collision between two users' passwords and salts couple might be low depending on the salt size. The shorter\nthe salt, the higher the collision probability. In any case, using longer, cryptographically secure salt should be preferred.</p>\n<h3>Exceptions</h3>\n<p>To securely store password hashes, it is a recommended to rely on key derivation functions that are computationally intensive. Examples of such\nfunctions are:</p>\n<ul>\n  <li> Argon2 </li>\n  <li> PBKDF2 </li>\n  <li> Scrypt </li>\n  <li> Bcrypt </li>\n</ul>\n<p>When they are used for password storage, using a secure, random salt is required.</p>\n<p>However, those functions can also be used for other purposes such as master key derivation or password-based pre-shared key generation. In those\ncases, the implemented cryptographic protocol might require using a fixed salt to derive keys in a deterministic way. In such cases, using a fixed\nsalt is safe and accepted.</p>",
    "howToFix": "<p>The following code contains examples of hard-coded salts.</p>\n<h4>Noncompliant code example</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\nimport javax.crypto.spec.PBEParameterSpec;\n\npublic void hash() {\n    byte[] salt = \"salty\".getBytes();\n    PBEParameterSpec cipherSpec = new PBEParameterSpec(salt, 10000); // Noncompliant\n}\n</pre>\n<h4>Compliant solution</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\nimport java.security.SecureRandom;\nimport javax.crypto.spec.PBEParameterSpec;\n\npublic void hash() {\n    SecureRandom random = new SecureRandom();\n    byte[] salt = new byte[16];\n    random.nextBytes(salt);\n\n    PBEParameterSpec cipherSpec = new PBEParameterSpec(salt, 10000);\n}\n</pre>\n<h3>How does this work?</h3>\n<p>This code ensures that each user's password has a unique salt value associated with it. It generates a salt randomly and with a length that\nprovides the required security level. It uses a salt length of at least 16 bytes (128 bits), as recommended by industry standards.</p>\n<p>Here, the compliant code example ensures the salt is random and has a sufficient length by calling the <code>nextBytes</code> method from the\n<code>SecureRandom</code> class with a salt buffer of 16 bytes. This class implements a cryptographically secure pseudo-random number generator.</p>",
    "moreInfo": "<h3>Standards</h3>\n<ul>\n  <li> OWASP - <a href=\"https://owasp.org/Top10/A02_2021-Cryptographic_Failures/\">Top 10 2021 Category A2 - Cryptographic Failures</a> </li>\n  <li> OWASP - <a href=\"https://www.owasp.org/www-project-top-ten/2017/A3_2017-Sensitive_Data_Exposure\">Top 10 2017 Category A3 - Sensitive Data\n  Exposure</a> </li>\n  <li> OWASP - <a href=\"https://owasp.org/www-project-mobile-top-10/2023-risks/m10-insufficient-cryptography\">Mobile Top 10 2024 Category M10 -\n  Insufficient Cryptography</a> </li>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/759\">CWE-759 - Use of a One-Way Hash without a Salt</a> </li>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/760\">CWE-760 - Use of a One-Way Hash with a Predictable Salt</a> </li>\n  <li> STIG Viewer - <a href=\"https://stigviewer.com/stigs/application_security_and_development/2024-12-06/finding/V-222542\">Application Security and\n  Development: V-222542</a> - The application must only store cryptographic representations of passwords. </li>\n</ul>",
    "status": "READY",
    "name_ko": "비밀번호 해싱 함수는 예측 불가능한 salt를 사용해야 합니다",
    "why_ko": "<p>비밀번호 해싱 과정에서 전체적인 보안을 강화하기 위해 \"salt\"라고 알려진 추가 구성 요소가 종종 통합됩니다. 이 salt는 방어 수단으로서 미리 계산된 테이블을 활용하여 비밀번호를 크랙하는 특정 유형의 공격을 주로 방어합니다.</p>\n<p>그러나 salt가 안전하지 않다고 간주될 때 잠재적인 위험이 발생합니다. 이는 salt가 모든 사용자에게 일관되게 동일하거나 너무 짧거나 예측 가능할 때 발생할 수 있습니다. 사용자가 동일한 비밀번호와 salt를 공유하는 시나리오에서 비밀번호 해시는 필연적으로 서로 동일해집니다. 마찬가지로 짧은 salt는 여러 사용자가 의도치 않게 동일한 salt를 가질 확률을 높이며, 이는 잠재적으로 동일한 비밀번호 해시로 이어질 수 있습니다. 이러한 동일한 해시는 잠재적 공격자가 평문 비밀번호를 복구하는 과정을 간소화합니다. 따라서 비밀번호 해싱 함수에서 안전하고 고유하며 충분히 긴 salt를 구현하는 것이 중요합니다.</p>\n<h3>잠재적 영향은 무엇인가요?</h3>\n<p>최선의 노력에도 불구하고 잘 보호된 시스템에도 공격자가 해시된 비밀번호에 액세스할 수 있는 취약점이 있을 수 있습니다. 이는 소프트웨어 취약점, 내부 위협 또는 공격자에게 필요한 액세스 권한을 부여하는 성공적인 피싱 시도로 인해 발생할 수 있습니다.</p>\n<p>공격자가 이러한 해시를 획득하면 몇 가지 방법을 사용하여 크랙을 시도할 것입니다. 하나는 올바른 비밀번호를 찾을 때까지 가능한 모든 조합을 시도하는 무차별 대입입니다. 이것은 시간이 많이 걸릴 수 있지만 모든 사용자에게 동일한 salt를 사용하거나 짧은 salt를 사용하면 작업이 훨씬 쉽고 빨라질 수 있습니다.</p>\n<p>여러 사용자가 동일한 비밀번호와 동일한 salt를 가지고 있으면 비밀번호 해시가 동일해집니다. 이는 공격자가 하나의 해시를 성공적으로 크랙하면 모든 동일한 해시를 효과적으로 크랙한 것이 되어 한 번에 여러 계정에 액세스할 수 있음을 의미합니다.</p>\n<p>짧은 salt는 공유된 것보다 덜 중요하지만 여전히 다른 사용자가 동일한 salt를 가질 확률을 높입니다. 이는 앞서 설명한 대로 공격받을 수 있는 동일한 salt를 가진 비밀번호 해시 클러스터를 생성할 수 있습니다.</p>\n<p>짧은 salt의 경우 두 사용자의 비밀번호와 salt 쌍 간의 충돌 확률은 salt 크기에 따라 낮을 수 있습니다. salt가 짧을수록 충돌 확률이 높아집니다. 어떤 경우든 더 길고 암호학적으로 안전한 salt를 사용하는 것이 좋습니다.</p>\n<h3>예외</h3>\n<p>비밀번호 해시를 안전하게 저장하려면 계산 집약적인 키 유도 함수에 의존하는 것이 권장됩니다. 이러한 함수의 예는 다음과 같습니다:</p>\n<ul>\n  <li> Argon2 </li>\n  <li> PBKDF2 </li>\n  <li> Scrypt </li>\n  <li> Bcrypt </li>\n</ul>\n<p>비밀번호 저장에 사용될 때 안전하고 무작위 salt를 사용해야 합니다.</p>\n<p>그러나 이러한 함수는 마스터 키 유도 또는 비밀번호 기반 사전 공유 키 생성과 같은 다른 목적으로도 사용될 수 있습니다. 이러한 경우 구현된 암호화 프로토콜은 결정론적 방식으로 키를 유도하기 위해 고정 salt를 사용해야 할 수 있습니다. 이러한 경우 고정 salt를 사용하는 것은 안전하고 허용됩니다.</p>",
    "howToFix_ko": "<p>다음 코드는 하드코딩된 salt의 예를 포함합니다.</p>\n<h4>규칙을 준수하지 않는 코드 예시</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\nimport javax.crypto.spec.PBEParameterSpec;\n\npublic void hash() {\n    byte[] salt = \"salty\".getBytes();\n    PBEParameterSpec cipherSpec = new PBEParameterSpec(salt, 10000); // 규칙 위반\n}\n</pre>\n<h4>규칙을 준수하는 해결책</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\nimport java.security.SecureRandom;\nimport javax.crypto.spec.PBEParameterSpec;\n\npublic void hash() {\n    SecureRandom random = new SecureRandom();\n    byte[] salt = new byte[16];\n    random.nextBytes(salt);\n\n    PBEParameterSpec cipherSpec = new PBEParameterSpec(salt, 10000);\n}\n</pre>\n<h3>어떻게 작동하나요?</h3>\n<p>이 코드는 각 사용자의 비밀번호에 고유한 salt 값이 연결되도록 합니다. 필요한 보안 수준을 제공하는 길이로 무작위로 salt를 생성합니다. 업계 표준에서 권장하는 대로 최소 16바이트(128비트)의 salt 길이를 사용합니다.</p>\n<p>여기서 규칙을 준수하는 코드 예시는 16바이트의 salt 버퍼로 <code>SecureRandom</code> 클래스의 <code>nextBytes</code> 메서드를 호출하여 salt가 무작위이고 충분한 길이를 갖도록 합니다. 이 클래스는 암호학적으로 안전한 의사 난수 생성기를 구현합니다.</p>",
    "moreInfo_ko": "<h3>표준</h3>\n<ul>\n  <li> OWASP - <a href=\"https://owasp.org/Top10/A02_2021-Cryptographic_Failures/\">Top 10 2021 Category A2 - Cryptographic Failures</a> </li>\n  <li> OWASP - <a href=\"https://www.owasp.org/www-project-top-ten/2017/A3_2017-Sensitive_Data_Exposure\">Top 10 2017 Category A3 - Sensitive Data Exposure</a> </li>\n  <li> OWASP - <a href=\"https://owasp.org/www-project-mobile-top-10/2023-risks/m10-insufficient-cryptography\">Mobile Top 10 2024 Category M10 - Insufficient Cryptography</a> </li>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/759\">CWE-759 - Use of a One-Way Hash without a Salt</a> </li>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/760\">CWE-760 - Use of a One-Way Hash with a Predictable Salt</a> </li>\n  <li> STIG Viewer - <a href=\"https://stigviewer.com/stigs/application_security_and_development/2024-12-06/finding/V-222542\">Application Security and Development: V-222542</a> - The application must only store cryptographic representations of passwords. </li>\n</ul>"
  },
  {
    "id": "S6856",
    "key": "java:S6856",
    "name": "\"@PathVariable\" annotation should be present if a path variable is used",
    "type": "bug",
    "severity": "major",
    "tags": [
      "spring"
    ],
    "why": "<p>The <code>@PathVariable</code> annotation in Spring extracts values from the URI path and binds them to method parameters in a Spring MVC\ncontroller. It is commonly used with <code>@GetMapping</code>, <code>@PostMapping</code>, <code>@PutMapping</code>, and <code>@DeleteMapping</code> to\ncapture path variables from the URI. These annotations map HTTP requests to specific handler methods in a controller. They are part of the Spring Web\nmodule and are commonly used to define the routes for different HTTP operations in a RESTful API.</p>\n<p>If a method has a path template containing a placeholder, like \"/api/resource/{id}\", and there's no <code>@PathVariable</code> annotation on a\nmethod parameter to capture the id path variable, Spring will disregard the id variable.</p>\n<p>This rule will raise an issue if a method has a path template with a placeholder, but no corresponding <code>@PathVariable</code>, or\nvice-versa.</p>",
    "howToFix": "<h4>Noncompliant code example</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\n@GetMapping(\"/api/resource/{id}\")\npublic ResponseEntity&lt;String&gt; getResourceById(Long id) { // Noncompliant - The 'id' parameter will not be automatically populated with the path variable value\n  return ResponseEntity.ok(\"Fetching resource with ID: \" + id);\n}\n\n@GetMapping(\"/api/asset/\")\npublic ResponseEntity&lt;String&gt; getAssetById(@PathVariable Long id) { // Noncompliant - The 'id' parameter does not have a corresponding placeholder\n  return ResponseEntity.ok(\"Fetching asset with ID: \" + id);\n}\n</pre>\n<h4>Compliant solution</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\n@GetMapping(\"/api/resource/{id}\")\npublic ResponseEntity&lt;String&gt; getResourceById(@PathVariable Long id) { // Compliant\n  return ResponseEntity.ok(\"Fetching resource with ID: \" + id);\n}\n\n@GetMapping(\"/api/asset/{id}\")\npublic ResponseEntity&lt;String&gt; getAssetById(@PathVariable Long id) {\n  return ResponseEntity.ok(\"Fetching asset with ID: \" + id);\n}\n</pre>",
    "moreInfo": "<h3>Documentation</h3>\n<ul>\n  <li> <a href=\"https://spring.io/guides/tutorials/rest/\">Spring IO - Building REST services with Spring</a> </li>\n  <li> <a href=\"https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/web/bind/annotation/PathVariable.html\">Spring\n  Framework API - PathVariable</a> </li>\n  <li> <a href=\"https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/web/bind/annotation/GetMapping.html\">Spring\n  Framework API - GetMapping</a> </li>\n  <li> <a href=\"https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/web/bind/annotation/PostMapping.html\">Spring\n  Framework API - PostMapping</a> </li>\n  <li> <a href=\"https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/web/bind/annotation/PutMapping.html\">Spring\n  Framework API - PutMapping</a> </li>\n  <li> <a href=\"https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/web/bind/annotation/DeleteMapping.html\">Spring\n  Framework API - DeleteMapping</a> </li>\n</ul>\n<h3>Articles &amp; blog posts</h3>\n<ul>\n  <li> <a href=\"https://www.baeldung.com/spring-pathvariable\">Baeldung - Spring @PathVariable</a> </li>\n</ul>",
    "status": "READY",
    "name_ko": "경로 변수를 사용하면 @PathVariable 어노테이션이 있어야 합니다",
    "why_ko": "<p>Spring의 <code>@PathVariable</code> 어노테이션은 URI 경로에서 값을 추출하여 Spring MVC 컨트롤러의 메서드 매개변수에 바인딩합니다. 일반적으로 <code>@GetMapping</code>, <code>@PostMapping</code>, <code>@PutMapping</code>, <code>@DeleteMapping</code>과 함께 사용하여 URI에서 경로 변수를 캡처합니다. 이러한 어노테이션은 HTTP 요청을 컨트롤러의 특정 핸들러 메서드에 매핑합니다. 이들은 Spring Web 모듈의 일부이며 RESTful API에서 다양한 HTTP 작업의 경로를 정의하는 데 일반적으로 사용됩니다.</p>\n<p>메서드에 \"/api/resource/{id}\"와 같이 플레이스홀더가 포함된 경로 템플릿이 있고 id 경로 변수를 캡처하기 위한 <code>@PathVariable</code> 어노테이션이 메서드 매개변수에 없으면 Spring은 id 변수를 무시합니다.</p>\n<p>이 규칙은 메서드에 플레이스홀더가 있는 경로 템플릿이 있지만 해당하는 <code>@PathVariable</code>이 없거나 그 반대인 경우 문제를 발생시킵니다.</p>",
    "howToFix_ko": "<h4>규칙을 준수하지 않는 코드 예시</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\n@GetMapping(\"/api/resource/{id}\")\npublic ResponseEntity&lt;String&gt; getResourceById(Long id) { // 규칙 위반 - 'id' 매개변수가 경로 변수 값으로 자동으로 채워지지 않습니다\n  return ResponseEntity.ok(\"Fetching resource with ID: \" + id);\n}\n\n@GetMapping(\"/api/asset/\")\npublic ResponseEntity&lt;String&gt; getAssetById(@PathVariable Long id) { // 규칙 위반 - 'id' 매개변수에 해당하는 플레이스홀더가 없습니다\n  return ResponseEntity.ok(\"Fetching asset with ID: \" + id);\n}\n</pre>\n<h4>규칙을 준수하는 해결책</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\n@GetMapping(\"/api/resource/{id}\")\npublic ResponseEntity&lt;String&gt; getResourceById(@PathVariable Long id) { // 규칙 준수\n  return ResponseEntity.ok(\"Fetching resource with ID: \" + id);\n}\n\n@GetMapping(\"/api/asset/{id}\")\npublic ResponseEntity&lt;String&gt; getAssetById(@PathVariable Long id) {\n  return ResponseEntity.ok(\"Fetching asset with ID: \" + id);\n}\n</pre>",
    "moreInfo_ko": "<h3>문서</h3>\n<ul>\n  <li> <a href=\"https://spring.io/guides/tutorials/rest/\">Spring IO - Spring으로 REST 서비스 구축하기</a> </li>\n  <li> <a href=\"https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/web/bind/annotation/PathVariable.html\">Spring Framework API - PathVariable</a> </li>\n  <li> <a href=\"https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/web/bind/annotation/GetMapping.html\">Spring Framework API - GetMapping</a> </li>\n  <li> <a href=\"https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/web/bind/annotation/PostMapping.html\">Spring Framework API - PostMapping</a> </li>\n  <li> <a href=\"https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/web/bind/annotation/PutMapping.html\">Spring Framework API - PutMapping</a> </li>\n  <li> <a href=\"https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/web/bind/annotation/DeleteMapping.html\">Spring Framework API - DeleteMapping</a> </li>\n</ul>\n<h3>기사 및 블로그 게시물</h3>\n<ul>\n  <li> <a href=\"https://www.baeldung.com/spring-pathvariable\">Baeldung - Spring @PathVariable</a> </li>\n</ul>"
  },
  {
    "id": "S5779",
    "key": "java:S5779",
    "name": "Assertion methods should not be used within the try block of a try-catch catching an Error",
    "type": "bug",
    "severity": "critical",
    "tags": [
      "junit",
      "tests"
    ],
    "why": "<p>Assertion methods&nbsp;are throwing a \"<code>java.lang.AssertionError</code>\". If this call is done within the try block of a try-catch cathing a\nsimilar error, you should make sure to test some properties of the exception. Otherwise, the assertion will never fail.</p>\n<h3>Noncompliant code example</h3>\n<pre>\n@Test\npublic void should_throw_assertion_error() {\n  try {\n    throwAssertionError();\n    Assert.fail(\"Expected an AssertionError!\"); // Noncompliant, the AssertionError will be caught and the test will never fail.\n  } catch (AssertionError e) {}\n}\n\nprivate void throwAssertionError() {\n  throw new AssertionError(\"My assertion error\");\n}\n</pre>\n<h3>Compliant solution</h3>\n<pre>\nassertThrows(AssertionError.class, () -&gt; throwAssertionError());\n</pre>\n<pre>\ntry {\n   throwAssertionError();\n   Assert.fail(\"Expected an AssertionError!\"); // Compliant, we made sure to test that the correct error is raised\n } catch (AssertionError e) {\n   Assert.assertThat(e.getMessage(), is(\"My assertion error\"));\n }\n</pre>",
    "howToFix": "",
    "moreInfo": "<ul>\n  <li> <a href=\"https://github.com/junit-team/junit4/wiki/Exception-testing\">JUnit 4 exception testing documentation</a> </li>\n</ul>",
    "status": "READY",
    "name_ko": "Error를 catch하는 try-catch의 try 블록에서 assertion 메서드를 사용하면 안 됩니다",
    "why_ko": "<p>Assertion 메서드는 \"<code>java.lang.AssertionError</code>\"를 던집니다. 이 호출이 유사한 오류를 catch하는 try-catch의 try 블록 내에서 수행되면 예외의 일부 속성을 테스트해야 합니다. 그렇지 않으면 assertion이 절대 실패하지 않습니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\n@Test\npublic void should_throw_assertion_error() {\n  try {\n    throwAssertionError();\n    Assert.fail(\"AssertionError가 예상되었습니다!\"); // 규칙 위반, AssertionError가 catch되어 테스트가 절대 실패하지 않습니다.\n  } catch (AssertionError e) {}\n}\n\nprivate void throwAssertionError() {\n  throw new AssertionError(\"My assertion error\");\n}\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre>\nassertThrows(AssertionError.class, () -&gt; throwAssertionError());\n</pre>\n<pre>\ntry {\n   throwAssertionError();\n   Assert.fail(\"AssertionError가 예상되었습니다!\"); // 규칙 준수, 올바른 오류가 발생하는지 테스트했습니다\n } catch (AssertionError e) {\n   Assert.assertThat(e.getMessage(), is(\"My assertion error\"));\n }\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": "<ul>\n  <li> <a href=\"https://github.com/junit-team/junit4/wiki/Exception-testing\">JUnit 4 예외 테스트 문서</a> </li>\n</ul>"
  },
  {
    "id": "S2116",
    "key": "java:S2116",
    "name": "\"hashCode\" and \"toString\" should not be called on array instances",
    "type": "bug",
    "severity": "major",
    "tags": [],
    "why": "<p>The purpose of the <code>hashCode</code> method is to return a hash code based on the contents of the object. Similarly, the purpose of the\n<code>toString</code> method is to provide a textual representation of the object's contents.</p>\n<p>Calling <code>hashCode()</code> and <code>toString()</code> directly on array instances should be avoided because the default implementations\nprovided by the <code>Object</code> class do not provide meaningful results for arrays. <code>hashCode()</code> returns the array's \"identity hash\ncode\", and <code>toString()</code> returns nearly the same value. Neither method's output reflects the array's contents.</p>",
    "howToFix": "<p>Use relevant static <code>Arrays</code> method.</p>\n<ul>\n  <li> <code>Arrays.hashCode</code> or <code>Arrays.deepHashCode</code> </li>\n  <li> <code>Arrays.toString</code> or <code>Arrays.deepToString</code> </li>\n</ul>\n\n<h4>Noncompliant code example</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\npublic static void main(String[] args) {\n    String argStr = args.toString();       // Noncompliant\n    int argHash = args.hashCode();         // Noncompliant\n}\n</pre>\n<h4>Compliant solution</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\npublic static void main(String[] args) {\n    String argStr = Arrays.toString(args); // Compliant\n    int argHash = Arrays.hashCode(args);   // Compliant\n}\n</pre>",
    "moreInfo": "<h3>Documentation</h3>\n<ul>\n  <li> <a href=\"https://docs.oracle.com/en/java/javase/20/docs/api/java.base/java/util/Arrays.html\">Oracle Java SE - Arrays API</a> </li>\n</ul>\n<h3>Articles &amp; blog posts</h3>\n<ul>\n  <li> <a href=\"https://github.com/google/error-prone/blob/master/docs/bugpattern/ArrayHashCode.md\">Error Prone - ArrayHashCode</a> </li>\n</ul>",
    "status": "READY",
    "name_ko": "\"hashCode\"와 \"toString\"은 배열 인스턴스에서 호출하면 안 됩니다",
    "why_ko": "<p><code>hashCode</code> 메서드의 목적은 객체의 내용을 기반으로 해시 코드를 반환하는 것입니다. 마찬가지로 <code>toString</code> 메서드의 목적은 객체 내용의 텍스트 표현을 제공하는 것입니다.</p>\n<p>배열 인스턴스에서 <code>hashCode()</code>와 <code>toString()</code>을 직접 호출하는 것은 피해야 합니다. <code>Object</code> 클래스가 제공하는 기본 구현은 배열에 대해 의미 있는 결과를 제공하지 않기 때문입니다. <code>hashCode()</code>는 배열의 \"아이덴티티 해시 코드\"를 반환하고, <code>toString()</code>은 거의 동일한 값을 반환합니다. 두 메서드의 출력 모두 배열의 내용을 반영하지 않습니다.</p>",
    "howToFix_ko": "<p>관련 static <code>Arrays</code> 메서드를 사용하세요.</p>\n<ul>\n  <li> <code>Arrays.hashCode</code> 또는 <code>Arrays.deepHashCode</code> </li>\n  <li> <code>Arrays.toString</code> 또는 <code>Arrays.deepToString</code> </li>\n</ul>\n\n<h4>규칙을 준수하지 않는 코드 예시</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\npublic static void main(String[] args) {\n    String argStr = args.toString();       // 규칙 위반\n    int argHash = args.hashCode();         // 규칙 위반\n}\n</pre>\n<h4>규칙을 준수하는 해결책</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\npublic static void main(String[] args) {\n    String argStr = Arrays.toString(args); // 규칙 준수\n    int argHash = Arrays.hashCode(args);   // 규칙 준수\n}\n</pre>",
    "moreInfo_ko": "<h3>문서</h3>\n<ul>\n  <li> <a href=\"https://docs.oracle.com/en/java/javase/20/docs/api/java.base/java/util/Arrays.html\">Oracle Java SE - Arrays API</a> </li>\n</ul>\n<h3>관련 문서 및 블로그 게시물</h3>\n<ul>\n  <li> <a href=\"https://github.com/google/error-prone/blob/master/docs/bugpattern/ArrayHashCode.md\">Error Prone - ArrayHashCode</a> </li>\n</ul>"
  },
  {
    "id": "S5329",
    "key": "java:S5329",
    "name": "Collection constructors should not be used as java.util.function.Function",
    "type": "code-smell",
    "severity": "major",
    "tags": [],
    "why": "<p>It is very common to pass a collection constructor reference as an argument, for example <code>Collectors.toCollection(ArrayList::new)</code> takes\nthe <code>ArrayList::new</code> constructor. When the method expects a <code>java.util.function.Supplier</code> it is perfectly fine. However when the\nmethod argument type is <code>java.util.function.Function</code> it means that an argument will be passed to the constructor.</p>\n<p>The first argument of Collections constructors is usually an integer representing its \"initial capacity\". This is generally not what the developer\nexpects, but the memory allocation is not visible at first glance.</p>\n<p>This rule raises an issue when a collection constructor is passed by reference as a <code>java.util.function.Function</code> argument.</p>\n<h3>Noncompliant code example</h3>\n<pre>\nArrays.asList(1, 2, 54000).stream().collect(Collectors.toMap(Function.identity(), ArrayList::new)); // Noncompliant, \"ArrayList::new\" unintentionally refers to \"ArrayList(int initialCapacity)\" instead of \"ArrayList()\"\n</pre>\n<h3>Compliant solution</h3>\n<pre>\nArrays.asList(1, 2, 54000).stream().collect(Collectors.toMap(Function.identity(), id -&gt; new ArrayList&lt;&gt;())); // Compliant, explicitly show the usage of \"id -&gt; new ArrayList&lt;&gt;()\" or \"id -&gt; new ArrayList&lt;&gt;(id)\"\n</pre>",
    "howToFix": "",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "Collection 생성자를 java.util.function.Function으로 사용하면 안 됩니다",
    "why_ko": "<p>컬렉션 생성자 참조를 인수로 전달하는 것은 매우 일반적입니다. 예를 들어 <code>Collectors.toCollection(ArrayList::new)</code>는 <code>ArrayList::new</code> 생성자를 사용합니다. 메서드가 <code>java.util.function.Supplier</code>를 기대할 때는 전혀 문제가 없습니다. 그러나 메서드 인수 타입이 <code>java.util.function.Function</code>인 경우 인수가 생성자에 전달된다는 것을 의미합니다.</p>\n<p>Collections 생성자의 첫 번째 인수는 일반적으로 \"초기 용량\"을 나타내는 정수입니다. 이것은 일반적으로 개발자가 기대하는 것이 아니지만 메모리 할당은 한눈에 보이지 않습니다.</p>\n<p>이 규칙은 컬렉션 생성자가 <code>java.util.function.Function</code> 인수로 참조로 전달될 때 문제를 제기합니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\nArrays.asList(1, 2, 54000).stream().collect(Collectors.toMap(Function.identity(), ArrayList::new)); // 규칙 위반, \"ArrayList::new\"가 의도치 않게 \"ArrayList()\" 대신 \"ArrayList(int initialCapacity)\"를 참조함\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre>\nArrays.asList(1, 2, 54000).stream().collect(Collectors.toMap(Function.identity(), id -&gt; new ArrayList&lt;&gt;())); // 규칙 준수, \"id -&gt; new ArrayList&lt;&gt;()\" 또는 \"id -&gt; new ArrayList&lt;&gt;(id)\"의 사용을 명시적으로 보여줌\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": ""
  },
  {
    "id": "S100",
    "key": "java:S100",
    "name": "Method names should comply with a naming convention",
    "type": "code-smell",
    "severity": "minor",
    "tags": [
      "convention"
    ],
    "why": "<p>Shared naming conventions allow teams to collaborate efficiently.</p>\n<p>This rule raises an issue when a method name does not match a provided regular expression.</p>\n<p>For example, with the default provided regular expression <code>^[a-z][a-zA-Z0-9]*$</code>, the method:</p>\n<pre>\npublic int DoSomething(){...} // Noncompliant\n</pre>\n<p>should be renamed to</p>\n<pre>\npublic int doSomething(){...}\n</pre>\n<h3>Exceptions</h3>\n<p>Overriding methods are excluded.</p>\n<pre>\n@Override\npublic int Do_Something(){...} // Compliant by exception\n</pre>",
    "howToFix": "",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "메서드 이름은 명명 규칙을 준수해야 합니다",
    "why_ko": "<p>공유된 명명 규칙은 팀이 효율적으로 협업할 수 있게 합니다.</p>\n<p>이 규칙은 메서드 이름이 제공된 정규 표현식과 일치하지 않을 때 이슈를 제기합니다.</p>\n<p>예를 들어, 기본 제공 정규 표현식 <code>^[a-z][a-zA-Z0-9]*$</code>을 사용하면, 다음 메서드는:</p>\n<pre>\npublic int DoSomething(){...} // 규칙 위반\n</pre>\n<p>다음과 같이 이름을 변경해야 합니다</p>\n<pre>\npublic int doSomething(){...}\n</pre>\n<h3>예외 사항</h3>\n<p>오버라이딩 메서드는 제외됩니다.</p>\n<pre>\n@Override\npublic int Do_Something(){...} // 예외로 규칙 준수\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": ""
  },
  {
    "id": "S1940",
    "key": "java:S1940",
    "name": "Boolean checks should not be inverted",
    "type": "code-smell",
    "severity": "minor",
    "tags": [
      "pitfall"
    ],
    "why": "<p>It is needlessly complex to invert the result of a boolean comparison. The opposite comparison should be made instead.</p>\n<h3>Noncompliant code example</h3>\n<pre>\nif ( !(a == 2)) { ...}  // Noncompliant\nboolean b = !(i &lt; 10);  // Noncompliant\n</pre>\n<h3>Compliant solution</h3>\n<pre>\nif (a != 2) { ...}\nboolean b = (i &gt;= 10);\n</pre>",
    "howToFix": "",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "Boolean 검사를 반전시키면 안 됩니다",
    "why_ko": "<p>부울 비교의 결과를 반전시키는 것은 불필요하게 복잡합니다. 대신 반대 비교를 수행해야 합니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\nif ( !(a == 2)) { ...}  // 규칙 위반\nboolean b = !(i &lt; 10);  // 규칙 위반\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre>\nif (a != 2) { ...}\nboolean b = (i &gt;= 10);\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": ""
  },
  {
    "id": "S5846",
    "key": "java:S5846",
    "name": "Empty lines should not be tested with regex MULTILINE flag",
    "type": "code-smell",
    "severity": "critical",
    "tags": [
      "regex"
    ],
    "why": "<p>One way to test for empty lines is to use the regex <code>\"^$\"</code>, which can be extremely handy when filtering out empty lines from collections\nof Strings, for instance. With regard to this, the Javadoc for <a\nhref=\"https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/regex/Pattern.html\">Pattern (Line Terminators)</a> states the\nfollowing:</p>\n<blockquote>\n  <p>By default, the regular expressions ^ and <code>$</code> ignore line terminators and only match at the beginning and the end, respectively, of\n  the entire input sequence. If <code>MULTILINE</code> mode is activated then ^ matches at the beginning of input and after any line terminator\n  <strong>except at the end of input</strong>. When in <code>MULTILINE</code> mode <code>$</code> matches just before a line terminator or the end of\n  the input sequence.</p>\n</blockquote>\n<p>As emphasized, ^ is not going to match at the end of an input, and the end of the input is necessarily included in the empty string, which might\nlead to completely missing empty lines, while it would be the initial reason for using such regex.</p>\n<p>Therefore, when searching for empty lines using a multi-line regular expression, you should also check whether the string is empty.</p>\n<p>This rule is raising an issue every time a pattern that can match the empty string is used with <code>MULTILINE</code> flag and without calling\n<code>isEmpty()</code> on the string.</p>\n<h3>Noncompliant code example</h3>\n<pre>\nstatic final Pattern p = Pattern.compile(\"^$\", Pattern.MULTILINE); // Noncompliant\n\n// Alternatively\nstatic final Pattern p = Pattern.compile(\"(?m)^$\"); // Noncompliant\n\n\nboolean containsEmptyLines(String str) {\n    return p.matcher(str).find();\n}\n\n// ...\nSystem.out.println(containsEmptyLines(\"a\\n\\nb\")); // correctly prints 'true'\nSystem.out.println(containsEmptyLines(\"\")); // incorrectly prints 'false'\n</pre>\n<h3>Compliant solution</h3>\n<pre>\nstatic final Pattern p = Pattern.compile(\"^$\", Pattern.MULTILINE);\n\nboolean containsEmptyLines(String str) {\n    return p.matcher(str).find() || str.isEmpty();\n}\n\n// ...\nSystem.out.println(containsEmptyLines(\"a\\n\\nb\")); // correctly prints 'true'\nSystem.out.println(containsEmptyLines(\"\")); // also correctly prints 'true'\n</pre>",
    "howToFix": "",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "빈 줄은 정규식 MULTILINE 플래그로 테스트하면 안 됩니다",
    "why_ko": "<p>빈 줄을 테스트하는 한 가지 방법은 정규식 <code>\"^$\"</code>를 사용하는 것입니다. 이는 예를 들어 문자열 컬렉션에서 빈 줄을 필터링할 때 매우 유용할 수 있습니다. 이와 관련하여 <a\nhref=\"https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/regex/Pattern.html\">Pattern (Line Terminators)</a>에 대한 Javadoc은 다음과 같이 명시합니다:</p>\n<blockquote>\n  <p>기본적으로 정규식 ^와 <code>$</code>는 줄 종결자를 무시하고 각각 전체 입력 시퀀스의 시작과 끝에서만 일치합니다. <code>MULTILINE</code> 모드가 활성화되면 ^는 입력의 시작과 <strong>입력의 끝을 제외한</strong> 모든 줄 종결자 뒤에서 일치합니다. <code>MULTILINE</code> 모드에서 <code>$</code>는 줄 종결자 바로 앞이나 입력 시퀀스의 끝에서 일치합니다.</p>\n</blockquote>\n<p>강조된 대로 ^는 입력의 끝에서 일치하지 않으며 입력의 끝은 반드시 빈 문자열에 포함됩니다. 이로 인해 빈 줄을 완전히 놓칠 수 있으며 이는 처음에 그러한 정규식을 사용한 이유일 수 있습니다.</p>\n<p>따라서 다중 줄 정규식을 사용하여 빈 줄을 검색할 때 문자열이 비어 있는지도 확인해야 합니다.</p>\n<p>이 규칙은 빈 문자열과 일치할 수 있는 패턴이 <code>MULTILINE</code> 플래그와 함께 사용되고 문자열에서 <code>isEmpty()</code>를 호출하지 않을 때마다 문제를 제기합니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\nstatic final Pattern p = Pattern.compile(\"^$\", Pattern.MULTILINE); // 규칙 위반\n\n// 대안\nstatic final Pattern p = Pattern.compile(\"(?m)^$\"); // 규칙 위반\n\n\nboolean containsEmptyLines(String str) {\n    return p.matcher(str).find();\n}\n\n// ...\nSystem.out.println(containsEmptyLines(\"a\\n\\nb\")); // 올바르게 'true' 출력\nSystem.out.println(containsEmptyLines(\"\")); // 잘못되게 'false' 출력\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre>\nstatic final Pattern p = Pattern.compile(\"^$\", Pattern.MULTILINE);\n\nboolean containsEmptyLines(String str) {\n    return p.matcher(str).find() || str.isEmpty();\n}\n\n// ...\nSystem.out.println(containsEmptyLines(\"a\\n\\nb\")); // 올바르게 'true' 출력\nSystem.out.println(containsEmptyLines(\"\")); // 역시 올바르게 'true' 출력\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": ""
  },
  {
    "id": "S6293",
    "key": "java:S6293",
    "name": "Using biometric authentication without a cryptographic solution is security-sensitive",
    "type": "security-hotspot",
    "severity": "major",
    "tags": [
      "cwe",
      "android"
    ],
    "why": "<p>Android comes with Android KeyStore, a secure container for storing key materials. It's possible to define certain keys to be unlocked when users\nauthenticate using biometric credentials. This way, even if the application process is compromised, the attacker cannot access keys, as presence of\nthe authorized user is required.</p>\n<p>These keys can be used, to encrypt, sign or create a message authentication code (MAC) as proof that the authentication result has not been\ntampered with. This protection defeats the scenario where an attacker with physical access to the device would try to hook into the application\nprocess and call the <code>onAuthenticationSucceeded</code> method directly. Therefore he would be unable to extract the sensitive data or to perform\nthe critical operations protected by the biometric authentication.</p>\n",
    "howToFix": "<h2>Recommended Secure Coding Practices</h2>\n<p>It's recommended to tie the biometric authentication to a cryptographic operation by using a <code>CryptoObject</code> during authentication.</p>\n<h2>Compliant Solution</h2>\n<p>A <code>CryptoObject</code> is used during authentication:</p>\n<pre>\n// ...\nBiometricPrompt biometricPrompt = new BiometricPrompt(activity, executor, callback);\n// ...\nbiometricPrompt.authenticate(promptInfo, new BiometricPrompt.CryptoObject(cipher)); // Compliant\n</pre>\n<h2>See</h2>\n<ul>\n  <li> OWASP - <a href=\"https://owasp.org/Top10/A07_2021-Identification_and_Authentication_Failures/\">Top 10 2021 Category A7 - Identification and\n  Authentication Failures</a> </li>\n  <li> OWASP - <a href=\"https://owasp.org/www-project-mobile-top-10/2016-risks/m4-insecure-authentication\">Mobile Top 10 2016 Category M4 - Insecure\n  Authentication</a> </li>\n  <li> OWASP - <a href=\"https://owasp.org/www-project-mobile-top-10/2023-risks/m3-insecure-authentication-authorization\">Mobile Top 10 2024 Category\n  M3 - Insecure Authentication/Authorization</a> </li>\n  <li> OWASP - <a href=\"https://mas.owasp.org/checklists/MASVS-AUTH/\">Mobile AppSec Verification Standard - Authentication and Session Management\n  Requirements</a> </li>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/287\">CWE-287 - Improper Authentication</a> </li>\n  <li> <a href=\"https://developer.android.com/training/sign-in/biometric-auth\">developer.android.com</a> - Use a cryptographic solution that depends\n  on authentication </li>\n</ul>",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "암호화 솔루션 없이 생체 인증을 사용하는 것은 보안에 민감합니다",
    "why_ko": "<p>Android에는 키 자료를 저장하기 위한 보안 컨테이너인 Android KeyStore가 함께 제공됩니다. 사용자가 생체 인식 자격 증명을 사용하여 인증할 때 특정 키가 잠금 해제되도록 정의할 수 있습니다. 이렇게 하면 애플리케이션 프로세스가 손상되더라도 승인된 사용자의 존재가 필요하기 때문에 공격자가 키에 접근할 수 없습니다.</p>\n<p>이러한 키는 인증 결과가 변조되지 않았다는 증거로 암호화, 서명 또는 메시지 인증 코드(MAC)를 생성하는 데 사용할 수 있습니다. 이 보호는 기기에 물리적으로 접근할 수 있는 공격자가 애플리케이션 프로세스에 연결하여 <code>onAuthenticationSucceeded</code> 메서드를 직접 호출하려는 시나리오를 방어합니다. 따라서 그는 민감한 데이터를 추출하거나 생체 인증으로 보호되는 중요한 작업을 수행할 수 없습니다.</p>\n",
    "howToFix_ko": "<h2>권장 보안 코딩 관행</h2>\n<p>인증 중에 <code>CryptoObject</code>를 사용하여 생체 인증을 암호화 작업에 연결하는 것이 권장됩니다.</p>\n<h2>규칙을 준수하는 해결책</h2>\n<p>인증 중에 <code>CryptoObject</code>가 사용됩니다:</p>\n<pre>\n// ...\nBiometricPrompt biometricPrompt = new BiometricPrompt(activity, executor, callback);\n// ...\nbiometricPrompt.authenticate(promptInfo, new BiometricPrompt.CryptoObject(cipher)); // 규칙 준수\n</pre>\n<h2>참고</h2>\n<ul>\n  <li> OWASP - <a href=\"https://owasp.org/Top10/A07_2021-Identification_and_Authentication_Failures/\">Top 10 2021 Category A7 - 식별 및 인증 실패</a> </li>\n  <li> OWASP - <a href=\"https://owasp.org/www-project-mobile-top-10/2016-risks/m4-insecure-authentication\">Mobile Top 10 2016 Category M4 - 안전하지 않은 인증</a> </li>\n  <li> OWASP - <a href=\"https://owasp.org/www-project-mobile-top-10/2023-risks/m3-insecure-authentication-authorization\">Mobile Top 10 2024 Category M3 - 안전하지 않은 인증/권한 부여</a> </li>\n  <li> OWASP - <a href=\"https://mas.owasp.org/checklists/MASVS-AUTH/\">Mobile AppSec Verification Standard - 인증 및 세션 관리 요구사항</a> </li>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/287\">CWE-287 - 부적절한 인증</a> </li>\n  <li> <a href=\"https://developer.android.com/training/sign-in/biometric-auth\">developer.android.com</a> - 인증에 의존하는 암호화 솔루션 사용 </li>\n</ul>",
    "moreInfo_ko": ""
  },
  {
    "id": "S1106",
    "key": "java:S1106",
    "name": "An open curly brace should be located at the beginning of a line",
    "type": "code-smell",
    "severity": "minor",
    "tags": [
      "convention"
    ],
    "why": "<p>Shared coding conventions make it possible to collaborate efficiently. This rule makes it mandatory to place the open curly brace at the beginning\nof a line.</p>\n<h3>Noncompliant code example</h3>\n<pre>\npublic void myMethod {  // Noncompliant\n  if(something) {  // Noncompliant\n    executeTask();\n  } else {  // Noncompliant\n    doSomethingElse();\n  }\n}\n</pre>\n<h3>Compliant solution</h3>\n<pre>\npublic void myMethod\n{\n  if(something)\n  {\n    executeTask();\n  } else\n  {\n    doSomethingElse();\n  }\n}\n</pre>",
    "howToFix": "",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "여는 중괄호는 줄의 시작에 위치해야 합니다",
    "why_ko": "<p>공유된 코딩 규칙은 효율적인 협업을 가능하게 합니다. 이 규칙은 여는 중괄호를 줄의 시작에 배치하도록 의무화합니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\npublic void myMethod {  // 규칙 위반\n  if(something) {  // 규칙 위반\n    executeTask();\n  } else {  // 규칙 위반\n    doSomethingElse();\n  }\n}\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre>\npublic void myMethod\n{\n  if(something)\n  {\n    executeTask();\n  } else\n  {\n    doSomethingElse();\n  }\n}\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": ""
  },
  {
    "id": "S7178",
    "key": "java:S7178",
    "name": "Injecting data into static fields is not supported by Spring",
    "type": "code-smell",
    "severity": "critical",
    "tags": [
      "spring"
    ],
    "why": "<p>Spring dependency injection framework does not support injecting data into static fields. When @Value, @Inject, or @Autowired are applied to static\nfields, they are ignored.</p>\n<h3>What is the potential impact?</h3>\n<ul>\n  <li> <strong>Null Values</strong>: Uninitialized static fields annotated with @Value, @Inject, or @Autowired will not be initialized by Spring,\n  potentially causing NullPointerException at runtime. </li>\n  <li> <strong>Confusing Code</strong>: The presence of injection annotations on static fields can mislead developers into believing that the fields\n  will be populated by Spring. </li>\n</ul>\n<p>This rule raises an issue when a static field is annotated with @Value, @Inject, or @Autowired.</p>",
    "howToFix": "<p>Either use an instance field instead of a static field or remove the @Value, @Inject, or @Autowired annotation and initialize the field.</p>\n\n<h4>Noncompliant code example</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\n@Component\npublic class MyComponent {\n\n    @Value(\"${my.app.prop}\")\n    private static SomeDependency dependency; // non compliant, @Value will be ignored and no value will be injected\n    // ...\n}\n</pre>\n<h4>Compliant solution</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\n@Component\npublic class MyComponent {\n\n    @Value(\"${my.app.prop}\")\n    private final SomeDependency dependency;\n    // ...\n}\n</pre>",
    "moreInfo": "<h3>Articles &amp; blog posts</h3>\n<ul>\n  <li> Java Guides - <a href=\"https://www.baeldung.com/spring-inject-static-field\">Injecting a Value in a Static Field in Spring</a> </li>\n</ul>",
    "status": "READY",
    "name_ko": "Spring은 static 필드에 데이터 주입을 지원하지 않습니다",
    "why_ko": "<p>Spring 의존성 주입 프레임워크는 static 필드에 데이터를 주입하는 것을 지원하지 않습니다. @Value, @Inject 또는 @Autowired가 static 필드에 적용되면 무시됩니다.</p>\n<h3>잠재적 영향은 무엇인가요?</h3>\n<ul>\n  <li> <strong>Null 값</strong>: @Value, @Inject 또는 @Autowired로 어노테이션된 초기화되지 않은 static 필드는 Spring에 의해 초기화되지 않아 런타임에 NullPointerException이 발생할 수 있습니다. </li>\n  <li> <strong>혼란스러운 코드</strong>: static 필드에 주입 어노테이션이 있으면 개발자들이 해당 필드가 Spring에 의해 채워질 것이라고 잘못 믿게 할 수 있습니다. </li>\n</ul>\n<p>이 규칙은 static 필드에 @Value, @Inject 또는 @Autowired 어노테이션이 있을 때 문제를 발생시킵니다.</p>",
    "howToFix_ko": "<p>static 필드 대신 인스턴스 필드를 사용하거나 @Value, @Inject 또는 @Autowired 어노테이션을 제거하고 필드를 초기화하세요.</p>\n\n<h4>규칙을 준수하지 않는 코드 예시</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\n@Component\npublic class MyComponent {\n\n    @Value(\"${my.app.prop}\")\n    private static SomeDependency dependency; // 규칙 위반, @Value가 무시되고 값이 주입되지 않습니다\n    // ...\n}\n</pre>\n<h4>규칙을 준수하는 해결책</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\n@Component\npublic class MyComponent {\n\n    @Value(\"${my.app.prop}\")\n    private final SomeDependency dependency;\n    // ...\n}\n</pre>",
    "moreInfo_ko": "<h3>기사 및 블로그 게시물</h3>\n<ul>\n  <li> Java Guides - <a href=\"https://www.baeldung.com/spring-inject-static-field\">Spring에서 Static 필드에 값 주입하기</a> </li>\n</ul>"
  },
  {
    "id": "S7482",
    "key": "java:S7482",
    "name": "Don't provide an initializer for a stateless stream gatherer",
    "type": "code-smell",
    "severity": "major",
    "tags": [
      "java24"
    ],
    "why": "<p>Stateless stream gatherers, which process each element of the stream independently, don't need an initializer function. That's because the role of\nthe initializer function is to set up the gatherer's private state object.</p>\n<p>The gatherer interface provides factory methods that create gatherers without taking an initializer as an argument:</p>\n<ul>\n  <li> <code>ofSequential(Gatherer.Integrator&lt;Void,T,R&gt; integrator)</code> </li>\n  <li> <code>ofSequential(Gatherer.Integrator&lt;Void,T,R&gt; integrator, BiConsumer&lt;Void, Gatherer.Downstream&lt;? super R&gt;&gt;\n  finisher)</code> </li>\n</ul>\n<p>Using these specific factory methods to create stateless gatherers is preferable because it clearly communicates their stateless nature.</p>\n<p>This rule reports the use of <code>ofSequential(Gatherer.Integrator&lt;Void,T,R&gt; integrator, BiConsumer&lt;Void, Gatherer.Downstream&lt;? super\nR&gt;&gt; finisher)</code> when it returns a stateless gatherer.</p>\n\n<h4>Noncompliant code example</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\nprivate static Gatherer inRange(int start, int end) {\n    return Gatherer.&lt;Integer, Void, Integer&gt;ofSequential(\n      () -&gt; null, // Noncompliant: unnecessary initializer\n      (_, element, downstream) -&gt; {\n        if (element &gt;= start &amp;&amp; element &lt;= end)\n          return downstream.push(element - start);\n        return !downstream.isRejecting();\n      },\n      (_, downstream) -&gt; downstream.push(-1)\n    );\n}\n</pre>\n<h4>Compliant solution</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\nprivate static Gatherer inRange(int start, int end) {\n    return Gatherer.&lt;Integer, Integer&gt;ofSequential(\n      (_, element, downstream) -&gt; {\n        if (element &gt;= start &amp;&amp; element &lt;= end)\n          return downstream.push(element - start);\n        return !downstream.isRejecting();\n      },\n      (_, downstream) -&gt; downstream.push(-1)\n    );\n}\n</pre>",
    "howToFix": "",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "상태 없는 stream gatherer에는 initializer를 제공하면 안 됩니다",
    "why_ko": "<p>스트림의 각 요소를 독립적으로 처리하는 상태 없는 stream gatherer는 initializer 함수가 필요하지 않습니다. 이는 initializer 함수의 역할이 gatherer의 개인 상태 객체를 설정하는 것이기 때문입니다.</p>\n<p>gatherer 인터페이스는 initializer를 인수로 받지 않고 gatherer를 생성하는 팩토리 메서드를 제공합니다:</p>\n<ul>\n  <li> <code>ofSequential(Gatherer.Integrator&lt;Void,T,R&gt; integrator)</code> </li>\n  <li> <code>ofSequential(Gatherer.Integrator&lt;Void,T,R&gt; integrator, BiConsumer&lt;Void, Gatherer.Downstream&lt;? super R&gt;&gt; finisher)</code> </li>\n</ul>\n<p>상태 없는 gatherer를 생성할 때 이러한 특정 팩토리 메서드를 사용하는 것이 상태 없는 특성을 명확하게 전달하므로 바람직합니다.</p>\n<p>이 규칙은 <code>ofSequential(Gatherer.Integrator&lt;Void,T,R&gt; integrator, BiConsumer&lt;Void, Gatherer.Downstream&lt;? super R&gt;&gt; finisher)</code>가 상태 없는 gatherer를 반환할 때 사용을 보고합니다.</p>\n\n<h4>규칙을 준수하지 않는 코드 예시</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\nprivate static Gatherer inRange(int start, int end) {\n    return Gatherer.&lt;Integer, Void, Integer&gt;ofSequential(\n      () -&gt; null, // 규칙 위반: 불필요한 initializer\n      (_, element, downstream) -&gt; {\n        if (element &gt;= start &amp;&amp; element &lt;= end)\n          return downstream.push(element - start);\n        return !downstream.isRejecting();\n      },\n      (_, downstream) -&gt; downstream.push(-1)\n    );\n}\n</pre>\n<h4>규칙을 준수하는 해결책</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\nprivate static Gatherer inRange(int start, int end) {\n    return Gatherer.&lt;Integer, Integer&gt;ofSequential(\n      (_, element, downstream) -&gt; {\n        if (element &gt;= start &amp;&amp; element &lt;= end)\n          return downstream.push(element - start);\n        return !downstream.isRejecting();\n      },\n      (_, downstream) -&gt; downstream.push(-1)\n    );\n}\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": ""
  },
  {
    "id": "S6905",
    "key": "java:S6905",
    "name": "SQL queries should retrieve only necessary fields",
    "type": "code-smell",
    "severity": "major",
    "tags": [
      "sustainability",
      "sql"
    ],
    "why": "<p>A common reason for a poorly performant query is because it's processing more data than required.</p>\n<p>Querying unnecessary data demands extra work on the server, adds network overhead, and consumes memory and CPU resources on the application server.\nThe effect is amplified when the query includes multiple <em>joins</em>.</p>\n<p>The rule flags an issue when a <code>SELECT *</code> query is provided as an argument to methods in <code>java.sql.Connection</code> and\n<code>java.sql.Statement</code>.</p>\n<h3>What is the potential impact?</h3>\n<ul>\n  <li> <em>Performance</em>: the unnecessary extra data being processed brings overhead. </li>\n  <li> <em>Sustainability</em>: the extra resources used have a negative impact on the environment. </li>\n</ul>",
    "howToFix": "<p>Make the <code>SELECT *</code> an explicit selection of the required fields.</p>\n\n<h4>Noncompliant code example</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\npublic class OrderRepository {\n\n    public record OrderSummary(String name, String orderId, BigDecimal price) { }\n\n    public List&lt;OrderSummary&gt; queryOrderSummaries(Connection conn) {\n            String sql = \"SELECT * \" +                                                         // Noncompliant\n                          \"FROM Orders JOIN Customers ON Orders.customerId = Customers.id \";\n\n            Statement stmt = conn.createStatement();\n            ResultSet rs = stmt.executeQuery(sql);\n\n            return convertResultToOrderSummaryList(rs);\n    }\n}\n</pre>\n<h4>Compliant solution</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\npublic class OrderRepository {\n\n    public record OrderSummary(String name, String orderId, BigDecimal price) { }\n\n    public List&lt;OrderSummary&gt; queryOrderSummaries(Connection conn) {\n            String sql = \"SELECT Customers.name, Orders.id, Orders.price \" +                   // Compliant\n                          \"FROM Orders JOIN Customers ON Orders.customerId = Customers.id \";\n\n            Statement stmt = conn.createStatement();\n            ResultSet rs = stmt.executeQuery(sql);\n\n            return convertResultToOrderSummaryList(rs);\n    }\n}\n</pre>",
    "moreInfo": "<h3>Documentation</h3>\n<ul>\n  <li> <a href=\"https://docs.oracle.com/en/java/javase/21/docs/api/java.sql/java/sql/Statement.html\">Oracle SDK - Statement</a> </li>\n  <li> <a href=\"https://www.oreilly.com/library/view/high-performance-mysql/9780596101718/ch04.html\">O'Reilly - High Performance MySQL - Query\n  Performance Optimization</a> </li>\n</ul>\n<h3>Articles &amp; blog posts</h3>\n<ul>\n  <li> <a href=\"https://www.geeksforgeeks.org/difference-between-execute-query-and-update-methods-in-java/\">GeeksforGeeks - Difference Between\n  Execute(), query() and Update() Methods in Java</a> </li>\n</ul>",
    "status": "READY",
    "name_ko": "SQL 쿼리는 필요한 필드만 조회해야 합니다",
    "why_ko": "<p>성능이 떨어지는 쿼리의 일반적인 이유는 필요한 것보다 더 많은 데이터를 처리하기 때문입니다.</p>\n<p>불필요한 데이터를 쿼리하면 서버에서 추가 작업이 필요하고 네트워크 오버헤드가 추가되며 애플리케이션 서버의 메모리와 CPU 리소스를 소비합니다. 쿼리에 여러 <em>조인</em>이 포함된 경우 영향이 증폭됩니다.</p>\n<p>이 규칙은 <code>java.sql.Connection</code> 및 <code>java.sql.Statement</code>의 메서드에 <code>SELECT *</code> 쿼리가 인수로 제공될 때 문제를 발생시킵니다.</p>\n<h3>잠재적 영향은 무엇인가요?</h3>\n<ul>\n  <li> <em>성능</em>: 처리되는 불필요한 추가 데이터가 오버헤드를 발생시킵니다. </li>\n  <li> <em>지속 가능성</em>: 사용된 추가 리소스는 환경에 부정적인 영향을 미칩니다. </li>\n</ul>",
    "howToFix_ko": "<p><code>SELECT *</code>를 필요한 필드의 명시적 선택으로 변경하세요.</p>\n\n<h4>규칙을 준수하지 않는 코드 예시</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\npublic class OrderRepository {\n\n    public record OrderSummary(String name, String orderId, BigDecimal price) { }\n\n    public List&lt;OrderSummary&gt; queryOrderSummaries(Connection conn) {\n            String sql = \"SELECT * \" +                                                         // 규칙 위반\n                          \"FROM Orders JOIN Customers ON Orders.customerId = Customers.id \";\n\n            Statement stmt = conn.createStatement();\n            ResultSet rs = stmt.executeQuery(sql);\n\n            return convertResultToOrderSummaryList(rs);\n    }\n}\n</pre>\n<h4>규칙을 준수하는 해결책</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\npublic class OrderRepository {\n\n    public record OrderSummary(String name, String orderId, BigDecimal price) { }\n\n    public List&lt;OrderSummary&gt; queryOrderSummaries(Connection conn) {\n            String sql = \"SELECT Customers.name, Orders.id, Orders.price \" +                   // 규칙 준수\n                          \"FROM Orders JOIN Customers ON Orders.customerId = Customers.id \";\n\n            Statement stmt = conn.createStatement();\n            ResultSet rs = stmt.executeQuery(sql);\n\n            return convertResultToOrderSummaryList(rs);\n    }\n}\n</pre>",
    "moreInfo_ko": "<h3>문서</h3>\n<ul>\n  <li> <a href=\"https://docs.oracle.com/en/java/javase/21/docs/api/java.sql/java/sql/Statement.html\">Oracle SDK - Statement</a> </li>\n  <li> <a href=\"https://www.oreilly.com/library/view/high-performance-mysql/9780596101718/ch04.html\">O'Reilly - 고성능 MySQL - 쿼리 성능 최적화</a> </li>\n</ul>\n<h3>기사 및 블로그 게시물</h3>\n<ul>\n  <li> <a href=\"https://www.geeksforgeeks.org/difference-between-execute-query-and-update-methods-in-java/\">GeeksforGeeks - Java의 Execute(), query(), Update() 메서드 차이</a> </li>\n</ul>"
  },
  {
    "id": "S116",
    "key": "java:S116",
    "name": "Field names should comply with a naming convention",
    "type": "code-smell",
    "severity": "minor",
    "tags": [
      "convention"
    ],
    "why": "<p>A naming convention in software development is a set of guidelines for naming code elements like variables, functions, and classes.</p>\n<p>The goal of a naming convention is to make the code more readable and understandable, which makes it easier to maintain and debug. It also ensures\nconsistency in the code, especially when multiple developers are working on the same project.</p>\n<p>This rule checks that field names match a provided regular expression.</p>\n<p>Using the regular expression <code>^[a-z][a-zA-Z0-9]*$</code>, the noncompliant code below:</p>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\nclass MyClass {\n   private int my_field;\n}\n</pre>\n<p>Should be replaced with:</p>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\nclass MyClass {\n   private int myField;\n}\n</pre>",
    "howToFix": "",
    "moreInfo": "<h3>Documentation</h3>\n<ul>\n  <li> Oracle - <a href=\"https://www.oracle.com/java/technologies/javase/codeconventions-namingconventions.html\">Java SE Naming Conventions</a> </li>\n  <li> Geeksforgeeks - <a href=\"https://www.geeksforgeeks.org/java-naming-conventions/\">Java Naming Conventions</a> </li>\n  <li> Wikipedia - <a href=\"https://en.wikipedia.org/wiki/Naming_convention_(programming)\">Naming Convention (programming)</a> </li>\n</ul>",
    "status": "READY",
    "name_ko": "필드 이름은 명명 규칙을 준수해야 합니다",
    "why_ko": "<p>소프트웨어 개발에서 명명 규칙은 변수, 함수, 클래스와 같은 코드 요소의 이름을 지정하기 위한 가이드라인 집합입니다.</p>\n<p>명명 규칙의 목표는 코드를 더 읽기 쉽고 이해하기 쉽게 만들어 유지 관리하고 디버그하기 쉽게 하는 것입니다. 또한 특히 여러 개발자가 같은 프로젝트에서 작업할 때 코드의 일관성을 보장합니다.</p>\n<p>이 규칙은 필드 이름이 제공된 정규 표현식과 일치하는지 확인합니다.</p>\n<p>정규 표현식 <code>^[a-z][a-zA-Z0-9]*$</code>를 사용하면 아래의 규칙을 준수하지 않는 코드:</p>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\nclass MyClass {\n   private int my_field;\n}\n</pre>\n<p>다음으로 교체되어야 합니다:</p>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\nclass MyClass {\n   private int myField;\n}\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": "<h3>문서</h3>\n<ul>\n  <li> Oracle - <a href=\"https://www.oracle.com/java/technologies/javase/codeconventions-namingconventions.html\">Java SE 명명 규칙</a> </li>\n  <li> Geeksforgeeks - <a href=\"https://www.geeksforgeeks.org/java-naming-conventions/\">Java 명명 규칙</a> </li>\n  <li> Wikipedia - <a href=\"https://en.wikipedia.org/wiki/Naming_convention_(programming)\">명명 규칙 (프로그래밍)</a> </li>\n</ul>"
  },
  {
    "id": "S2229",
    "key": "java:S2229",
    "name": "Methods should not call same-class methods with incompatible \"@Transactional\" values",
    "type": "bug",
    "severity": "blocker",
    "tags": [
      "spring"
    ],
    "why": "<p>Transactional methods have a propagation type parameter in the @Transaction annotation that specifies the requirements about the transactional\ncontext in which the method can be called and how it creates, appends, or suspends an ongoing transaction.</p>\n<p>When an instance that contains transactional methods is injected, Spring uses proxy objects to wrap these methods with the actual transaction\ncode.</p>\n<p>However, if a transactional method is called from another method in the same class, the <code>this</code> argument is used as the receiver instance\ninstead of the injected proxy object, which bypasses the wrapper code. This results in specific transitions from one transactional method to another,\nwhich are not allowed:</p>\n<table>\n  <colgroup>\n    <col style=\"width: 50%;\">\n    <col style=\"width: 50%;\">\n  </colgroup>\n  <thead>\n    <tr>\n      <th>From</th>\n      <th>To</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td><p>non-<code>@Transactional</code></p></td>\n      <td><p>MANDATORY, NESTED, REQUIRED, REQUIRES_NEW</p></td>\n    </tr>\n    <tr>\n      <td><p>MANDATORY</p></td>\n      <td><p>NESTED, NEVER, NOT_SUPPORTED, REQUIRES_NEW</p></td>\n    </tr>\n    <tr>\n      <td><p>NESTED</p></td>\n      <td><p>NESTED, NEVER, NOT_SUPPORTED, REQUIRES_NEW</p></td>\n    </tr>\n    <tr>\n      <td><p>NEVER</p></td>\n      <td><p>MANDATORY, NESTED, REQUIRED, REQUIRES_NEW</p></td>\n    </tr>\n    <tr>\n      <td><p>NOT_SUPPORTED</p></td>\n      <td><p>MANDATORY, NESTED, REQUIRED, REQUIRES_NEW</p></td>\n    </tr>\n    <tr>\n      <td><p>REQUIRED or <code>@Transactional</code></p></td>\n      <td><p>NESTED, NEVER, NOT_SUPPORTED, REQUIRES_NEW</p></td>\n    </tr>\n    <tr>\n      <td><p>REQUIRES_NEW</p></td>\n      <td><p>NESTED, NEVER, NOT_SUPPORTED, REQUIRES_NEW</p></td>\n    </tr>\n    <tr>\n      <td><p>SUPPORTS</p></td>\n      <td><p>MANDATORY, NESTED, NEVER, NOT_SUPPORTED, REQUIRED, REQUIRES_NEW</p></td>\n    </tr>\n  </tbody>\n</table>",
    "howToFix": "<p>Change the corresponding functions into a compatible propagation type.</p>\n\n<h4>Noncompliant code example</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\npublic void doTheThing() {\n  // ...\n  actuallyDoTheThing(); // Noncompliant, call from non-transactional to transactional\n}\n\n@Transactional\npublic void actuallyDoTheThing() {\n  // ...\n}\n</pre>\n<h4>Compliant solution</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\n@Transactional\npublic void doTheThing() {\n  // ...\n  actuallyDoTheThing(); // Compliant\n}\n\n@Transactional\npublic void actuallyDoTheThing() {\n  // ...\n}\n</pre>\n<h4>Noncompliant code example</h4>\n<pre data-diff-id=\"2\" data-diff-type=\"noncompliant\">\n@Transactional\npublic void doTheThing() {\n  // ...\n  actuallyDoTheThing(); // Noncompliant, call from REQUIRED to REQUIRES_NEW\n}\n\n@Transactional(propagation = Propagation.REQUIRES_NEW)\npublic void actuallyDoTheThing() {\n  // ...\n}\n</pre>\n<h4>Compliant solution</h4>\n<pre data-diff-id=\"2\" data-diff-type=\"compliant\">\n@Transactional\npublic void doTheThing() {\n  // ...\n  actuallyDoTheThing(); // Compliant, call from REQUIRED to MANDATORY\n}\n\n@Transactional(propagation = Propagation.MANDATORY)\npublic void actuallyDoTheThing() {\n  // ...\n}\n</pre>",
    "moreInfo": "<ul>\n  <li> <a href=\"https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/transaction/annotation/Propagation.html\">Spring\n  Framework 6 API: Enum Class propagation</a> </li>\n  <li> <a href=\"https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/transaction/annotation/Transactional.html\">Spring\n  Framework 6 API: Annotation Interface Transactional</a> </li>\n  <li> <a href=\"https://docs.spring.io/spring-framework/reference/data-access/transaction/declarative/tx-propagation.html\">Spring 6 Documentation:\n  Transaction Propagation</a> </li>\n</ul>\n<h3>Articles &amp; blog posts</h3>\n<ul>\n  <li> <a href=\"https://www.baeldung.com/spring-transactional-propagation-isolation\">Baeldung: Transaction Propagation and Isolation in Spring\n  @Transactional</a> </li>\n  <li> <a href=\"https://dzone.com/articles/spring-transaction-propagation\">DZone: Spring Transaction Propagation in a Nutshell</a> </li>\n</ul>",
    "status": "READY",
    "name_ko": "메서드는 호환되지 않는 \"@Transactional\" 값을 가진 같은 클래스의 메서드를 호출하면 안 됩니다",
    "why_ko": "<p>트랜잭션 메서드는 @Transaction 어노테이션에 전파 유형 매개변수가 있으며, 이는 메서드가 호출될 수 있는 트랜잭션 컨텍스트에 대한 요구사항과 진행 중인 트랜잭션을 생성, 추가 또는 일시 중단하는 방법을 지정합니다.</p>\n<p>트랜잭션 메서드를 포함하는 인스턴스가 주입되면 Spring은 프록시 객체를 사용하여 이러한 메서드를 실제 트랜잭션 코드로 래핑합니다.</p>\n<p>그러나 트랜잭션 메서드가 같은 클래스의 다른 메서드에서 호출되면 주입된 프록시 객체 대신 <code>this</code> 인수가 수신자 인스턴스로 사용되어 래퍼 코드를 우회합니다. 이로 인해 허용되지 않는 특정 트랜잭션 메서드 간 전환이 발생합니다:</p>\n<table>\n  <colgroup>\n    <col style=\"width: 50%;\">\n    <col style=\"width: 50%;\">\n  </colgroup>\n  <thead>\n    <tr>\n      <th>시작</th>\n      <th>대상</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td><p>non-<code>@Transactional</code></p></td>\n      <td><p>MANDATORY, NESTED, REQUIRED, REQUIRES_NEW</p></td>\n    </tr>\n    <tr>\n      <td><p>MANDATORY</p></td>\n      <td><p>NESTED, NEVER, NOT_SUPPORTED, REQUIRES_NEW</p></td>\n    </tr>\n    <tr>\n      <td><p>NESTED</p></td>\n      <td><p>NESTED, NEVER, NOT_SUPPORTED, REQUIRES_NEW</p></td>\n    </tr>\n    <tr>\n      <td><p>NEVER</p></td>\n      <td><p>MANDATORY, NESTED, REQUIRED, REQUIRES_NEW</p></td>\n    </tr>\n    <tr>\n      <td><p>NOT_SUPPORTED</p></td>\n      <td><p>MANDATORY, NESTED, REQUIRED, REQUIRES_NEW</p></td>\n    </tr>\n    <tr>\n      <td><p>REQUIRED 또는 <code>@Transactional</code></p></td>\n      <td><p>NESTED, NEVER, NOT_SUPPORTED, REQUIRES_NEW</p></td>\n    </tr>\n    <tr>\n      <td><p>REQUIRES_NEW</p></td>\n      <td><p>NESTED, NEVER, NOT_SUPPORTED, REQUIRES_NEW</p></td>\n    </tr>\n    <tr>\n      <td><p>SUPPORTS</p></td>\n      <td><p>MANDATORY, NESTED, NEVER, NOT_SUPPORTED, REQUIRED, REQUIRES_NEW</p></td>\n    </tr>\n  </tbody>\n</table>",
    "howToFix_ko": "<p>해당 함수를 호환되는 전파 유형으로 변경하세요.</p>\n\n<h4>규칙을 준수하지 않는 코드 예시</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\npublic void doTheThing() {\n  // ...\n  actuallyDoTheThing(); // 규칙 위반, non-transactional에서 transactional로 호출\n}\n\n@Transactional\npublic void actuallyDoTheThing() {\n  // ...\n}\n</pre>\n<h4>규칙을 준수하는 해결책</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\n@Transactional\npublic void doTheThing() {\n  // ...\n  actuallyDoTheThing(); // 규칙 준수\n}\n\n@Transactional\npublic void actuallyDoTheThing() {\n  // ...\n}\n</pre>\n<h4>규칙을 준수하지 않는 코드 예시</h4>\n<pre data-diff-id=\"2\" data-diff-type=\"noncompliant\">\n@Transactional\npublic void doTheThing() {\n  // ...\n  actuallyDoTheThing(); // 규칙 위반, REQUIRED에서 REQUIRES_NEW로 호출\n}\n\n@Transactional(propagation = Propagation.REQUIRES_NEW)\npublic void actuallyDoTheThing() {\n  // ...\n}\n</pre>\n<h4>규칙을 준수하는 해결책</h4>\n<pre data-diff-id=\"2\" data-diff-type=\"compliant\">\n@Transactional\npublic void doTheThing() {\n  // ...\n  actuallyDoTheThing(); // 규칙 준수, REQUIRED에서 MANDATORY로 호출\n}\n\n@Transactional(propagation = Propagation.MANDATORY)\npublic void actuallyDoTheThing() {\n  // ...\n}\n</pre>",
    "moreInfo_ko": "<ul>\n  <li> <a href=\"https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/transaction/annotation/Propagation.html\">Spring Framework 6 API: Enum Class propagation</a> </li>\n  <li> <a href=\"https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/transaction/annotation/Transactional.html\">Spring Framework 6 API: Annotation Interface Transactional</a> </li>\n  <li> <a href=\"https://docs.spring.io/spring-framework/reference/data-access/transaction/declarative/tx-propagation.html\">Spring 6 문서: 트랜잭션 전파</a> </li>\n</ul>\n<h3>기사 및 블로그 포스트</h3>\n<ul>\n  <li> <a href=\"https://www.baeldung.com/spring-transactional-propagation-isolation\">Baeldung: Spring @Transactional의 트랜잭션 전파 및 격리</a> </li>\n  <li> <a href=\"https://dzone.com/articles/spring-transaction-propagation\">DZone: Spring 트랜잭션 전파 핵심 정리</a> </li>\n</ul>"
  },
  {
    "id": "S3984",
    "key": "java:S3984",
    "name": "Exceptions should not be created without being thrown",
    "type": "bug",
    "severity": "major",
    "tags": [
      "error-handling"
    ],
    "why": "<p>Creating a new <code>Throwable</code> without actually throwing it is useless and is probably due to a mistake.</p>\n<h3>Noncompliant code example</h3>\n<pre>\nif (x &lt; 0)\n  new IllegalArgumentException(\"x must be nonnegative\");\n</pre>\n<h3>Compliant solution</h3>\n<pre>\nif (x &lt; 0)\n  throw new IllegalArgumentException(\"x must be nonnegative\");\n</pre>",
    "howToFix": "",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "Exception은 생성만 하고 던지지 않으면 안 됩니다",
    "why_ko": "<p>새 <code>Throwable</code>을 생성하고 실제로 던지지 않는 것은 쓸모없으며 아마도 실수로 인한 것입니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\nif (x &lt; 0)\n  new IllegalArgumentException(\"x must be nonnegative\");\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre>\nif (x &lt; 0)\n  throw new IllegalArgumentException(\"x must be nonnegative\");\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": ""
  },
  {
    "id": "S2696",
    "key": "java:S2696",
    "name": "Instance methods should not write to \"static\" fields",
    "type": "code-smell",
    "severity": "critical",
    "tags": [
      "multi-threading"
    ],
    "why": "<p>Correctly updating a <code>static</code> field from a non-static method is tricky to get right and could easily lead to bugs if there are multiple\nclass instances and/or multiple threads in play. Ideally, <code>static</code> fields are only updated from <code>synchronized static</code>\nmethods.</p>\n<p>This rule raises an issue each time a <code>static</code> field is updated from a non-static method.</p>\n<h3>Noncompliant code example</h3>\n<pre>\npublic class MyClass {\n\n  private static int count = 0;\n\n  public void doSomething() {\n    //...\n    count++;  // Noncompliant\n  }\n}\n</pre>",
    "howToFix": "",
    "moreInfo": "<h3>Standards</h3>\n<ul>\n  <li> STIG Viewer - <a href=\"https://stigviewer.com/stigs/application_security_and_development/2024-12-06/finding/V-222567\">Application Security and\n  Development: V-222567</a> - The application must not be vulnerable to race conditions. </li>\n</ul>",
    "status": "READY",
    "name_ko": "인스턴스 메서드에서 \"static\" 필드에 쓰면 안 됩니다",
    "why_ko": "<p>비정적 메서드에서 <code>static</code> 필드를 올바르게 업데이트하는 것은 까다로우며, 여러 클래스 인스턴스 및/또는 여러 스레드가 작동 중인 경우 쉽게 버그로 이어질 수 있습니다. 이상적으로 <code>static</code> 필드는 <code>synchronized static</code> 메서드에서만 업데이트되어야 합니다.</p>\n<p>이 규칙은 비정적 메서드에서 <code>static</code> 필드가 업데이트될 때마다 문제를 제기합니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\npublic class MyClass {\n\n  private static int count = 0;\n\n  public void doSomething() {\n    //...\n    count++;  // 규칙 위반\n  }\n}\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": "<h3>표준</h3>\n<ul>\n  <li> STIG Viewer - <a href=\"https://stigviewer.com/stigs/application_security_and_development/2024-12-06/finding/V-222567\">Application Security and\n  Development: V-222567</a> - 애플리케이션은 경쟁 조건에 취약해서는 안 됩니다. </li>\n</ul>"
  },
  {
    "id": "S1110",
    "key": "java:S1110",
    "name": "Redundant pairs of parentheses should be removed",
    "type": "code-smell",
    "severity": "major",
    "tags": [
      "confusing"
    ],
    "why": "<p>Parentheses can disambiguate the order of operations in complex expressions and make the code easier to understand.</p>\n<pre>\na = (b * c) + (d * e); // Compliant: the intent is clear.\n</pre>\n<p>Redundant parentheses are parenthesis that do not change the behavior of the code, and do not clarify the intent. They can mislead and complexify\nthe code. They should be removed.</p>\n<h3>Noncompliant code example</h3>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\nint x = ((y / 2 + 1)); // Noncompliant\n\nif (a &amp;&amp; ((x + y &gt; 0))) { // Noncompliant\n  return ((x + 1)); // Noncompliant\n}\n</pre>\n<h3>Compliant solution</h3>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\nint x = (y / 2 + 1);\n\nif (a &amp;&amp; (x + y &gt; 0)) {\n  return (x + 1);\n}\n</pre>",
    "howToFix": "",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "중복된 괄호 쌍은 제거해야 합니다",
    "why_ko": "<p>괄호는 복잡한 표현식에서 연산 순서를 명확하게 하고 코드를 이해하기 쉽게 만들 수 있습니다.</p>\n<pre>\na = (b * c) + (d * e); // 규칙 준수: 의도가 명확합니다.\n</pre>\n<p>중복 괄호는 코드의 동작을 변경하지 않고 의도를 명확하게 하지도 않는 괄호입니다. 이는 코드를 오해하게 하고 복잡하게 만들 수 있습니다. 제거해야 합니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\nint x = ((y / 2 + 1)); // 규칙 위반\n\nif (a &amp;&amp; ((x + y &gt; 0))) { // 규칙 위반\n  return ((x + 1)); // 규칙 위반\n}\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\nint x = (y / 2 + 1);\n\nif (a &amp;&amp; (x + y &gt; 0)) {\n  return (x + 1);\n}\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": ""
  },
  {
    "id": "S5850",
    "key": "java:S5850",
    "name": "Alternatives in regular expressions should be grouped when used with anchors",
    "type": "bug",
    "severity": "major",
    "tags": [
      "regex"
    ],
    "why": "<p>In regular expressions, anchors (<code>^</code>, <code>$</code>, <code>\\A</code>, <code>\\Z</code> and <code>\\z</code>) have higher precedence than\nthe <code>|</code> operator. So in a regular expression like <code>^alt1|alt2|alt3$</code>, <code>alt1</code> would be anchored to the beginning,\n<code>alt3</code> to the end and <code>alt2</code> wouldn't be anchored at all. Usually the intended behavior is that all alternatives are anchored at\nboth ends. To achieve this, a non-capturing group should be used around the alternatives.</p>\n<p>In cases where it is intended that the anchors only apply to one alternative each, adding (non-capturing) groups around the anchors and the parts\nthat they apply to will make it explicit which parts are anchored and avoid readers misunderstanding the precedence or changing it because they\nmistakenly assume the precedence was not intended.</p>\n<h3>Noncompliant code example</h3>\n<pre>\n^a|b|c$\n</pre>\n<h3>Compliant solution</h3>\n<pre>\n^(?:a|b|c)$\n</pre>\n<p>or</p>\n<pre>\n^a$|^b$|^c$\n</pre>\n<p>or, if you do want the anchors to only apply to <code>a</code> and <code>c</code> respectively:</p>\n<pre>\n(?:^a)|b|(?:c$)\n</pre>",
    "howToFix": "",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "정규 표현식의 대안은 앵커와 함께 사용할 때 그룹화해야 합니다",
    "why_ko": "<p>정규 표현식에서 앵커(<code>^</code>, <code>$</code>, <code>\\A</code>, <code>\\Z</code> 및 <code>\\z</code>)는 <code>|</code> 연산자보다 우선순위가 높습니다. 따라서 <code>^alt1|alt2|alt3$</code>와 같은 정규 표현식에서 <code>alt1</code>은 시작에 앵커되고 <code>alt3</code>은 끝에 앵커되며 <code>alt2</code>는 전혀 앵커되지 않습니다. 일반적으로 의도된 동작은 모든 대안이 양쪽 끝에 앵커되는 것입니다. 이를 달성하려면 대안 주위에 비캡처 그룹을 사용해야 합니다.</p>\n<p>앵커가 각 대안에만 적용되도록 의도된 경우 앵커와 적용되는 부분 주위에 (비캡처) 그룹을 추가하면 어떤 부분이 앵커되는지 명확해지고 독자가 우선순위를 오해하거나 우선순위가 의도되지 않았다고 잘못 가정하여 변경하는 것을 방지합니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\n^a|b|c$\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre>\n^(?:a|b|c)$\n</pre>\n<p>또는</p>\n<pre>\n^a$|^b$|^c$\n</pre>\n<p>또는 앵커가 각각 <code>a</code>와 <code>c</code>에만 적용되도록 하려면:</p>\n<pre>\n(?:^a)|b|(?:c$)\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": ""
  },
  {
    "id": "S2442",
    "key": "java:S2442",
    "name": "Synchronizing on a \"Lock\" object should be avoided",
    "type": "code-smell",
    "severity": "major",
    "tags": [
      "multi-threading",
      "cert",
      "clumsy"
    ],
    "why": "<p><code>java.util.concurrent.locks.Lock</code> offers far more powerful and flexible locking operations than are available with\n<code>synchronized</code> blocks. So synchronizing on a <code>Lock</code> instance throws away the power of the object, as it overrides its better\nlocking mechanisms. Instead, such objects should be locked and unlocked using one of their <code>lock</code> and <code>unlock</code> method\nvariants.</p>\n<h3>Noncompliant code example</h3>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\nLock lock = new MyLockImpl();\nsynchronized(lock) {  // Noncompliant\n  // ...\n}\n</pre>\n<h3>Compliant solution</h3>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\nLock lock = new MyLockImpl();\nif (lock.tryLock()) {\n  try {\n    // ...\n  } finally {\n    lock.unlock();\n  }\n}\n</pre>",
    "howToFix": "",
    "moreInfo": "<ul>\n  <li> <a href=\"https://wiki.sei.cmu.edu/confluence/x/qjdGBQ\">CERT, LCK03-J.</a> - Do not synchronize on the intrinsic locks of high-level concurrency\n  objects </li>\n</ul>",
    "status": "READY",
    "name_ko": "\"Lock\" 객체에 synchronized 사용은 피해야 합니다",
    "why_ko": "<p><code>java.util.concurrent.locks.Lock</code>은 <code>synchronized</code> 블록보다 훨씬 더 강력하고 유연한 잠금 작업을 제공합니다. 따라서 <code>Lock</code> 인스턴스에 대해 synchronized를 사용하면 더 나은 잠금 메커니즘을 재정의하여 객체의 강력함을 버리게 됩니다. 대신, 이러한 객체는 <code>lock</code> 및 <code>unlock</code> 메서드 변형 중 하나를 사용하여 잠금 및 잠금 해제해야 합니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\nLock lock = new MyLockImpl();\nsynchronized(lock) {  // 규칙 위반\n  // ...\n}\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\nLock lock = new MyLockImpl();\nif (lock.tryLock()) {\n  try {\n    // ...\n  } finally {\n    lock.unlock();\n  }\n}\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": "<ul>\n  <li> <a href=\"https://wiki.sei.cmu.edu/confluence/x/qjdGBQ\">CERT, LCK03-J.</a> - 고수준 동시성 객체의 내장 잠금에 대해 동기화하지 마십시오 </li>\n</ul>"
  },
  {
    "id": "S5738",
    "key": "java:S5738",
    "name": "\"@Deprecated\" code marked for removal should never be used",
    "type": "code-smell",
    "severity": "major",
    "tags": [
      "cwe",
      "obsolete",
      "cert"
    ],
    "why": "<p>With the introduction of Java 9, the standard annotation class <code>java.lang.Deprecated</code> has been updated with new parameters. Notably, a\nboolean parameter <code>forRemoval</code> has been added to clearly signify whether the deprecated code is intended to be removed in the future. This\nis indicated with <code>forRemoval=true</code>. The javadoc of the annotation explicitly mentions the following:</p>\n<blockquote>\n  <p>This annotation type has a boolean-valued element <code>forRemoval</code>. A value of <code>true</code> indicates intent to remove the annotated\n  program element in a future version. A value of <code>false</code> indicates that use of the annotated program element is discouraged, but at the\n  time the program element was annotated, there was no specific intent to remove it.</p>\n</blockquote>\n<p>While it is generally recommended for developers to steer clear of using deprecated classes, interfaces, and their deprecated members, those\nalready marked for removal will surely block you from upgrading your dependency. Usage of deprecated code should be avoided or eliminated as soon as\npossible to prevent accumulation and allow a smooth upgrade of dependencies.</p>\n<p>The deprecated code is usually no longer maintained, can contain some bugs or vulnerabilities, and usually indicates that there is a better way to\ndo the same thing. Removing it can even lead to significant improvement of your software.</p>",
    "howToFix": "<p>Usage of deprecated classes, interfaces, and their methods explicitly marked for removal is discouraged. A developer should either migrate to\nalternative methods or refactor the code to avoid the deprecated ones.</p>\n\n<h4>Noncompliant code example</h4>\n<pre>\n/**\n * @deprecated As of release 1.3, replaced by {@link #Fee}. Will be dropped with release 1.4.\n */\n@Deprecated(forRemoval=true)\npublic class Foo { ... }\n\npublic class Bar {\n  /**\n   * @deprecated  As of release 1.7, replaced by {@link #doTheThingBetter()}\n   */\n  @Deprecated(forRemoval=true)\n  public void doTheThing() { ... }\n\n  public void doTheThingBetter() { ... }\n\n  /**\n   * @deprecated As of release 1.14 due to poor performances.\n   */\n  @Deprecated(forRemoval=false)\n  public void doTheOtherThing() { ... }\n}\n\npublic class Qix extends Bar {\n  @Override\n  public void doTheThing() { ... } // Noncompliant; don't override a deprecated method marked for removal\n}\n\npublic class Bar extends Foo {  // Noncompliant; Foo is deprecated and will be removed\n\n  public void myMethod() {\n    Bar bar = new Bar();  // okay; the class isn't deprecated\n    bar.doTheThing();  // Noncompliant; doTheThing method is deprecated and will be removed\n\n    bar.doTheOtherThing(); // Okay; deprecated, but not marked for removal\n  }\n}\n</pre>",
    "moreInfo": "<ul>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/477\">CWE-477 - Use of Obsolete Functions</a> </li>\n  <li> <a href=\"https://wiki.sei.cmu.edu/confluence/x/6TdGBQ\">CERT, MET02-J.</a> - Do not use deprecated or obsolete classes or methods </li>\n  <li> RSPEC-1874 for standard deprecation use </li>\n</ul>",
    "status": "READY",
    "name_ko": "제거 예정으로 표시된 \"@Deprecated\" 코드는 절대 사용하면 안 됩니다",
    "why_ko": "<p>Java 9의 도입으로 표준 어노테이션 클래스 <code>java.lang.Deprecated</code>가 새로운 매개변수로 업데이트되었습니다. 특히 불리언 매개변수 <code>forRemoval</code>이 추가되어 더 이상 사용되지 않는 코드가 향후 제거될 예정인지 명확하게 나타냅니다. 이는 <code>forRemoval=true</code>로 표시됩니다. 어노테이션의 javadoc은 다음을 명시적으로 언급합니다:</p>\n<blockquote>\n  <p>이 어노테이션 유형에는 불리언 값 요소 <code>forRemoval</code>이 있습니다. <code>true</code> 값은 향후 버전에서 어노테이션된 프로그램 요소를 제거할 의도를 나타냅니다. <code>false</code> 값은 어노테이션된 프로그램 요소의 사용이 권장되지 않지만 프로그램 요소가 어노테이션될 당시에는 제거할 특별한 의도가 없었음을 나타냅니다.</p>\n</blockquote>\n<p>개발자가 더 이상 사용되지 않는 클래스, 인터페이스 및 해당 멤버의 사용을 피하는 것이 일반적으로 권장되지만, 이미 제거 예정으로 표시된 것들은 확실히 종속성 업그레이드를 막을 것입니다. 축적을 방지하고 종속성의 원활한 업그레이드를 허용하기 위해 더 이상 사용되지 않는 코드의 사용을 가능한 빨리 피하거나 제거해야 합니다.</p>\n<p>더 이상 사용되지 않는 코드는 일반적으로 더 이상 유지되지 않고 일부 버그나 취약점을 포함할 수 있으며 일반적으로 같은 작업을 수행하는 더 나은 방법이 있음을 나타냅니다. 이를 제거하면 소프트웨어가 크게 개선될 수도 있습니다.</p>",
    "howToFix_ko": "<p>제거 예정으로 명시적으로 표시된 더 이상 사용되지 않는 클래스, 인터페이스 및 해당 메서드의 사용은 권장되지 않습니다. 개발자는 대체 메서드로 마이그레이션하거나 더 이상 사용되지 않는 것을 피하도록 코드를 리팩토링해야 합니다.</p>\n\n<h4>규칙을 준수하지 않는 코드 예시</h4>\n<pre>\n/**\n * @deprecated 릴리스 1.3부터 {@link #Fee}로 대체됨. 릴리스 1.4에서 삭제 예정.\n */\n@Deprecated(forRemoval=true)\npublic class Foo { ... }\n\npublic class Bar {\n  /**\n   * @deprecated  릴리스 1.7부터 {@link #doTheThingBetter()}로 대체됨\n   */\n  @Deprecated(forRemoval=true)\n  public void doTheThing() { ... }\n\n  public void doTheThingBetter() { ... }\n\n  /**\n   * @deprecated 릴리스 1.14부터 성능 저하로 인해 더 이상 사용되지 않음.\n   */\n  @Deprecated(forRemoval=false)\n  public void doTheOtherThing() { ... }\n}\n\npublic class Qix extends Bar {\n  @Override\n  public void doTheThing() { ... } // 규칙 위반; 제거 예정으로 표시된 더 이상 사용되지 않는 메서드를 오버라이드하지 마세요\n}\n\npublic class Bar extends Foo {  // 규칙 위반; Foo는 더 이상 사용되지 않으며 제거될 예정입니다\n\n  public void myMethod() {\n    Bar bar = new Bar();  // 괜찮음; 클래스가 더 이상 사용되지 않는 것이 아님\n    bar.doTheThing();  // 규칙 위반; doTheThing 메서드는 더 이상 사용되지 않으며 제거될 예정입니다\n\n    bar.doTheOtherThing(); // 괜찮음; 더 이상 사용되지 않지만 제거 예정으로 표시되지 않음\n  }\n}\n</pre>",
    "moreInfo_ko": "<ul>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/477\">CWE-477 - 폐기된 함수 사용</a> </li>\n  <li> <a href=\"https://wiki.sei.cmu.edu/confluence/x/6TdGBQ\">CERT, MET02-J.</a> - 더 이상 사용되지 않거나 폐기된 클래스 또는 메서드를 사용하지 마세요 </li>\n  <li> 표준 deprecation 사용에 대한 RSPEC-1874 </li>\n</ul>"
  },
  {
    "id": "S6817",
    "key": "java:S6817",
    "name": "Use of the \"@Async\" annotation on methods declared within a \"@Configuration\" class in Spring Boot",
    "type": "bug",
    "severity": "critical",
    "tags": [
      "spring"
    ],
    "why": "<p><code>@Configuration</code> is a class-level annotation indicating that an object is a source of bean definitions. <code>@Configuration</code>\nclasses declare beans through <code>@Bean</code>-annotated methods. Calls to <code>@Bean</code> methods on <code>@Configuration</code> classes can\nalso be used to define inter-bean dependencies. The <code>@Bean</code> annotation indicates that a method instantiates, configures, and initializes a\nnew object to be managed by the Spring IoC container.</p>\n<p>Annotating a method of a bean with <code>@Async</code> will make it execute in a separate thread. In other words, the caller will not wait for the\ncompletion of the called method.</p>\n<p>The <code>@Async</code> annotation is not supported on methods declared within a <code>@Configuration</code> class. This is because\n<code>@Async</code> methods are typically used for asynchronous processing, and they require certain infrastructure to be set up, which may not be\navailable or appropriate in a <code>@Configuration</code> class.</p>",
    "howToFix": "<p>Don't use <code>@Async</code> annotations on methods of <code>@Configuration</code> classes.</p>\n\n<h4>Noncompliant code example</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\n@EnableAsync\n@Configuration\npublic class MyConfiguration {\n\n  @Async // Noncompliant - This is not allowed\n  public void asyncMethod() {\n    // ...\n  }\n}\n</pre>\n<h4>Compliant solution</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\n@EnableAsync\n@Configuration\npublic class MyConfiguration {\n\n  public void method() {\n    // ...\n  }\n}\n</pre>",
    "moreInfo": "<h3>Documentation</h3>\n<ul>\n  <li> <a href=\"https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/scheduling/annotation/Async.html\">Spring\n  Framework - @Async</a> </li>\n  <li> <a href=\"https://docs.spring.io/spring-framework/reference/core/beans/java/configuration-annotation.html\">Spring Framework - Using the\n  @Configuration annotation</a> </li>\n  <li> <a href=\"https://docs.spring.io/spring-framework/reference/core/beans/java/basic-concepts.html\">Spring Framework - Basic Concepts: @Bean and\n  @Configuration</a> </li>\n</ul>\n<h3>Articles &amp; blog posts</h3>\n<ul>\n  <li> <a href=\"https://www.baeldung.com/spring-async\">Baeldung - How To Do @Async in Spring</a> </li>\n</ul>",
    "status": "READY",
    "name_ko": "Spring Boot에서 \"@Configuration\" 클래스 내에 선언된 메서드에 \"@Async\" 어노테이션 사용",
    "why_ko": "<p><code>@Configuration</code>은 객체가 빈 정의의 소스임을 나타내는 클래스 수준 어노테이션입니다. <code>@Configuration</code> 클래스는 <code>@Bean</code> 어노테이션이 달린 메서드를 통해 빈을 선언합니다. <code>@Configuration</code> 클래스의 <code>@Bean</code> 메서드 호출은 빈 간 의존성을 정의하는 데에도 사용할 수 있습니다. <code>@Bean</code> 어노테이션은 메서드가 Spring IoC 컨테이너에 의해 관리되는 새 객체를 인스턴스화, 구성 및 초기화함을 나타냅니다.</p>\n<p>빈의 메서드에 <code>@Async</code> 어노테이션을 달면 별도의 스레드에서 실행됩니다. 즉, 호출자는 호출된 메서드의 완료를 기다리지 않습니다.</p>\n<p><code>@Async</code> 어노테이션은 <code>@Configuration</code> 클래스 내에 선언된 메서드에서 지원되지 않습니다. 이는 <code>@Async</code> 메서드가 일반적으로 비동기 처리에 사용되며 특정 인프라가 설정되어야 하지만 <code>@Configuration</code> 클래스에서는 사용할 수 없거나 적절하지 않을 수 있기 때문입니다.</p>",
    "howToFix_ko": "<p><code>@Configuration</code> 클래스의 메서드에 <code>@Async</code> 어노테이션을 사용하지 마세요.</p>\n\n<h4>규칙을 준수하지 않는 코드 예시</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\n@EnableAsync\n@Configuration\npublic class MyConfiguration {\n\n  @Async // 규칙 위반 - 허용되지 않습니다\n  public void asyncMethod() {\n    // ...\n  }\n}\n</pre>\n<h4>규칙을 준수하는 해결책</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\n@EnableAsync\n@Configuration\npublic class MyConfiguration {\n\n  public void method() {\n    // ...\n  }\n}\n</pre>",
    "moreInfo_ko": "<h3>문서</h3>\n<ul>\n  <li> <a href=\"https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/scheduling/annotation/Async.html\">Spring Framework - @Async</a> </li>\n  <li> <a href=\"https://docs.spring.io/spring-framework/reference/core/beans/java/configuration-annotation.html\">Spring Framework - @Configuration 어노테이션 사용하기</a> </li>\n  <li> <a href=\"https://docs.spring.io/spring-framework/reference/core/beans/java/basic-concepts.html\">Spring Framework - 기본 개념: @Bean과 @Configuration</a> </li>\n</ul>\n<h3>기사 및 블로그 게시물</h3>\n<ul>\n  <li> <a href=\"https://www.baeldung.com/spring-async\">Baeldung - Spring에서 @Async 사용하기</a> </li>\n</ul>"
  },
  {
    "id": "S2157",
    "key": "java:S2157",
    "name": "\"Cloneables\" should implement \"clone\"",
    "type": "code-smell",
    "severity": "critical",
    "tags": [
      "convention",
      "api-design"
    ],
    "why": "<p><code>Cloneable</code> is a <em>marker interface</em> that defines the contract of the <code>Object.clone</code> method, which is to create a\nconsistent copy of the instance. The <code>clone</code> method is not defined by the interface though, but by class <code>Objects</code>.</p>\n<p>The general problem with marker interfaces is that their definitions cannot be enforced by the compiler because they have no own API. When a class\nimplements <code>Cloneable</code> but does not override <code>Object.clone</code>, it is highly likely that it violates the contract for\n<code>Cloneable</code>.</p>",
    "howToFix": "<p>Consider the following example:</p>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\nclass Foo implements Cloneable { // Noncompliant, override `clone` method\n  public int value;\n}\n</pre>\n<p>Override the <code>clone</code> method in class <code>Foo</code>. By convention, it must call <code>super.clone()</code>. At this point, we know\nthat:</p>\n<ul>\n  <li> By behavioral contract, <code>Object.clone</code> will not throw a <code>CloneNotSupportedException</code>, because <code>Foo</code> implements\n  <code>Cloneable</code>. </li>\n  <li> The returned object is an instance of class <code>Foo</code> </li>\n</ul>\n<p>We can narrow down the return type of <code>clone</code> to <code>Foo</code> and handle the <code>CloneNotSupportedException</code> inside the\nfunction instead of throwing it:</p>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\nclass Foo implements Cloneable { // Compliant\n\n  public int value;\n\n  @Override\n  public Foo clone() {\n    try {\n      return (Foo) super.clone();\n    } catch (CloneNotSupportedException e) {\n      throw new AssertionError();\n    }\n  }\n}\n</pre>\n<p>Be aware that <code>super.clone()</code> returns a one-by-one copy of the fields of the original instance. This means that in our example, the\n<code>Foo.value</code> field is not required to be explicitly copied in the overridden function.</p>\n<p>If you require another copy behavior for some or all of the fields, for example, deep copy or certain invariants that need to be true for a field,\nthese fields must be patched after <code>super.clone()</code>:</p>\n<pre>\nclass Entity implements Cloneable {\n\n  public int id; // unique per instance\n  public List&lt;Entity&gt; children; // deep copy wanted\n\n  @Override\n  public Entity clone() {\n    try {\n      Entity copy = (Entity) super.clone();\n      copy.id = System.identityHashCode(this);\n      copy.children = children.stream().map(Entity::clone).toList();\n      return copy;\n    } catch (CloneNotSupportedException e) {\n      throw new AssertionError();\n    }\n  }\n}\n</pre>\n<p>Be aware that the <code>Cloneable</code> / <code>Object.clone</code> approach has several drawbacks. You might, therefore, also consider resorting\nto other solutions, such as a custom <code>copy</code> method or a copy constructor:</p>\n<pre>\nclass Entity implements Cloneable {\n\n  public int id; // unique per instance\n  public List&lt;Entity&gt; children; // deep copy wanted\n\n  Entity(Entity template) {\n    id = System.identityHashCode(this);\n    children = template.children.stream().map(Entity::new).toList();\n  }\n}\n</pre>",
    "moreInfo": "<h3>Documentation</h3>\n<ul>\n  <li> <a href=\"https://docs.oracle.com/javase/8/docs/api/java/lang/Cloneable.html\">Interface Cloneable - Java™ Platform, Standard Edition 8 API\n  Specification</a> </li>\n  <li> <a href=\"https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html#clone--\">Object.clone - Java™ Platform, Standard Edition 8 API\n  Specification</a> </li>\n</ul>",
    "status": "READY",
    "name_ko": "\"Cloneable\" 구현 클래스는 \"clone\"을 구현해야 합니다",
    "why_ko": "<p><code>Cloneable</code>은 인스턴스의 일관된 복사본을 생성하는 <code>Object.clone</code> 메서드의 계약을 정의하는 <em>마커 인터페이스</em>입니다. 하지만 <code>clone</code> 메서드는 인터페이스가 아니라 <code>Objects</code> 클래스에 의해 정의됩니다.</p>\n<p>마커 인터페이스의 일반적인 문제점은 자체 API가 없기 때문에 컴파일러에 의해 정의가 강제될 수 없다는 것입니다. 클래스가 <code>Cloneable</code>을 구현하지만 <code>Object.clone</code>을 재정의하지 않으면 <code>Cloneable</code>의 계약을 위반할 가능성이 높습니다.</p>",
    "howToFix_ko": "<p>다음 예시를 고려하세요:</p>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\nclass Foo implements Cloneable { // 규칙 위반, `clone` 메서드를 재정의하세요\n  public int value;\n}\n</pre>\n<p><code>Foo</code> 클래스에서 <code>clone</code> 메서드를 재정의하세요. 관례상 <code>super.clone()</code>을 호출해야 합니다. 이 시점에서 우리가 알 수 있는 것은:</p>\n<ul>\n  <li> 동작 계약에 따라 <code>Foo</code>가 <code>Cloneable</code>을 구현하므로 <code>Object.clone</code>은 <code>CloneNotSupportedException</code>을 던지지 않습니다. </li>\n  <li> 반환된 객체는 <code>Foo</code> 클래스의 인스턴스입니다 </li>\n</ul>\n<p><code>clone</code>의 반환 타입을 <code>Foo</code>로 좁히고 <code>CloneNotSupportedException</code>을 던지는 대신 함수 내에서 처리할 수 있습니다:</p>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\nclass Foo implements Cloneable { // 규칙 준수\n\n  public int value;\n\n  @Override\n  public Foo clone() {\n    try {\n      return (Foo) super.clone();\n    } catch (CloneNotSupportedException e) {\n      throw new AssertionError();\n    }\n  }\n}\n</pre>\n<p><code>super.clone()</code>은 원본 인스턴스의 필드를 하나씩 복사하여 반환합니다. 이는 우리 예시에서 <code>Foo.value</code> 필드가 재정의된 함수에서 명시적으로 복사될 필요가 없음을 의미합니다.</p>\n<p>일부 또는 모든 필드에 대해 다른 복사 동작이 필요한 경우, 예를 들어 깊은 복사 또는 필드에 대해 참이어야 하는 특정 불변식이 있는 경우 이러한 필드는 <code>super.clone()</code> 이후에 패치되어야 합니다:</p>\n<pre>\nclass Entity implements Cloneable {\n\n  public int id; // 인스턴스당 고유\n  public List&lt;Entity&gt; children; // 깊은 복사 필요\n\n  @Override\n  public Entity clone() {\n    try {\n      Entity copy = (Entity) super.clone();\n      copy.id = System.identityHashCode(this);\n      copy.children = children.stream().map(Entity::clone).toList();\n      return copy;\n    } catch (CloneNotSupportedException e) {\n      throw new AssertionError();\n    }\n  }\n}\n</pre>\n<p><code>Cloneable</code> / <code>Object.clone</code> 접근 방식에는 여러 단점이 있습니다. 따라서 사용자 정의 <code>copy</code> 메서드나 복사 생성자와 같은 다른 솔루션을 사용하는 것도 고려해볼 수 있습니다:</p>\n<pre>\nclass Entity implements Cloneable {\n\n  public int id; // 인스턴스당 고유\n  public List&lt;Entity&gt; children; // 깊은 복사 필요\n\n  Entity(Entity template) {\n    id = System.identityHashCode(this);\n    children = template.children.stream().map(Entity::new).toList();\n  }\n}\n</pre>",
    "moreInfo_ko": "<h3>문서</h3>\n<ul>\n  <li> <a href=\"https://docs.oracle.com/javase/8/docs/api/java/lang/Cloneable.html\">Interface Cloneable - Java™ Platform, Standard Edition 8 API 명세</a> </li>\n  <li> <a href=\"https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html#clone--\">Object.clone - Java™ Platform, Standard Edition 8 API 명세</a> </li>\n</ul>"
  },
  {
    "id": "S5411",
    "key": "java:S5411",
    "name": "Avoid using boxed \"Boolean\" types directly in boolean expressions",
    "type": "code-smell",
    "severity": "minor",
    "tags": [
      "pitfall"
    ],
    "why": "<p>When boxed type <code>java.lang.Boolean</code> is used as an expression to determine the control flow (as described in <a\nhref=\"https://docs.oracle.com/javase/specs/jls/se8/html/jls-4.html#jls-4.2.5\">Java Language Specification §4.2.5 The <code>boolean</code> Type and\nboolean Values</a>) it will throw a <code>NullPointerException</code> if the value is <code>null</code> (as defined in <a\nhref=\"https://docs.oracle.com/javase/specs/jls/se8/html/jls-5.html#jls-5.1.8\">Java Language Specification §5.1.8 Unboxing Conversion</a>).</p>\n<p>It is safer to avoid such conversion altogether and handle the <code>null</code> value explicitly.</p>\n<p>Note, however, that no issues will be raised for Booleans that have already been null-checked or are marked <code>@NonNull/@NotNull</code>.</p>\n<h3>Noncompliant code example</h3>\n<pre>\nBoolean b = getBoolean();\nif (b) {  // Noncompliant, it will throw NPE when b == null\n  foo();\n} else {\n  bar();\n}\n</pre>\n<h3>Compliant solution</h3>\n<pre>\nBoolean b = getBoolean();\nif (Boolean.TRUE.equals(b)) {\n  foo();\n} else {\n  bar();  // will be invoked for both b == false and b == null\n}\n\n\nBoolean b = getBoolean();\nif(b != null){\n  String test = b ? \"test\" : \"\";\n}\n</pre>\n<h3>Exceptions</h3>\n<p>The issue is not raised if the expression is annotated <code>@NonNull</code> / <code>@NotNull</code>. This is useful if a boxed type is an\ninstantiation of a generic type parameter and cannot be avoided.</p>\n<pre>\nList&lt;Boolean&gt; list = new ArrayList&lt;&gt;();\nlist.add(true);\nlist.add(false);\nlist.forEach((@NonNull Boolean value) -&gt; {\n  // Compliant\n  if(value) {\n    System.out.println(\"yes\");\n  }\n});\n\n@NonNull Boolean someMethod() { /* ... */ }\n\n// Compliant\nif(someMethod()) { /* ... */ }\n\n@NonNull Boolean boxedNonNull = Boolean.TRUE;\n\n// Compliant\nif(boxedNonNull) { /* ... */ }\n</pre>",
    "howToFix": "",
    "moreInfo": "<ul>\n  <li> <a href=\"https://docs.oracle.com/javase/specs/jls/se8/html/jls-5.html#jls-5.1.8\">Java Language Specification §5.1.8 Unboxing Conversion</a>\n  </li>\n</ul>",
    "status": "READY",
    "name_ko": "boolean 표현식에서 박싱된 \"Boolean\" 타입을 직접 사용하지 마세요",
    "why_ko": "<p>박싱된 타입 <code>java.lang.Boolean</code>이 제어 흐름을 결정하는 표현식으로 사용될 때(<a href=\"https://docs.oracle.com/javase/specs/jls/se8/html/jls-4.html#jls-4.2.5\">Java Language Specification §4.2.5 <code>boolean</code> 타입과 boolean 값</a>에 설명된 대로) 값이 <code>null</code>이면 <code>NullPointerException</code>을 던집니다(<a href=\"https://docs.oracle.com/javase/specs/jls/se8/html/jls-5.html#jls-5.1.8\">Java Language Specification §5.1.8 언박싱 변환</a>에 정의된 대로).</p>\n<p>이러한 변환을 완전히 피하고 <code>null</code> 값을 명시적으로 처리하는 것이 더 안전합니다.</p>\n<p>그러나 이미 null 검사가 수행되었거나 <code>@NonNull/@NotNull</code>로 표시된 Boolean에는 문제가 제기되지 않습니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\nBoolean b = getBoolean();\nif (b) {  // 규칙 위반, b == null일 때 NPE를 던짐\n  foo();\n} else {\n  bar();\n}\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre>\nBoolean b = getBoolean();\nif (Boolean.TRUE.equals(b)) {\n  foo();\n} else {\n  bar();  // b == false와 b == null 모두에 대해 호출됨\n}\n\n\nBoolean b = getBoolean();\nif(b != null){\n  String test = b ? \"test\" : \"\";\n}\n</pre>\n<h3>예외</h3>\n<p>표현식이 <code>@NonNull</code> / <code>@NotNull</code>로 어노테이션된 경우 문제가 제기되지 않습니다. 이는 박싱된 타입이 제네릭 타입 매개변수의 인스턴스화이고 피할 수 없는 경우에 유용합니다.</p>\n<pre>\nList&lt;Boolean&gt; list = new ArrayList&lt;&gt;();\nlist.add(true);\nlist.add(false);\nlist.forEach((@NonNull Boolean value) -&gt; {\n  // 규칙 준수\n  if(value) {\n    System.out.println(\"yes\");\n  }\n});\n\n@NonNull Boolean someMethod() { /* ... */ }\n\n// 규칙 준수\nif(someMethod()) { /* ... */ }\n\n@NonNull Boolean boxedNonNull = Boolean.TRUE;\n\n// 규칙 준수\nif(boxedNonNull) { /* ... */ }\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": "<ul>\n  <li> <a href=\"https://docs.oracle.com/javase/specs/jls/se8/html/jls-5.html#jls-5.1.8\">Java Language Specification §5.1.8 언박싱 변환</a> </li>\n</ul>"
  },
  {
    "id": "S1452",
    "key": "java:S1452",
    "name": "Generic wildcard types should not be used in return types",
    "type": "code-smell",
    "severity": "critical",
    "tags": [
      "pitfall"
    ],
    "why": "<p>A return type containing wildcards cannot be narrowed down in any context. This indicates that the developer's intention was likely something\nelse.</p>\n<p>The core problem lies in type variance. Expressions at an input position, such as arguments passed to a method, can have a more specific type than\nthe type expected by the method, which is called <em>covariance</em>. Expressions at an output position, such as a variable that receives the return\nresult from a method, can have a more general type than the method's return type, which is called <em>contravariance</em>. This can be traced back to\nthe Liskov substitution principle.</p>\n<p>In Java, type parameters of a generic type are invariant by default due to their potential occurrence in both input and output positions at the\nsame time. A classic example of this is the methods <code>T get()</code> (output position) and <code>add(T element)</code> (input position) in\ninterface <code>java.util.List</code>. We could construct cases with invalid typing in <code>List</code> if <code>T</code> were not invariant.</p>\n<p>Wildcards can be employed to achieve covariance or contravariance in situations where the type parameter appears in one position only:</p>\n<ul>\n  <li> <code>&lt;? extends Foo&gt;</code> for covariance (input positions) </li>\n  <li> <code>&lt;? super Foo&gt;</code> for contravariance (output positions) </li>\n</ul>\n<p>However, covariance is ineffective for the return type of a method since it is not an input position. Making it contravariant also has no effect\nsince it is the receiver of the return value which must be contravariant (use-site variance in Java). Consequently, a return type containing wildcards\nis generally a mistake.</p>",
    "howToFix": "<p>The solution to this problem depends on the original intention of the developer. Given the examples:</p>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\nList&lt;? extends Animal&gt; getAnimals() { ... } // Noncompliant, wildcard with no use\nList&lt;? super Plant&gt; getLifeforms() { ... }  // Noncompliant, wildcard with no use\n</pre>\n<p>You can remove the wildcards to make the types invariant:</p>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\nList&lt;Animal&gt; getAnimals() { ... }           // Compliant, using invariant type instead\nList&lt;Plant&gt; getLifeforms() { ... }          // Compliant, using invariant type instead\n</pre>\n<p>Or replace them with a super- or subtypes (still invariant):</p>\n<pre>\nList&lt;Dog&gt; getAnimals() { ... }              // Compliant, using subtype instead\nList&lt;Lifeform&gt; getLifeforms() { ... }       // Compliant, using supertype instead\n</pre>",
    "moreInfo": "<h3>Documentation</h3>\n<ul>\n  <li> <a href=\"https://docs.oracle.com/javase/tutorial/extra/generics/wildcards.html\">The Java™ Tutorials - Wildcards</a> </li>\n</ul>\n<h3>Articles &amp; blog posts</h3>\n<ul>\n  <li> <a href=\"https://medium.com/javarevisited/variance-in-java-and-scala-63af925d21dc\">Sinisa Louc - A Complete Guide to Variance in Java and\n  Scala</a> </li>\n  <li> <a href=\"https://web.archive.org/web/20240206045705/https://kotlinexpertise.com/kotlin-generics-and-variance-vs-java/\">Kotlin Expertise Blog -\n  Kotlin Generics and Variance (Compared to Java)</a> </li>\n  <li> <a href=\"https://en.wikipedia.org/wiki/Covariance_and_contravariance_(computer_science)\">Wikipedia - Covariance and contravariance (computer\n  science)</a> </li>\n  <li> <a href=\"https://schneide.blog/2015/05/11/declaration-site-and-use-site-variance-explained/\">Schneide Blog - Declaration-site and use-site\n  variance explained</a> </li>\n  <li> <a href=\"https://en.wikipedia.org/wiki/Liskov_substitution_principle\">Wikipedia - Liskov substitution principle</a> </li>\n</ul>",
    "status": "READY",
    "name_ko": "반환 타입에 제네릭 와일드카드 타입을 사용하면 안 됩니다",
    "why_ko": "<p>와일드카드를 포함하는 반환 타입은 어떤 컨텍스트에서도 좁힐 수 없습니다. 이는 개발자의 의도가 다른 것이었을 가능성이 높음을 나타냅니다.</p>\n<p>핵심 문제는 타입 변성에 있습니다. 메서드에 전달되는 인자와 같은 입력 위치의 표현식은 메서드가 예상하는 타입보다 더 구체적인 타입을 가질 수 있으며, 이를 <em>공변성</em>이라고 합니다. 메서드의 반환 결과를 받는 변수와 같은 출력 위치의 표현식은 메서드의 반환 타입보다 더 일반적인 타입을 가질 수 있으며, 이를 <em>반공변성</em>이라고 합니다. 이는 리스코프 치환 원칙으로 추적할 수 있습니다.</p>\n<p>Java에서 제네릭 타입의 타입 파라미터는 입력과 출력 위치 모두에 동시에 나타날 수 있기 때문에 기본적으로 불변입니다. 이에 대한 전형적인 예는 <code>java.util.List</code> 인터페이스의 <code>T get()</code>(출력 위치)과 <code>add(T element)</code>(입력 위치) 메서드입니다. <code>T</code>가 불변이 아니라면 <code>List</code>에서 유효하지 않은 타이핑 케이스를 구성할 수 있습니다.</p>\n<p>와일드카드는 타입 파라미터가 한 위치에만 나타나는 상황에서 공변성 또는 반공변성을 달성하는 데 사용할 수 있습니다:</p>\n<ul>\n  <li> <code>&lt;? extends Foo&gt;</code> - 공변성용(입력 위치) </li>\n  <li> <code>&lt;? super Foo&gt;</code> - 반공변성용(출력 위치) </li>\n</ul>\n<p>그러나 공변성은 메서드의 반환 타입에는 효과가 없습니다. 입력 위치가 아니기 때문입니다. 반공변으로 만드는 것도 효과가 없습니다. 반환 값을 받는 쪽이 반공변이어야 하기 때문입니다(Java의 사용 위치 변성). 결과적으로 와일드카드를 포함하는 반환 타입은 일반적으로 실수입니다.</p>",
    "howToFix_ko": "<p>이 문제의 해결책은 개발자의 원래 의도에 따라 다릅니다. 예시가 주어졌을 때:</p>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\nList&lt;? extends Animal&gt; getAnimals() { ... } // 규칙 위반, 사용되지 않는 와일드카드\nList&lt;? super Plant&gt; getLifeforms() { ... }  // 규칙 위반, 사용되지 않는 와일드카드\n</pre>\n<p>와일드카드를 제거하여 타입을 불변으로 만들 수 있습니다:</p>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\nList&lt;Animal&gt; getAnimals() { ... }           // 규칙 준수, 대신 불변 타입 사용\nList&lt;Plant&gt; getLifeforms() { ... }          // 규칙 준수, 대신 불변 타입 사용\n</pre>\n<p>또는 상위 또는 하위 타입으로 대체할 수 있습니다(여전히 불변):</p>\n<pre>\nList&lt;Dog&gt; getAnimals() { ... }              // 규칙 준수, 대신 하위 타입 사용\nList&lt;Lifeform&gt; getLifeforms() { ... }       // 규칙 준수, 대신 상위 타입 사용\n</pre>",
    "moreInfo_ko": "<h3>문서</h3>\n<ul>\n  <li> <a href=\"https://docs.oracle.com/javase/tutorial/extra/generics/wildcards.html\">The Java™ Tutorials - 와일드카드</a> </li>\n</ul>\n<h3>기사 및 블로그 포스트</h3>\n<ul>\n  <li> <a href=\"https://medium.com/javarevisited/variance-in-java-and-scala-63af925d21dc\">Sinisa Louc - Java와 Scala의 변성에 대한 완전 가이드</a> </li>\n  <li> <a href=\"https://web.archive.org/web/20240206045705/https://kotlinexpertise.com/kotlin-generics-and-variance-vs-java/\">Kotlin Expertise Blog - Kotlin 제네릭과 변성 (Java와 비교)</a> </li>\n  <li> <a href=\"https://en.wikipedia.org/wiki/Covariance_and_contravariance_(computer_science)\">Wikipedia - 공변성과 반공변성 (컴퓨터 과학)</a> </li>\n  <li> <a href=\"https://schneide.blog/2015/05/11/declaration-site-and-use-site-variance-explained/\">Schneide Blog - 선언 위치와 사용 위치 변성 설명</a> </li>\n  <li> <a href=\"https://en.wikipedia.org/wiki/Liskov_substitution_principle\">Wikipedia - 리스코프 치환 원칙</a> </li>\n</ul>"
  },
  {
    "id": "S6397",
    "key": "java:S6397",
    "name": "Character classes in regular expressions should not contain only one character",
    "type": "code-smell",
    "severity": "major",
    "tags": [
      "regex"
    ],
    "why": "<p>Character classes in regular expressions are a convenient way to match one of several possible characters by listing the allowed characters or\nranges of characters. If a character class contains only one character, the effect is the same as just writing the character without a character\nclass.</p>\n<p>Thus, having only one character in a character class is usually a simple oversight that remained after removing other characters of the class.</p>\n<h3>Noncompliant code example</h3>\n<pre>\n\"a[b]c\"\n\"[\\\\^]\"\n</pre>\n<h3>Compliant solution</h3>\n<pre>\n\"abc\"\n\"\\\\^\"\n\"a[*]c\" // Compliant, see Exceptions\n</pre>\n<h3>Exceptions</h3>\n<p>This rule does not raise when the character inside the class is a metacharacter. This notation is sometimes used to avoid escaping (e.g.,\n<code>[.]{3}</code> to match three dots).</p>",
    "howToFix": "",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "정규 표현식의 문자 클래스는 단일 문자만 포함하면 안 됩니다",
    "why_ko": "<p>정규 표현식의 문자 클래스는 허용된 문자나 문자 범위를 나열하여 여러 가능한 문자 중 하나를 매칭하는 편리한 방법입니다. 문자 클래스에 단일 문자만 포함된 경우 효과는 문자 클래스 없이 문자만 작성하는 것과 동일합니다.</p>\n<p>따라서 문자 클래스에 하나의 문자만 있는 것은 일반적으로 클래스의 다른 문자를 제거한 후 남은 단순한 실수입니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\n\"a[b]c\"\n\"[\\\\^]\"\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre>\n\"abc\"\n\"\\\\^\"\n\"a[*]c\" // 규칙 준수, 예외 참조\n</pre>\n<h3>예외</h3>\n<p>이 규칙은 클래스 내부의 문자가 메타문자인 경우 문제를 발생시키지 않습니다. 이 표기법은 이스케이프를 피하기 위해 때때로 사용됩니다(예: 세 개의 점을 매칭하기 위한 <code>[.]{3}</code>).</p>",
    "howToFix_ko": "",
    "moreInfo_ko": ""
  },
  {
    "id": "S1147",
    "key": "java:S1147",
    "name": "Exit methods should not be called",
    "type": "code-smell",
    "severity": "blocker",
    "tags": [
      "cwe",
      "cert",
      "suspicious"
    ],
    "why": "<p>Calling <code>System.exit(int status)</code> or <code>Rutime.getRuntime().exit(int status)</code> calls the shutdown hooks and shuts downs the\nentire Java virtual machine. Calling <code>Runtime.getRuntime().halt(int)</code> does an immediate shutdown, without calling the shutdown hooks, and\nskipping finalization.</p>\n<p>Each of these methods should be used with extreme care, and only when the intent is to stop the whole Java process. For instance, none of them\nshould be called from applications running in a J2EE container.</p>\n<h3>Noncompliant code example</h3>\n<pre>\nSystem.exit(0);\nRuntime.getRuntime().exit(0);\nRuntime.getRuntime().halt(0);\n</pre>\n<h3>Exceptions</h3>\n<p>These methods are ignored inside <code>main</code>.</p>",
    "howToFix": "",
    "moreInfo": "<ul>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/382\">CWE-382 - Use of System.exit()</a> </li>\n  <li> <a href=\"https://wiki.sei.cmu.edu/confluence/x/7zZGBQ\">CERT, ERR09-J.</a> - Do not allow untrusted code to terminate the JVM </li>\n</ul>",
    "status": "READY",
    "name_ko": "Exit 메서드는 호출하면 안 됩니다",
    "why_ko": "<p><code>System.exit(int status)</code> 또는 <code>Runtime.getRuntime().exit(int status)</code>를 호출하면 종료 훅이 호출되고 전체 Java 가상 머신이 종료됩니다. <code>Runtime.getRuntime().halt(int)</code>를 호출하면 종료 훅을 호출하지 않고 finalization을 건너뛰며 즉시 종료됩니다.</p>\n<p>이러한 각 메서드는 매우 주의해서 사용해야 하며, 전체 Java 프로세스를 중지하려는 의도가 있을 때만 사용해야 합니다. 예를 들어, J2EE 컨테이너에서 실행되는 애플리케이션에서는 이 메서드들을 호출하면 안 됩니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\nSystem.exit(0);\nRuntime.getRuntime().exit(0);\nRuntime.getRuntime().halt(0);\n</pre>\n<h3>예외 사항</h3>\n<p>이 메서드들은 <code>main</code> 내부에서는 무시됩니다.</p>",
    "howToFix_ko": "",
    "moreInfo_ko": "<ul>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/382\">CWE-382 - System.exit() 사용</a> </li>\n  <li> <a href=\"https://wiki.sei.cmu.edu/confluence/x/7zZGBQ\">CERT, ERR09-J.</a> - 신뢰할 수 없는 코드가 JVM을 종료하도록 허용하지 마세요 </li>\n</ul>"
  },
  {
    "id": "S1844",
    "key": "java:S1844",
    "name": "\"Object.wait\" should not be called on objects that implement \"java.util.concurrent.locks.Condition\"",
    "type": "code-smell",
    "severity": "major",
    "tags": [
      "suspicious"
    ],
    "why": "<p>The <code>java.util.concurrent.locks.Condition</code> interface provides an alternative to the <code>Object</code> monitor methods\n(<code>wait</code>, <code>notify</code> and <code>notifyAll</code>). Hence, the purpose of implementing said interface is to gain access to its more\nnuanced <code>await</code> methods.</p>\n<p>Consequently, calling the method <code>Object.wait</code> on a class implementing the <code>Condition</code> interface is contradictory and should\nbe avoided. Use <code>Condition.await</code> instead.</p>\n\n<h4>Noncompliant code example</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\nvoid doSomething(Condition condition) {\n    condition.wait(); // Noncompliant, Object.wait is called\n\n        ...\n}\n</pre>\n<h4>Compliant solution</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\nvoid doSomething(Condition condition) {\n    condition.await(); // Compliant, Condition.await is called\n\n        ...\n}\n</pre>",
    "howToFix": "",
    "moreInfo": "<h3>Documentation</h3>\n<ul>\n  <li> <a href=\"https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/locks/Condition.html\">Interface Condition - Java™ Platform SE 8, API\n  Specification</a> </li>\n</ul>",
    "status": "READY",
    "name_ko": "\"java.util.concurrent.locks.Condition\"을 구현하는 객체에서 \"Object.wait\"을 호출하면 안 됩니다",
    "why_ko": "<p><code>java.util.concurrent.locks.Condition</code> 인터페이스는 <code>Object</code> 모니터 메서드(<code>wait</code>, <code>notify</code>, <code>notifyAll</code>)에 대한 대안을 제공합니다. 따라서 해당 인터페이스를 구현하는 목적은 더 세밀한 <code>await</code> 메서드에 접근하기 위함입니다.</p>\n<p>결과적으로, <code>Condition</code> 인터페이스를 구현하는 클래스에서 <code>Object.wait</code> 메서드를 호출하는 것은 모순되며 피해야 합니다. 대신 <code>Condition.await</code>를 사용하세요.</p>\n\n<h4>규칙을 준수하지 않는 코드 예시</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\nvoid doSomething(Condition condition) {\n    condition.wait(); // 규칙 위반, Object.wait이 호출됨\n\n        ...\n}\n</pre>\n<h4>규칙을 준수하는 해결책</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\nvoid doSomething(Condition condition) {\n    condition.await(); // 규칙 준수, Condition.await이 호출됨\n\n        ...\n}\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": "<h3>문서</h3>\n<ul>\n  <li> <a href=\"https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/locks/Condition.html\">Interface Condition - Java™ Platform SE 8, API Specification</a> </li>\n</ul>"
  },
  {
    "id": "S1130",
    "key": "java:S1130",
    "name": "Exceptions in \"throws\" clauses should not be superfluous",
    "type": "code-smell",
    "severity": "minor",
    "tags": [
      "error-handling",
      "unused",
      "redundant",
      "clumsy"
    ],
    "why": "<p>Superfluous exceptions within <code>throws</code> clauses have negative effects on the readability and maintainability of the code. An exception in\na <code>throws</code> clause is superfluous if it is:</p>\n<ul>\n  <li> listed multiple times </li>\n  <li> a subclass of another listed exception </li>\n  <li> not actually thrown by any execution path of the method </li>\n</ul>\n<h3>Noncompliant code example</h3>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\nvoid foo() throws MyException, MyException {}  // Noncompliant; should be listed once\nvoid bar() throws Throwable, Exception {}  // Noncompliant; Exception is a subclass of Throwable\nvoid boo() throws IOException { // Noncompliant; IOException cannot be thrown\n  System.out.println(\"Hi!\");\n}\n</pre>\n<h3>Compliant solution</h3>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\nvoid foo() throws MyException {}\nvoid bar() throws Throwable {}\nvoid boo() {\n  System.out.println(\"Hi!\");\n}\n</pre>\n<h3>Exceptions</h3>\n<p>The rule will not raise any issue for exceptions that cannot be thrown from the method body:</p>\n<ul>\n  <li> in interface <code>default</code> methods </li>\n  <li> in overriding and implementating methods </li>\n  <li> in non-private methods that only <code>throw</code>, have empty bodies, or a single return statement. </li>\n  <li> in overridable methods (non-final, or not member of a final class, non-static, non-private), if the exception is documented with a proper\n  JavaDoc </li>\n</ul>\n<pre>\ninterface MyInterface {\n  default void defaultMethod() throws IOException {\n    System.out.println(\"Hi!\");\n  }\n  void doSomething() throws IOException;\n}\n\nclass A implements MyInterface {\n  @Override\n  void doSomething() throws IOException {\n    System.out.println(\"Hi!\");\n  }\n\n  public void emptyBody() throws IOException {}\n\n  protected void singleThrowStatement() throws IOException {\n    throw new UnsupportedOperationException(\"This method should be implemented in subclasses\");\n  }\n\n  Object singleReturnStatement() throws IOException {\n    return null;\n  }\n\n  /**\n   * @throws IOException Overriding classes may throw this exception if they print values into a file\n   */\n  protected void overridable() throws IOException { // no issue, method is overridable and the exception has proper javadoc\n    System.out.println(\"foo\");\n  }\n}\n</pre>\n<p>Also, the rule will not raise issues on <code>RuntimeException</code>, or one of its sub-classes, because documenting runtime exceptions which\ncould be thrown can ultimately help users of the method understand its behavior.</p>\n<pre>\nclass B {\n  int possibleDivisionByZero(int a, int b) throws ArithmeticException {\n      return a / b;\n  }\n}\n</pre>",
    "howToFix": "",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "\"throws\" 절의 예외는 불필요하게 선언되면 안 됩니다",
    "why_ko": "<p><code>throws</code> 절 내의 불필요한 예외는 코드의 가독성과 유지보수성에 부정적인 영향을 미칩니다. <code>throws</code> 절의 예외는 다음과 같은 경우 불필요합니다:</p>\n<ul>\n  <li> 여러 번 나열된 경우 </li>\n  <li> 다른 나열된 예외의 하위 클래스인 경우 </li>\n  <li> 메서드의 어떤 실행 경로에서도 실제로 발생하지 않는 경우 </li>\n</ul>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\nvoid foo() throws MyException, MyException {}  // 규칙 위반; 한 번만 나열해야 함\nvoid bar() throws Throwable, Exception {}  // 규칙 위반; Exception은 Throwable의 하위 클래스임\nvoid boo() throws IOException { // 규칙 위반; IOException이 발생할 수 없음\n  System.out.println(\"Hi!\");\n}\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\nvoid foo() throws MyException {}\nvoid bar() throws Throwable {}\nvoid boo() {\n  System.out.println(\"Hi!\");\n}\n</pre>\n<h3>예외 사항</h3>\n<p>이 규칙은 메서드 본문에서 발생할 수 없는 예외에 대해서는 이슈를 제기하지 않습니다:</p>\n<ul>\n  <li> 인터페이스 <code>default</code> 메서드 내 </li>\n  <li> 오버라이딩 및 구현 메서드 내 </li>\n  <li> <code>throw</code>만 포함하거나, 빈 본문을 가지거나, 단일 return 문만 있는 non-private 메서드 내 </li>\n  <li> 예외가 적절한 JavaDoc으로 문서화된 경우의 오버라이드 가능한 메서드(non-final, final 클래스의 멤버가 아닌, non-static, non-private) 내 </li>\n</ul>\n<pre>\ninterface MyInterface {\n  default void defaultMethod() throws IOException {\n    System.out.println(\"Hi!\");\n  }\n  void doSomething() throws IOException;\n}\n\nclass A implements MyInterface {\n  @Override\n  void doSomething() throws IOException {\n    System.out.println(\"Hi!\");\n  }\n\n  public void emptyBody() throws IOException {}\n\n  protected void singleThrowStatement() throws IOException {\n    throw new UnsupportedOperationException(\"This method should be implemented in subclasses\");\n  }\n\n  Object singleReturnStatement() throws IOException {\n    return null;\n  }\n\n  /**\n   * @throws IOException 오버라이딩하는 클래스가 파일에 값을 출력할 때 이 예외를 발생시킬 수 있음\n   */\n  protected void overridable() throws IOException { // 이슈 없음, 메서드가 오버라이드 가능하고 예외에 적절한 javadoc이 있음\n    System.out.println(\"foo\");\n  }\n}\n</pre>\n<p>또한, <code>RuntimeException</code> 또는 그 하위 클래스에 대해서는 이슈를 제기하지 않습니다. 발생할 수 있는 런타임 예외를 문서화하면 메서드 사용자가 그 동작을 이해하는 데 도움이 될 수 있기 때문입니다.</p>\n<pre>\nclass B {\n  int possibleDivisionByZero(int a, int b) throws ArithmeticException {\n      return a / b;\n  }\n}\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": ""
  },
  {
    "id": "S1075",
    "key": "java:S1075",
    "name": "URIs should not be hardcoded",
    "type": "code-smell",
    "severity": "minor",
    "tags": [
      "android",
      "cert"
    ],
    "why": "<p>Hard-coding a URI makes it difficult to test a program for a variety of reasons:</p>\n<ul>\n  <li> path literals are not always portable across operating systems </li>\n  <li> a given absolute path may not exist in a specific test environment </li>\n  <li> a specified Internet URL may not be available when executing the tests </li>\n  <li> production environment filesystems usually differ from the development environment </li>\n</ul>\n<p>In addition, hard-coded URIs can contain sensitive information, like IP addresses, and they should not be stored in the code.</p>\n<p>For all those reasons, a URI should never be hard coded. Instead, it should be replaced by a customizable parameter.</p>\n<p>Further, even if the elements of a URI are obtained dynamically, portability can still be limited if the path delimiters are hard-coded.</p>\n<p>This rule raises an issue when URIs or path delimiters are hard-coded.</p>\n<h3>Exceptions</h3>\n<p>This rule does not raise an issue when:</p>\n<ul>\n  <li> A constant path is relative and contains at most two parts. </li>\n  <li> A constant path is used in an annotation </li>\n  <li> A path is annotated </li>\n</ul>",
    "howToFix": "<h4>Noncompliant code example</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\npublic class Foo {\n  public static final String FRIENDS_ENDPOINT = \"/user/friends\"; // Compliant path is relative and has only two parts\n\n  public Collection&lt;User&gt; listUsers() {\n    File userList = new File(\"/home/mylogin/Dev/users.txt\"); // Noncompliant\n    Collection&lt;User&gt; users = parse(userList);\n    return users;\n  }\n}\n</pre>\n<h4>Compliant solution</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\npublic class Foo {\n  // Configuration is a class that returns customizable properties: it can be mocked to be injected during tests.\n  private Configuration config;\n  public Foo(Configuration myConfig) {\n    this.config = myConfig;\n  }\n  public Collection&lt;User&gt; listUsers() {\n    // Find here the way to get the correct folder, in this case using the Configuration object\n    String listingFolder = config.getProperty(\"myApplication.listingFolder\");\n    // and use this parameter instead of the hard coded path\n    File userList = new File(listingFolder, \"users.txt\"); // Compliant\n    Collection&lt;User&gt; users = parse(userList);\n    return users;\n  }\n}\n</pre>\n<p>Exceptions examples:</p>\n<pre>\npublic class Foo {\n  public static final String FRIENDS_ENDPOINT = \"/user/friends\"; // Compliant path is relative and has only two parts\n\n  public static final String ACCOUNT = \"/account/group/list.html\"; // Compliant path is used in an annotation\n\n  @Value(\"${base.url}\" + ACCOUNT)\n  private String groupUrl;\n\n  @MyAnnotation()\n  String path = \"/default/url/for/site\"; // Compliant path is annotated\n\n}\n</pre>",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "URI는 하드코딩하면 안 됩니다",
    "why_ko": "<p>URI를 하드코딩하면 여러 가지 이유로 프로그램을 테스트하기 어려워집니다:</p>\n<ul>\n  <li> 경로 리터럴은 운영 체제 간에 항상 이식 가능하지 않습니다 </li>\n  <li> 주어진 절대 경로가 특정 테스트 환경에 존재하지 않을 수 있습니다 </li>\n  <li> 지정된 인터넷 URL이 테스트 실행 시 사용할 수 없을 수 있습니다 </li>\n  <li> 프로덕션 환경 파일 시스템은 일반적으로 개발 환경과 다릅니다 </li>\n</ul>\n<p>또한 하드코딩된 URI에는 IP 주소와 같은 민감한 정보가 포함될 수 있으며, 코드에 저장하면 안 됩니다.</p>\n<p>이러한 모든 이유로 URI는 절대 하드코딩해서는 안 됩니다. 대신 사용자 정의 가능한 매개변수로 대체해야 합니다.</p>\n<p>또한 URI의 요소가 동적으로 얻어지더라도 경로 구분자가 하드코딩되면 이식성이 제한될 수 있습니다.</p>\n<p>이 규칙은 URI 또는 경로 구분자가 하드코딩된 경우 이슈를 발생시킵니다.</p>\n<h3>예외</h3>\n<p>이 규칙은 다음 경우에 이슈를 발생시키지 않습니다:</p>\n<ul>\n  <li> 상수 경로가 상대적이고 최대 두 부분을 포함하는 경우 </li>\n  <li> 상수 경로가 어노테이션에서 사용되는 경우 </li>\n  <li> 경로가 어노테이션 처리된 경우 </li>\n</ul>",
    "howToFix_ko": "<h4>규칙을 준수하지 않는 코드 예시</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\npublic class Foo {\n  public static final String FRIENDS_ENDPOINT = \"/user/friends\"; // 규칙 준수 - 경로가 상대적이고 두 부분만 있음\n\n  public Collection&lt;User&gt; listUsers() {\n    File userList = new File(\"/home/mylogin/Dev/users.txt\"); // 규칙 위반\n    Collection&lt;User&gt; users = parse(userList);\n    return users;\n  }\n}\n</pre>\n<h4>규칙을 준수하는 해결책</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\npublic class Foo {\n  // Configuration은 사용자 정의 가능한 속성을 반환하는 클래스입니다: 테스트 중에 주입될 수 있도록 모킹할 수 있습니다.\n  private Configuration config;\n  public Foo(Configuration myConfig) {\n    this.config = myConfig;\n  }\n  public Collection&lt;User&gt; listUsers() {\n    // 여기서 올바른 폴더를 얻는 방법을 찾습니다. 이 경우 Configuration 객체를 사용합니다\n    String listingFolder = config.getProperty(\"myApplication.listingFolder\");\n    // 하드코딩된 경로 대신 이 매개변수를 사용합니다\n    File userList = new File(listingFolder, \"users.txt\"); // 규칙 준수\n    Collection&lt;User&gt; users = parse(userList);\n    return users;\n  }\n}\n</pre>\n<p>예외 예시:</p>\n<pre>\npublic class Foo {\n  public static final String FRIENDS_ENDPOINT = \"/user/friends\"; // 규칙 준수 - 경로가 상대적이고 두 부분만 있음\n\n  public static final String ACCOUNT = \"/account/group/list.html\"; // 규칙 준수 - 경로가 어노테이션에서 사용됨\n\n  @Value(\"${base.url}\" + ACCOUNT)\n  private String groupUrl;\n\n  @MyAnnotation()\n  String path = \"/default/url/for/site\"; // 규칙 준수 - 경로가 어노테이션 처리됨\n\n}\n</pre>",
    "moreInfo_ko": ""
  },
  {
    "id": "S2209",
    "key": "java:S2209",
    "name": "\"static\" members should be accessed statically",
    "type": "code-smell",
    "severity": "major",
    "tags": [
      "pitfall"
    ],
    "why": "<p>While it is <em>possible</em> to access <code>static</code> members from a class instance, it's bad form, and considered by most to be misleading\nbecause it implies to the readers of your code that there's an instance of the member per class instance.</p>\n<h3>Noncompliant code example</h3>\n<pre>\npublic class A {\n  public static int counter = 0;\n}\n\npublic class B {\n  private A first = new A();\n  private A second = new A();\n\n  public void runUpTheCount() {\n    first.counter ++;  // Noncompliant\n    second.counter ++;  // Noncompliant. A.counter is now 2, which is perhaps contrary to expectations\n  }\n}\n</pre>\n<h3>Compliant solution</h3>\n<pre>\npublic class A {\n  public static int counter = 0;\n}\n\npublic class B {\n  private A first = new A();\n  private A second = new A();\n\n  public void runUpTheCount() {\n    A.counter ++;  // Compliant\n    A.counter ++;  // Compliant\n  }\n}\n</pre>",
    "howToFix": "",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "\"static\" 멤버는 정적으로 접근해야 합니다",
    "why_ko": "<p>클래스 인스턴스에서 <code>static</code> 멤버에 접근하는 것이 <em>가능</em>하지만, 이는 좋지 않은 형태이며 대부분의 사람들이 오해의 소지가 있다고 생각합니다. 왜냐하면 코드를 읽는 사람들에게 클래스 인스턴스당 멤버의 인스턴스가 있다는 것을 암시하기 때문입니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\npublic class A {\n  public static int counter = 0;\n}\n\npublic class B {\n  private A first = new A();\n  private A second = new A();\n\n  public void runUpTheCount() {\n    first.counter ++;  // 규칙 위반\n    second.counter ++;  // 규칙 위반. A.counter는 이제 2이며, 이는 아마도 예상과 다를 수 있음\n  }\n}\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre>\npublic class A {\n  public static int counter = 0;\n}\n\npublic class B {\n  private A first = new A();\n  private A second = new A();\n\n  public void runUpTheCount() {\n    A.counter ++;  // 규칙 준수\n    A.counter ++;  // 규칙 준수\n  }\n}\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": ""
  },
  {
    "id": "S2065",
    "key": "java:S2065",
    "name": "Fields in non-serializable classes should not be \"transient\"",
    "type": "code-smell",
    "severity": "minor",
    "tags": [
      "serialization",
      "unused"
    ],
    "why": "<p>Fields marked as <code>transient</code> in a <code>Serializable</code> class will be ignored during serialization and consequently not written out\nto a file (or stream).</p>\n<p>This can be useful in situations such as where the content of a field can be recomputed from other fields. To reduce the output size, this field\ncan be marked as <code>transient</code> and recomputed when a given object is deserialized.</p>\n<p>Since <code>transient</code> is very specific to classes that implement <code>Serializable</code>, it is superfluous in classes that do not.</p>\n<p>This rule raises an issue when a field is marked as <code>transient</code>, even though the containing class does not implement\n<code>Serializable</code>.</p>",
    "howToFix": "<p>Ask yourself whether this class should be serializable. If yes, ensure it implements <code>Serializable</code> and provides any additional logic\nrequired to serialize and deserialize an instance of this type. Otherwise, remove the <code>transient</code> modifier from this field.</p>\n\n<h4>Noncompliant code example</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\nclass Vegetable {\n  private transient Season ripe; // Noncompliant, the \"Vegetable\" class does not implement \"Serializable\" but the field is marked as \"transient\"\n  // ...\n}\n</pre>\n<h4>Compliant solution</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\nclass Vegetable {\n  private Season ripe; // Compliant, the field is not marked as \"transient\"\n  // ...\n}\n</pre>",
    "moreInfo": "<ul>\n  <li> <a href=\"https://www.baeldung.com/java-transient-keyword\">Baeldung - The transient Keyword in Java</a> </li>\n</ul>",
    "status": "READY",
    "name_ko": "직렬화 불가능한 클래스의 필드에 \"transient\"를 사용하면 안 됩니다",
    "why_ko": "<p><code>Serializable</code> 클래스에서 <code>transient</code>로 표시된 필드는 직렬화 중에 무시되어 파일(또는 스트림)에 기록되지 않습니다.</p>\n<p>이것은 필드의 내용이 다른 필드에서 다시 계산될 수 있는 상황에서 유용할 수 있습니다. 출력 크기를 줄이기 위해 이 필드를 <code>transient</code>로 표시하고 주어진 객체가 역직렬화될 때 다시 계산할 수 있습니다.</p>\n<p><code>transient</code>는 <code>Serializable</code>을 구현하는 클래스에 매우 특정적이므로 그렇지 않은 클래스에서는 불필요합니다.</p>\n<p>이 규칙은 포함하는 클래스가 <code>Serializable</code>을 구현하지 않는데도 필드가 <code>transient</code>로 표시된 경우 문제를 제기합니다.</p>",
    "howToFix_ko": "<p>이 클래스가 직렬화 가능해야 하는지 자문해 보세요. 그렇다면 <code>Serializable</code>을 구현하고 이 타입의 인스턴스를 직렬화 및 역직렬화하는 데 필요한 추가 로직을 제공하세요. 그렇지 않으면 이 필드에서 <code>transient</code> 수정자를 제거하세요.</p>\n\n<h4>규칙을 준수하지 않는 코드 예시</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\nclass Vegetable {\n  private transient Season ripe; // 규칙 위반, \"Vegetable\" 클래스는 \"Serializable\"을 구현하지 않지만 필드가 \"transient\"로 표시됨\n  // ...\n}\n</pre>\n<h4>규칙을 준수하는 해결책</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\nclass Vegetable {\n  private Season ripe; // 규칙 준수, 필드가 \"transient\"로 표시되지 않음\n  // ...\n}\n</pre>",
    "moreInfo_ko": "<ul>\n  <li> <a href=\"https://www.baeldung.com/java-transient-keyword\">Baeldung - The transient Keyword in Java</a> </li>\n</ul>"
  },
  {
    "id": "S1219",
    "key": "java:S1219",
    "name": "\"switch\" statements should not contain non-case labels",
    "type": "code-smell",
    "severity": "blocker",
    "tags": [
      "suspicious"
    ],
    "why": "<p>Even if it is legal, mixing case and non-case labels in the body of a switch statement is very confusing and can even be the result of a typing\nerror.</p>\n<h3>Noncompliant code example</h3>\n<pre>\nswitch (day) {\n  case MONDAY:\n  case TUESDAY:\n  WEDNESDAY:   // Noncompliant; syntactically correct, but behavior is not what's expected\n    doSomething();\n    break;\n  ...\n}\n\nswitch (day) {\n  case MONDAY:\n    break;\n  case TUESDAY:\n    foo:for(int i = 0 ; i &lt; X ; i++) {  // Noncompliant; the code is correct and behaves as expected but is barely readable\n         /* ... */\n        break foo;  // this break statement doesn't relate to the nesting case TUESDAY\n         /* ... */\n    }\n    break;\n    /* ... */\n}\n</pre>\n<h3>Compliant solution</h3>\n<pre>\nswitch (day) {\n  case MONDAY:\n  case TUESDAY:\n  case WEDNESDAY:\n    doSomething();\n    break;\n  ...\n}\n\nswitch (day) {\n  case MONDAY:\n    break;\n  case TUESDAY:\n    compute(args); // put the content of the labelled \"for\" statement in a dedicated method\n    break;\n\n    /* ... */\n}\n</pre>",
    "howToFix": "",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "\"switch\" 문에 case가 아닌 레이블이 포함되면 안 됩니다",
    "why_ko": "<p>합법적이더라도 switch 문의 본문에서 case와 case가 아닌 레이블을 혼합하는 것은 매우 혼란스럽고 타이핑 오류의 결과일 수도 있습니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\nswitch (day) {\n  case MONDAY:\n  case TUESDAY:\n  WEDNESDAY:   // 규칙 위반; 구문적으로는 올바르지만 동작은 예상과 다름\n    doSomething();\n    break;\n  ...\n}\n\nswitch (day) {\n  case MONDAY:\n    break;\n  case TUESDAY:\n    foo:for(int i = 0 ; i &lt; X ; i++) {  // 규칙 위반; 코드는 올바르고 예상대로 동작하지만 거의 읽을 수 없음\n         /* ... */\n        break foo;  // 이 break 문은 중첩된 case TUESDAY와 관련이 없음\n         /* ... */\n    }\n    break;\n    /* ... */\n}\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre>\nswitch (day) {\n  case MONDAY:\n  case TUESDAY:\n  case WEDNESDAY:\n    doSomething();\n    break;\n  ...\n}\n\nswitch (day) {\n  case MONDAY:\n    break;\n  case TUESDAY:\n    compute(args); // 레이블이 있는 \"for\" 문의 내용을 전용 메서드에 넣음\n    break;\n\n    /* ... */\n}\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": ""
  },
  {
    "id": "S1188",
    "key": "java:S1188",
    "name": "Anonymous classes should not have too many lines",
    "type": "code-smell",
    "severity": "major",
    "tags": [],
    "why": "<p>Anonymous classes are a very convenient and compact way to inject a behavior without having to create a dedicated class. But those anonymous inner\nclasses should be used only if the behavior to be injected can be defined in a few lines of code, otherwise the source code can quickly become\nunreadable.</p>",
    "howToFix": "",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "익명 클래스는 너무 많은 줄을 가지면 안 됩니다",
    "why_ko": "<p>익명 클래스는 전용 클래스를 만들지 않고도 동작을 주입하는 매우 편리하고 간결한 방법입니다. 그러나 이러한 익명 내부 클래스는 주입할 동작이 몇 줄의 코드로 정의될 수 있는 경우에만 사용해야 하며, 그렇지 않으면 소스 코드가 빠르게 읽기 어려워질 수 있습니다.</p>",
    "howToFix_ko": "",
    "moreInfo_ko": ""
  },
  {
    "id": "S6837",
    "key": "java:S6837",
    "name": "Superfluous \"@ResponseBody\" annotations should be removed",
    "type": "code-smell",
    "severity": "major",
    "tags": [
      "spring"
    ],
    "why": "<p>The Spring framework's <code>@RestController</code> annotation is equivalent to using the <code>@Controller</code> and <code>@ResponseBody</code>\nannotations together. As such, it is redundant to add a <code>@ResponseBody</code> annotation when the class is already annotated with\n<code>@RestController</code>.</p>",
    "howToFix": "<p>Remove the <code>@ResponseBody</code> annotation from the class or method.</p>\n\n<h4>Noncompliant code example</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\n@RestController\npublic class MyController {\n  @ResponseBody // Noncompliant, the @RestController annotation already implies @ResponseBody\n  @RequestMapping(\"/hello\")\n  public String hello() {\n    return \"Hello World!\";\n  }\n}\n</pre>\n<h4>Compliant solution</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\n@RestController\npublic class MyController {\n  @RequestMapping(\"/hello\")\n  public String hello() {\n    return \"Hello World!\";\n  }\n}\n</pre>\n<h4>Noncompliant code example</h4>\n<pre data-diff-id=\"2\" data-diff-type=\"noncompliant\">\n@RestController\n@ResponseBody // Noncompliant, the @RestController annotation already implies @ResponseBody\npublic class MyController {\n  @RequestMapping(\"/hello\")\n  public String hello() {\n    return \"Hello World!\";\n  }\n}\n</pre>\n<h4>Compliant solution</h4>\n<pre data-diff-id=\"2\" data-diff-type=\"compliant\">\n@RestController\npublic class MyController {\n  @RequestMapping(\"/hello\")\n  public String hello() {\n    return \"Hello World!\";\n  }\n}\n</pre>",
    "moreInfo": "<h3>Articles &amp; blog posts</h3>\n<ul>\n  <li> Spring Guides - <a href=\"https://spring.io/guides/gs/rest-service/\">Building a RESTful Web Service</a> </li>\n  <li> Baeldung - <a href=\"https://www.baeldung.com/spring-controller-vs-restcontroller\">The Spring @Controller and @RestController Annotations</a>\n  </li>\n  <li> Baeldung - <a href=\"https://www.baeldung.com/spring-request-response-body\">Spring's RequestBody and ResponseBody Annotations</a> </li>\n</ul>",
    "status": "READY",
    "name_ko": "불필요한 \"@ResponseBody\" 어노테이션은 제거해야 합니다",
    "why_ko": "<p>Spring 프레임워크의 <code>@RestController</code> 어노테이션은 <code>@Controller</code>와 <code>@ResponseBody</code> 어노테이션을 함께 사용하는 것과 동일합니다. 따라서 클래스에 이미 <code>@RestController</code>가 어노테이션되어 있을 때 <code>@ResponseBody</code> 어노테이션을 추가하는 것은 중복입니다.</p>",
    "howToFix_ko": "<p>클래스나 메서드에서 <code>@ResponseBody</code> 어노테이션을 제거하세요.</p>\n\n<h4>규칙을 준수하지 않는 코드 예시</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\n@RestController\npublic class MyController {\n  @ResponseBody // 규칙 위반, @RestController 어노테이션이 이미 @ResponseBody를 의미합니다\n  @RequestMapping(\"/hello\")\n  public String hello() {\n    return \"Hello World!\";\n  }\n}\n</pre>\n<h4>규칙을 준수하는 해결책</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\n@RestController\npublic class MyController {\n  @RequestMapping(\"/hello\")\n  public String hello() {\n    return \"Hello World!\";\n  }\n}\n</pre>\n<h4>규칙을 준수하지 않는 코드 예시</h4>\n<pre data-diff-id=\"2\" data-diff-type=\"noncompliant\">\n@RestController\n@ResponseBody // 규칙 위반, @RestController 어노테이션이 이미 @ResponseBody를 의미합니다\npublic class MyController {\n  @RequestMapping(\"/hello\")\n  public String hello() {\n    return \"Hello World!\";\n  }\n}\n</pre>\n<h4>규칙을 준수하는 해결책</h4>\n<pre data-diff-id=\"2\" data-diff-type=\"compliant\">\n@RestController\npublic class MyController {\n  @RequestMapping(\"/hello\")\n  public String hello() {\n    return \"Hello World!\";\n  }\n}\n</pre>",
    "moreInfo_ko": "<h3>기사 및 블로그 게시물</h3>\n<ul>\n  <li> Spring Guides - <a href=\"https://spring.io/guides/gs/rest-service/\">RESTful 웹 서비스 구축하기</a> </li>\n  <li> Baeldung - <a href=\"https://www.baeldung.com/spring-controller-vs-restcontroller\">Spring @Controller와 @RestController 어노테이션</a> </li>\n  <li> Baeldung - <a href=\"https://www.baeldung.com/spring-request-response-body\">Spring의 RequestBody와 ResponseBody 어노테이션</a> </li>\n</ul>"
  },
  {
    "id": "S2177",
    "key": "java:S2177",
    "name": "Child class methods named for parent class methods should be overrides",
    "type": "bug",
    "severity": "major",
    "tags": [
      "pitfall"
    ],
    "why": "<p>When a method in a child class has the same signature as a method in a parent class, it is assumed to be an override. However, that's not the case\nwhen:</p>\n<ul>\n  <li> the parent class method is <code>static</code> and the child class method is not. </li>\n  <li> the arguments or return types of the child method are in different packages than those of the parent method. </li>\n  <li> the parent class method is <code>private</code>. </li>\n</ul>\n<p>Typically, these things are done unintentionally; the private parent class method is overlooked, the <code>static</code> keyword in the parent\ndeclaration is overlooked, or the wrong class is imported in the child. But if the intent is truly for the child class method to be different, then\nthe method should be renamed to prevent confusion.</p>\n<h3>Noncompliant code example</h3>\n<pre>\n// Parent.java\nimport computer.Pear;\npublic class Parent {\n\n  public void doSomething(Pear p) {\n    //,,,\n  }\n\n  public static void doSomethingElse() {\n    //...\n  }\n}\n\n// Child.java\nimport fruit.Pear;\npublic class Child extends Parent {\n\n  public void doSomething(Pear p) {  // Noncompliant; this is not an override\n    // ...\n  }\n\n\n  public void doSomethingElse() {  // Noncompliant; parent method is static\n    //...\n  }\n}\n</pre>\n<h3>Compliant solution</h3>\n<pre>\n// Parent.java\nimport computer.Pear;\npublic class Parent {\n\n  public void doSomething(Pear p) {\n    //,,,\n  }\n\n  public static void doSomethingElse() {\n    //...\n  }\n}\n\n// Child.java\nimport computer.Pear;  // import corrected\npublic class Child extends Parent {\n\n  public void doSomething(Pear p) {  // true override (see import)\n    //,,,\n  }\n\n  public static void doSomethingElse() {\n    //...\n  }\n}\n</pre>",
    "howToFix": "",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "상위 클래스 메서드와 같은 이름의 하위 클래스 메서드는 오버라이드여야 합니다",
    "why_ko": "<p>하위 클래스의 메서드가 상위 클래스의 메서드와 같은 시그니처를 가지면 오버라이드로 간주됩니다. 그러나 다음과 같은 경우에는 그렇지 않습니다:</p>\n<ul>\n  <li> 상위 클래스 메서드가 <code>static</code>이고 하위 클래스 메서드는 그렇지 않은 경우. </li>\n  <li> 하위 메서드의 인자 또는 반환 타입이 상위 메서드와 다른 패키지에 있는 경우. </li>\n  <li> 상위 클래스 메서드가 <code>private</code>인 경우. </li>\n</ul>\n<p>일반적으로 이러한 것들은 의도하지 않게 발생합니다; private 상위 클래스 메서드를 간과하거나, 상위 선언의 <code>static</code> 키워드를 간과하거나, 하위에서 잘못된 클래스를 임포트합니다. 그러나 하위 클래스 메서드가 진정으로 다르게 하려는 의도라면, 혼란을 방지하기 위해 메서드 이름을 바꿔야 합니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\n// Parent.java\nimport computer.Pear;\npublic class Parent {\n\n  public void doSomething(Pear p) {\n    //,,,\n  }\n\n  public static void doSomethingElse() {\n    //...\n  }\n}\n\n// Child.java\nimport fruit.Pear;\npublic class Child extends Parent {\n\n  public void doSomething(Pear p) {  // 규칙 위반; 이것은 오버라이드가 아님\n    // ...\n  }\n\n\n  public void doSomethingElse() {  // 규칙 위반; 상위 메서드가 static임\n    //...\n  }\n}\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre>\n// Parent.java\nimport computer.Pear;\npublic class Parent {\n\n  public void doSomething(Pear p) {\n    //,,,\n  }\n\n  public static void doSomethingElse() {\n    //...\n  }\n}\n\n// Child.java\nimport computer.Pear;  // import 수정됨\npublic class Child extends Parent {\n\n  public void doSomething(Pear p) {  // 진정한 오버라이드 (import 참조)\n    //,,,\n  }\n\n  public static void doSomethingElse() {\n    //...\n  }\n}\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": ""
  },
  {
    "id": "S1872",
    "key": "java:S1872",
    "name": "Classes should not be compared by name",
    "type": "bug",
    "severity": "major",
    "tags": [
      "cwe",
      "cert"
    ],
    "why": "<p>There is no requirement that class names be unique, only that they be unique within a package. Therefore trying to determine an object's type based\non its class name is an exercise fraught with danger. One of those dangers is that a malicious user will send objects of the same name as the trusted\nclass and thereby gain trusted access.</p>\n<p>Instead, the <code>instanceof</code> operator or the <code>Class.isAssignableFrom()</code> method should be used to check the object's underlying\ntype.</p>\n<h3>Noncompliant code example</h3>\n<pre>\npackage computer;\nclass Pear extends Laptop { ... }\n\npackage food;\nclass Pear extends Fruit { ... }\n\nclass Store {\n\n  public boolean hasSellByDate(Object item) {\n    if (\"Pear\".equals(item.getClass().getSimpleName())) {  // Noncompliant\n      return true;  // Results in throwing away week-old computers\n    }\n    return false;\n  }\n\n  public boolean isList(Class&lt;T&gt; valueClass) {\n    if (List.class.getName().equals(valueClass.getName())) {  // Noncompliant\n      return true;\n    }\n    return false;\n  }\n}\n</pre>\n<h3>Compliant solution</h3>\n<pre>\nclass Store {\n\n  public boolean hasSellByDate(Object item) {\n    if (item instanceof food.Pear) {\n      return true;\n    }\n    return false;\n  }\n\n  public boolean isList(Class&lt;T&gt; valueClass) {\n    if (valueClass.isAssignableFrom(List.class)) {\n      return true;\n    }\n    return false;\n  }\n}\n</pre>",
    "howToFix": "",
    "moreInfo": "<ul>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/486\">CWE-486 - Comparison of Classes by Name</a> </li>\n  <li> <a href=\"https://wiki.sei.cmu.edu/confluence/x/eDdGBQ\">CERT, OBJ09-J.</a> - Compare classes and not class names </li>\n</ul>",
    "status": "READY",
    "name_ko": "클래스를 이름으로 비교하면 안 됩니다",
    "why_ko": "<p>클래스 이름이 고유해야 한다는 요구 사항은 없으며, 패키지 내에서만 고유하면 됩니다. 따라서 클래스 이름을 기반으로 객체의 타입을 결정하려는 것은 위험이 따르는 일입니다. 그러한 위험 중 하나는 악의적인 사용자가 신뢰할 수 있는 클래스와 동일한 이름의 객체를 보내 신뢰할 수 있는 접근 권한을 얻을 수 있다는 것입니다.</p>\n<p>대신 객체의 기본 타입을 확인하려면 <code>instanceof</code> 연산자나 <code>Class.isAssignableFrom()</code> 메서드를 사용해야 합니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\npackage computer;\nclass Pear extends Laptop { ... }\n\npackage food;\nclass Pear extends Fruit { ... }\n\nclass Store {\n\n  public boolean hasSellByDate(Object item) {\n    if (\"Pear\".equals(item.getClass().getSimpleName())) {  // 규칙 위반\n      return true;  // 일주일된 컴퓨터를 버리는 결과 초래\n    }\n    return false;\n  }\n\n  public boolean isList(Class&lt;T&gt; valueClass) {\n    if (List.class.getName().equals(valueClass.getName())) {  // 규칙 위반\n      return true;\n    }\n    return false;\n  }\n}\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre>\nclass Store {\n\n  public boolean hasSellByDate(Object item) {\n    if (item instanceof food.Pear) {\n      return true;\n    }\n    return false;\n  }\n\n  public boolean isList(Class&lt;T&gt; valueClass) {\n    if (valueClass.isAssignableFrom(List.class)) {\n      return true;\n    }\n    return false;\n  }\n}\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": "<ul>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/486\">CWE-486 - 이름으로 클래스 비교</a> </li>\n  <li> <a href=\"https://wiki.sei.cmu.edu/confluence/x/eDdGBQ\">CERT, OBJ09-J.</a> - 클래스 이름이 아닌 클래스를 비교하세요 </li>\n</ul>"
  },
  {
    "id": "S1171",
    "key": "java:S1171",
    "name": "Only static class initializers should be used",
    "type": "code-smell",
    "severity": "major",
    "tags": [
      "pitfall"
    ],
    "why": "<p>Non-static initializers, also known as instance initializers, are blocks of code within a class that are executed when an instance of the class is\ncreated. They are executed when an object of the class is created just before the constructor is called. Non-static initializers are useful when you\nwant to perform some common initialization logic for all objects of a class. They allow you to initialize instance variables in a concise and\ncentralized manner, without having to repeat the same initialization code in each constructor.</p>\n<p>While non-static initializers may have some limited use cases, they are rarely used and can be confusing for most developers because they only run\nwhen new class instances are created.</p>",
    "howToFix": "<p>Non-static initializers should be refactored into standard constructors or field initializers when possible.</p>\n<p>In most cases, the use of constructors, overloaded constructors, or factory methods is preferable for initializing instance variables. These\napproaches provide more explicit and controlled initialization, separate concerns, allow for better error handling, and make the code easier to\nunderstand and maintain.</p>\n\n<h4>Noncompliant code example</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\nclass MyClass {\n  private static final Map&lt;String, String&gt; MY_MAP = new HashMap&lt;String, String&gt;() {\n    {\n      put(\"a\", \"b\");\n    }\n  }; // Noncompliant - HashMap should be extended only to add behavior, not for initialization\n}\n</pre>\n<h4>Compliant solution</h4>\n<p>Using static initialization block:</p>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\nclass MyClass {\n  private static final Map&lt;String, String&gt; MY_MAP = new HashMap&lt;&gt;();\n\n  static {\n    MY_MAP.put(\"a\", \"b\");  // Compliant\n  }\n}\n</pre>\n<p>or using constructor:</p>\n<pre>\nclass MyClass {\n  private static final Map&lt;String, String&gt; MY_MAP = new HashMap&lt;&gt;();\n\n  public MyClass() {\n    MY_MAP.put(\"a\", \"b\");  // Compliant\n  }\n}\n</pre>\n<p>or using Java 9 <code>Map.of</code>:</p>\n<pre>\nclass MyClass {\n  private static final Map&lt;String, String&gt; MY_MAP = java.util.Map.of(\"a\", \"b\");   // Compliant\n}\n</pre>\n<p>or using Guava <code>ImmutableMap.of</code>:</p>\n<pre>\nclass MyClass {\n  private static final Map&lt;String, String&gt; MY_MAP = com.google.common.collect.ImmutableMap.of(\"a\", \"b\");   // Compliant\n}\n</pre>",
    "moreInfo": "<h3>Articles &amp; blog posts</h3>\n<ul>\n  <li> <a href=\"https://www.baeldung.com/java-static-instance-initializer-blocks\">Static vs. Instance Initializer Block in Java</a> </li>\n</ul>",
    "status": "READY",
    "name_ko": "static 클래스 초기화자만 사용해야 합니다",
    "why_ko": "<p>인스턴스 초기화자라고도 하는 비정적(non-static) 초기화자는 클래스의 인스턴스가 생성될 때 실행되는 클래스 내의 코드 블록입니다. 클래스의 객체가 생성될 때 생성자가 호출되기 직전에 실행됩니다. 비정적 초기화자는 클래스의 모든 객체에 대해 공통 초기화 로직을 수행하려는 경우에 유용합니다. 각 생성자에서 동일한 초기화 코드를 반복하지 않고도 간결하고 중앙 집중적인 방식으로 인스턴스 변수를 초기화할 수 있습니다.</p>\n<p>비정적 초기화자는 일부 제한된 사용 사례가 있을 수 있지만, 새 클래스 인스턴스가 생성될 때만 실행되기 때문에 대부분의 개발자에게 혼란스럽고 거의 사용되지 않습니다.</p>",
    "howToFix_ko": "<p>비정적 초기화자는 가능하면 표준 생성자나 필드 초기화자로 리팩토링해야 합니다.</p>\n<p>대부분의 경우 인스턴스 변수 초기화에는 생성자, 오버로드된 생성자 또는 팩토리 메서드를 사용하는 것이 바람직합니다. 이러한 접근 방식은 더 명시적이고 제어된 초기화를 제공하고, 관심사를 분리하며, 더 나은 오류 처리를 허용하고, 코드를 이해하고 유지보수하기 쉽게 만듭니다.</p>\n\n<h4>규칙을 준수하지 않는 코드 예시</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\nclass MyClass {\n  private static final Map&lt;String, String&gt; MY_MAP = new HashMap&lt;String, String&gt;() {\n    {\n      put(\"a\", \"b\");\n    }\n  }; // 규칙 위반 - HashMap은 초기화가 아닌 동작 추가를 위해서만 확장해야 합니다\n}\n</pre>\n<h4>규칙을 준수하는 해결책</h4>\n<p>static 초기화 블록 사용:</p>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\nclass MyClass {\n  private static final Map&lt;String, String&gt; MY_MAP = new HashMap&lt;&gt;();\n\n  static {\n    MY_MAP.put(\"a\", \"b\");  // 규칙 준수\n  }\n}\n</pre>\n<p>또는 생성자 사용:</p>\n<pre>\nclass MyClass {\n  private static final Map&lt;String, String&gt; MY_MAP = new HashMap&lt;&gt;();\n\n  public MyClass() {\n    MY_MAP.put(\"a\", \"b\");  // 규칙 준수\n  }\n}\n</pre>\n<p>또는 Java 9 <code>Map.of</code> 사용:</p>\n<pre>\nclass MyClass {\n  private static final Map&lt;String, String&gt; MY_MAP = java.util.Map.of(\"a\", \"b\");   // 규칙 준수\n}\n</pre>\n<p>또는 Guava <code>ImmutableMap.of</code> 사용:</p>\n<pre>\nclass MyClass {\n  private static final Map&lt;String, String&gt; MY_MAP = com.google.common.collect.ImmutableMap.of(\"a\", \"b\");   // 규칙 준수\n}\n</pre>",
    "moreInfo_ko": "<h3>관련 글 및 블로그 포스트</h3>\n<ul>\n  <li> <a href=\"https://www.baeldung.com/java-static-instance-initializer-blocks\">Java의 Static vs. Instance 초기화 블록</a> </li>\n</ul>"
  },
  {
    "id": "S5831",
    "key": "java:S5831",
    "name": "AssertJ configuration should be applied",
    "type": "bug",
    "severity": "major",
    "tags": [
      "tests",
      "assertj"
    ],
    "why": "<p>A <code>org.assertj.core.configuration.Configuration</code> will be effective only once you call <code>Configuration.apply()</code> or\n<code>Configuration.applyAndDisplay()</code>.</p>\n<p>This rule raises an issue when configurations are set without the appropriate call to apply them.</p>\n<h3>Noncompliant code example</h3>\n<pre>\nConfiguration configuration = new Configuration(); // Noncompliant, this configuration will not be applied.\nconfiguration.setComparingPrivateFields(true);\n</pre>\n<h3>Compliant solution</h3>\n<pre>\nConfiguration configuration = new Configuration();\nconfiguration.setComparingPrivateFields(true);\nconfiguration.applyAndDisplay();\n// Alternatively: configuration.apply();\n</pre>",
    "howToFix": "",
    "moreInfo": "<ul>\n  <li> <a href=\"https://assertj.github.io/doc/#assertj-configuration\">AssertJ configuration documentation</a> </li>\n</ul>",
    "status": "READY",
    "name_ko": "AssertJ 설정이 적용되어야 합니다",
    "why_ko": "<p><code>org.assertj.core.configuration.Configuration</code>은 <code>Configuration.apply()</code> 또는 <code>Configuration.applyAndDisplay()</code>를 호출해야만 효력이 있습니다.</p>\n<p>이 규칙은 설정이 적용하는 적절한 호출 없이 설정될 때 문제를 제기합니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\nConfiguration configuration = new Configuration(); // 규칙 위반, 이 설정은 적용되지 않습니다.\nconfiguration.setComparingPrivateFields(true);\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre>\nConfiguration configuration = new Configuration();\nconfiguration.setComparingPrivateFields(true);\nconfiguration.applyAndDisplay();\n// 대안: configuration.apply();\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": "<ul>\n  <li> <a href=\"https://assertj.github.io/doc/#assertj-configuration\">AssertJ 설정 문서</a> </li>\n</ul>"
  },
  {
    "id": "S6437",
    "key": "java:S6437",
    "name": "Credentials should not be hard-coded",
    "type": "vulnerability",
    "severity": "blocker",
    "tags": [
      "cwe"
    ],
    "why": "<p>In most cases, trust boundaries are violated when a secret is exposed in a source code repository or an uncontrolled deployment environment.\nUnintended people who don't need to know the secret might get access to it. They might then be able to use it to gain unwanted access to associated\nservices or resources.</p>\n<p>The trust issue can be more or less severe depending on the people's role and entitlement.</p>\n<h3>What is the potential impact?</h3>\n<p>The consequences vary greatly depending on the situation and the secret-exposed audience. Still, two main scenarios should be considered.</p>\n<h4>Financial loss</h4>\n<p>Financial losses can occur when a secret is used to access a paid third-party-provided service and is disclosed as part of the source code of\nclient applications. Having the secret, each user of the application will be able to use it without limit to use the third party service to their own\nneed, including in a way that was not expected.</p>\n<p>This additional use of the secret will lead to added costs with the service provider.</p>\n<p>Moreover, when rate or volume limiting is set up on the provider side, this additional use can prevent the regular operation of the affected\napplication. This might result in a partial denial of service for all the application's users.</p>\n<h4>Application's security downgrade</h4>\n<p>A downgrade can happen when the disclosed secret is used to protect security-sensitive assets or features of the application. Depending on the\naffected asset or feature, the practical impact can range from a sensitive information leak to a complete takeover of the application, its hosting\nserver or another linked component.</p>\n<p>For example, an application that would disclose a secret used to sign user authentication tokens would be at risk of user identity impersonation.\nAn attacker accessing the leaked secret could sign session tokens for arbitrary users and take over their privileges and entitlements.</p>",
    "howToFix": "<p><strong>Revoke the secret</strong></p>\n<p>Revoke any leaked secrets and remove them from the application source code.</p>\n<p>Before revoking the secret, ensure that no other applications or processes are using it. Other usages of the secret will also be impacted when the\nsecret is revoked.</p>\n<p><strong>Analyze recent secret use</strong></p>\n<p>When available, analyze authentication logs to identify any unintended or malicious use of the secret since its disclosure date. Doing this will\nallow determining if an attacker took advantage of the leaked secret and to what extent.</p>\n<p>This operation should be part of a global incident response process.</p>\n<p><strong>Use a secret vault</strong></p>\n<p>A secret vault should be used to generate and store the new secret. This will ensure the secret's security and prevent any further unexpected\ndisclosure.</p>\n<p>Depending on the development platform and the leaked secret type, multiple solutions are currently available.</p>\n\n<p>The following code example is noncompliant because it uses a hardcoded secret value.</p>\n<h4>Noncompliant code example</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\nimport org.h2.security.SHA256;\n\nString inputString = \"s3cr37\";\nbyte[] key         = inputString.getBytes();\n\nSHA256.getHMAC(key, message);  // Noncompliant\n</pre>\n<h4>Compliant solution</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\nimport org.h2.security.SHA256;\n\nString inputString = System.getenv(\"SECRET\");\nbyte[] key         = inputString.getBytes();\n\nSHA256.getHMAC(key, message);\n</pre>\n<h3>How does this work?</h3>\n<p>While the noncompliant code example contains a hard-coded password, the compliant solution retrieves the secret's value from its environment. This\nallows to have an environment-dependent secret value and avoids storing the password in the source code itself.</p>\n<p>Depending on the application and its underlying infrastructure, how the secret gets added to the environment might change.</p>",
    "moreInfo": "<h3>Documentation</h3>\n<ul>\n  <li> AWS Documentation - <a href=\"https://docs.aws.amazon.com/secretsmanager/latest/userguide/intro.html\">What is AWS Secrets Manager</a> </li>\n  <li> Azure Documentation - <a href=\"https://learn.microsoft.com/en-us/azure/key-vault/\">Azure Key Vault</a> </li>\n  <li> Google Cloud - <a href=\"https://cloud.google.com/secret-manager/docs\">Secret Manager documentation</a> </li>\n  <li> HashiCorp Developer - <a href=\"https://developer.hashicorp.com/vault/docs\">Vault Documentation</a> </li>\n</ul>\n<h3>Standards</h3>\n<ul>\n  <li> OWASP - <a href=\"https://owasp.org/Top10/A07_2021-Identification_and_Authentication_Failures/\">Top 10 2021 - Category A7 - Identification and\n  Authentication Failures</a> </li>\n  <li> OWASP - <a href=\"https://owasp.org/www-project-top-ten/2017/A2_2017-Broken_Authentication\">Top 10 2017 - Category A2 - Broken\n  Authentication</a> </li>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/798\">CWE-798 - Use of Hard-coded Credentials</a> </li>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/259\">CWE-259 - Use of Hard-coded Password</a> </li>\n</ul>",
    "status": "READY",
    "name_ko": "자격 증명은 하드코딩하면 안 됩니다",
    "why_ko": "<p>대부분의 경우, 비밀이 소스 코드 저장소나 통제되지 않는 배포 환경에 노출되면 신뢰 경계가 침해됩니다. 비밀을 알 필요가 없는 의도하지 않은 사람들이 이에 접근할 수 있게 됩니다. 그들은 이를 사용하여 관련 서비스나 리소스에 원치 않는 접근 권한을 얻을 수 있습니다.</p>\n<p>신뢰 문제는 사람들의 역할과 권한에 따라 심각성이 달라질 수 있습니다.</p>\n<h3>잠재적 영향은 무엇인가요?</h3>\n<p>결과는 상황과 비밀이 노출된 대상에 따라 크게 달라집니다. 그러나 두 가지 주요 시나리오를 고려해야 합니다.</p>\n<h4>재정적 손실</h4>\n<p>재정적 손실은 비밀이 유료 타사 제공 서비스에 접근하는 데 사용되고 클라이언트 애플리케이션의 소스 코드의 일부로 공개될 때 발생할 수 있습니다. 비밀을 가지고 있으면 애플리케이션의 각 사용자가 예상치 못한 방식을 포함하여 자신의 필요에 따라 제한 없이 타사 서비스를 사용할 수 있습니다.</p>\n<p>이러한 비밀의 추가 사용은 서비스 제공업체와의 추가 비용으로 이어질 것입니다.</p>\n<p>또한 제공자 측에서 속도 또는 볼륨 제한이 설정된 경우 이러한 추가 사용은 영향을 받는 애플리케이션의 정상적인 운영을 방해할 수 있습니다. 이로 인해 모든 애플리케이션 사용자에 대한 부분적인 서비스 거부가 발생할 수 있습니다.</p>\n<h4>애플리케이션의 보안 수준 저하</h4>\n<p>공개된 비밀이 애플리케이션의 보안에 민감한 자산이나 기능을 보호하는 데 사용되면 보안 수준 저하가 발생할 수 있습니다. 영향을 받는 자산이나 기능에 따라 실제 영향은 민감한 정보 유출부터 애플리케이션, 호스팅 서버 또는 연결된 다른 구성 요소의 완전한 탈취까지 다양할 수 있습니다.</p>\n<p>예를 들어, 사용자 인증 토큰에 서명하는 데 사용되는 비밀을 공개하는 애플리케이션은 사용자 신원 사칭의 위험에 처하게 됩니다. 유출된 비밀에 접근한 공격자는 임의의 사용자에 대한 세션 토큰에 서명하고 그들의 권한을 탈취할 수 있습니다.</p>",
    "howToFix_ko": "<p><strong>비밀 취소</strong></p>\n<p>유출된 비밀을 취소하고 애플리케이션 소스 코드에서 제거하세요.</p>\n<p>비밀을 취소하기 전에 다른 애플리케이션이나 프로세스가 이를 사용하고 있지 않은지 확인하세요. 비밀이 취소되면 비밀의 다른 사용도 영향을 받습니다.</p>\n<p><strong>최근 비밀 사용 분석</strong></p>\n<p>가능한 경우 인증 로그를 분석하여 공개 날짜 이후 비밀의 의도하지 않거나 악의적인 사용을 식별하세요. 이를 통해 공격자가 유출된 비밀을 이용했는지, 어느 정도까지 이용했는지 확인할 수 있습니다.</p>\n<p>이 작업은 전체 인시던트 대응 프로세스의 일부여야 합니다.</p>\n<p><strong>비밀 저장소 사용</strong></p>\n<p>새 비밀을 생성하고 저장하려면 비밀 저장소를 사용해야 합니다. 이렇게 하면 비밀의 보안이 보장되고 예상치 못한 추가 공개가 방지됩니다.</p>\n<p>개발 플랫폼과 유출된 비밀 유형에 따라 현재 여러 솔루션을 사용할 수 있습니다.</p>\n\n<p>다음 코드 예제는 하드코딩된 비밀 값을 사용하므로 규칙을 준수하지 않습니다.</p>\n<h4>규칙을 준수하지 않는 코드 예시</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\nimport org.h2.security.SHA256;\n\nString inputString = \"s3cr37\";\nbyte[] key         = inputString.getBytes();\n\nSHA256.getHMAC(key, message);  // 규칙 위반\n</pre>\n<h4>규칙을 준수하는 해결책</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\nimport org.h2.security.SHA256;\n\nString inputString = System.getenv(\"SECRET\");\nbyte[] key         = inputString.getBytes();\n\nSHA256.getHMAC(key, message);\n</pre>\n<h3>작동 방식</h3>\n<p>규칙을 준수하지 않는 코드 예제에는 하드코딩된 비밀번호가 포함되어 있지만, 규칙을 준수하는 솔루션은 환경에서 비밀 값을 가져옵니다. 이를 통해 환경에 따른 비밀 값을 가질 수 있고 소스 코드 자체에 비밀번호를 저장하지 않을 수 있습니다.</p>\n<p>애플리케이션과 기반 인프라에 따라 환경에 비밀을 추가하는 방법이 달라질 수 있습니다.</p>",
    "moreInfo_ko": "<h3>문서</h3>\n<ul>\n  <li> AWS 문서 - <a href=\"https://docs.aws.amazon.com/secretsmanager/latest/userguide/intro.html\">AWS Secrets Manager란 무엇인가</a> </li>\n  <li> Azure 문서 - <a href=\"https://learn.microsoft.com/en-us/azure/key-vault/\">Azure Key Vault</a> </li>\n  <li> Google Cloud - <a href=\"https://cloud.google.com/secret-manager/docs\">Secret Manager 문서</a> </li>\n  <li> HashiCorp Developer - <a href=\"https://developer.hashicorp.com/vault/docs\">Vault 문서</a> </li>\n</ul>\n<h3>표준</h3>\n<ul>\n  <li> OWASP - <a href=\"https://owasp.org/Top10/A07_2021-Identification_and_Authentication_Failures/\">Top 10 2021 - 카테고리 A7 - 식별 및 인증 실패</a> </li>\n  <li> OWASP - <a href=\"https://owasp.org/www-project-top-ten/2017/A2_2017-Broken_Authentication\">Top 10 2017 - 카테고리 A2 - 취약한 인증</a> </li>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/798\">CWE-798 - 하드코딩된 자격 증명 사용</a> </li>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/259\">CWE-259 - 하드코딩된 비밀번호 사용</a> </li>\n</ul>"
  },
  {
    "id": "S1258",
    "key": "java:S1258",
    "name": "Classes and enums with private members should have a constructor",
    "type": "code-smell",
    "severity": "major",
    "tags": [
      "pitfall"
    ],
    "why": "<p>Non-abstract classes and enums with non-<code>static</code>, <code>private</code> members should explicitly initialize those members, either in a\nconstructor or with a default value.</p>\n<h3>Noncompliant code example</h3>\n<pre>\nclass A { // Noncompliant\n  private int field;\n}\n</pre>\n<h3>Compliant solution</h3>\n<pre>\nclass A {\n  private int field;\n\n  A(int field) {\n    this.field = field;\n  }\n}\n</pre>\n<h3>Exceptions</h3>\n<ul>\n  <li> Class implementing a Builder Pattern (name ending with \"Builder\"). </li>\n  <li> <a href=\"https://docs.oracle.com/javaee/7/tutorial/index.html\">Java EE</a> class annotated with:\n    <ul>\n      <li> <a href=\"https://docs.oracle.com/javaee/7/api/javax/annotation/ManagedBean.html\">ManagedBean</a> </li>\n      <li> <a href=\"https://docs.oracle.com/javaee/7/api/javax/ejb/MessageDriven.html\">MessageDriven</a> </li>\n      <li> <a href=\"https://docs.oracle.com/javaee/7/api/javax/ejb/Singleton.html\">Singleton</a> </li>\n      <li> <a href=\"https://docs.oracle.com/javaee/7/api/javax/ejb/Stateful.html\">Stateful</a> </li>\n      <li> <a href=\"https://docs.oracle.com/javaee/7/api/javax/ejb/Stateless.html\">Stateless</a> </li>\n      <li> <a href=\"https://docs.oracle.com/javaee/7/api/javax/jws/WebService.html\">WebService</a> </li>\n      <li> <a href=\"https://docs.oracle.com/javaee/7/api/javax/servlet/annotation/WebFilter.html\">WebFilter</a> </li>\n      <li> <a href=\"https://docs.oracle.com/javaee/7/api/javax/servlet/annotation/WebServlet.html\">WebServlet</a> </li>\n    </ul>  </li>\n  <li> Class and field annotated with:\n    <ul>\n      <li> <a href=\"https://codehaus-plexus.github.io/plexus-containers/plexus-component-annotations/index.html\">Plexus Component Annotations</a>\n      </li>\n      <li> <a href=\"https://maven.apache.org/developers/mojo-api-specification.html\">Maven Mojo</a> </li>\n    </ul>  </li>\n  <li> Field annotated with:\n    <ul>\n      <li> <a href=\"https://docs.oracle.com/javaee/7/api/javax/annotation/Resource.html\">Resource</a> </li>\n      <li> <a href=\"https://docs.oracle.com/javaee/7/api/javax/ejb/EJB.html\">EJB</a> </li>\n      <li> <a href=\"https://docs.oracle.com/javaee/7/api/javax/inject/Inject.html\">Inject</a> </li>\n      <li> <a\n      href=\"https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/beans/factory/annotation/Autowired.html\">Autowired</a> </li>\n    </ul>  </li>\n  <li> Class annotated with:\n    <ul>\n      <li> <a href=\"https://www.javadoc.io/doc/org.projectlombok/lombok/latest/lombok/Builder.html\">Lombok Builder</a> </li>\n    </ul>  </li>\n</ul>",
    "howToFix": "",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "private 멤버가 있는 클래스와 enum은 생성자를 가져야 합니다",
    "why_ko": "<p>non-<code>static</code>, <code>private</code> 멤버를 가진 비추상 클래스와 enum은 생성자에서 또는 기본값으로 해당 멤버를 명시적으로 초기화해야 합니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\nclass A { // 규칙 위반\n  private int field;\n}\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre>\nclass A {\n  private int field;\n\n  A(int field) {\n    this.field = field;\n  }\n}\n</pre>\n<h3>예외 사항</h3>\n<ul>\n  <li> Builder 패턴을 구현하는 클래스 (이름이 \"Builder\"로 끝나는 경우). </li>\n  <li> 다음 어노테이션이 붙은 <a href=\"https://docs.oracle.com/javaee/7/tutorial/index.html\">Java EE</a> 클래스:\n    <ul>\n      <li> <a href=\"https://docs.oracle.com/javaee/7/api/javax/annotation/ManagedBean.html\">ManagedBean</a> </li>\n      <li> <a href=\"https://docs.oracle.com/javaee/7/api/javax/ejb/MessageDriven.html\">MessageDriven</a> </li>\n      <li> <a href=\"https://docs.oracle.com/javaee/7/api/javax/ejb/Singleton.html\">Singleton</a> </li>\n      <li> <a href=\"https://docs.oracle.com/javaee/7/api/javax/ejb/Stateful.html\">Stateful</a> </li>\n      <li> <a href=\"https://docs.oracle.com/javaee/7/api/javax/ejb/Stateless.html\">Stateless</a> </li>\n      <li> <a href=\"https://docs.oracle.com/javaee/7/api/javax/jws/WebService.html\">WebService</a> </li>\n      <li> <a href=\"https://docs.oracle.com/javaee/7/api/javax/servlet/annotation/WebFilter.html\">WebFilter</a> </li>\n      <li> <a href=\"https://docs.oracle.com/javaee/7/api/javax/servlet/annotation/WebServlet.html\">WebServlet</a> </li>\n    </ul>  </li>\n  <li> 다음 어노테이션이 붙은 클래스와 필드:\n    <ul>\n      <li> <a href=\"https://codehaus-plexus.github.io/plexus-containers/plexus-component-annotations/index.html\">Plexus Component Annotations</a>\n      </li>\n      <li> <a href=\"https://maven.apache.org/developers/mojo-api-specification.html\">Maven Mojo</a> </li>\n    </ul>  </li>\n  <li> 다음 어노테이션이 붙은 필드:\n    <ul>\n      <li> <a href=\"https://docs.oracle.com/javaee/7/api/javax/annotation/Resource.html\">Resource</a> </li>\n      <li> <a href=\"https://docs.oracle.com/javaee/7/api/javax/ejb/EJB.html\">EJB</a> </li>\n      <li> <a href=\"https://docs.oracle.com/javaee/7/api/javax/inject/Inject.html\">Inject</a> </li>\n      <li> <a\n      href=\"https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/beans/factory/annotation/Autowired.html\">Autowired</a> </li>\n    </ul>  </li>\n  <li> 다음 어노테이션이 붙은 클래스:\n    <ul>\n      <li> <a href=\"https://www.javadoc.io/doc/org.projectlombok/lombok/latest/lombok/Builder.html\">Lombok Builder</a> </li>\n    </ul>  </li>\n</ul>",
    "howToFix_ko": "",
    "moreInfo_ko": ""
  },
  {
    "id": "S5866",
    "key": "java:S5866",
    "name": "Case insensitive Unicode regular expressions should enable the \"UNICODE_CASE\" flag",
    "type": "bug",
    "severity": "major",
    "tags": [
      "regex"
    ],
    "why": "<p>By default case insensitivity only affects letters in the ASCII range. This can be changed by either passing <code>Pattern.UNICODE_CASE</code> or\n<code>Pattern.UNICODE_CHARACTER_CLASS</code> as an argument to <code>Pattern.compile</code> or using <code>(?u)</code> or <code>(?U)</code> within the\nregex.</p>\n<p>If not done, regular expressions involving non-ASCII letters will still handle those letters as being case sensitive.</p>\n<h3>Noncompliant code example</h3>\n<pre>\nPattern.compile(\"söme pättern\", Pattern.CASE_INSENSITIVE);\nstr.matches(\"(?i)söme pättern\");\nstr.matches(\"(?i:söme) pättern\");\n</pre>\n<h3>Compliant solution</h3>\n<pre>\nPattern.compile(\"söme pättern\", Pattern.CASE_INSENSITIVE | Pattern.UNICODE_CASE);\nstr.matches(\"(?iu)söme pättern\");\nstr.matches(\"(?iu:söme) pättern\");\n\n// UNICODE_CHARACTER_CLASS implies UNICODE_CASE\nPattern.compile(\"söme pättern\", Pattern.CASE_INSENSITIVE | Pattern.UNICODE_CHARACTER_CLASS);\nstr.matches(\"(?iU)söme pättern\");\nstr.matches(\"(?iU:söme) pättern\");\n</pre>",
    "howToFix": "",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "대소문자 무시 Unicode 정규식은 \"UNICODE_CASE\" 플래그를 활성화해야 합니다",
    "why_ko": "<p>기본적으로 대소문자 무시는 ASCII 범위의 문자에만 영향을 줍니다. 이는 <code>Pattern.compile</code>에 <code>Pattern.UNICODE_CASE</code> 또는 <code>Pattern.UNICODE_CHARACTER_CLASS</code>를 인수로 전달하거나 정규식 내에서 <code>(?u)</code> 또는 <code>(?U)</code>를 사용하여 변경할 수 있습니다.</p>\n<p>이렇게 하지 않으면 비ASCII 문자를 포함하는 정규 표현식은 여전히 해당 문자를 대소문자를 구분하는 것으로 처리합니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\nPattern.compile(\"söme pättern\", Pattern.CASE_INSENSITIVE);\nstr.matches(\"(?i)söme pättern\");\nstr.matches(\"(?i:söme) pättern\");\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre>\nPattern.compile(\"söme pättern\", Pattern.CASE_INSENSITIVE | Pattern.UNICODE_CASE);\nstr.matches(\"(?iu)söme pättern\");\nstr.matches(\"(?iu:söme) pättern\");\n\n// UNICODE_CHARACTER_CLASS는 UNICODE_CASE를 포함\nPattern.compile(\"söme pättern\", Pattern.CASE_INSENSITIVE | Pattern.UNICODE_CHARACTER_CLASS);\nstr.matches(\"(?iU)söme pättern\");\nstr.matches(\"(?iU:söme) pättern\");\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": ""
  },
  {
    "id": "S1126",
    "key": "java:S1126",
    "name": "Return of boolean expressions should not be wrapped into an \"if-then-else\" statement",
    "type": "code-smell",
    "severity": "minor",
    "tags": [
      "clumsy"
    ],
    "why": "<p>Return of boolean literal statements wrapped into <code>if-then-else</code> ones should be simplified.</p>\n<p>Similarly, method invocations wrapped into <code>if-then-else</code> differing only from boolean literals should be simplified into a single\ninvocation.</p>\n<h3>Noncompliant code example</h3>\n<pre>\nboolean foo(Object param) {\n  if (expression) { // Noncompliant\n    bar(param, true, \"qix\");\n  } else {\n    bar(param, false, \"qix\");\n  }\n\n  if (expression) {  // Noncompliant\n    return true;\n  } else {\n    return false;\n  }\n}\n</pre>\n<h3>Compliant solution</h3>\n<pre>\nboolean foo(Object param) {\n  bar(param, expression, \"qix\");\n\n  return expression;\n}\n</pre>",
    "howToFix": "",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "Boolean 표현식의 반환은 \"if-then-else\" 문으로 감싸면 안 됩니다",
    "why_ko": "<p><code>if-then-else</code>로 감싸진 boolean 리터럴 문의 반환은 단순화해야 합니다.</p>\n<p>마찬가지로, boolean 리터럴만 다른 <code>if-then-else</code>로 감싸진 메서드 호출은 단일 호출로 단순화해야 합니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\nboolean foo(Object param) {\n  if (expression) { // 규칙 위반\n    bar(param, true, \"qix\");\n  } else {\n    bar(param, false, \"qix\");\n  }\n\n  if (expression) {  // 규칙 위반\n    return true;\n  } else {\n    return false;\n  }\n}\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre>\nboolean foo(Object param) {\n  bar(param, expression, \"qix\");\n\n  return expression;\n}\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": ""
  },
  {
    "id": "S7158",
    "key": "java:S7158",
    "name": "\"String.isEmpty()\" should be used to test for emptiness",
    "type": "code-smell",
    "severity": "minor",
    "tags": [],
    "why": "<p>Calling <code>String.isEmpty()</code> clearly communicates the code's intention, which is to test if the string is empty. Using\n<code>String.length() == 0</code> is less direct and makes the code less readable. This preference for <code>isEmpty()</code> extends to all\n<code>CharSequence</code> objects, including <code>StringBuilder</code> and <code>StringBuffer</code>.</p>",
    "howToFix": "<h4>Noncompliant code example</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\nif (\"string\".length() == 0) { /* … */ } // Noncompliant\n\nif (\"string\".length() &gt; 0) { /* … */ } // Noncompliant\n</pre>\n<pre data-diff-id=\"2\" data-diff-type=\"noncompliant\">\nStringBuilder sb = new StringBuilder();\n...\nif (sb.length() == 0) { /* … */ } // Noncompliant\n</pre>\n<h4>Compliant solution</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\nif (\"string\".isEmpty()){ /* … */ }\n\nif (!\"string\".isEmpty()){ /* … */ }\n</pre>\n<pre data-diff-id=\"2\" data-diff-type=\"compliant\">\nStringBuilder sb = new StringBuilder();\n...\nif (sb.isEmpty()) { /* … */ }\n</pre>",
    "moreInfo": "<h3>Documentation</h3>\n<ul>\n  <li> Java Documentation - <a href=\"https://docs.oracle.com/javase/7/docs/api/java/lang/String.html#isEmpty()\">java.lang.String.isEmpty() method</a>\n  </li>\n</ul>",
    "status": "READY",
    "name_ko": "빈 문자열 검사에는 \"String.isEmpty()\"를 사용해야 합니다",
    "why_ko": "<p><code>String.isEmpty()</code>를 호출하면 문자열이 비어 있는지 테스트하려는 코드의 의도가 명확하게 전달됩니다. <code>String.length() == 0</code>을 사용하는 것은 덜 직접적이며 코드의 가독성이 떨어집니다. <code>isEmpty()</code>에 대한 이러한 선호는 <code>StringBuilder</code>와 <code>StringBuffer</code>를 포함한 모든 <code>CharSequence</code> 객체에 적용됩니다.</p>",
    "howToFix_ko": "<h4>규칙을 준수하지 않는 코드 예시</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\nif (\"string\".length() == 0) { /* … */ } // 규칙 위반\n\nif (\"string\".length() &gt; 0) { /* … */ } // 규칙 위반\n</pre>\n<pre data-diff-id=\"2\" data-diff-type=\"noncompliant\">\nStringBuilder sb = new StringBuilder();\n...\nif (sb.length() == 0) { /* … */ } // 규칙 위반\n</pre>\n<h4>규칙을 준수하는 해결책</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\nif (\"string\".isEmpty()){ /* … */ }\n\nif (!\"string\".isEmpty()){ /* … */ }\n</pre>\n<pre data-diff-id=\"2\" data-diff-type=\"compliant\">\nStringBuilder sb = new StringBuilder();\n...\nif (sb.isEmpty()) { /* … */ }\n</pre>",
    "moreInfo_ko": "<h3>문서</h3>\n<ul>\n  <li> Java 문서 - <a href=\"https://docs.oracle.com/javase/7/docs/api/java/lang/String.html#isEmpty()\">java.lang.String.isEmpty() 메서드</a> </li>\n</ul>"
  },
  {
    "id": "S120",
    "key": "java:S120",
    "name": "Package names should comply with a naming convention",
    "type": "code-smell",
    "severity": "minor",
    "tags": [
      "convention"
    ],
    "why": "<p>Shared naming conventions improve readability and allow teams to collaborate efficiently. This rule checks that all package names match a provided\nregular expression.</p>",
    "howToFix": "<p>Rename packages with the expected naming convention</p>\n\n<h4>Noncompliant code example</h4>\n<p>With the default regular expression <code>^[a-z_]+(\\.[a-z_][a-z0-9_]*)*$</code>:</p>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\npackage org.exAmple; // Noncompliant\n</pre>\n<h4>Compliant solution</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\npackage org.example;\n</pre>",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "패키지 이름은 명명 규칙을 준수해야 합니다",
    "why_ko": "<p>공유된 명명 규칙은 가독성을 향상시키고 팀이 효율적으로 협업할 수 있게 해줍니다. 이 규칙은 모든 패키지 이름이 제공된 정규 표현식과 일치하는지 확인합니다.</p>",
    "howToFix_ko": "<p>예상되는 명명 규칙에 맞게 패키지 이름을 변경하세요</p>\n\n<h4>규칙을 준수하지 않는 코드 예시</h4>\n<p>기본 정규 표현식 <code>^[a-z_]+(\\.[a-z_][a-z0-9_]*)*$</code>의 경우:</p>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\npackage org.exAmple; // 규칙 위반\n</pre>\n<h4>규칙을 준수하는 해결책</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\npackage org.example;\n</pre>",
    "moreInfo_ko": ""
  },
  {
    "id": "S6876",
    "key": "java:S6876",
    "name": "Reverse iteration should utilize reversed view",
    "type": "code-smell",
    "severity": "critical",
    "tags": [
      "java21"
    ],
    "why": "<p>Java 21 introduces the new Sequenced Collections API, which is applicable to all collections with a defined sequence on their elements, such as\n<code>LinkedList</code>, <code>TreeSet</code>, and others (see <a href=\"https://openjdk.org/jeps/431\">JEP 431</a>). For projects using Java 21 and\nonwards, this API should be utilized instead of workaround implementations that were necessary before Java 21.</p>\n<p>This rule reports when a collection is iterated in reverse through explicit implementation or workarounds, instead of using the reversed view of\nthe collection.</p>",
    "howToFix": "<p>Replace the reported statement with a forward-iteration over the reversed view of the collection.</p>\n\n<h4>Noncompliant code example</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\nvoid printLastToFirst(List&lt;String&gt; list) {\n  for (var it = list.listIterator(list.size()); it.hasPrevious();) {\n    var element = it.previous();\n    System.out.println(element);\n  }\n}\n</pre>\n<h4>Compliant solution</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\nvoid printLastToFirst(List&lt;String&gt; list) {\n  for (var element: list.reversed()) {\n    System.out.println(element);\n  }\n}\n</pre>",
    "moreInfo": "<h3>Documentation</h3>\n<ul>\n  <li> Java Documentation - <a href=\"https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/util/SequencedCollection.html\">Interface\n  SequencedCollection</a> </li>\n  <li> OpenJDK - <a href=\"https://openjdk.org/jeps/431\">JEP 431: Sequenced Collections</a> </li>\n  <li> Java Documentation - <a\n  href=\"https://docs.oracle.com/en/java/javase/21/core/creating-sequenced-collections-sets-and-maps.html#GUID-DCFE1D88-A0F5-47DE-A816-AEDA50B97523\">Creating Sequenced Collections, Sets, and Maps</a> </li>\n</ul>",
    "status": "READY",
    "name_ko": "역방향 반복은 reversed 뷰를 활용해야 합니다",
    "why_ko": "<p>Java 21은 <code>LinkedList</code>, <code>TreeSet</code> 등과 같이 요소에 정의된 순서가 있는 모든 컬렉션에 적용할 수 있는 새로운 Sequenced Collections API를 도입합니다(<a href=\"https://openjdk.org/jeps/431\">JEP 431</a> 참조). Java 21 이상을 사용하는 프로젝트의 경우 Java 21 이전에 필요했던 우회 구현 대신 이 API를 활용해야 합니다.</p>\n<p>이 규칙은 컬렉션의 reversed 뷰를 사용하는 대신 명시적 구현이나 우회 방법을 통해 역방향으로 반복할 때 보고합니다.</p>","howToFix_ko": "<p>보고된 문을 컬렉션의 reversed 뷰에 대한 정방향 반복으로 교체하세요.</p>\n\n<h4>규칙을 준수하지 않는 코드 예시</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\nvoid printLastToFirst(List&lt;String&gt; list) {\n  for (var it = list.listIterator(list.size()); it.hasPrevious();) {\n    var element = it.previous();\n    System.out.println(element);\n  }\n}\n</pre>\n<h4>규칙을 준수하는 해결책</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\nvoid printLastToFirst(List&lt;String&gt; list) {\n  for (var element: list.reversed()) {\n    System.out.println(element);\n  }\n}\n</pre>",
    "moreInfo_ko": "<h3>문서</h3>\n<ul>\n  <li> Java 문서 - <a href=\"https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/util/SequencedCollection.html\">SequencedCollection 인터페이스</a> </li>\n  <li> OpenJDK - <a href=\"https://openjdk.org/jeps/431\">JEP 431: Sequenced Collections</a> </li>\n  <li> Java 문서 - <a href=\"https://docs.oracle.com/en/java/javase/21/core/creating-sequenced-collections-sets-and-maps.html#GUID-DCFE1D88-A0F5-47DE-A816-AEDA50B97523\">Sequenced Collections, Sets, Maps 생성하기</a> </li>\n</ul>"
  },
  {
    "id": "S3398",
    "key": "java:S3398",
    "name": "\"private\" methods called only by inner classes should be moved to those classes",
    "type": "code-smell",
    "severity": "minor",
    "tags": [
      "confusing"
    ],
    "why": "<p>When a <code>private</code> method is only invoked by an inner class, there's no reason not to move it into that class. It will still have the same\naccess to the outer class' members, but the outer class will be clearer and less cluttered.</p>\n<h3>Noncompliant code example</h3>\n<pre>\npublic class Outie {\n  private int i=0;\n\n  private void increment() {  // Noncompliant\n    i++;\n  }\n\n  public class Innie {\n    public void doTheThing() {\n      Outie.this.increment();\n    }\n  }\n}\n</pre>\n<h3>Compliant solution</h3>\n<pre>\npublic class Outie {\n  private int i=0;\n\n  public class Innie {\n    public void doTheThing() {\n      increment();\n    }\n\n    private void increment() {\n      Outie.this.i++;\n    }\n  }\n}\n</pre>",
    "howToFix": "",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "내부 클래스에서만 호출되는 \"private\" 메서드는 해당 클래스로 이동해야 합니다",
    "why_ko": "<p><code>private</code> 메서드가 내부 클래스에서만 호출되는 경우, 해당 클래스로 이동하지 않을 이유가 없습니다. 외부 클래스의 멤버에 대해 동일한 접근 권한을 가지면서도 외부 클래스는 더 명확하고 덜 복잡해집니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\npublic class Outie {\n  private int i=0;\n\n  private void increment() {  // 규칙 위반\n    i++;\n  }\n\n  public class Innie {\n    public void doTheThing() {\n      Outie.this.increment();\n    }\n  }\n}\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre>\npublic class Outie {\n  private int i=0;\n\n  public class Innie {\n    public void doTheThing() {\n      increment();\n    }\n\n    private void increment() {\n      Outie.this.i++;\n    }\n  }\n}\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": ""
  },
  {
    "id": "S2970",
    "key": "java:S2970",
    "name": "Assertions should be complete",
    "type": "code-smell",
    "severity": "blocker",
    "tags": [
      "tests",
      "assertj",
      "mockito"
    ],
    "why": "<p>It is very easy to write incomplete assertions when using some test frameworks. This rule enforces complete assertions in the following cases:</p>\n<ul>\n  <li> Fest: <code>assertThat</code> is not followed by an assertion invocation </li>\n  <li> AssertJ: <code>assertThat</code> is not followed by an assertion invocation </li>\n  <li> Mockito: <code>verify</code> is not followed by a method invocation </li>\n  <li> Truth: <code>assertXXX</code> is not followed by an assertion invocation </li>\n</ul>\n<p>In such cases, what is intended to be a test doesn't actually verify anything</p>\n<h3>Noncompliant code example</h3>\n<pre>\n// Fest\nboolean result = performAction();\n// let's now check that result value is true\nassertThat(result); // Noncompliant; nothing is actually checked, the test passes whether \"result\" is true or false\n\n// Mockito\nList mockedList = Mockito.mock(List.class);\nmockedList.add(\"one\");\nmockedList.clear();\n// let's check that \"add\" and \"clear\" methods are actually called\nMockito.verify(mockedList); // Noncompliant; nothing is checked here, oups no call is chained to verify()\n</pre>\n<h3>Compliant solution</h3>\n<pre>\n// Fest\nboolean result = performAction();\n// let's now check that result value is true\nassertThat(result).isTrue();\n\n// Mockito\nList mockedList = Mockito.mock(List.class);\nmockedList.add(\"one\");\nmockedList.clear();\n// let's check that \"add\" and \"clear\" methods are actually called\nMockito.verify(mockedList).add(\"one\");\nMockito.verify(mockedList).clear();\n</pre>\n<h3>Exceptions</h3>\n<p>Variable assignments and return statements are skipped to allow helper methods.</p>\n<pre>\nprivate BooleanAssert check(String filename, String key) {\n  String fileContent = readFileContent(filename);\n  performReplacements(fileContent);\n  return assertThat(fileContent.contains(key)); // No issue is raised here\n}\n\n@Test\npublic void test() {\n  check(\"foo.txt\", \"key1\").isTrue();\n  check(\"bar.txt\", \"key2\").isTrue();\n}\n</pre>",
    "howToFix": "",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "Assertion은 완전해야 합니다",
    "why_ko": "<p>일부 테스트 프레임워크를 사용할 때 불완전한 assertion을 작성하기 매우 쉽습니다. 이 규칙은 다음 경우에 완전한 assertion을 강제합니다:</p>\n<ul>\n  <li> Fest: <code>assertThat</code> 뒤에 assertion 호출이 없음 </li>\n  <li> AssertJ: <code>assertThat</code> 뒤에 assertion 호출이 없음 </li>\n  <li> Mockito: <code>verify</code> 뒤에 메서드 호출이 없음 </li>\n  <li> Truth: <code>assertXXX</code> 뒤에 assertion 호출이 없음 </li>\n</ul>\n<p>이러한 경우 테스트하려는 것이 실제로 아무것도 검증하지 않습니다</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\n// Fest\nboolean result = performAction();\n// 이제 result 값이 true인지 확인합니다\nassertThat(result); // 규칙 위반; 실제로 아무것도 확인되지 않으며, \"result\"가 true든 false든 테스트가 통과합니다\n\n// Mockito\nList mockedList = Mockito.mock(List.class);\nmockedList.add(\"one\");\nmockedList.clear();\n// \"add\"와 \"clear\" 메서드가 실제로 호출되었는지 확인합니다\nMockito.verify(mockedList); // 규칙 위반; 여기서 아무것도 확인되지 않으며, verify()에 체인된 호출이 없습니다\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre>\n// Fest\nboolean result = performAction();\n// 이제 result 값이 true인지 확인합니다\nassertThat(result).isTrue();\n\n// Mockito\nList mockedList = Mockito.mock(List.class);\nmockedList.add(\"one\");\nmockedList.clear();\n// \"add\"와 \"clear\" 메서드가 실제로 호출되었는지 확인합니다\nMockito.verify(mockedList).add(\"one\");\nMockito.verify(mockedList).clear();\n</pre>\n<h3>예외</h3>\n<p>헬퍼 메서드를 허용하기 위해 변수 할당 및 return 문은 건너뜁니다.</p>\n<pre>\nprivate BooleanAssert check(String filename, String key) {\n  String fileContent = readFileContent(filename);\n  performReplacements(fileContent);\n  return assertThat(fileContent.contains(key)); // 여기서는 문제가 제기되지 않습니다\n}\n\n@Test\npublic void test() {\n  check(\"foo.txt\", \"key1\").isTrue();\n  check(\"bar.txt\", \"key2\").isTrue();\n}\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": ""
  },
  {
    "id": "S2589",
    "key": "java:S2589",
    "name": "Boolean expressions should not be gratuitous",
    "type": "code-smell",
    "severity": "major",
    "tags": [
      "cwe",
      "symbolic-execution",
      "suspicious",
      "redundant"
    ],
    "why": "<p>Control flow constructs like <code>if</code>-statements allow the programmer to direct the flow of a program depending on a boolean expression.\nHowever, if the condition is always true or always false, only one of the branches will ever be executed. In that case, the control flow construct and\nthe condition no longer serve a purpose; they become <em>gratuitous</em>.</p>\n<h3>What is the potential impact?</h3>\n<p>The presence of gratuitous conditions can indicate a logical error. For example, the programmer <em>intended</em> to have the program branch into\ndifferent paths but made a mistake when formulating the branching condition. In this case, this issue might result in a bug and thus affect the\nreliability of the application. For instance, it might lead to the computation of incorrect results.</p>\n<p>Additionally, gratuitous conditions and control flow constructs introduce unnecessary complexity. The source code becomes harder to understand, and\nthus, the application becomes more difficult to maintain.</p>",
    "howToFix": "<p>Gratuitous boolean expressions are suspicious and should be carefully removed from the code.</p>\n<p>First, the boolean expression in question should be closely inspected for logical errors. If a mistake was made, it can be corrected so the\ncondition is no longer gratuitous.</p>\n<p>If it becomes apparent that the condition is actually unnecessary, it can be removed. The associated control flow construct (e.g., the\n<code>if</code>-statement containing the condition) will be adapted or even removed, leaving only the necessary branches.</p>\n\n<h4>Noncompliant code example</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\npublic class MyClass {\n    public void doThings(boolean b, boolean c) {\n        a = true;\n        if (a) {                // Noncompliant\n          doSomething();\n        }\n\n        if (b &amp;&amp; a) {           // Noncompliant; \"a\" is always \"true\"\n          doSomething();\n        }\n\n        if (c || !a) {          // Noncompliant; \"!a\" is always \"false\"\n          doSomething();\n        }\n\n        if (c || (!c &amp;&amp; b)) {   // Noncompliant; c || (!c &amp;&amp; b) is equal to c || b\n          doSomething();\n        }\n    }\n}\n</pre>\n<h4>Compliant solution</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\npublic class MyClass {\n    public void doThings(boolean b, boolean c) {\n        a = true;\n        if (foo(a)) {\n          doSomething();\n        }\n\n        if (b) {\n          doSomething();\n        }\n\n        if (c) {\n          doSomething();\n        }\n\n        if (c || b) {\n          doSomething();\n        }\n    }\n}\n</pre>",
    "moreInfo": "<h3>Articles &amp; blog posts</h3>\n<ul>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/571\">CWE-571 - Expression is Always True</a> </li>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/570\">CWE-570 - Expression is Always False</a> </li>\n</ul>",
    "status": "READY",
    "name_ko": "Boolean 표현식은 불필요하게 사용되면 안 됩니다",
    "why_ko": "<p><code>if</code>-문과 같은 제어 흐름 구조는 프로그래머가 불리언 표현식에 따라 프로그램의 흐름을 지시할 수 있게 합니다. 그러나 조건이 항상 true이거나 항상 false이면 분기 중 하나만 실행됩니다. 이 경우 제어 흐름 구조와 조건은 더 이상 목적을 달성하지 못하며 <em>불필요</em>해집니다.</p>\n<h3>잠재적인 영향은 무엇인가요?</h3>\n<p>불필요한 조건의 존재는 논리적 오류를 나타낼 수 있습니다. 예를 들어, 프로그래머가 프로그램이 다른 경로로 분기하도록 <em>의도</em>했지만 분기 조건을 공식화할 때 실수를 저질렀습니다. 이 경우 이 문제는 버그로 이어져 애플리케이션의 신뢰성에 영향을 미칠 수 있습니다. 예를 들어, 잘못된 결과의 계산으로 이어질 수 있습니다.</p>\n<p>또한 불필요한 조건과 제어 흐름 구조는 불필요한 복잡성을 도입합니다. 소스 코드는 이해하기 어려워지고, 따라서 애플리케이션은 유지보수하기 더 어려워집니다.</p>",
    "howToFix_ko": "<p>불필요한 불리언 표현식은 의심스러우며 코드에서 신중하게 제거해야 합니다.</p>\n<p>먼저 해당 불리언 표현식을 논리적 오류에 대해 면밀히 검사해야 합니다. 실수가 발견되면 조건이 더 이상 불필요하지 않도록 수정할 수 있습니다.</p>\n<p>조건이 실제로 불필요하다는 것이 분명해지면 제거할 수 있습니다. 관련 제어 흐름 구조(예: 조건을 포함하는 <code>if</code>-문)는 조정되거나 심지어 제거되어 필요한 분기만 남게 됩니다.</p>\n\n<h4>규칙을 준수하지 않는 코드 예시</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\npublic class MyClass {\n    public void doThings(boolean b, boolean c) {\n        a = true;\n        if (a) {                // 규칙 위반\n          doSomething();\n        }\n\n        if (b &amp;&amp; a) {           // 규칙 위반; \"a\"는 항상 \"true\"\n          doSomething();\n        }\n\n        if (c || !a) {          // 규칙 위반; \"!a\"는 항상 \"false\"\n          doSomething();\n        }\n\n        if (c || (!c &amp;&amp; b)) {   // 규칙 위반; c || (!c &amp;&amp; b)는 c || b와 동일\n          doSomething();\n        }\n    }\n}\n</pre>\n<h4>규칙을 준수하는 해결책</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\npublic class MyClass {\n    public void doThings(boolean b, boolean c) {\n        a = true;\n        if (foo(a)) {\n          doSomething();\n        }\n\n        if (b) {\n          doSomething();\n        }\n\n        if (c) {\n          doSomething();\n        }\n\n        if (c || b) {\n          doSomething();\n        }\n    }\n}\n</pre>",
    "moreInfo_ko": "<h3>기사 및 블로그 포스트</h3>\n<ul>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/571\">CWE-571 - 표현식이 항상 True</a> </li>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/570\">CWE-570 - 표현식이 항상 False</a> </li>\n</ul>"
  },
  {
    "id": "S1448",
    "key": "java:S1448",
    "name": "Classes should not have too many methods",
    "type": "code-smell",
    "severity": "major",
    "tags": [
      "brain-overload"
    ],
    "why": "<p>A class that grows too much tends to aggregate too many responsibilities and inevitably becomes harder to understand and therefore to maintain.\nAbove a specific threshold, it is strongly advised to refactor the class into smaller ones which focus on well defined topics.</p>",
    "howToFix": "",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "클래스에 너무 많은 메서드가 있으면 안 됩니다",
    "why_ko": "<p>너무 커진 클래스는 너무 많은 책임을 모으는 경향이 있으며 필연적으로 이해하기 어렵고 따라서 유지보수하기 어려워집니다.\n특정 임계값을 초과하면 잘 정의된 주제에 집중하는 더 작은 클래스로 리팩토링하는 것이 강력히 권장됩니다.</p>",
    "howToFix_ko": "",
    "moreInfo_ko": ""
  },
  {
    "id": "S5958",
    "key": "java:S5958",
    "name": "AssertJ \"assertThatThrownBy\" should not be used alone",
    "type": "code-smell",
    "severity": "major",
    "tags": [
      "tests",
      "assertj"
    ],
    "why": "<p>Unlike similar AssertJ methods testing exceptions (<code>assertThatCode()</code>, <code>assertThatExceptionOfType()</code>, …​), the\n<code>assertThatThrownBy()</code> method can be used alone, failing if the code did not raise any exception.</p>\n<p>Still, only testing that an exception was raised is not enough to guarantee that it was the expected one, and you should test the exception type or\ncontent further. In addition, it will make explicit what you are expecting, without relying on side-effects.</p>\n<p>This rule raises an issue when <code>assertThatThrownBy</code> is used, without testing the exception further.</p>\n<h3>Noncompliant code example</h3>\n<pre>\nassertThatThrownBy(() -&gt; shouldThrow()); // Noncompliant, is it really the exception you expected?\n</pre>\n<h3>Compliant solution</h3>\n<pre>\nassertThatThrownBy(() -&gt; shouldThrow()).isInstanceOf(IOException.class);\n//or\nassertThatThrownBy(() -&gt; shouldThrow()).hasMessage(\"My exception\");\n</pre>",
    "howToFix": "",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "AssertJ의 \"assertThatThrownBy\"는 단독으로 사용하면 안 됩니다",
    "why_ko": "<p>예외를 테스트하는 유사한 AssertJ 메서드(<code>assertThatCode()</code>, <code>assertThatExceptionOfType()</code>, …)와 달리 <code>assertThatThrownBy()</code> 메서드는 코드가 예외를 발생시키지 않으면 실패하면서 단독으로 사용될 수 있습니다.</p>\n<p>그러나 예외가 발생했는지만 테스트하는 것은 예상한 예외인지 보장하기에 충분하지 않으며, 예외 유형이나 내용을 추가로 테스트해야 합니다. 또한, 부작용에 의존하지 않고 기대하는 바를 명시적으로 만듭니다.</p>\n<p>이 규칙은 <code>assertThatThrownBy</code>가 예외를 추가로 테스트하지 않고 사용될 때 문제를 제기합니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\nassertThatThrownBy(() -&gt; shouldThrow()); // 규칙 위반, 정말 예상한 예외인가요?\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre>\nassertThatThrownBy(() -&gt; shouldThrow()).isInstanceOf(IOException.class);\n// 또는\nassertThatThrownBy(() -&gt; shouldThrow()).hasMessage(\"My exception\");\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": ""
  },
  {
    "id": "S6362",
    "key": "java:S6362",
    "name": "Enabling JavaScript support for WebViews is security-sensitive",
    "type": "security-hotspot",
    "severity": "major",
    "tags": [
      "cwe",
      "android"
    ],
    "why": "<p>WebViews can be used to display web content as part of a mobile application. A browser engine is used to render and display the content. Like a web\napplication, a mobile application that uses WebViews can be vulnerable to Cross-Site Scripting if untrusted code is rendered. In the context of a\nWebView, JavaScript code can exfiltrate local files that might be sensitive or even worse, access exposed functions of the application that can result\nin more severe vulnerabilities such as code injection. Thus JavaScript support should not be enabled for WebViews unless it is absolutely necessary\nand the authenticity of the web resources can be guaranteed.</p>\n",
    "howToFix": "<h2>Recommended Secure Coding Practices</h2>\n<p>It is recommended to disable JavaScript support for WebViews unless it is necessary to execute JavaScript code. Only trusted pages should be\nrendered.</p>\n<h2>Compliant Solution</h2>\n<pre>\nimport android.webkit.WebView;\n\nWebView webView = (WebView) findViewById(R.id.webview);\nwebView.getSettings().setJavaScriptEnabled(false);\n</pre>\n<h2>See</h2>\n<ul>\n  <li> OWASP - <a href=\"https://owasp.org/Top10/A03_2021-Injection/\">Top 10 2021 Category A3 - Injection</a> </li>\n  <li> OWASP - <a href=\"https://owasp.org/www-project-top-ten/2017/A6_2017-Security_Misconfiguration\">Top 10 2017 Category A6 - Security\n  Misconfiguration</a> </li>\n  <li> OWASP - <a href=\"https://owasp.org/www-project-top-ten/2017/A7_2017-Cross-Site_Scripting_(XSS)\">Top 10 2017 Category A7 - Cross-Site Scripting\n  (XSS)</a> </li>\n  <li> OWASP - <a href=\"https://owasp.org/www-project-mobile-top-10/2023-risks/m8-security-misconfiguration\">Mobile Top 10 2024 Category M8 - Security\n  Misconfiguration</a> </li>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/79\">CWE-79 - Improper Neutralization of Input During Web Page Generation ('Cross-site\n  Scripting')</a> </li>\n</ul>\n<h3>Related rules</h3>\n<ul>\n  <li> <a href='/coding_rules#rule_key=java%3AS7409'>S7409</a> - Exposing Java objects through JavaScript interfaces is security-sensitive </li>\n</ul>",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "WebView에서 JavaScript 지원을 활성화하는 것은 보안에 민감합니다",
    "why_ko": "<p>WebView는 모바일 애플리케이션의 일부로 웹 콘텐츠를 표시하는 데 사용할 수 있습니다. 브라우저 엔진을 사용하여 콘텐츠를 렌더링하고 표시합니다. 웹 애플리케이션과 마찬가지로 WebView를 사용하는 모바일 애플리케이션은 신뢰할 수 없는 코드가 렌더링되면 크로스 사이트 스크립팅에 취약할 수 있습니다. WebView 컨텍스트에서 JavaScript 코드는 민감할 수 있는 로컬 파일을 유출하거나 더 심각하게는 코드 인젝션과 같은 더 심각한 취약점을 초래할 수 있는 애플리케이션의 노출된 함수에 접근할 수 있습니다. 따라서 JavaScript 코드 실행이 절대적으로 필요하고 웹 리소스의 진위가 보장될 수 있는 경우가 아니면 WebView에서 JavaScript 지원을 활성화하면 안 됩니다.</p>\n",
    "howToFix_ko": "<h2>권장 보안 코딩 관행</h2>\n<p>JavaScript 코드를 실행해야 하는 경우가 아니면 WebView에서 JavaScript 지원을 비활성화하는 것이 권장됩니다. 신뢰할 수 있는 페이지만 렌더링해야 합니다.</p>\n<h2>규칙을 준수하는 해결책</h2>\n<pre>\nimport android.webkit.WebView;\n\nWebView webView = (WebView) findViewById(R.id.webview);\nwebView.getSettings().setJavaScriptEnabled(false);\n</pre>\n<h2>참고</h2>\n<ul>\n  <li> OWASP - <a href=\"https://owasp.org/Top10/A03_2021-Injection/\">Top 10 2021 Category A3 - 인젝션</a> </li>\n  <li> OWASP - <a href=\"https://owasp.org/www-project-top-ten/2017/A6_2017-Security_Misconfiguration\">Top 10 2017 Category A6 - 보안 구성 오류</a> </li>\n  <li> OWASP - <a href=\"https://owasp.org/www-project-top-ten/2017/A7_2017-Cross-Site_Scripting_(XSS)\">Top 10 2017 Category A7 - 크로스 사이트 스크립팅(XSS)</a> </li>\n  <li> OWASP - <a href=\"https://owasp.org/www-project-mobile-top-10/2023-risks/m8-security-misconfiguration\">Mobile Top 10 2024 Category M8 - 보안 구성 오류</a> </li>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/79\">CWE-79 - 웹 페이지 생성 중 입력의 부적절한 무력화('크로스 사이트 스크립팅')</a> </li>\n</ul>\n<h3>관련 규칙</h3>\n<ul>\n  <li> <a href='/coding_rules#rule_key=java%3AS7409'>S7409</a> - JavaScript 인터페이스를 통해 Java 객체를 노출하는 것은 보안에 민감합니다 </li>\n</ul>",
    "moreInfo_ko": ""
  },
  {
    "id": "S4426",
    "key": "java:S4426",
    "name": "Cryptographic keys should be robust",
    "type": "vulnerability",
    "severity": "critical",
    "tags": [
      "cwe",
      "privacy",
      "rules"
    ],
    "why": "<p>Encryption algorithms are essential for protecting sensitive information and ensuring secure communications in a variety of domains. They are used\nfor several important reasons:</p>\n<ul>\n  <li> Confidentiality, privacy, and intellectual property protection </li>\n  <li> Security during transmission or on storage devices </li>\n  <li> Data integrity, general trust, and authentication </li>\n</ul>\n<p>When selecting encryption algorithms, tools, or combinations, you should also consider two things:</p>\n<ol>\n  <li> No encryption is unbreakable. </li>\n  <li> The strength of an encryption algorithm is usually measured by the effort required to crack it within a reasonable time frame. </li>\n</ol>\n<p>In today's cryptography, the length of the <strong>key</strong> directly affects the security level of cryptographic algorithms.</p>\n<p>Note that depending on the algorithm, the term <strong>key</strong> refers to a different mathematical property. For example:</p>\n<ul>\n  <li> For RSA, the key is the product of two large prime numbers, also called the <strong>modulus</strong>. </li>\n  <li> For Elliptic Curve Cryptography (ECC), the key is only a sequence of randomly generated bytes.\n    <ul>\n      <li> In some cases, keys are derived from a master key or a passphrase using a Key Derivation Function (KDF) like PBKDF2 (Password-Based Key\n      Derivation Function 2) </li>\n    </ul>  </li>\n</ul>\n<p>If an application uses a key that is considered short and <strong>insecure</strong>, the encrypted data is exposed to attacks aimed at getting at\nthe plaintext.</p>\n<p>In general, it is best practice to expect a breach: that a user or organization with malicious intent will perform cryptographic attacks on this\ndata after obtaining it by other means.</p>\n<h3>What is the potential impact?</h3>\n<p>After retrieving encrypted data and performing cryptographic attacks on it on a given timeframe, attackers can recover the plaintext that\nencryption was supposed to protect.</p>\n<p>Depending on the recovered data, the impact may vary.</p>\n<p>Below are some real-world scenarios that illustrate the potential impact of an attacker exploiting the vulnerability.</p>\n<h4>Additional attack surface</h4>\n<p>By modifying the plaintext of the encrypted message, an attacker may be able to trigger additional vulnerabilities in the code. An attacker can\nfurther exploit a system to obtain more information.<br> Encrypted values are often considered trustworthy because it would not be possible for a\nthird party to modify them under normal circumstances.</p>\n<h4>Breach of confidentiality and privacy</h4>\n<p>When encrypted data contains personal or sensitive information, its retrieval by an attacker can lead to privacy violations, identity theft,\nfinancial loss, reputational damage, or unauthorized access to confidential systems.</p>\n<p>In this scenario, the company, its employees, users, and partners could be seriously affected.</p>\n<p>The impact is twofold, as data breaches and exposure of encrypted data can undermine trust in the organization, as customers, clients and\nstakeholders may lose confidence in the organization's ability to protect their sensitive data.</p>\n<h4>Legal and compliance issues</h4>\n<p>In many industries and locations, there are legal and compliance requirements to protect sensitive data. If encrypted data is compromised and the\nplaintext can be recovered, companies face legal consequences, penalties, or violations of privacy laws.</p>",
    "howToFix": "<p>The following code examples either explicitly or implicitly generate keys. Note that there are differences in the size of the keys depending on the\nalgorithm.</p>\n<p>Due to the mathematical properties of the algorithms, the security requirements for the key size vary depending on the algorithm.<br> For example,\na 256-bit ECC key provides about the same level of security as a 3072-bit RSA key and a 128-bit symmetric key.</p>\n<h4>Noncompliant code example</h4>\n<p>Here is an example of a private key generation with RSA:</p>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\nimport java.security.KeyPairGenerator;\nimport java.security.NoSuchAlgorithmException;\n\npublic static void main(String[] args) {\n    try {\n        KeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance(\"RSA\");\n        keyPairGenerator.initialize(1024); // Noncompliant\n\n    } catch (NoSuchAlgorithmException e) {\n        // ...\n    }\n}\n</pre>\n<p>Here is an example of an Elliptic Curve (EC) initialization. It implicitly generates a private key whose size is indicated in the elliptic curve\nname:</p>\n<pre data-diff-id=\"3\" data-diff-type=\"noncompliant\">\nimport java.security.KeyPairGenerator;\nimport java.security.NoSuchAlgorithmException;\nimport java.security.InvalidAlgorithmParameterException;\nimport java.security.spec.ECGenParameterSpec;\n\npublic static void main(String[] args) {\n    try {\n        KeyPairGenerator keyPairGenerator    = KeyPairGenerator.getInstance(\"EC\");\n        ECGenParameterSpec ellipticCurveName = new ECGenParameterSpec(\"secp112r1\"); // Noncompliant\n        keyPairGenerator.initialize(ellipticCurveName);\n\n    } catch (NoSuchAlgorithmException | InvalidAlgorithmParameterException e) {\n        // ...\n    }\n}\n</pre>\n<h4>Compliant solution</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\nimport java.security.KeyPairGenerator;\nimport java.security.NoSuchAlgorithmException;\n\npublic static void main(String[] args) {\n    try {\n        KeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance(\"RSA\");\n        keyPairGenerator.initialize(2048);\n\n    } catch (NoSuchAlgorithmException e) {\n        // ...\n    }\n}\n</pre>\n<pre data-diff-id=\"3\" data-diff-type=\"compliant\">\nimport java.security.KeyPairGenerator;\nimport java.security.NoSuchAlgorithmException;\nimport java.security.InvalidAlgorithmParameterException;\nimport java.security.spec.ECGenParameterSpec;\n\npublic static void main(String[] args) {\n    try {\n        KeyPairGenerator keyPairGenerator    = KeyPairGenerator.getInstance(\"EC\");\n        ECGenParameterSpec ellipticCurveName = new ECGenParameterSpec(\"secp256r1\");\n        keyPairGenerator.initialize(ellipticCurveName);\n\n    } catch (NoSuchAlgorithmException | InvalidAlgorithmParameterException e) {\n        // ...\n    }\n}\n</pre>\n<h3>How does this work?</h3>\n<p>As a rule of thumb, use the cryptographic algorithms and mechanisms that are considered strong by the cryptography community.</p>\n<p>The appropriate choices are the following.</p>\n<h4>RSA (Rivest-Shamir-Adleman) and DSA (Digital Signature Algorithm)</h4>\n<p>The security of these algorithms depends on the difficulty of attacks attempting to solve their underlying mathematical problem.</p>\n<p>In general, a minimum key size of <strong>2048</strong> bits is recommended for both. It provides 112 bits of security. A key length of\n<strong>3072</strong> or <strong>4096</strong> should be preferred when possible.</p>\n<h4>Elliptic Curve Cryptography (ECC)</h4>\n<p>Elliptic curve cryptography is also used in various algorithms, such as ECDSA, ECDH, or ECMQV. The length of keys generated with elliptic curve\nalgorithms is mentioned directly in their names. For example, <code>secp256k1</code> generates a 256-bits long private key.</p>\n<p>Currently, a minimum key size of <strong>224 bits</strong> is recommended for EC-based algorithms.</p>\n<p>Additionally, some curves that theoretically provide sufficiently long keys are still discouraged. This can be because of a flaw in the curve\nparameters, a bad overall design, or poor performance. It is generally advised to use a NIST-approved elliptic curve wherever possible. Such curves\ncurrently include:</p>\n<ul>\n  <li> NIST P curves with a size of at least 224 bits, e.g. secp256r1. </li>\n  <li> Curve25519, generally known as ed25519 or x25519 depending on its application. </li>\n  <li> Curve448. </li>\n  <li> Brainpool curves with a size of at least 224 bits, e.g. brainpoolP224r1 </li>\n</ul>\n<h3>Going the extra mile</h3>\n<h4>Pre-Quantum Cryptography</h4>\n<p>Encrypted data and communications recorded today could be decrypted in the future by an attack from a quantum computer.<br> It is important to keep\nin mind that NIST-approved digital signature schemes, key agreement, and key transport may need to be replaced with secure quantum-resistant (or\n\"post-quantum\") counterpart.</p>\n<p>Thus, if data is to remain secure beyond 2030, proactive measures should be taken now to ensure its safety.</p>\n<p><a href=\"https://www.enisa.europa.eu/publications/post-quantum-cryptography-current-state-and-quantum-mitigation\">Learn more here</a>.</p>",
    "moreInfo": "<ul>\n  <li> Documentation\n    <ul>\n      <li> NIST Documentation - <a href=\"https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-186.pdf\">NIST SP 800-186: Recommendations\n      for Discrete Logarithm-based Cryptography: Elliptic Curve Domain Parameters</a> </li>\n      <li> IETF - <a href=\"https://datatracker.ietf.org/doc/html/rfc5639\">rfc5639: Elliptic Curve Cryptography (ECC) Brainpool Standard Curves and\n      Curve Generation</a> </li>\n    </ul>  </li>\n</ul>\n<h3>Articles &amp; blog posts</h3>\n<ul>\n  <li> <a href=\"https://learn.microsoft.com/en-us/dotnet/standard/security/vulnerabilities-cbc-mode\">Microsoft, Timing vulnerabilities with CBC-mode\n  symmetric decryption using padding</a> </li>\n  <li> <a href=\"https://en.wikipedia.org/wiki/Padding_oracle_attack\">Wikipedia, Padding Oracle Attack</a> </li>\n  <li> <a href=\"https://en.wikipedia.org/wiki/Chosen-ciphertext_attack\">Wikipedia, Chosen-Ciphertext Attack</a> </li>\n  <li> <a href=\"https://en.wikipedia.org/wiki/Chosen-plaintext_attack\">Wikipedia, Chosen-Plaintext Attack</a> </li>\n  <li> <a href=\"https://en.wikipedia.org/wiki/Semantic_security\">Wikipedia, Semantically Secure Cryptosystems</a> </li>\n  <li> <a href=\"https://en.wikipedia.org/wiki/Optimal_asymmetric_encryption_padding\">Wikipedia, OAEP</a> </li>\n  <li> <a href=\"https://en.wikipedia.org/wiki/Galois/Counter_Mode\">Wikipedia, Galois/Counter Mode</a> </li>\n</ul>\n<h3>Standards</h3>\n<ul>\n  <li> OWASP - <a href=\"https://owasp.org/Top10/A02_2021-Cryptographic_Failures/\">Top 10 2021 Category A2 - Cryptographic Failures</a> </li>\n  <li> OWASP - <a href=\"https://www.owasp.org/www-project-top-ten/2017/A3_2017-Sensitive_Data_Exposure\">Top 10 2017 Category A3 - Sensitive Data\n  Exposure</a> </li>\n  <li> OWASP - <a href=\"https://owasp.org/www-project-top-ten/2017/A6_2017-Security_Misconfiguration\">Top 10 2017 Category A6 - Security\n  Misconfiguration</a> </li>\n  <li> OWASP - <a href=\"https://mas.owasp.org/checklists/MASVS-CRYPTO/\">Mobile AppSec Verification Standard - Cryptography Requirements</a> </li>\n  <li> OWASP - <a href=\"https://owasp.org/www-project-mobile-top-10/2016-risks/m5-insufficient-cryptography\">Mobile Top 10 2016 Category M5 -\n  Insufficient Cryptography</a> </li>\n  <li> OWASP - <a href=\"https://owasp.org/www-project-mobile-top-10/2023-risks/m10-insufficient-cryptography\">Mobile Top 10 2024 Category M10 -\n  Insufficient Cryptography</a> </li>\n  <li> <a href=\"https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-131Ar1.pdf\">NIST 800-131A</a> - Recommendation for Transitioning the\n  Use of Cryptographic Algorithms and Key Lengths </li>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/326\">CWE-326 - Inadequate Encryption Strength</a> </li>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/327\">CWE-327 - Use of a Broken or Risky Cryptographic Algorithm</a> </li>\n  <li> <a href=\"https://wiki.sei.cmu.edu/confluence/x/hDdGBQ\">CERT, MSC61-J.</a> - Do not use insecure or weak cryptographic algorithms </li>\n</ul>",
    "status": "READY",
    "name_ko": "암호화 키는 충분히 강력해야 합니다",
    "why_ko": "<p>암호화 알고리즘은 다양한 도메인에서 민감한 정보를 보호하고 안전한 통신을 보장하는 데 필수적입니다. 여러 중요한 이유로 사용됩니다:</p>\n<ul>\n  <li> 기밀성, 개인정보 보호, 지적 재산 보호 </li>\n  <li> 전송 중 또는 저장 장치에서의 보안 </li>\n  <li> 데이터 무결성, 일반적인 신뢰, 인증 </li>\n</ul>\n<p>암호화 알고리즘, 도구 또는 조합을 선택할 때 두 가지를 고려해야 합니다:</p>\n<ol>\n  <li> 깨지지 않는 암호화는 없습니다. </li>\n  <li> 암호화 알고리즘의 강도는 일반적으로 합리적인 시간 내에 해독하는 데 필요한 노력으로 측정됩니다. </li>\n</ol>\n<p>오늘날의 암호화에서 <strong>키</strong>의 길이는 암호화 알고리즘의 보안 수준에 직접적으로 영향을 미칩니다.</p>\n<p>알고리즘에 따라 <strong>키</strong>라는 용어는 다른 수학적 속성을 나타냅니다. 예를 들어:</p>\n<ul>\n  <li> RSA의 경우 키는 두 개의 큰 소수의 곱이며 <strong>모듈러스</strong>라고도 합니다. </li>\n  <li> 타원 곡선 암호화(ECC)의 경우 키는 무작위로 생성된 바이트 시퀀스입니다.\n    <ul>\n      <li> 경우에 따라 키는 PBKDF2(Password-Based Key Derivation Function 2)와 같은 키 파생 함수(KDF)를 사용하여 마스터 키 또는 암호에서 파생됩니다. </li>\n    </ul>  </li>\n</ul>\n<p>애플리케이션이 짧고 <strong>안전하지 않은</strong> 것으로 간주되는 키를 사용하는 경우, 암호화된 데이터는 평문을 얻으려는 공격에 노출됩니다.</p>\n<p>일반적으로 침해를 예상하는 것이 가장 좋습니다: 악의적인 의도를 가진 사용자나 조직이 다른 수단으로 이 데이터를 획득한 후 암호화 공격을 수행할 것입니다.</p>\n<h3>잠재적 영향은 무엇인가요?</h3>\n<p>암호화된 데이터를 검색하고 주어진 시간 내에 암호화 공격을 수행한 후, 공격자는 암호화가 보호해야 했던 평문을 복구할 수 있습니다.</p>\n<p>복구된 데이터에 따라 영향은 다양할 수 있습니다.</p>\n<p>아래는 공격자가 취약점을 악용할 때의 잠재적 영향을 보여주는 실제 시나리오입니다.</p>\n<h4>추가적인 공격 표면</h4>\n<p>암호화된 메시지의 평문을 수정함으로써 공격자는 코드에서 추가적인 취약점을 유발할 수 있습니다. 공격자는 시스템을 더 악용하여 더 많은 정보를 얻을 수 있습니다.<br> 암호화된 값은 일반적인 상황에서 제3자가 수정할 수 없기 때문에 종종 신뢰할 수 있는 것으로 간주됩니다.</p>\n<h4>기밀성 및 개인정보 침해</h4>\n<p>암호화된 데이터에 개인 또는 민감한 정보가 포함되어 있는 경우, 공격자에 의한 검색은 개인정보 침해, 신원 도용, 재정적 손실, 평판 손상 또는 기밀 시스템에 대한 무단 액세스로 이어질 수 있습니다.</p>\n<p>이 시나리오에서 회사, 직원, 사용자 및 파트너가 심각하게 영향을 받을 수 있습니다.</p>\n<p>영향은 두 가지입니다. 데이터 유출 및 암호화된 데이터 노출은 조직에 대한 신뢰를 약화시킬 수 있으며, 고객 및 이해 관계자가 민감한 데이터를 보호하는 조직의 능력에 대한 신뢰를 잃을 수 있습니다.</p>\n<h4>법적 및 규정 준수 문제</h4>\n<p>많은 산업 및 지역에서 민감한 데이터를 보호하기 위한 법적 및 규정 준수 요구 사항이 있습니다. 암호화된 데이터가 손상되고 평문을 복구할 수 있는 경우 회사는 법적 결과, 처벌 또는 개인정보 보호법 위반에 직면합니다.</p>",
    "howToFix_ko": "<p>다음 코드 예제는 명시적으로 또는 암시적으로 키를 생성합니다. 알고리즘에 따라 키 크기에 차이가 있습니다.</p>\n<p>알고리즘의 수학적 속성으로 인해 키 크기에 대한 보안 요구 사항은 알고리즘에 따라 다릅니다.<br> 예를 들어 256비트 ECC 키는 3072비트 RSA 키 및 128비트 대칭 키와 거의 동일한 수준의 보안을 제공합니다.</p>\n<h4>규칙을 준수하지 않는 코드 예시</h4>\n<p>RSA를 사용한 개인 키 생성 예시입니다:</p>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\nimport java.security.KeyPairGenerator;\nimport java.security.NoSuchAlgorithmException;\n\npublic static void main(String[] args) {\n    try {\n        KeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance(\"RSA\");\n        keyPairGenerator.initialize(1024); // 규칙 위반\n\n    } catch (NoSuchAlgorithmException e) {\n        // ...\n    }\n}\n</pre>\n<p>타원 곡선(EC) 초기화 예시입니다. 타원 곡선 이름에 표시된 크기의 개인 키를 암시적으로 생성합니다:</p>\n<pre data-diff-id=\"3\" data-diff-type=\"noncompliant\">\nimport java.security.KeyPairGenerator;\nimport java.security.NoSuchAlgorithmException;\nimport java.security.InvalidAlgorithmParameterException;\nimport java.security.spec.ECGenParameterSpec;\n\npublic static void main(String[] args) {\n    try {\n        KeyPairGenerator keyPairGenerator    = KeyPairGenerator.getInstance(\"EC\");\n        ECGenParameterSpec ellipticCurveName = new ECGenParameterSpec(\"secp112r1\"); // 규칙 위반\n        keyPairGenerator.initialize(ellipticCurveName);\n\n    } catch (NoSuchAlgorithmException | InvalidAlgorithmParameterException e) {\n        // ...\n    }\n}\n</pre>\n<h4>규칙을 준수하는 해결책</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\nimport java.security.KeyPairGenerator;\nimport java.security.NoSuchAlgorithmException;\n\npublic static void main(String[] args) {\n    try {\n        KeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance(\"RSA\");\n        keyPairGenerator.initialize(2048);\n\n    } catch (NoSuchAlgorithmException e) {\n        // ...\n    }\n}\n</pre>\n<pre data-diff-id=\"3\" data-diff-type=\"compliant\">\nimport java.security.KeyPairGenerator;\nimport java.security.NoSuchAlgorithmException;\nimport java.security.InvalidAlgorithmParameterException;\nimport java.security.spec.ECGenParameterSpec;\n\npublic static void main(String[] args) {\n    try {\n        KeyPairGenerator keyPairGenerator    = KeyPairGenerator.getInstance(\"EC\");\n        ECGenParameterSpec ellipticCurveName = new ECGenParameterSpec(\"secp256r1\");\n        keyPairGenerator.initialize(ellipticCurveName);\n\n    } catch (NoSuchAlgorithmException | InvalidAlgorithmParameterException e) {\n        // ...\n    }\n}\n</pre>\n<h3>어떻게 작동하나요?</h3>\n<p>경험상 암호화 커뮤니티에서 강력하다고 간주하는 암호화 알고리즘과 메커니즘을 사용해야 합니다.</p>\n<p>적절한 선택은 다음과 같습니다.</p>\n<h4>RSA(Rivest-Shamir-Adleman) 및 DSA(Digital Signature Algorithm)</h4>\n<p>이러한 알고리즘의 보안은 기본 수학적 문제를 풀려는 공격의 어려움에 달려 있습니다.</p>\n<p>일반적으로 두 알고리즘 모두 최소 <strong>2048</strong>비트 키 크기가 권장됩니다. 이는 112비트의 보안을 제공합니다. 가능하면 <strong>3072</strong> 또는 <strong>4096</strong> 키 길이가 선호됩니다.</p>\n<h4>타원 곡선 암호화(ECC)</h4>\n<p>타원 곡선 암호화는 ECDSA, ECDH 또는 ECMQV와 같은 다양한 알고리즘에서도 사용됩니다. 타원 곡선 알고리즘으로 생성된 키의 길이는 이름에 직접 언급됩니다. 예를 들어 <code>secp256k1</code>은 256비트 길이의 개인 키를 생성합니다.</p>\n<p>현재 EC 기반 알고리즘에는 최소 <strong>224비트</strong> 키 크기가 권장됩니다.</p>\n<p>또한 이론적으로 충분히 긴 키를 제공하는 일부 곡선은 여전히 권장되지 않습니다. 이는 곡선 매개변수의 결함, 전반적인 설계 불량 또는 성능 저하 때문일 수 있습니다. 가능한 경우 NIST 승인 타원 곡선을 사용하는 것이 일반적으로 권장됩니다. 이러한 곡선에는 현재 다음이 포함됩니다:</p>\n<ul>\n  <li> 최소 224비트 크기의 NIST P 곡선(예: secp256r1) </li>\n  <li> 애플리케이션에 따라 ed25519 또는 x25519로 일반적으로 알려진 Curve25519 </li>\n  <li> Curve448 </li>\n  <li> 최소 224비트 크기의 Brainpool 곡선(예: brainpoolP224r1) </li>\n</ul>\n<h3>더 나아가기</h3>\n<h4>양자 이전 암호화</h4>\n<p>오늘날 기록된 암호화된 데이터와 통신은 미래에 양자 컴퓨터의 공격으로 해독될 수 있습니다.<br> NIST 승인 디지털 서명 체계, 키 합의 및 키 전송을 안전한 양자 저항(또는 \"포스트 양자\") 대응물로 교체해야 할 수 있다는 점을 명심해야 합니다.</p>\n<p>따라서 데이터가 2030년 이후에도 안전하게 유지되려면 지금 안전을 보장하기 위한 선제적 조치를 취해야 합니다.</p>\n<p><a href=\"https://www.enisa.europa.eu/publications/post-quantum-cryptography-current-state-and-quantum-mitigation\">여기에서 자세히 알아보세요</a>.</p>",
    "moreInfo_ko": "<ul>\n  <li> 문서\n    <ul>\n      <li> NIST 문서 - <a href=\"https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-186.pdf\">NIST SP 800-186: Recommendations for Discrete Logarithm-based Cryptography: Elliptic Curve Domain Parameters</a> </li>\n      <li> IETF - <a href=\"https://datatracker.ietf.org/doc/html/rfc5639\">rfc5639: Elliptic Curve Cryptography (ECC) Brainpool Standard Curves and Curve Generation</a> </li>\n    </ul>  </li>\n</ul>\n<h3>기사 및 블로그 게시물</h3>\n<ul>\n  <li> <a href=\"https://learn.microsoft.com/en-us/dotnet/standard/security/vulnerabilities-cbc-mode\">Microsoft, Timing vulnerabilities with CBC-mode symmetric decryption using padding</a> </li>\n  <li> <a href=\"https://en.wikipedia.org/wiki/Padding_oracle_attack\">Wikipedia, Padding Oracle Attack</a> </li>\n  <li> <a href=\"https://en.wikipedia.org/wiki/Chosen-ciphertext_attack\">Wikipedia, Chosen-Ciphertext Attack</a> </li>\n  <li> <a href=\"https://en.wikipedia.org/wiki/Chosen-plaintext_attack\">Wikipedia, Chosen-Plaintext Attack</a> </li>\n  <li> <a href=\"https://en.wikipedia.org/wiki/Semantic_security\">Wikipedia, Semantically Secure Cryptosystems</a> </li>\n  <li> <a href=\"https://en.wikipedia.org/wiki/Optimal_asymmetric_encryption_padding\">Wikipedia, OAEP</a> </li>\n  <li> <a href=\"https://en.wikipedia.org/wiki/Galois/Counter_Mode\">Wikipedia, Galois/Counter Mode</a> </li>\n</ul>\n<h3>표준</h3>\n<ul>\n  <li> OWASP - <a href=\"https://owasp.org/Top10/A02_2021-Cryptographic_Failures/\">Top 10 2021 Category A2 - Cryptographic Failures</a> </li>\n  <li> OWASP - <a href=\"https://www.owasp.org/www-project-top-ten/2017/A3_2017-Sensitive_Data_Exposure\">Top 10 2017 Category A3 - Sensitive Data Exposure</a> </li>\n  <li> OWASP - <a href=\"https://owasp.org/www-project-top-ten/2017/A6_2017-Security_Misconfiguration\">Top 10 2017 Category A6 - Security Misconfiguration</a> </li>\n  <li> OWASP - <a href=\"https://mas.owasp.org/checklists/MASVS-CRYPTO/\">Mobile AppSec Verification Standard - Cryptography Requirements</a> </li>\n  <li> OWASP - <a href=\"https://owasp.org/www-project-mobile-top-10/2016-risks/m5-insufficient-cryptography\">Mobile Top 10 2016 Category M5 - Insufficient Cryptography</a> </li>\n  <li> OWASP - <a href=\"https://owasp.org/www-project-mobile-top-10/2023-risks/m10-insufficient-cryptography\">Mobile Top 10 2024 Category M10 - Insufficient Cryptography</a> </li>\n  <li> <a href=\"https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-131Ar1.pdf\">NIST 800-131A</a> - Recommendation for Transitioning the Use of Cryptographic Algorithms and Key Lengths </li>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/326\">CWE-326 - Inadequate Encryption Strength</a> </li>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/327\">CWE-327 - Use of a Broken or Risky Cryptographic Algorithm</a> </li>\n  <li> <a href=\"https://wiki.sei.cmu.edu/confluence/x/hDdGBQ\">CERT, MSC61-J.</a> - Do not use insecure or weak cryptographic algorithms </li>\n</ul>"
  },
  {
    "id": "S4830",
    "key": "java:S4830",
    "name": "Server certificates should be verified during SSL/TLS connections",
    "type": "vulnerability",
    "severity": "critical",
    "tags": [
      "cwe",
      "privacy",
      "cert",
      "ssl"
    ],
    "why": "<p>Transport Layer Security (TLS) provides secure communication between systems over the internet by encrypting the data sent between them.\nCertificate validation adds an extra layer of trust and security to this process to ensure that a system is indeed the one it claims to be.</p>\n<p>When certificate validation is disabled, the client skips a critical security check. This creates an opportunity for attackers to pose as a trusted\nentity and intercept, manipulate, or steal the data being transmitted.</p>\n<h3>What is the potential impact?</h3>\n<p>Establishing trust in a secure way is a non-trivial task. When you disable certificate validation, you are removing a key mechanism designed to\nbuild this trust in internet communication, opening your system up to a number of potential threats.</p>\n<h4>Identity spoofing</h4>\n<p>If a system does not validate certificates, it cannot confirm the identity of the other party involved in the communication. An attacker can\nexploit this by creating a fake server and masquerading as a legitimate one. For example, they might set up a server that looks like your bank's\nserver, tricking your system into thinking it is communicating with the bank. This scenario, called identity spoofing, allows the attacker to collect\nany data your system sends to them, potentially leading to significant data breaches.</p>\n<h4>Loss of data integrity</h4>\n<p>When TLS certificate validation is disabled, the integrity of the data you send and receive cannot be guaranteed. An attacker could modify the data\nin transit, and you would have no way of knowing. This could range from subtle manipulations of the data you receive to the injection of malicious\ncode or malware into your system. The consequences of such breaches of data integrity can be severe, depending on the nature of the data and the\nsystem.</p>",
    "howToFix": "<p>The following code contains examples of disabled certificate validation.</p>\n<p>The certificate validation gets disabled by overriding <code>X509TrustManager</code> with an empty implementation. It is highly recommended to use\nthe original implementation.</p>\n<h4>Noncompliant code example</h4>\n<pre>\nclass TrustAllManager implements X509TrustManager {\n\n    @Override\n    public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {  // Noncompliant\n    }\n\n    @Override\n    public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException { // Noncompliant\n    }\n\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return null;\n    }\n}\n</pre>\n<h3>How does this work?</h3>\n<p>Addressing the vulnerability of disabled TLS certificate validation primarily involves re-enabling the default validation.</p>\n<p>To avoid running into problems with invalid certificates, consider the following sections.</p>\n<h4>Using trusted certificates</h4>\n<p>If possible, always use a certificate issued by a well-known, trusted CA for your server. Most programming environments come with a predefined list\nof trusted root CAs, and certificates issued by these authorities are validated automatically. This is the best practice, and it requires no\nadditional code or configuration.</p>\n<h4>Working with self-signed certificates or non-standard CAs</h4>\n<p>In some cases, you might need to work with a server using a self-signed certificate, or a certificate issued by a CA not included in your trusted\nroots. Rather than disabling certificate validation in your code, you can add the necessary certificates to your trust store.</p>\n<p>Here is a sample command to import a certificate to the Java trust store:</p>\n<pre>\nkeytool -import -alias myserver -file myserver.crt -keystore cacerts\n</pre>",
    "moreInfo": "<h3>Standards</h3>\n<ul>\n  <li> OWASP - <a href=\"https://owasp.org/Top10/A02_2021-Cryptographic_Failures/\">Top 10 2021 Category A2 - Cryptographic Failures</a> </li>\n  <li> OWASP - <a href=\"https://owasp.org/Top10/A05_2021-Security_Misconfiguration/\">Top 10 2021 Category A5 - Security Misconfiguration</a> </li>\n  <li> OWASP - <a href=\"https://owasp.org/Top10/A07_2021-Identification_and_Authentication_Failures/\">Top 10 2021 Category A7 - Identification and\n  Authentication Failures</a> </li>\n  <li> OWASP - <a href=\"https://owasp.org/www-project-top-ten/2017/A3_2017-Sensitive_Data_Exposure\">Top 10 2017 Category A3 - Sensitive Data\n  Exposure</a> </li>\n  <li> OWASP - <a href=\"https://owasp.org/www-project-top-ten/2017/A6_2017-Security_Misconfiguration\">Top 10 2017 Category A6 - Security\n  Misconfiguration</a> </li>\n  <li> OWASP - <a href=\"https://owasp.org/www-project-mobile-top-10/2016-risks/m3-insecure-communication\">Mobile Top 10 2016 Category M3 - Insecure\n  Communication</a> </li>\n  <li> OWASP - <a href=\"https://owasp.org/www-project-mobile-top-10/2023-risks/m5-insecure-communication\">Mobile Top 10 2024 Category M5 - Insecure\n  Communication</a> </li>\n  <li> OWASP - <a href=\"https://mas.owasp.org/checklists/MASVS-NETWORK/\">Mobile AppSec Verification Standard - Network Communication Requirements</a>\n  </li>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/295\">CWE-295 - Improper Certificate Validation</a> </li>\n  <li> STIG Viewer - <a href=\"https://stigviewer.com/stigs/application_security_and_development/2024-12-06/finding/V-222550\">Application Security and\n  Development: V-222550</a> - The application must validate certificates by constructing a certification path to an accepted trust anchor. </li>\n  <li> <a\n  href=\"https://wiki.sei.cmu.edu/confluence/display/java/MSC61-J.+Do+not+use+insecure+or+weak+cryptographic+algorithms\">https://wiki.sei.cmu.edu/confluence/display/java/MSC61-J.+Do+not+use+insecure+or+weak+cryptographic+algorithms</a> </li>\n</ul>",
    "status": "READY",
    "name_ko": "SSL/TLS 연결 시 서버 인증서를 검증해야 합니다",
    "why_ko": "<p>TLS(전송 계층 보안)는 시스템 간에 전송되는 데이터를 암호화하여 인터넷을 통해 시스템 간의 안전한 통신을 제공합니다. 인증서 검증은 시스템이 실제로 자신이 주장하는 것임을 보장하기 위해 이 프로세스에 추가적인 신뢰 및 보안 계층을 추가합니다.</p>\n<p>인증서 검증이 비활성화되면 클라이언트는 중요한 보안 검사를 건너뜁니다. 이것은 공격자가 신뢰할 수 있는 엔터티로 가장하여 전송 중인 데이터를 가로채거나, 조작하거나, 훔칠 기회를 만듭니다.</p>\n<h3>잠재적 영향은 무엇인가요?</h3>\n<p>안전한 방식으로 신뢰를 구축하는 것은 쉬운 작업이 아닙니다. 인증서 검증을 비활성화하면 인터넷 통신에서 이 신뢰를 구축하도록 설계된 핵심 메커니즘을 제거하여 시스템을 여러 잠재적 위협에 노출시킵니다.</p>\n<h4>신원 스푸핑</h4>\n<p>시스템이 인증서를 검증하지 않으면 통신에 관련된 상대방의 신원을 확인할 수 없습니다. 공격자는 가짜 서버를 만들고 합법적인 서버로 가장하여 이를 악용할 수 있습니다. 예를 들어, 은행 서버처럼 보이는 서버를 설정하여 시스템이 은행과 통신하고 있다고 착각하게 할 수 있습니다. 신원 스푸핑이라고 하는 이 시나리오는 공격자가 시스템이 보내는 모든 데이터를 수집할 수 있게 하여 잠재적으로 심각한 데이터 침해로 이어질 수 있습니다.</p>\n<h4>데이터 무결성 손실</h4>\n<p>TLS 인증서 검증이 비활성화되면 보내고 받는 데이터의 무결성을 보장할 수 없습니다. 공격자가 전송 중인 데이터를 수정해도 알 방법이 없습니다. 이것은 수신하는 데이터의 미묘한 조작부터 시스템에 악성 코드나 맬웨어 주입에 이르기까지 다양할 수 있습니다. 이러한 데이터 무결성 침해의 결과는 데이터 및 시스템의 특성에 따라 심각할 수 있습니다.</p>",
    "howToFix_ko": "<p>다음 코드는 비활성화된 인증서 검증의 예를 포함합니다.</p>\n<p>빈 구현으로 <code>X509TrustManager</code>를 오버라이드하여 인증서 검증이 비활성화됩니다. 원래 구현을 사용하는 것이 강력히 권장됩니다.</p>\n<h4>규칙을 준수하지 않는 코드 예시</h4>\n<pre>\nclass TrustAllManager implements X509TrustManager {\n\n    @Override\n    public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {  // 규칙 위반\n    }\n\n    @Override\n    public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException { // 규칙 위반\n    }\n\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return null;\n    }\n}\n</pre>\n<h3>어떻게 작동하나요?</h3>\n<p>비활성화된 TLS 인증서 검증의 취약점을 해결하는 것은 주로 기본 검증을 다시 활성화하는 것입니다.</p>\n<p>잘못된 인증서로 인한 문제를 방지하려면 다음 섹션을 고려하세요.</p>\n<h4>신뢰할 수 있는 인증서 사용</h4>\n<p>가능하면 항상 서버에 잘 알려진 신뢰할 수 있는 CA가 발급한 인증서를 사용하세요. 대부분의 프로그래밍 환경에는 신뢰할 수 있는 루트 CA의 미리 정의된 목록이 있으며, 이러한 기관에서 발급한 인증서는 자동으로 검증됩니다. 이것이 가장 좋은 방법이며 추가 코드나 구성이 필요하지 않습니다.</p>\n<h4>자체 서명 인증서 또는 비표준 CA 작업</h4>\n<p>경우에 따라 자체 서명 인증서를 사용하는 서버 또는 신뢰할 수 있는 루트에 포함되지 않은 CA가 발급한 인증서로 작업해야 할 수 있습니다. 코드에서 인증서 검증을 비활성화하는 대신 필요한 인증서를 신뢰 저장소에 추가할 수 있습니다.</p>\n<p>다음은 Java 신뢰 저장소로 인증서를 가져오는 샘플 명령입니다:</p>\n<pre>\nkeytool -import -alias myserver -file myserver.crt -keystore cacerts\n</pre>",
    "moreInfo_ko": "<h3>표준</h3>\n<ul>\n  <li> OWASP - <a href=\"https://owasp.org/Top10/A02_2021-Cryptographic_Failures/\">Top 10 2021 카테고리 A2 - 암호화 실패</a> </li>\n  <li> OWASP - <a href=\"https://owasp.org/Top10/A05_2021-Security_Misconfiguration/\">Top 10 2021 카테고리 A5 - 보안 구성 오류</a> </li>\n  <li> OWASP - <a href=\"https://owasp.org/Top10/A07_2021-Identification_and_Authentication_Failures/\">Top 10 2021 카테고리 A7 - 식별 및 인증 실패</a> </li>\n  <li> OWASP - <a href=\"https://owasp.org/www-project-top-ten/2017/A3_2017-Sensitive_Data_Exposure\">Top 10 2017 카테고리 A3 - 민감한 데이터 노출</a> </li>\n  <li> OWASP - <a href=\"https://owasp.org/www-project-top-ten/2017/A6_2017-Security_Misconfiguration\">Top 10 2017 카테고리 A6 - 보안 구성 오류</a> </li>\n  <li> OWASP - <a href=\"https://owasp.org/www-project-mobile-top-10/2016-risks/m3-insecure-communication\">Mobile Top 10 2016 카테고리 M3 - 안전하지 않은 통신</a> </li>\n  <li> OWASP - <a href=\"https://owasp.org/www-project-mobile-top-10/2023-risks/m5-insecure-communication\">Mobile Top 10 2024 카테고리 M5 - 안전하지 않은 통신</a> </li>\n  <li> OWASP - <a href=\"https://mas.owasp.org/checklists/MASVS-NETWORK/\">Mobile AppSec 검증 표준 - 네트워크 통신 요구 사항</a> </li>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/295\">CWE-295 - 부적절한 인증서 검증</a> </li>\n  <li> STIG Viewer - <a href=\"https://stigviewer.com/stigs/application_security_and_development/2024-12-06/finding/V-222550\">애플리케이션 보안 및 개발: V-222550</a> - 애플리케이션은 허용된 트러스트 앵커에 대한 인증 경로를 구성하여 인증서를 검증해야 합니다. </li>\n  <li> <a href=\"https://wiki.sei.cmu.edu/confluence/display/java/MSC61-J.+Do+not+use+insecure+or+weak+cryptographic+algorithms\">https://wiki.sei.cmu.edu/confluence/display/java/MSC61-J.+Do+not+use+insecure+or+weak+cryptographic+algorithms</a> </li>\n</ul>"
  },
  {
    "id": "S1223",
    "key": "java:S1223",
    "name": "Non-constructor methods should not have the same name as the enclosing class",
    "type": "code-smell",
    "severity": "major",
    "tags": [
      "pitfall"
    ],
    "why": "<p>Having a class and some of its methods sharing the same name is misleading, and leaves others to wonder whether it was done that way on purpose, or\nwas the methods supposed to be a constructor.</p>\n<h3>Noncompliant code example</h3>\n<pre>\npublic class Foo {\n   public Foo() {...}\n   public void Foo(String label) {...}  // Noncompliant\n}\n</pre>\n<h3>Compliant solution</h3>\n<pre>\npublic class Foo {\n   public Foo() {...}\n   public void foo(String label) {...}  // Compliant\n}\n</pre>",
    "howToFix": "",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "생성자가 아닌 메서드는 포함 클래스와 같은 이름을 가지면 안 됩니다","why_ko": "<p>클래스와 일부 메서드가 같은 이름을 공유하면 오해를 불러일으키며, 다른 사람들이 의도적으로 그렇게 한 것인지 아니면 메서드가 생성자여야 했던 것인지 의문을 갖게 됩니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\npublic class Foo {\n   public Foo() {...}\n   public void Foo(String label) {...}  // 규칙 위반\n}\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre>\npublic class Foo {\n   public Foo() {...}\n   public void foo(String label) {...}  // 규칙 준수\n}\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": ""
  },
  {
    "id": "S2225",
    "key": "java:S2225",
    "name": "\"toString()\" and \"clone()\" methods should not return null",
    "type": "bug",
    "severity": "major",
    "tags": [
      "cwe",
      "cert"
    ],
    "why": "<p>Calling <code>toString()</code> or <code>clone()</code> on an object should always return a string or an object. Returning <code>null</code>\ninstead contravenes the method's implicit contract.</p>\n<h3>Noncompliant code example</h3>\n<pre>\npublic String toString () {\n  if (this.collection.isEmpty()) {\n    return null; // Noncompliant\n  } else {\n    // ...\n</pre>\n<h3>Compliant solution</h3>\n<pre>\npublic String toString () {\n  if (this.collection.isEmpty()) {\n    return \"\";\n  } else {\n    // ...\n</pre>",
    "howToFix": "",
    "moreInfo": "<ul>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/476\">CWE-476 - NULL Pointer Dereference</a> </li>\n  <li> <a href=\"https://wiki.sei.cmu.edu/confluence/x/aDdGBQ\">CERT, EXP01-J.</a> - Do not use a null in a case where an object is required </li>\n</ul>",
    "status": "READY",
    "name_ko": "\"toString()\"과 \"clone()\" 메서드는 null을 반환하면 안 됩니다",
    "why_ko": "<p>객체에서 <code>toString()</code> 또는 <code>clone()</code>을 호출하면 항상 문자열이나 객체를 반환해야 합니다. 대신 <code>null</code>을 반환하면 메서드의 암묵적 계약을 위반하는 것입니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\npublic String toString () {\n  if (this.collection.isEmpty()) {\n    return null; // 규칙 위반\n  } else {\n    // ...\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre>\npublic String toString () {\n  if (this.collection.isEmpty()) {\n    return \"\";\n  } else {\n    // ...\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": "<ul>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/476\">CWE-476 - NULL 포인터 역참조</a> </li>\n  <li> <a href=\"https://wiki.sei.cmu.edu/confluence/x/aDdGBQ\">CERT, EXP01-J.</a> - 객체가 필요한 곳에 null을 사용하지 마세요 </li>\n</ul>"
  },
  {
    "id": "S2675",
    "key": "java:S2675",
    "name": "\"readObject\" should not be \"synchronized\"",
    "type": "code-smell",
    "severity": "major",
    "tags": [
      "confusing"
    ],
    "why": "<p>The <code>readObject</code> method is implemented when a <code>Serializable</code> object requires special handling to be reconstructed from a\nfile. The object created by <code>readObject</code> is accessed only by the thread that called the method, thus using the <code>synchronized</code>\nkeyword in this context is unnecessary and causes confusion.</p>\n<h3>Noncompliant code example</h3>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\nprivate synchronized void readObject(java.io.ObjectInputStream in)\n     throws IOException, ClassNotFoundException { // Noncompliant\n  //...\n}\n</pre>\n<h3>Compliant solution</h3>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\nprivate void readObject(java.io.ObjectInputStream in)\n     throws IOException, ClassNotFoundException { // Compliant\n  //...\n}\n</pre>",
    "howToFix": "",
    "moreInfo": "<h3>Documentation</h3>\n<ul>\n  <li> <a href=\"https://docs.oracle.com/en/java/javase/20/docs/api/java.base/java/io/Serializable.html\">Oracle SDK 20 - Serializable</a> </li>\n  <li> <a href=\"https://docs.oracle.com/en/java/javase/20/docs/api/java.base/java/io/ObjectInputStream.html\">Oracle SDK 20 - ObjectInputStream</a>\n  </li>\n</ul>\n<h3>Articles &amp; blog posts</h3>\n<ul>\n  <li> <a href=\"https://www.baeldung.com/java-serialization\">Serialization in Java</a> </li>\n</ul>",
    "status": "READY",
    "name_ko": "readObject는 synchronized로 선언하면 안 됩니다",
    "why_ko": "<p><code>readObject</code> 메서드는 <code>Serializable</code> 객체가 파일에서 재구성되기 위해 특별한 처리가 필요할 때 구현됩니다. <code>readObject</code>로 생성된 객체는 해당 메서드를 호출한 스레드만 접근하므로, 이 컨텍스트에서 <code>synchronized</code> 키워드를 사용하는 것은 불필요하고 혼란을 야기합니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\nprivate synchronized void readObject(java.io.ObjectInputStream in)\n     throws IOException, ClassNotFoundException { // 규칙 위반\n  //...\n}\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\nprivate void readObject(java.io.ObjectInputStream in)\n     throws IOException, ClassNotFoundException { // 규칙 준수\n  //...\n}\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": "<h3>문서</h3>\n<ul>\n  <li> <a href=\"https://docs.oracle.com/en/java/javase/20/docs/api/java.base/java/io/Serializable.html\">Oracle SDK 20 - Serializable</a> </li>\n  <li> <a href=\"https://docs.oracle.com/en/java/javase/20/docs/api/java.base/java/io/ObjectInputStream.html\">Oracle SDK 20 - ObjectInputStream</a> </li>\n</ul>\n<h3>관련 문서 및 블로그 게시물</h3>\n<ul>\n  <li> <a href=\"https://www.baeldung.com/java-serialization\">Serialization in Java</a> </li>\n</ul>"
  },
  {
    "id": "S7477",
    "key": "java:S7477",
    "name": "Class name should be omitted when unchanged by class transform",
    "type": "code-smell",
    "severity": "minor",
    "tags": [
      "java24"
    ],
    "why": "<p>In the classfile API introduced by Java 24, there are several versions of the <code>transformClass</code> methods. In particular if the name of the\ntransformed class is unchanged compared to the original class, then it is recommended to use the simplest version of the method that takes only 2\narguments. This makes the code shorter, clearer, and reduces chances for mistakes.</p>",
    "howToFix": "<p>Remove the class name argument of the <code>transformClass</code> call.</p>\n\n<h4>Noncompliant code example</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\npublic static void transformClassFile(Path path) throws IOException {\n    ClassFile classFile = ClassFile.of();\n    ClassModel classModel = classFile.parse(path);\n    byte[] newBytes = classFile.transformClass(classModel,\n      classModel.thisClass().asSymbol(), // Noncompliant\n      (classBuilder, classElement) -&gt; {\n        if (!(classElement instanceof MethodModel methodModel &amp;&amp;\n            methodModel.methodName().stringValue().startsWith(\"debug\"))) {\n            classBuilder.with(classElement);\n        }\n      });\n}\n</pre>\n<h4>Compliant solution</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\npublic static void transformClassFile(Path path) throws IOException {\n    ClassFile classFile = ClassFile.of();\n    ClassModel classModel = classFile.parse(path);\n    byte[] newBytes = classFile.transformClass(classModel,\n      (classBuilder, classElement) -&gt; {\n        if (!(classElement instanceof MethodModel methodModel &amp;&amp;\n            methodModel.methodName().stringValue().startsWith(\"debug\"))) {\n            classBuilder.with(classElement);\n        }\n      });\n}\n</pre>",
    "moreInfo": "<ul>\n  <li> <a href=\"https://openjdk.org/jeps/484\">JEP 484: Class-File API</a> </li>\n  <li> <a\n  href=\"https://docs.oracle.com/en/java/javase/24/docs/api/java.base/java/lang/classfile/ClassFile.html#transformClass(java.lang.classfile.ClassModel,java.lang.classfile.ClassTransform)\">ClassFile API, transformClass(ClassModel, ClassTransform)</a> </li>\n  <li> <a\n  href=\"https://docs.oracle.com/en/java/javase/24/docs/api/java.base/java/lang/classfile/ClassFile.html#transformClass(java.lang.classfile.ClassModel,java.lang.constant.ClassDesc,java.lang.classfile.ClassTransform)\">ClassFile API, transformClass(ClassModel, ClassDesc, ClassTransform)</a> </li>\n</ul>",
    "status": "READY",
    "name_ko": "클래스 변환으로 변경되지 않는 경우 클래스 이름은 생략해야 합니다",
    "why_ko": "<p>Java 24에서 도입된 classfile API에는 여러 버전의 <code>transformClass</code> 메서드가 있습니다. 특히 변환된 클래스의 이름이 원래 클래스와 비교하여 변경되지 않는 경우 2개의 인수만 받는 가장 간단한 버전의 메서드를 사용하는 것이 좋습니다. 이렇게 하면 코드가 더 짧고 명확해지며 실수 가능성이 줄어듭니다.</p>",
    "howToFix_ko": "<p><code>transformClass</code> 호출에서 클래스 이름 인수를 제거하세요.</p>\n\n<h4>규칙을 준수하지 않는 코드 예시</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\npublic static void transformClassFile(Path path) throws IOException {\n    ClassFile classFile = ClassFile.of();\n    ClassModel classModel = classFile.parse(path);\n    byte[] newBytes = classFile.transformClass(classModel,\n      classModel.thisClass().asSymbol(), // 규칙 위반\n      (classBuilder, classElement) -&gt; {\n        if (!(classElement instanceof MethodModel methodModel &amp;&amp;\n            methodModel.methodName().stringValue().startsWith(\"debug\"))) {\n            classBuilder.with(classElement);\n        }\n      });\n}\n</pre>\n<h4>규칙을 준수하는 해결책</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\npublic static void transformClassFile(Path path) throws IOException {\n    ClassFile classFile = ClassFile.of();\n    ClassModel classModel = classFile.parse(path);\n    byte[] newBytes = classFile.transformClass(classModel,\n      (classBuilder, classElement) -&gt; {\n        if (!(classElement instanceof MethodModel methodModel &amp;&amp;\n            methodModel.methodName().stringValue().startsWith(\"debug\"))) {\n            classBuilder.with(classElement);\n        }\n      });\n}\n</pre>",
    "moreInfo_ko": "<ul>\n  <li> <a href=\"https://openjdk.org/jeps/484\">JEP 484: Class-File API</a> </li>\n  <li> <a href=\"https://docs.oracle.com/en/java/javase/24/docs/api/java.base/java/lang/classfile/ClassFile.html#transformClass(java.lang.classfile.ClassModel,java.lang.classfile.ClassTransform)\">ClassFile API, transformClass(ClassModel, ClassTransform)</a> </li>\n  <li> <a href=\"https://docs.oracle.com/en/java/javase/24/docs/api/java.base/java/lang/classfile/ClassFile.html#transformClass(java.lang.classfile.ClassModel,java.lang.constant.ClassDesc,java.lang.classfile.ClassTransform)\">ClassFile API, transformClass(ClassModel, ClassDesc, ClassTransform)</a> </li>\n</ul>"
  },
  {
    "id": "S3064",
    "key": "java:S3064",
    "name": "Assignment of lazy-initialized members should be the last step with double-checked locking",
    "type": "bug",
    "severity": "major",
    "tags": [
      "multi-threading",
      "cert"
    ],
    "why": "<p>Double-checked locking can be used for lazy initialization of <code>volatile</code> fields, but only if field assignment is the last step in the\n<code>synchronized</code> block. Otherwise you run the risk of threads accessing a half-initialized object.</p>\n<h3>Noncompliant code example</h3>\n<pre>\npublic class MyClass {\n\n  private volatile List&lt;String&gt; strings;\n\n  public List&lt;String&gt; getStrings() {\n    if (strings == null) {  // check#1\n      synchronized(MyClass.class) {\n        if (strings == null) {\n          strings = new ArrayList&lt;&gt;();  // Noncompliant\n          strings.add(\"Hello\");  //When threadA gets here, threadB can skip the synchronized block because check#1 is false\n          strings.add(\"World\");\n        }\n      }\n    }\n    return strings;\n  }\n}\n</pre>\n<h3>Compliant solution</h3>\n<pre>\npublic class MyClass {\n\n  private volatile List&lt;String&gt; strings;\n\n  public List&lt;String&gt; getStrings() {\n    if (strings == null) {  // check#1\n      synchronized(MyClass.class) {\n        if (strings == null) {\n          List&lt;String&gt; tmpList = new ArrayList&lt;&gt;();\n          tmpList.add(\"Hello\");\n          tmpList.add(\"World\");\n          strings = tmpList;\n        }\n      }\n    }\n    return strings;\n  }\n}\n</pre>",
    "howToFix": "",
    "moreInfo": "<ul>\n  <li> <a href=\"https://wiki.sei.cmu.edu/confluence/x/6zdGBQ\">CERT, LCK10-J.</a> - Use a correct form of the double-checked locking idiom </li>\n</ul>\n<h3>Related rules</h3>\n<ul>\n  <li> <a href='/coding_rules#rule_key=java%3AS2168'>S2168</a> - Double-checked locking should not be used </li>\n</ul>",
    "status": "READY",
    "name_ko": "Double-checked locking에서 지연 초기화 멤버 할당은 마지막 단계여야 합니다",
    "why_ko": "<p>Double-checked locking은 <code>volatile</code> 필드의 지연 초기화에 사용될 수 있지만, 필드 할당이 <code>synchronized</code> 블록의 마지막 단계인 경우에만 가능합니다. 그렇지 않으면 스레드가 반쯤 초기화된 객체에 접근하는 위험이 있습니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\npublic class MyClass {\n\n  private volatile List&lt;String&gt; strings;\n\n  public List&lt;String&gt; getStrings() {\n    if (strings == null) {  // check#1\n      synchronized(MyClass.class) {\n        if (strings == null) {\n          strings = new ArrayList&lt;&gt;();  // 규칙 위반\n          strings.add(\"Hello\");  //threadA가 여기에 도달하면, threadB는 check#1이 false이므로 synchronized 블록을 건너뛸 수 있습니다\n          strings.add(\"World\");\n        }\n      }\n    }\n    return strings;\n  }\n}\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre>\npublic class MyClass {\n\n  private volatile List&lt;String&gt; strings;\n\n  public List&lt;String&gt; getStrings() {\n    if (strings == null) {  // check#1\n      synchronized(MyClass.class) {\n        if (strings == null) {\n          List&lt;String&gt; tmpList = new ArrayList&lt;&gt;();\n          tmpList.add(\"Hello\");\n          tmpList.add(\"World\");\n          strings = tmpList;\n        }\n      }\n    }\n    return strings;\n  }\n}\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": "<ul>\n  <li> <a href=\"https://wiki.sei.cmu.edu/confluence/x/6zdGBQ\">CERT, LCK10-J.</a> - Double-checked locking 관용구의 올바른 형태를 사용하세요 </li>\n</ul>\n<h3>관련 규칙</h3>\n<ul>\n  <li> <a href='/coding_rules#rule_key=java%3AS2168'>S2168</a> - Double-checked locking을 사용하면 안 됩니다 </li>\n</ul>"
  },
  {
    "id": "S3658",
    "key": "java:S3658",
    "name": "Unit tests should throw exceptions",
    "type": "code-smell",
    "severity": "minor",
    "tags": [
      "error-handling",
      "junit",
      "tests",
      "clumsy"
    ],
    "why": "<p>When the code under test in a unit test throws an exception, the test itself fails. Therefore, there is no need to surround the tested code with a\n<code>try</code>-<code>catch</code> structure to detect failure. Instead, you can simply move the exception type to the method signature.</p>\n<p>This rule raises an issue when there is a fail assertion inside a <code>catch</code> block.</p>\n<p>Supported frameworks:</p>\n<ul>\n  <li> JUnit3 </li>\n  <li> JUnit4 </li>\n  <li> JUnit5 </li>\n  <li> Fest assert </li>\n  <li> AssertJ </li>\n</ul>\n<h3>Noncompliant code example</h3>\n<pre>\n@Test\npublic void testMethod() {\n  try {\n            // Some code\n  } catch (MyException e) {\n    Assert.fail(e.getMessage());  // Noncompliant\n  }\n}\n</pre>\n<h3>Compliant solution</h3>\n<pre>\n@Test\npublic void testMethod() throws MyException {\n    // Some code\n}\n</pre>",
    "howToFix": "",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "단위 테스트는 예외를 던져야 합니다",
    "why_ko": "<p>단위 테스트에서 테스트 대상 코드가 예외를 던지면 테스트 자체가 실패합니다. 따라서 실패를 감지하기 위해 테스트 코드를 <code>try</code>-<code>catch</code> 구조로 감쌀 필요가 없습니다. 대신 예외 타입을 메서드 시그니처로 옮기면 됩니다.</p>\n<p>이 규칙은 <code>catch</code> 블록 내에 fail assertion이 있을 때 문제를 제기합니다.</p>\n<p>지원되는 프레임워크:</p>\n<ul>\n  <li> JUnit3 </li>\n  <li> JUnit4 </li>\n  <li> JUnit5 </li>\n  <li> Fest assert </li>\n  <li> AssertJ </li>\n</ul>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\n@Test\npublic void testMethod() {\n  try {\n            // 일부 코드\n  } catch (MyException e) {\n    Assert.fail(e.getMessage());  // 규칙 위반\n  }\n}\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre>\n@Test\npublic void testMethod() throws MyException {\n    // 일부 코드\n}\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": ""
  },
  {
    "id": "S6909",
    "key": "java:S6909",
    "name": "Constant parameters in a \"PreparedStatement\" should not be set more than once",
    "type": "code-smell",
    "severity": "major",
    "tags": [
      "sustainability",
      "sql"
    ],
    "why": "<p>The <code>PreparedStatement</code> is frequently used in loops because it allows to conveniently set parameters. A small optimization is possible\nby setting constant parameters outside the loop or hard-coding them in the query whenever possible.</p>\n<h3>What is the potential impact?</h3>\n<ul>\n  <li> <em>Performance</em>: the unnecessary calls to the setter methods bring overhead. </li>\n  <li> <em>Sustainability</em>: the extra overhead has a negative impact on the environment. </li>\n</ul>",
    "howToFix": "<p>Place calls to setter methods that take a constant argument outside the loop.</p>\n\n<h4>Noncompliant code example</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\npublic class DatabaseExample {\n\n    public record Order(String id, BigDecimal price) {}\n\n    public void updateTodayOrders(Connection connection, List&lt;Order&gt; orders) {\n            Date today = java.sql.Date.valueOf(LocalDate.now());\n            String insertQuery = \"INSERT INTO Order (id, price, executionDate) VALUES (?, ?, ?)\";\n            PreparedStatement preparedStatement = connection.prepareStatement(insertQuery);\n\n            for(Order order: orders) {\n                preparedStatement.setString(1, order.id());\n                preparedStatement.setString(2, order.price());\n                preparedStatement.setDate(3, today); // Noncompliant\n                preparedStatement.executeUpdate();\n            }\n    }\n}\n</pre>\n<h4>Compliant solution</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\npublic class DatabaseExample {\n\n    public record Order(String id, BigDecimal price) {}\n\n    public void updateTodayOrders(Connection connection, List&lt;Order&gt; orders) {\n            Date today = java.sql.Date.valueOf(LocalDate.now());\n            String insertQuery = \"INSERT INTO Order (id, price, executionDate) VALUES (?, ?, ?)\";\n            PreparedStatement preparedStatement = connection.prepareStatement(insertQuery);\n\n            preparedStatement.setDate(3, today); // Compliant\n            for(Order order: orders) {\n                preparedStatement.setString(1, order.id());\n                preparedStatement.setString(2, order.price());\n                preparedStatement.executeUpdate();\n            }\n    }\n}\n</pre>",
    "moreInfo": "<h3>Documentation</h3>\n<ul>\n  <li> <a href=\"https://docs.oracle.com/en/java/javase/21/docs/api/java.sql/java/sql/PreparedStatement.html\">Oracle SDK - PreparedStatement</a> </li>\n  <li> <a href=\"https://docs.oracle.com/javase/tutorial/jdbc/basics/prepared.html\">Oracle Tutorial - Using Prepared Statements</a> </li>\n</ul>",
    "status": "READY",
    "name_ko": "PreparedStatement의 상수 매개변수를 두 번 이상 설정하면 안 됩니다",
    "why_ko": "<p><code>PreparedStatement</code>는 매개변수를 편리하게 설정할 수 있기 때문에 루프에서 자주 사용됩니다. 가능한 경우 상수 매개변수를 루프 외부에서 설정하거나 쿼리에 하드코딩하면 작은 최적화가 가능합니다.</p>\n<h3>잠재적 영향은 무엇인가요?</h3>\n<ul>\n  <li> <em>성능</em>: setter 메서드에 대한 불필요한 호출이 오버헤드를 발생시킵니다. </li>\n  <li> <em>지속 가능성</em>: 추가 오버헤드는 환경에 부정적인 영향을 미칩니다. </li>\n</ul>",
    "howToFix_ko": "<p>상수 인수를 받는 setter 메서드 호출을 루프 외부에 배치하세요.</p>\n\n<h4>규칙을 준수하지 않는 코드 예시</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\npublic class DatabaseExample {\n\n    public record Order(String id, BigDecimal price) {}\n\n    public void updateTodayOrders(Connection connection, List&lt;Order&gt; orders) {\n            Date today = java.sql.Date.valueOf(LocalDate.now());\n            String insertQuery = \"INSERT INTO Order (id, price, executionDate) VALUES (?, ?, ?)\";\n            PreparedStatement preparedStatement = connection.prepareStatement(insertQuery);\n\n            for(Order order: orders) {\n                preparedStatement.setString(1, order.id());\n                preparedStatement.setString(2, order.price());\n                preparedStatement.setDate(3, today); // 규칙 위반\n                preparedStatement.executeUpdate();\n            }\n    }\n}\n</pre>\n<h4>규칙을 준수하는 해결책</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\npublic class DatabaseExample {\n\n    public record Order(String id, BigDecimal price) {}\n\n    public void updateTodayOrders(Connection connection, List&lt;Order&gt; orders) {\n            Date today = java.sql.Date.valueOf(LocalDate.now());\n            String insertQuery = \"INSERT INTO Order (id, price, executionDate) VALUES (?, ?, ?)\";\n            PreparedStatement preparedStatement = connection.prepareStatement(insertQuery);\n\n            preparedStatement.setDate(3, today); // 규칙 준수\n            for(Order order: orders) {\n                preparedStatement.setString(1, order.id());\n                preparedStatement.setString(2, order.price());\n                preparedStatement.executeUpdate();\n            }\n    }\n}\n</pre>",
    "moreInfo_ko": "<h3>문서</h3>\n<ul>\n  <li> <a href=\"https://docs.oracle.com/en/java/javase/21/docs/api/java.sql/java/sql/PreparedStatement.html\">Oracle SDK - PreparedStatement</a> </li>\n  <li> <a href=\"https://docs.oracle.com/javase/tutorial/jdbc/basics/prepared.html\">Oracle 튜토리얼 - Prepared Statements 사용하기</a> </li>\n</ul>"
  },
  {
    "id": "S4488",
    "key": "java:S4488",
    "name": "Composed \"@RequestMapping\" variants should be preferred",
    "type": "code-smell",
    "severity": "minor",
    "tags": [
      "spring"
    ],
    "why": "<p>Spring framework 4.3 introduced variants of the <code>@RequestMapping</code> annotation to better represent the semantics of the annotated methods.\nThe use of <code>@GetMapping</code>, <code>@PostMapping</code>, <code>@PutMapping</code>, <code>@PatchMapping</code> and <code>@DeleteMapping</code>\nshould be preferred to the use of the raw <code>@RequestMapping(method = RequestMethod.XYZ)</code>.</p>\n<h3>Noncompliant code example</h3>\n<pre>\n@RequestMapping(path = \"/greeting\", method = RequestMethod.GET) // Noncompliant\npublic Greeting greeting(@RequestParam(value = \"name\", defaultValue = \"World\") String name) {\n...\n}\n</pre>\n<h3>Compliant solution</h3>\n<pre>\n@GetMapping(path = \"/greeting\") // Compliant\npublic Greeting greeting(@RequestParam(value = \"name\", defaultValue = \"World\") String name) {\n...\n}\n</pre>",
    "howToFix": "",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "조합된 \"@RequestMapping\" 변형을 사용하는 것이 좋습니다",
    "why_ko": "<p>Spring 프레임워크 4.3은 어노테이션이 달린 메서드의 의미를 더 잘 나타내기 위해 <code>@RequestMapping</code> 어노테이션의 변형을 도입했습니다. <code>@GetMapping</code>, <code>@PostMapping</code>, <code>@PutMapping</code>, <code>@PatchMapping</code> 및 <code>@DeleteMapping</code>의 사용이 원시 <code>@RequestMapping(method = RequestMethod.XYZ)</code>의 사용보다 선호되어야 합니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\n@RequestMapping(path = \"/greeting\", method = RequestMethod.GET) // 규칙 위반\npublic Greeting greeting(@RequestParam(value = \"name\", defaultValue = \"World\") String name) {\n...\n}\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre>\n@GetMapping(path = \"/greeting\") // 규칙 준수\npublic Greeting greeting(@RequestParam(value = \"name\", defaultValue = \"World\") String name) {\n...\n}\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": ""
  },
  {
    "id": "S3033",
    "key": "java:S3033",
    "name": "\".isEmpty\" should be used to test for the emptiness of StringBuffers/Builders",
    "type": "code-smell",
    "severity": "minor",
    "tags": [
      "performance",
      "clumsy"
    ],
    "why": "<p>It is inefficient to build a <code>String</code> from a <code>StringBuilder</code> or <code>StringBuffer</code> just to check if it's empty.\nInstead, directly use the <code>.isEmpty</code> method.</p>\n<h3>Noncompliant code example</h3>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\nStringBuilder sb = new StringBuilder();\n// ...\nif (\"\".equals(sb.toString()) { // Noncompliant\n  // ...\n}\nif (sb.toString().isEmpty()) { // Noncompliant\n  // ...\n}\n</pre>\n<h3>Compliant solution</h3>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\nStringBuilder sb = new StringBuilder();\n// ...\nif (sb.isEmpty()) {\n  // ...\n}\nif (sb.isEmpty()) {\n  // ...\n}\n</pre>\n<h3>Benchmarks</h3>\n<table>\n  <colgroup>\n    <col style=\"width: 20%;\">\n    <col style=\"width: 20%;\">\n    <col style=\"width: 20%;\">\n    <col style=\"width: 20%;\">\n    <col style=\"width: 20%;\">\n  </colgroup>\n  <thead>\n    <tr>\n      <th>Method</th>\n      <th>stringBuilderSize</th>\n      <th>Runtime</th>\n      <th>Average time</th>\n      <th>Error margin</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td><p>isEmpty</p></td>\n      <td><p>10</p></td>\n      <td><p>Temurin 21</p></td>\n      <td><p>6.57 ns/op</p></td>\n      <td><p>±0.38 ns/op</p></td>\n    </tr>\n    <tr>\n      <td><p>isEmpty</p></td>\n      <td><p>100</p></td>\n      <td><p>Temurin 21</p></td>\n      <td><p>6.68 ns/op</p></td>\n      <td><p>±0.10 ns/op</p></td>\n    </tr>\n    <tr>\n      <td><p>isEmpty</p></td>\n      <td><p>1000</p></td>\n      <td><p>Temurin 21</p></td>\n      <td><p>6.80 ns/op</p></td>\n      <td><p>±0.12 ns/op</p></td>\n    </tr>\n    <tr>\n      <td><p>length</p></td>\n      <td><p>10</p></td>\n      <td><p>Temurin 21</p></td>\n      <td><p>6.83 ns/op</p></td>\n      <td><p>±0.12 ns/op</p></td>\n    </tr>\n    <tr>\n      <td><p>length</p></td>\n      <td><p>100</p></td>\n      <td><p>Temurin 21</p></td>\n      <td><p>6.66 ns/op</p></td>\n      <td><p>±0.11 ns/op</p></td>\n    </tr>\n    <tr>\n      <td><p>length</p></td>\n      <td><p>1000</p></td>\n      <td><p>Temurin 21</p></td>\n      <td><p>6.67 ns/op</p></td>\n      <td><p>±0.07 ns/op</p></td>\n    </tr>\n    <tr>\n      <td><p>toStringEquals</p></td>\n      <td><p>10</p></td>\n      <td><p>Temurin 21</p></td>\n      <td><p>13.92 ns/op</p></td>\n      <td><p>±0.18 ns/op</p></td>\n    </tr>\n    <tr>\n      <td><p>toStringEquals</p></td>\n      <td><p>100</p></td>\n      <td><p>Temurin 21</p></td>\n      <td><p>59.09 ns/op</p></td>\n      <td><p>±0.53 ns/op</p></td>\n    </tr>\n    <tr>\n      <td><p>toStringEquals</p></td>\n      <td><p>1000</p></td>\n      <td><p>Temurin 21</p></td>\n      <td><p>465.79 ns/op</p></td>\n      <td><p>±5.86 ns/op</p></td>\n    </tr>\n    <tr>\n      <td><p>toStringIsEmpty</p></td>\n      <td><p>10</p></td>\n      <td><p>Temurin 21</p></td>\n      <td><p>13.83 ns/op</p></td>\n      <td><p>±0.23 ns/op</p></td>\n    </tr>\n    <tr>\n      <td><p>toStringIsEmpty</p></td>\n      <td><p>100</p></td>\n      <td><p>Temurin 21</p></td>\n      <td><p>60.06 ns/op</p></td>\n      <td><p>±3.42 ns/op</p></td>\n    </tr>\n    <tr>\n      <td><p>toStringIsEmpty</p></td>\n      <td><p>1000</p></td>\n      <td><p>Temurin 21</p></td>\n      <td><p>484.58 ns/op</p></td>\n      <td><p>±4.24 ns/op</p></td>\n    </tr>\n  </tbody>\n</table>\n<p><strong>Benchmarking code</strong></p>\n<p>The results were generated by running the following snippet with <a href=\"https://github.com/openjdk/jmh\">JMH</a>.</p>\n<pre>\n@Param({\"10\", \"100\", \"1000\"})\nint stringBuilderSize;\n\n\nprivate StringBuilder sb;\n\n@Setup(Level.Iteration)\npublic void setup() {\n  sb = new StringBuilder();\n  IntStream.range(0, stringBuilderSize).forEach(i -&gt; sb.append(\"word\"));\n}\n\n@Benchmark\npublic StringBuilder toStringEquals() {\n  if (\"\".equals((sb.toString()))) {\n    return sb;\n  }\n  return new StringBuilder();\n}\n\n@Benchmark\npublic StringBuilder toStringIsEmpty() {\n  if (sb.toString().isEmpty()) {\n    return sb;\n  }\n  return new StringBuilder();\n}\n\n@Benchmark\npublic StringBuilder length() {\n  if (sb.length() == 0) {\n    return sb;\n  }\n  return new StringBuilder();\n}\n\n@Benchmark\npublic StringBuilder isEmpty() {\n  if (sb.isEmpty()) {\n    return sb;\n  }\n  return new StringBuilder();\n}\n</pre>",
    "howToFix": "",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "StringBuffer/StringBuilder의 빈 값 검사에는 \".isEmpty\"를 사용해야 합니다",
    "why_ko": "<p><code>StringBuilder</code> 또는 <code>StringBuffer</code>가 비어 있는지 확인하기 위해 <code>String</code>을 빌드하는 것은 비효율적입니다.\n대신 <code>.isEmpty</code> 메서드를 직접 사용하세요.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\nStringBuilder sb = new StringBuilder();\n// ...\nif (\"\".equals(sb.toString()) { // 규칙 위반\n  // ...\n}\nif (sb.toString().isEmpty()) { // 규칙 위반\n  // ...\n}\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\nStringBuilder sb = new StringBuilder();\n// ...\nif (sb.isEmpty()) {\n  // ...\n}\nif (sb.isEmpty()) {\n  // ...\n}\n</pre>\n<h3>벤치마크</h3>\n<table>\n  <colgroup>\n    <col style=\"width: 20%;\">\n    <col style=\"width: 20%;\">\n    <col style=\"width: 20%;\">\n    <col style=\"width: 20%;\">\n    <col style=\"width: 20%;\">\n  </colgroup>\n  <thead>\n    <tr>\n      <th>메서드</th>\n      <th>stringBuilderSize</th>\n      <th>런타임</th>\n      <th>평균 시간</th>\n      <th>오차 범위</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td><p>isEmpty</p></td>\n      <td><p>10</p></td>\n      <td><p>Temurin 21</p></td>\n      <td><p>6.57 ns/op</p></td>\n      <td><p>±0.38 ns/op</p></td>\n    </tr>\n    <tr>\n      <td><p>isEmpty</p></td>\n      <td><p>100</p></td>\n      <td><p>Temurin 21</p></td>\n      <td><p>6.68 ns/op</p></td>\n      <td><p>±0.10 ns/op</p></td>\n    </tr>\n    <tr>\n      <td><p>isEmpty</p></td>\n      <td><p>1000</p></td>\n      <td><p>Temurin 21</p></td>\n      <td><p>6.80 ns/op</p></td>\n      <td><p>±0.12 ns/op</p></td>\n    </tr>\n    <tr>\n      <td><p>length</p></td>\n      <td><p>10</p></td>\n      <td><p>Temurin 21</p></td>\n      <td><p>6.83 ns/op</p></td>\n      <td><p>±0.12 ns/op</p></td>\n    </tr>\n    <tr>\n      <td><p>length</p></td>\n      <td><p>100</p></td>\n      <td><p>Temurin 21</p></td>\n      <td><p>6.66 ns/op</p></td>\n      <td><p>±0.11 ns/op</p></td>\n    </tr>\n    <tr>\n      <td><p>length</p></td>\n      <td><p>1000</p></td>\n      <td><p>Temurin 21</p></td>\n      <td><p>6.67 ns/op</p></td>\n      <td><p>±0.07 ns/op</p></td>\n    </tr>\n    <tr>\n      <td><p>toStringEquals</p></td>\n      <td><p>10</p></td>\n      <td><p>Temurin 21</p></td>\n      <td><p>13.92 ns/op</p></td>\n      <td><p>±0.18 ns/op</p></td>\n    </tr>\n    <tr>\n      <td><p>toStringEquals</p></td>\n      <td><p>100</p></td>\n      <td><p>Temurin 21</p></td>\n      <td><p>59.09 ns/op</p></td>\n      <td><p>±0.53 ns/op</p></td>\n    </tr>\n    <tr>\n      <td><p>toStringEquals</p></td>\n      <td><p>1000</p></td>\n      <td><p>Temurin 21</p></td>\n      <td><p>465.79 ns/op</p></td>\n      <td><p>±5.86 ns/op</p></td>\n    </tr>\n    <tr>\n      <td><p>toStringIsEmpty</p></td>\n      <td><p>10</p></td>\n      <td><p>Temurin 21</p></td>\n      <td><p>13.83 ns/op</p></td>\n      <td><p>±0.23 ns/op</p></td>\n    </tr>\n    <tr>\n      <td><p>toStringIsEmpty</p></td>\n      <td><p>100</p></td>\n      <td><p>Temurin 21</p></td>\n      <td><p>60.06 ns/op</p></td>\n      <td><p>±3.42 ns/op</p></td>\n    </tr>\n    <tr>\n      <td><p>toStringIsEmpty</p></td>\n      <td><p>1000</p></td>\n      <td><p>Temurin 21</p></td>\n      <td><p>484.58 ns/op</p></td>\n      <td><p>±4.24 ns/op</p></td>\n    </tr>\n  </tbody>\n</table>\n<p><strong>벤치마킹 코드</strong></p>\n<p>결과는 <a href=\"https://github.com/openjdk/jmh\">JMH</a>로 다음 스니펫을 실행하여 생성되었습니다.</p>\n<pre>\n@Param({\"10\", \"100\", \"1000\"})\nint stringBuilderSize;\n\n\nprivate StringBuilder sb;\n\n@Setup(Level.Iteration)\npublic void setup() {\n  sb = new StringBuilder();\n  IntStream.range(0, stringBuilderSize).forEach(i -&gt; sb.append(\"word\"));\n}\n\n@Benchmark\npublic StringBuilder toStringEquals() {\n  if (\"\".equals((sb.toString()))) {\n    return sb;\n  }\n  return new StringBuilder();\n}\n\n@Benchmark\npublic StringBuilder toStringIsEmpty() {\n  if (sb.toString().isEmpty()) {\n    return sb;\n  }\n  return new StringBuilder();\n}\n\n@Benchmark\npublic StringBuilder length() {\n  if (sb.length() == 0) {\n    return sb;\n  }\n  return new StringBuilder();\n}\n\n@Benchmark\npublic StringBuilder isEmpty() {\n  if (sb.isEmpty()) {\n    return sb;\n  }\n  return new StringBuilder();\n}\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": ""
  },
  {
    "id": "S2272",
    "key": "java:S2272",
    "name": "\"Iterator.next()\" methods should throw \"NoSuchElementException\"",
    "type": "bug",
    "severity": "minor",
    "tags": [
      "error-handling",
      "unpredictable"
    ],
    "why": "<p>The <code>java.util.Iterator.next()</code> method must throw a <code>NoSuchElementException</code> when there are no more elements in the\niteration. Any other behavior is non-compliant with the API contract and may cause unexpected behavior for users.</p>\n<h3>Noncompliant code example</h3>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\npublic class MyIterator implements Iterator&lt;String&gt; {\n  public String next() {\n    if (!hasNext()) {\n      return null;\n    }\n    // ...\n  }\n}\n</pre>\n<h3>Compliant solution</h3>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\npublic class MyIterator implements Iterator&lt;String&gt; {\n  public String next() {\n    if (!hasNext()) {\n      throw new NoSuchElementException();\n    }\n    // ...\n  }\n}\n</pre>",
    "howToFix": "",
    "moreInfo": "<h3>Documentation</h3>\n<ul>\n  <li> <a href=\"https://docs.oracle.com/javase/7/docs/api/java/util/Iterator.html#next--\">Java SE 7 API Specification: Iterator</a> </li>\n</ul>",
    "status": "READY",
    "name_ko": "\"Iterator.next()\" 메서드는 \"NoSuchElementException\"을 던져야 합니다",
    "why_ko": "<p><code>java.util.Iterator.next()</code> 메서드는 반복에 더 이상 요소가 없을 때 <code>NoSuchElementException</code>을 던져야 합니다. 다른 동작은 API 계약을 준수하지 않으며 사용자에게 예기치 않은 동작을 유발할 수 있습니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\npublic class MyIterator implements Iterator&lt;String&gt; {\n  public String next() {\n    if (!hasNext()) {\n      return null;\n    }\n    // ...\n  }\n}\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\npublic class MyIterator implements Iterator&lt;String&gt; {\n  public String next() {\n    if (!hasNext()) {\n      throw new NoSuchElementException();\n    }\n    // ...\n  }\n}\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": "<h3>문서</h3>\n<ul>\n  <li> <a href=\"https://docs.oracle.com/javase/7/docs/api/java/util/Iterator.html#next--\">Java SE 7 API Specification: Iterator</a> </li>\n</ul>"
  },
  {
    "id": "S4349",
    "key": "java:S4349",
    "name": "\"write(byte[],int,int)\" should be overridden",
    "type": "code-smell",
    "severity": "minor",
    "tags": [
      "performance"
    ],
    "why": "<p>When directly subclassing <code>java.io.OutputStream</code> or <code>java.io.FilterOutputStream</code>, the only requirement is that you implement\nthe method <code>write(int)</code>. However most uses for such streams don't write a single byte at a time and the default implementation for\n<code>write(byte[],int,int)</code> will call <code>write(int)</code> for every single byte in the array which can create a lot of overhead and is\nutterly inefficient. It is therefore strongly recommended that subclasses provide an efficient implementation of\n<code>write(byte[],int,int)</code>.</p>\n<p>This rule raises an issue when a direct subclass of <code>java.io.OutputStream</code> or <code>java.io.FilterOutputStream</code> doesn't provide an\noverride of <code>write(byte[],int,int)</code>.</p>\n<h3>Noncompliant code example</h3>\n<pre>\npublic class MyStream extends OutputStream { // Noncompliant\n    private FileOutputStream fout;\n\n    public MyStream(File file) throws IOException {\n        fout = new FileOutputStream(file);\n    }\n\n    @Override\n    public void write(int b) throws IOException {\n        fout.write(b);\n    }\n\n    @Override\n    public void close() throws IOException {\n        fout.write(\"\\n\\n\".getBytes());\n        fout.close();\n        super.close();\n    }\n}\n</pre>\n<h3>Compliant solution</h3>\n<pre>\npublic class MyStream extends OutputStream {\n    private FileOutputStream fout;\n\n    public MyStream(File file) throws IOException {\n        fout = new FileOutputStream(file);\n    }\n\n    @Override\n    public void write(int b) throws IOException {\n        fout.write(b);\n    }\n\n    @Override\n    public void write(byte[] b, int off, int len) throws IOException {\n        fout.write(b, off, len);\n    }\n\n    @Override\n    public void close() throws IOException {\n        fout.write(\"\\n\\n\".getBytes());\n        fout.close();\n        super.close();\n    }\n}\n</pre>\n<h3>Exceptions</h3>\n<p>This rule doesn't raise an issue when the class is declared <code>abstract</code>.</p>",
    "howToFix": "",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "\"write(byte[],int,int)\"를 오버라이드해야 합니다",
    "why_ko": "<p><code>java.io.OutputStream</code> 또는 <code>java.io.FilterOutputStream</code>을 직접 상속할 때 유일한 요구 사항은 <code>write(int)</code> 메서드를 구현하는 것입니다. 그러나 이러한 스트림의 대부분의 사용 사례는 한 번에 한 바이트를 쓰지 않으며, <code>write(byte[],int,int)</code>의 기본 구현은 배열의 모든 단일 바이트에 대해 <code>write(int)</code>를 호출하여 많은 오버헤드를 생성하고 매우 비효율적입니다. 따라서 서브클래스가 <code>write(byte[],int,int)</code>의 효율적인 구현을 제공하는 것이 강력히 권장됩니다.</p>\n<p>이 규칙은 <code>java.io.OutputStream</code> 또는 <code>java.io.FilterOutputStream</code>의 직접 서브클래스가 <code>write(byte[],int,int)</code>의 오버라이드를 제공하지 않을 때 문제를 제기합니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\npublic class MyStream extends OutputStream { // 규칙 위반\n    private FileOutputStream fout;\n\n    public MyStream(File file) throws IOException {\n        fout = new FileOutputStream(file);\n    }\n\n    @Override\n    public void write(int b) throws IOException {\n        fout.write(b);\n    }\n\n    @Override\n    public void close() throws IOException {\n        fout.write(\"\\n\\n\".getBytes());\n        fout.close();\n        super.close();\n    }\n}\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre>\npublic class MyStream extends OutputStream {\n    private FileOutputStream fout;\n\n    public MyStream(File file) throws IOException {\n        fout = new FileOutputStream(file);\n    }\n\n    @Override\n    public void write(int b) throws IOException {\n        fout.write(b);\n    }\n\n    @Override\n    public void write(byte[] b, int off, int len) throws IOException {\n        fout.write(b, off, len);\n    }\n\n    @Override\n    public void close() throws IOException {\n        fout.write(\"\\n\\n\".getBytes());\n        fout.close();\n        super.close();\n    }\n}\n</pre>\n<h3>예외</h3>\n<p>이 규칙은 클래스가 <code>abstract</code>로 선언된 경우 문제를 제기하지 않습니다.</p>",
    "howToFix_ko": "",
    "moreInfo_ko": ""
  },
  {
    "id": "S6374",
    "key": "java:S6374",
    "name": "XML parsers should not load external schemas",
    "type": "vulnerability",
    "severity": "major",
    "tags": [
      "symbolic-execution"
    ],
    "why": "<p>By default XML processors attempt to load all XML schemas and DTD (their locations are defined with <code>xsi:schemaLocation</code> attributes and\n<code>DOCTYPE</code> declarations), potentially from an external storage such as file system or network, which may lead, if no restrictions are put in\nplace, to <a href=\"https://owasp.org/www-community/attacks/Server_Side_Request_Forgery\">server-side request forgery (SSRF)</a> vulnerabilities.</p>\n<h3>Noncompliant code example</h3>\n<p>For <a href=\"https://docs.oracle.com/javase/9/docs/api/javax/xml/parsers/DocumentBuilderFactory.html\">DocumentBuilder</a>, <a\nhref=\"https://docs.oracle.com/javase/9/docs/api/javax/xml/parsers/SAXParserFactory.html\">SAXParser</a> and <a\nhref=\"https://docs.oracle.com/javase/9/docs/api/javax/xml/validation/SchemaFactory.html\">Schema</a> JAPX factories:</p>\n<pre>\nDocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\nfactory.setValidating(true); // Noncompliant\nfactory.setFeature(\"http://apache.org/xml/features/nonvalidating/load-external-dtd\", true); // Noncompliant\n\nSAXParserFactory factory = SAXParserFactory.newInstance();\nfactory.setValidating(true); // Noncompliant\nfactory.setFeature(\"http://apache.org/xml/features/nonvalidating/load-external-dtd\", true); // Noncompliant\n\nSchemaFactory schemaFactory = SchemaFactory.newInstance(XMLConstants.W3C_XML_SCHEMA_NS_URI);\nschemaFactory.setFeature(\"http://apache.org/xml/features/nonvalidating/load-external-dtd\", true); // Noncompliant\n</pre>\n<p>For <a href=\"https://dom4j.github.io/\">Dom4j</a> library:</p>\n<pre>\nSAXReader xmlReader = new SAXReader(); // Noncompliant\nxmlReader.setFeature(\"http://apache.org/xml/features/nonvalidating/load-external-dtd\", true);  // Noncompliant\n</pre>\n<p>For <a href=\"http://www.jdom.org/\">Jdom2</a> library:</p>\n<pre>\nSAXBuilder builder = new SAXBuilder();\nbuilder.setFeature(\"http://apache.org/xml/features/nonvalidating/load-external-dtd\", true); // Noncompliant\n</pre>\n<h3>Compliant solution</h3>\n<p>For <a href=\"https://docs.oracle.com/javase/9/docs/api/javax/xml/parsers/DocumentBuilderFactory.html\">DocumentBuilder</a>, <a\nhref=\"https://docs.oracle.com/javase/9/docs/api/javax/xml/parsers/SAXParserFactory.html\">SAXParser</a> and <a\nhref=\"https://docs.oracle.com/javase/9/docs/api/javax/xml/validation/SchemaFactory.html\">Schema</a> JAPX factories:</p>\n<pre>\nDocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\nfactory.setFeature(\"http://apache.org/xml/features/nonvalidating/load-external-dtd\", false);\n\nSAXParserFactory factory = SAXParserFactory.newInstance();\nfactory.setFeature(\"http://apache.org/xml/features/nonvalidating/load-external-dtd\", false);\n\nSchemaFactory schemaFactory = SchemaFactory.newInstance(XMLConstants.W3C_XML_SCHEMA_NS_URI);\nschemaFactory.setFeature(\"http://apache.org/xml/features/nonvalidating/load-external-dtd\", false);\n</pre>\n<p>For <a href=\"https://dom4j.github.io/\">Dom4j</a> library:</p>\n<pre>\nSAXReader xmlReader = new SAXReader(); // Noncompliant\nxmlReader.setFeature(\"http://apache.org/xml/features/nonvalidating/load-external-dtd\", false);\n</pre>\n<p>For <a href=\"http://www.jdom.org/\">Jdom2</a> library:</p>\n<pre>\nSAXBuilder builder = new SAXBuilder();\nbuilder.setFeature(\"http://apache.org/xml/features/nonvalidating/load-external-dtd\", false);\n</pre>\n<h3>Exceptions</h3>\n<p>This rules does not raise an issue when an <code>EntityResolver</code> is set.</p>\n<pre>\nDocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\nfactory.setValidating(true);\nDocumentBuilder builder = factory.newDocumentBuilder();\nbuilder.setEntityResolver(new MyEntityResolver());\n\nSAXBuilder builder = new SAXBuilder();\nbuilder.setFeature(\"http://apache.org/xml/features/nonvalidating/load-external-dtd\", true);\nbuilder.setEntityResolver(new EntityResolver());\n</pre>",
    "howToFix": "",
    "moreInfo": "<ul>\n  <li> <a\n  href=\"https://docs.oracle.com/en/java/javase/13/security/java-api-xml-processing-jaxp-security-guide.html#GUID-8CD65EF5-D113-4D5C-A564-B875C8625FAC\">Oracle Java Documentation</a> - XML External Entity Injection Attack </li>\n  <li> OWASP - <a href=\"https://owasp.org/www-project-top-ten/2017/A4_2017-XML_External_Entities_(XXE)\">Top 10 2017 Category A4 - XML External\n  Entities (XXE)</a> </li>\n  <li> <a href=\"https://cheatsheetseries.owasp.org/cheatsheets/XML_External_Entity_Prevention_Cheat_Sheet.html#java\">OWASP XXE Prevention Cheat\n  Sheet</a> </li>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/611\">CWE-611 - Information Exposure Through XML External Entity Reference</a> </li>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/827\">CWE-827 - Improper Control of Document Type Definition</a> </li>\n</ul>",
    "status": "DEPRECATED",
    "name_ko": "XML 파서는 외부 스키마를 로드하면 안 됩니다",
    "why_ko": "<p>기본적으로 XML 프로세서는 모든 XML 스키마와 DTD(그 위치는 <code>xsi:schemaLocation</code> 속성과 <code>DOCTYPE</code> 선언으로 정의됨)를 로드하려고 시도하며, 이는 잠재적으로 파일 시스템이나 네트워크와 같은 외부 저장소에서 로드될 수 있습니다. 제한이 설정되지 않으면 <a href=\"https://owasp.org/www-community/attacks/Server_Side_Request_Forgery\">서버 측 요청 위조(SSRF)</a> 취약점으로 이어질 수 있습니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<p><a href=\"https://docs.oracle.com/javase/9/docs/api/javax/xml/parsers/DocumentBuilderFactory.html\">DocumentBuilder</a>, <a href=\"https://docs.oracle.com/javase/9/docs/api/javax/xml/parsers/SAXParserFactory.html\">SAXParser</a> 및 <a href=\"https://docs.oracle.com/javase/9/docs/api/javax/xml/validation/SchemaFactory.html\">Schema</a> JAXP 팩토리의 경우:</p>\n<pre>\nDocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\nfactory.setValidating(true); // 규칙 위반\nfactory.setFeature(\"http://apache.org/xml/features/nonvalidating/load-external-dtd\", true); // 규칙 위반\n\nSAXParserFactory factory = SAXParserFactory.newInstance();\nfactory.setValidating(true); // 규칙 위반\nfactory.setFeature(\"http://apache.org/xml/features/nonvalidating/load-external-dtd\", true); // 규칙 위반\n\nSchemaFactory schemaFactory = SchemaFactory.newInstance(XMLConstants.W3C_XML_SCHEMA_NS_URI);\nschemaFactory.setFeature(\"http://apache.org/xml/features/nonvalidating/load-external-dtd\", true); // 규칙 위반\n</pre>\n<p><a href=\"https://dom4j.github.io/\">Dom4j</a> 라이브러리의 경우:</p>\n<pre>\nSAXReader xmlReader = new SAXReader(); // 규칙 위반\nxmlReader.setFeature(\"http://apache.org/xml/features/nonvalidating/load-external-dtd\", true);  // 규칙 위반\n</pre>\n<p><a href=\"http://www.jdom.org/\">Jdom2</a> 라이브러리의 경우:</p>\n<pre>\nSAXBuilder builder = new SAXBuilder();\nbuilder.setFeature(\"http://apache.org/xml/features/nonvalidating/load-external-dtd\", true); // 규칙 위반\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<p><a href=\"https://docs.oracle.com/javase/9/docs/api/javax/xml/parsers/DocumentBuilderFactory.html\">DocumentBuilder</a>, <a href=\"https://docs.oracle.com/javase/9/docs/api/javax/xml/parsers/SAXParserFactory.html\">SAXParser</a> 및 <a href=\"https://docs.oracle.com/javase/9/docs/api/javax/xml/validation/SchemaFactory.html\">Schema</a> JAXP 팩토리의 경우:</p>\n<pre>\nDocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\nfactory.setFeature(\"http://apache.org/xml/features/nonvalidating/load-external-dtd\", false);\n\nSAXParserFactory factory = SAXParserFactory.newInstance();\nfactory.setFeature(\"http://apache.org/xml/features/nonvalidating/load-external-dtd\", false);\n\nSchemaFactory schemaFactory = SchemaFactory.newInstance(XMLConstants.W3C_XML_SCHEMA_NS_URI);\nschemaFactory.setFeature(\"http://apache.org/xml/features/nonvalidating/load-external-dtd\", false);\n</pre>\n<p><a href=\"https://dom4j.github.io/\">Dom4j</a> 라이브러리의 경우:</p>\n<pre>\nSAXReader xmlReader = new SAXReader(); // 규칙 위반\nxmlReader.setFeature(\"http://apache.org/xml/features/nonvalidating/load-external-dtd\", false);\n</pre>\n<p><a href=\"http://www.jdom.org/\">Jdom2</a> 라이브러리의 경우:</p>\n<pre>\nSAXBuilder builder = new SAXBuilder();\nbuilder.setFeature(\"http://apache.org/xml/features/nonvalidating/load-external-dtd\", false);\n</pre>\n<h3>예외</h3>\n<p>이 규칙은 <code>EntityResolver</code>가 설정된 경우 문제를 발생시키지 않습니다.</p>\n<pre>\nDocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\nfactory.setValidating(true);\nDocumentBuilder builder = factory.newDocumentBuilder();\nbuilder.setEntityResolver(new MyEntityResolver());\n\nSAXBuilder builder = new SAXBuilder();\nbuilder.setFeature(\"http://apache.org/xml/features/nonvalidating/load-external-dtd\", true);\nbuilder.setEntityResolver(new EntityResolver());\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": "<ul>\n  <li> <a href=\"https://docs.oracle.com/en/java/javase/13/security/java-api-xml-processing-jaxp-security-guide.html#GUID-8CD65EF5-D113-4D5C-A564-B875C8625FAC\">Oracle Java Documentation</a> - XML 외부 엔티티 인젝션 공격 </li>\n  <li> OWASP - <a href=\"https://owasp.org/www-project-top-ten/2017/A4_2017-XML_External_Entities_(XXE)\">Top 10 2017 Category A4 - XML 외부 엔티티(XXE)</a> </li>\n  <li> <a href=\"https://cheatsheetseries.owasp.org/cheatsheets/XML_External_Entity_Prevention_Cheat_Sheet.html#java\">OWASP XXE 예방 치트 시트</a> </li>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/611\">CWE-611 - XML 외부 엔티티 참조를 통한 정보 노출</a> </li>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/827\">CWE-827 - 문서 타입 정의의 부적절한 제어</a> </li>\n</ul>"
  },
  {
    "id": "S4719",
    "key": "java:S4719",
    "name": "\"StandardCharsets\" constants should be preferred",
    "type": "code-smell",
    "severity": "minor",
    "tags": [
      "java7",
      "clumsy"
    ],
    "why": "<p>JDK7 introduced the class <code>java.nio.charset.StandardCharsets</code>. It provides constants for all charsets that are guaranteed to be\navailable on every implementation of the Java platform.</p>\n<ul>\n  <li> ISO_8859_1 </li>\n  <li> US_ASCII </li>\n  <li> UTF_16 </li>\n  <li> UTF_16BE </li>\n  <li> UTF_16LE </li>\n  <li> UTF_8 </li>\n</ul>\n<p>These constants should be preferred to:</p>\n<ul>\n  <li> the use of a String such as \"UTF-8\" which has the drawback of requiring the <code>catch</code>/<code>throw</code> of an\n  <code>UnsupportedEncodingException</code> that will never actually happen </li>\n  <li> the use of Guava's <code>Charsets</code> class, which has been obsolete since JDK7 </li>\n</ul>\n<h3>Noncompliant code example</h3>\n<pre>\ntry {\n  byte[] bytes = string.getBytes(\"UTF-8\"); // Noncompliant; use a String instead of StandardCharsets.UTF_8\n} catch (UnsupportedEncodingException e) {\n  throw new AssertionError(e);\n}\n// ...\nbyte[] bytes = string.getBytes(Charsets.UTF_8); // Noncompliant; Guava way obsolete since JDK7\n</pre>\n<h3>Compliant solution</h3>\n<pre>\nbyte[] bytes = string.getBytes(StandardCharsets.UTF_8)\n</pre>",
    "howToFix": "",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "\"StandardCharsets\" 상수를 사용하는 것이 좋습니다",
    "why_ko": "<p>JDK7은 <code>java.nio.charset.StandardCharsets</code> 클래스를 도입했습니다. 이 클래스는 Java 플랫폼의 모든 구현에서 사용 가능하도록 보장된 모든 문자 집합에 대한 상수를 제공합니다.</p>\n<ul>\n  <li> ISO_8859_1 </li>\n  <li> US_ASCII </li>\n  <li> UTF_16 </li>\n  <li> UTF_16BE </li>\n  <li> UTF_16LE </li>\n  <li> UTF_8 </li>\n</ul>\n<p>이러한 상수는 다음보다 선호되어야 합니다:</p>\n<ul>\n  <li> 실제로 발생하지 않을 <code>UnsupportedEncodingException</code>의 <code>catch</code>/<code>throw</code>를 요구하는 단점이 있는 \"UTF-8\"과 같은 문자열 사용 </li>\n  <li> JDK7 이후 더 이상 사용되지 않는 Guava의 <code>Charsets</code> 클래스 사용 </li>\n</ul>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\ntry {\n  byte[] bytes = string.getBytes(\"UTF-8\"); // 규칙 위반; StandardCharsets.UTF_8 대신 문자열을 사용\n} catch (UnsupportedEncodingException e) {\n  throw new AssertionError(e);\n}\n// ...\nbyte[] bytes = string.getBytes(Charsets.UTF_8); // 규칙 위반; JDK7 이후 더 이상 사용되지 않는 Guava 방식\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre>\nbyte[] bytes = string.getBytes(StandardCharsets.UTF_8)\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": ""
  },
  {
    "id": "S6548",
    "key": "java:S6548",
    "name": "The Singleton design pattern should be used with care",
    "type": "code-smell",
    "severity": "info",
    "tags": [
      "design"
    ],
    "why": "<p>While the Singleton pattern can be useful in certain situations, overusing it can have several drawbacks:</p>\n<ul>\n  <li> Tight coupling: The Singleton pattern can create tight coupling between the Singleton class and other classes that use it, making the code\n  difficult to maintain and modify. </li>\n  <li> Global state: The Singleton pattern can create a global state, making it difficult to manage the state of the application and leading to\n  unexpected behavior. </li>\n  <li> Testing: The Singleton pattern can make it difficult to test classes that depend on the Singleton, as the Singleton cannot be easily\n  substituted with a mock object. </li>\n  <li> Scalability: The Singleton pattern can make it difficult to scale an application, as it can create a bottleneck if multiple threads try to\n  access the Singleton concurrently. </li>\n  <li> Dependency injection: The Singleton pattern can make it difficult to use dependency injection frameworks, as the Singleton instance is usually\n  created statically. </li>\n</ul>\n<p>In general, the Singleton pattern should be used sparingly and only in situations where it provides a clear benefit over other patterns or\napproaches. It is important to consider the drawbacks and tradeoffs of using the Singleton pattern before incorporating it into an application.</p>\n<h3>What is the potential impact?</h3>\n<h4>Enum Implementation</h4>\n<pre>\npublic enum EnumSingleton {\n\n    INSTANCE;\n\n    private EnumSingleton() {\n        // Initialization code here...\n    }\n}\n</pre>\n<p><strong>Advantages</strong>:</p>\n<p>This implementation is thread-safe by default because the initialization of an Enum value is guaranteed to be thread-safe and atomic.</p>\n<p>The Enum Singleton implementation allows for lazy initialization while also providing thread-safety guarantees.</p>\n<h4>Bill Pugh Implementation</h4>\n<pre>\npublic class BillPughSingleton {\n\n    private BillPughSingleton(){}\n\n    private static class SingletonHelper {\n        private static final BillPughSingleton INSTANCE = new BillPughSingleton();\n    }\n\n    public static BillPughSingleton getInstance() {\n        return SingletonHelper.INSTANCE;\n    }\n}\n</pre>\n<p><strong>Advantages</strong>:</p>\n<p>The instance is created only at the first call of the <code>getInstance()</code> method.</p>\n<p>This implementation is thread-safe.</p>\n<h4>Thread Safe Implementation</h4>\n<pre>\npublic class ThreadSafeSingleton {\n\n    private static ThreadSafeSingleton instance;\n\n    private ThreadSafeSingleton(){}\n\n    public static synchronized ThreadSafeSingleton getInstance() {\n        if (instance == null) {\n            instance = new ThreadSafeSingleton();\n        }\n        return instance;\n    }\n}\n</pre>\n<p><strong>Advantage</strong>:</p>\n<p>This implementation is thread-safe.</p>\n<p><strong>Disadvantage</strong>:</p>\n<p>It reduces the performance because of the cost associated with the synchronized method. To avoid this extra overhead every time, double-checked\nlocking principle should be used.</p>\n<h4>Static Block Initialization Implementation</h4>\n<pre>\npublic class StaticBlockSingleton {\n\n    private static StaticBlockSingleton instance;\n\n    private StaticBlockSingleton(){}\n\n    static {\n        try {\n            instance = new StaticBlockSingleton();\n        } catch (Exception e) {\n            throw new RuntimeException(\"Exception while creating singleton instance\");\n        }\n    }\n\n    public static StaticBlockSingleton getInstance() {\n        return instance;\n    }\n}\n</pre>\n<p><strong>Advantage</strong>:</p>\n<p>Compared to the Eager Initialization, this implementation provides options for exception handling.</p>\n<p><strong>Disadvantage</strong>:</p>\n<p>The instance is created even if it's never used, like for the Eager Initialization implementation.</p>\n<h4>Eager Initialization Implementation</h4>\n<pre>\npublic class EagerInitializedSingleton {\n\n    private static final EagerInitializedSingleton instance = new EagerInitializedSingleton();\n\n    private EagerInitializedSingleton() {}\n\n    public static EagerInitializedSingleton getInstance() {\n        return instance;\n    }\n}\n</pre>\n<p><strong>Advantage</strong>:</p>\n<p>This implementation is thread-safe, as the instance variable is initialized when the class is loaded.</p>\n<p><strong>Disadvantages</strong>:</p>\n<p>The instance is created even if it's never used, which can be wasteful in terms of memory usage. However, if the Singleton is expected to be used\nfrequently or is not too memory-intensive, Eager Initialization can be a good choice.</p>\n<p>This implementation doesn't provide any options for exception handling.</p>\n<h4>Lazy Initialization Implementation</h4>\n<pre>\npublic class LazyInitializedSingleton {\n\n    private static LazyInitializedSingleton instance;\n\n    private LazyInitializedSingleton(){}\n\n    public static LazyInitializedSingleton getInstance() {\n        if (instance == null) {\n            instance = new LazyInitializedSingleton();\n        }\n        return instance;\n    }\n}\n</pre>\n<p><strong>Advantage</strong>:</p>\n<p>This implementation works fine in the case of the single-threaded environment.</p>\n<p><strong>Disadvantage</strong>:</p>\n<p>This implementation is not thread-safe if multiple threads are at the same time in the <code>if</code> condition.</p>\n<h4>Public Static Field Implementation</h4>\n<pre>\npublic class PublicStaticSingleton {\n\n    public static final PublicStaticSingleton INSTANCE = new PublicStaticSingleton();\n\n    private PublicStaticSingleton() {}\n}\n</pre>\n<p><strong>Advantage</strong>:</p>\n<p>This implementation is thread-safe.</p>\n<p><strong>Disadvantage</strong>:</p>\n<p>This implementation does not allow lazy initialization: the constructor runs as soon as the class is initialized.</p>",
    "howToFix": "",
    "moreInfo": "",
    "status": "BETA",
    "name_ko": "Singleton 디자인 패턴은 주의해서 사용해야 합니다",
    "why_ko": "<p>Singleton 패턴은 특정 상황에서 유용할 수 있지만 과도하게 사용하면 여러 단점이 있습니다:</p>\n<ul>\n  <li> 강한 결합: Singleton 패턴은 Singleton 클래스와 이를 사용하는 다른 클래스 간에 강한 결합을 만들어 코드를 유지 관리하고 수정하기 어렵게 만들 수 있습니다. </li>\n  <li> 전역 상태: Singleton 패턴은 전역 상태를 만들어 애플리케이션의 상태를 관리하기 어렵게 하고 예상치 못한 동작을 유발할 수 있습니다. </li>\n  <li> 테스트: Singleton 패턴은 Singleton을 모의 객체로 쉽게 대체할 수 없으므로 Singleton에 의존하는 클래스를 테스트하기 어렵게 만들 수 있습니다. </li>\n  <li> 확장성: Singleton 패턴은 여러 스레드가 동시에 Singleton에 접근하려고 하면 병목 현상이 발생할 수 있어 애플리케이션을 확장하기 어렵게 만들 수 있습니다. </li>\n  <li> 의존성 주입: Singleton 인스턴스는 일반적으로 정적으로 생성되므로 Singleton 패턴은 의존성 주입 프레임워크를 사용하기 어렵게 만들 수 있습니다. </li>\n</ul>\n<p>일반적으로 Singleton 패턴은 다른 패턴이나 접근 방식에 비해 명확한 이점을 제공하는 상황에서만 드물게 사용해야 합니다. 애플리케이션에 Singleton 패턴을 통합하기 전에 단점과 트레이드오프를 고려하는 것이 중요합니다.</p>\n<h3>잠재적 영향은 무엇인가요?</h3>\n<h4>Enum 구현</h4>\n<pre>\npublic enum EnumSingleton {\n\n    INSTANCE;\n\n    private EnumSingleton() {\n        // 초기화 코드...\n    }\n}\n</pre>\n<p><strong>장점</strong>:</p>\n<p>Enum 값의 초기화는 스레드 안전하고 원자적임이 보장되므로 이 구현은 기본적으로 스레드 안전합니다.</p>\n<p>Enum Singleton 구현은 스레드 안전성 보장을 제공하면서 지연 초기화를 허용합니다.</p>\n<h4>Bill Pugh 구현</h4>\n<pre>\npublic class BillPughSingleton {\n\n    private BillPughSingleton(){}\n\n    private static class SingletonHelper {\n        private static final BillPughSingleton INSTANCE = new BillPughSingleton();\n    }\n\n    public static BillPughSingleton getInstance() {\n        return SingletonHelper.INSTANCE;\n    }\n}\n</pre>\n<p><strong>장점</strong>:</p>\n<p>인스턴스는 <code>getInstance()</code> 메서드의 첫 번째 호출에서만 생성됩니다.</p>\n<p>이 구현은 스레드 안전합니다.</p>\n<h4>스레드 안전 구현</h4>\n<pre>\npublic class ThreadSafeSingleton {\n\n    private static ThreadSafeSingleton instance;\n\n    private ThreadSafeSingleton(){}\n\n    public static synchronized ThreadSafeSingleton getInstance() {\n        if (instance == null) {\n            instance = new ThreadSafeSingleton();\n        }\n        return instance;\n    }\n}\n</pre>\n<p><strong>장점</strong>:</p>\n<p>이 구현은 스레드 안전합니다.</p>\n<p><strong>단점</strong>:</p>\n<p>synchronized 메서드와 관련된 비용으로 인해 성능이 저하됩니다. 매번 이러한 추가 오버헤드를 피하려면 이중 확인 잠금 원칙을 사용해야 합니다.</p>\n<h4>정적 블록 초기화 구현</h4>\n<pre>\npublic class StaticBlockSingleton {\n\n    private static StaticBlockSingleton instance;\n\n    private StaticBlockSingleton(){}\n\n    static {\n        try {\n            instance = new StaticBlockSingleton();\n        } catch (Exception e) {\n            throw new RuntimeException(\"싱글톤 인스턴스 생성 중 예외\");\n        }\n    }\n\n    public static StaticBlockSingleton getInstance() {\n        return instance;\n    }\n}\n</pre>\n<p><strong>장점</strong>:</p>\n<p>Eager 초기화와 비교하여 이 구현은 예외 처리 옵션을 제공합니다.</p>\n<p><strong>단점</strong>:</p>\n<p>Eager 초기화 구현과 마찬가지로 사용되지 않더라도 인스턴스가 생성됩니다.</p>\n<h4>Eager 초기화 구현</h4>\n<pre>\npublic class EagerInitializedSingleton {\n\n    private static final EagerInitializedSingleton instance = new EagerInitializedSingleton();\n\n    private EagerInitializedSingleton() {}\n\n    public static EagerInitializedSingleton getInstance() {\n        return instance;\n    }\n}\n</pre>\n<p><strong>장점</strong>:</p>\n<p>클래스가 로드될 때 인스턴스 변수가 초기화되므로 이 구현은 스레드 안전합니다.</p>\n<p><strong>단점</strong>:</p>\n<p>인스턴스가 사용되지 않더라도 생성되어 메모리 사용 측면에서 낭비가 될 수 있습니다. 그러나 Singleton이 자주 사용되거나 메모리 집약적이지 않다면 Eager 초기화가 좋은 선택이 될 수 있습니다.</p>\n<p>이 구현은 예외 처리에 대한 옵션을 제공하지 않습니다.</p>\n<h4>Lazy 초기화 구현</h4>\n<pre>\npublic class LazyInitializedSingleton {\n\n    private static LazyInitializedSingleton instance;\n\n    private LazyInitializedSingleton(){}\n\n    public static LazyInitializedSingleton getInstance() {\n        if (instance == null) {\n            instance = new LazyInitializedSingleton();\n        }\n        return instance;\n    }\n}\n</pre>\n<p><strong>장점</strong>:</p>\n<p>이 구현은 단일 스레드 환경에서 잘 작동합니다.</p>\n<p><strong>단점</strong>:</p>\n<p>여러 스레드가 동시에 <code>if</code> 조건에 있으면 이 구현은 스레드 안전하지 않습니다.</p>\n<h4>Public Static 필드 구현</h4>\n<pre>\npublic class PublicStaticSingleton {\n\n    public static final PublicStaticSingleton INSTANCE = new PublicStaticSingleton();\n\n    private PublicStaticSingleton() {}\n}\n</pre>\n<p><strong>장점</strong>:</p>\n<p>이 구현은 스레드 안전합니다.</p>\n<p><strong>단점</strong>:</p>\n<p>이 구현은 지연 초기화를 허용하지 않습니다: 클래스가 초기화되면 생성자가 바로 실행됩니다.</p>",
    "howToFix_ko": "",
    "moreInfo_ko": ""
  },
  {
    "id": "S3032",
    "key": "java:S3032",
    "name": "JEE applications should not \"getClassLoader\"",
    "type": "bug",
    "severity": "minor",
    "tags": [
      "jee"
    ],
    "why": "<p>Using the standard <code>getClassLoader()</code> may not return the <em>right</em> class loader in a JEE context. Instead, go through the\n<code>currentThread</code>.</p>\n<h3>Noncompliant code example</h3>\n<pre>\nClassLoader cl = this.getClass().getClassLoader();  // Noncompliant\n</pre>\n<h3>Compliant solution</h3>\n<pre>\nClassLoader cl = Thread.currentThread().getContextClassLoader();\n</pre>",
    "howToFix": "",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "JEE 애플리케이션에서 \"getClassLoader\"를 사용하면 안 됩니다",
    "why_ko": "<p>표준 <code>getClassLoader()</code>를 사용하면 JEE 컨텍스트에서 <em>올바른</em> 클래스 로더를 반환하지 않을 수 있습니다. 대신 <code>currentThread</code>를 통해 가져오세요.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\nClassLoader cl = this.getClass().getClassLoader();  // 규칙 위반\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre>\nClassLoader cl = Thread.currentThread().getContextClassLoader();\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": ""
  },
  {
    "id": "S2789",
    "key": "java:S2789",
    "name": "\"null\" should not be used with \"Optional\"",
    "type": "bug",
    "severity": "major",
    "tags": [
      "java8"
    ],
    "why": "<p><code>Optional</code> acts as a container object that may or may not contain a non-null value. It is introduced in Java 8 to help avoid\n<code>NullPointerException</code>. It provides methods to check if a value is present and retrieve the value if it is present.</p>\n<p><code>Optional</code> is used instead of <code>null</code> values to make the code more readable and avoid potential errors.</p>\n<p>It is a bad practice to use <code>null</code> with <code>Optional</code> because it is unclear whether a value is present or not, leading to\nconfusion and potential <code>NullPointerException</code> errors.</p>",
    "howToFix": "<p>There are a few ways to fix this issue:</p>\n<ul>\n  <li> Avoid returning <code>null</code> from a method whose return type is <code>Optional</code>. </li>\n  <li> Remove the null-check of an <code>Optional</code> and use <code>Optional</code> methods instead, like <code>isPresent()</code> or\n  <code>ifPresent()</code>. </li>\n</ul>\n\n<h4>Noncompliant code example</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\npublic void doSomething () {\n  Optional&lt;String&gt; optional = getOptional();\n  if (optional != null) {  // Noncompliant\n    // do something with optional...\n  }\n  Optional&lt;String&gt; text = null; // Noncompliant, a variable whose type is Optional should never itself be null\n  // ...\n}\n\n@Nullable // Noncompliant\npublic Optional&lt;String&gt; getOptional() {\n  // ...\n  return null;  // Noncompliant\n}\n</pre>\n<h4>Compliant solution</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\npublic void doSomething () {\n  Optional&lt;String&gt; optional = getOptional();\n  optional.ifPresent(\n    // do something with optional...\n  );\n  Optional&lt;String&gt; text = Optional.empty();\n  // ...\n}\n\npublic Optional&lt;String&gt; getOptional() {\n  // ...\n  return Optional.empty();\n}\n</pre>",
    "moreInfo": "<h3>Documentation</h3>\n<ul>\n  <li> <a href=\"https://docs.oracle.com/en/java/javase/20/docs/api/java.base/java/util/Optional.html\">Oracle SDK 20 - Optional</a> </li>\n</ul>\n<h3>Articles &amp; blog posts</h3>\n<ul>\n  <li> <a href=\"https://www.baeldung.com/java-optional\">Java Optional Guide</a> </li>\n</ul>",
    "status": "READY",
    "name_ko": "Optional과 함께 null을 사용하면 안 됩니다",
    "why_ko": "<p><code>Optional</code>은 null이 아닌 값을 포함하거나 포함하지 않을 수 있는 컨테이너 객체로 작동합니다. Java 8에서 <code>NullPointerException</code>을 피하기 위해 도입되었습니다. 값이 존재하는지 확인하고 존재하면 값을 검색하는 메서드를 제공합니다.</p>\n<p><code>Optional</code>은 코드를 더 읽기 쉽게 만들고 잠재적인 오류를 피하기 위해 <code>null</code> 값 대신 사용됩니다.</p>\n<p><code>Optional</code>과 함께 <code>null</code>을 사용하는 것은 값이 존재하는지 여부가 불분명하여 혼란과 잠재적인 <code>NullPointerException</code> 오류를 초래하므로 나쁜 관행입니다.</p>",
    "howToFix_ko": "<p>이 문제를 해결하는 몇 가지 방법이 있습니다:</p>\n<ul>\n  <li> 반환 타입이 <code>Optional</code>인 메서드에서 <code>null</code>을 반환하지 마세요. </li>\n  <li> <code>Optional</code>의 null 검사를 제거하고 대신 <code>isPresent()</code> 또는 <code>ifPresent()</code>와 같은 <code>Optional</code> 메서드를 사용하세요. </li>\n</ul>\n\n<h4>규칙을 준수하지 않는 코드 예시</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\npublic void doSomething () {\n  Optional&lt;String&gt; optional = getOptional();\n  if (optional != null) {  // 규칙 위반\n    // optional로 작업 수행...\n  }\n  Optional&lt;String&gt; text = null; // 규칙 위반, Optional 타입의 변수는 절대 null이면 안 됩니다\n  // ...\n}\n\n@Nullable // 규칙 위반\npublic Optional&lt;String&gt; getOptional() {\n  // ...\n  return null;  // 규칙 위반\n}\n</pre>\n<h4>규칙을 준수하는 해결책</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\npublic void doSomething () {\n  Optional&lt;String&gt; optional = getOptional();\n  optional.ifPresent(\n    // optional로 작업 수행...\n  );\n  Optional&lt;String&gt; text = Optional.empty();\n  // ...\n}\n\npublic Optional&lt;String&gt; getOptional() {\n  // ...\n  return Optional.empty();\n}\n</pre>",
    "moreInfo_ko": "<h3>문서</h3>\n<ul>\n  <li> <a href=\"https://docs.oracle.com/en/java/javase/20/docs/api/java.base/java/util/Optional.html\">Oracle SDK 20 - Optional</a> </li>\n</ul>\n<h3>관련 문서 및 블로그 게시물</h3>\n<ul>\n  <li> <a href=\"https://www.baeldung.com/java-optional\">Java Optional Guide</a> </li>\n</ul>"
  },
  {
    "id": "S2273",
    "key": "java:S2273",
    "name": "\"Object.wait()\", \"Object.notify()\" and \"Object.notifyAll()\" should only be called from synchronized code",
    "type": "bug",
    "severity": "major",
    "tags": [
      "multi-threading"
    ],
    "why": "<p>The <code>Object.wait(…​)</code>, <code>Object.notify()</code> and <code>Object.notifyAll()</code> methods are used in multithreaded environments\nto coordinate interdependent tasks that are performed by different threads. These methods are not thread-safe and by contract, they require the\ninvoking <code>Thread</code> to own the object's monitor. If a thread invokes one of these methods without owning the object's monitor an\n<code>IllegalMonitorStateException</code> is thrown.</p>",
    "howToFix": "<p>To become the owner of an object's monitor Java provides the <code>synchronized</code> keyword. In other words, calling\n<code>Object.wait(…​)</code>, <code>Object.notify()</code> and <code>Object.notifyAll()</code> on a given object should only be done from code\nsynchronized on the same object.</p>\n<p>For example, the call to <code>someObject.wait(…​)</code> should be wrapped in a <code>synchronized(someObject){ …​ }</code> block. If\n<code>wait</code> or <code>notify</code> are invoked on <code>this</code>, then the entire method can be marked as <code>synchronized</code>.</p>\n\n<h4>Noncompliant code example</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\nprivate void performSomeAction(Object syncValue) {\n  while (!suitableCondition()){\n    syncValue.wait(); // Noncompliant, not being inside a `synchronized` block, this will raise an IllegalMonitorStateException\n  }\n  ... // Perform some action\n}\n</pre>\n<h4>Compliant solution</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\nprivate void performSomeAction(Object syncValue) {\n  synchronized(syncValue) {\n    while (!suitableCondition()){\n      syncValue.wait(); // Compliant, the `synchronized` block guarantees ownership of syncValue's monitor\n    }\n    ... // Perform some action\n  }\n}\n</pre>",
    "moreInfo": "<h3>Documentation</h3>\n<ul>\n  <li> <a href=\"https://docs.oracle.com/javase/tutorial/essential/concurrency/syncmeth.html\">Java Documentation</a> - Synchronized methods </li>\n  <li> <a href=\"https://docs.oracle.com/javase%2F7%2Fdocs%2Fapi%2F%2F/java/lang/Object.html#wait()\">Java Documentation</a> - java.lang.Object class\n  and its methods </li>\n</ul>",
    "status": "READY",
    "name_ko": "\"Object.wait()\", \"Object.notify()\", \"Object.notifyAll()\"은 synchronized 코드에서만 호출해야 합니다",
    "why_ko": "<p><code>Object.wait(…​)</code>, <code>Object.notify()</code>, <code>Object.notifyAll()</code> 메서드는 멀티스레드 환경에서 서로 다른 스레드가 수행하는 상호 의존적인 작업을 조정하는 데 사용됩니다. 이러한 메서드는 스레드에 안전하지 않으며 계약상 호출하는 <code>Thread</code>가 객체의 모니터를 소유해야 합니다. 스레드가 객체의 모니터를 소유하지 않고 이러한 메서드 중 하나를 호출하면 <code>IllegalMonitorStateException</code>이 발생합니다.</p>",
    "howToFix_ko": "<p>객체의 모니터 소유자가 되기 위해 Java는 <code>synchronized</code> 키워드를 제공합니다. 즉, 주어진 객체에서 <code>Object.wait(…​)</code>, <code>Object.notify()</code>, <code>Object.notifyAll()</code>을 호출하는 것은 동일한 객체에서 동기화된 코드에서만 수행해야 합니다.</p>\n<p>예를 들어 <code>someObject.wait(…​)</code> 호출은 <code>synchronized(someObject){ …​ }</code> 블록으로 감싸야 합니다. <code>wait</code> 또는 <code>notify</code>가 <code>this</code>에서 호출되면 전체 메서드를 <code>synchronized</code>로 표시할 수 있습니다.</p>\n\n<h4>규칙을 준수하지 않는 코드 예시</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\nprivate void performSomeAction(Object syncValue) {\n  while (!suitableCondition()){\n    syncValue.wait(); // 규칙 위반, `synchronized` 블록 안에 있지 않으므로 IllegalMonitorStateException이 발생함\n  }\n  ... // 일부 작업 수행\n}\n</pre>\n<h4>규칙을 준수하는 해결책</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\nprivate void performSomeAction(Object syncValue) {\n  synchronized(syncValue) {\n    while (!suitableCondition()){\n      syncValue.wait(); // 규칙 준수, `synchronized` 블록이 syncValue 모니터의 소유권을 보장함\n    }\n    ... // 일부 작업 수행\n  }\n}\n</pre>",
    "moreInfo_ko": "<h3>문서</h3>\n<ul>\n  <li> <a href=\"https://docs.oracle.com/javase/tutorial/essential/concurrency/syncmeth.html\">Java Documentation</a> - Synchronized 메서드 </li>\n  <li> <a href=\"https://docs.oracle.com/javase%2F7%2Fdocs%2Fapi%2F%2F/java/lang/Object.html#wait()\">Java Documentation</a> - java.lang.Object 클래스와 메서드 </li>\n</ul>"
  },
  {
    "id": "S1849",
    "key": "java:S1849",
    "name": "\"Iterator.hasNext()\" should not call \"Iterator.next()\"",
    "type": "bug",
    "severity": "major",
    "tags": [],
    "why": "<p>Calling <code>Iterator.hasNext()</code> is not supposed to have any side effects and hence should not change the iterator's state.\n<code>Iterator.next()</code> advances the iterator by one item. So calling it inside <code>Iterator.hasNext()</code> breaks the <code>hasNext()</code>\ncontract and will lead to unexpected behavior in production.</p>",
    "howToFix": "<p>How to fix this issue strongly depends on the specific implementation of the iterator. Make sure that the logic of the <code>hasNext()</code>\nimplementation does not change the state of the iterator or any underlying data sources. Instead, it should merely return state information.</p>\n\n<h4>Noncompliant code example</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\nclass MyIterator implements Iterator&lt;Integer&gt; {\n\n  private Queue&lt;Integer&gt; elements;\n\n    ...\n\n  @Override\n  public boolean hasNext() {\n    try {\n      next(); // Noncompliant, next() is called from hasNext()\n      return true;\n    } catch (NoSuchElementException e) {\n      return false;\n    }\n  }\n\n  @Override\n  public Integer next() {\n    return elements.remove();\n  }\n}\n</pre>\n<h4>Compliant solution</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\nclass MyIterator implements Iterator&lt;Integer&gt; {\n\n  private Queue&lt;Integer&gt; elements;\n\n    ...\n\n  @Override\n  public boolean hasNext() {\n    return !elements.isEmpty(); // Compliant, no call to next()\n  }\n\n  @Override\n  public Integer next() {\n    return elements.remove();\n  }\n}\n</pre>",
    "moreInfo": "<ul>\n  <li> <a href=\"https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Iterator.html\">Interface Iterator&lt;E&gt; - Java® Platform SE\n  11 API Specification</a> </li>\n</ul>",
    "status": "READY",
    "name_ko": "\"Iterator.hasNext()\"에서 \"Iterator.next()\"를 호출하면 안 됩니다",
    "why_ko": "<p><code>Iterator.hasNext()</code>를 호출하는 것은 부작용이 없어야 하므로 반복자의 상태를 변경해서는 안 됩니다. <code>Iterator.next()</code>는 반복자를 한 항목씩 진행시킵니다. 따라서 <code>Iterator.hasNext()</code> 내부에서 호출하면 <code>hasNext()</code> 계약을 위반하고 프로덕션에서 예기치 않은 동작이 발생합니다.</p>",
    "howToFix_ko": "<p>이 문제를 해결하는 방법은 반복자의 특정 구현에 따라 크게 달라집니다. <code>hasNext()</code> 구현의 로직이 반복자나 기본 데이터 소스의 상태를 변경하지 않도록 하세요. 대신 단순히 상태 정보를 반환해야 합니다.</p>\n\n<h4>규칙을 준수하지 않는 코드 예시</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\nclass MyIterator implements Iterator&lt;Integer&gt; {\n\n  private Queue&lt;Integer&gt; elements;\n\n    ...\n\n  @Override\n  public boolean hasNext() {\n    try {\n      next(); // 규칙 위반, hasNext()에서 next()가 호출됨\n      return true;\n    } catch (NoSuchElementException e) {\n      return false;\n    }\n  }\n\n  @Override\n  public Integer next() {\n    return elements.remove();\n  }\n}\n</pre>\n<h4>규칙을 준수하는 해결책</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\nclass MyIterator implements Iterator&lt;Integer&gt; {\n\n  private Queue&lt;Integer&gt; elements;\n\n    ...\n\n  @Override\n  public boolean hasNext() {\n    return !elements.isEmpty(); // 규칙 준수, next() 호출 없음\n  }\n\n  @Override\n  public Integer next() {\n    return elements.remove();\n  }\n}\n</pre>",
    "moreInfo_ko": "<ul>\n  <li> <a href=\"https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Iterator.html\">Interface Iterator&lt;E&gt; - Java® Platform SE 11 API Specification</a> </li>\n</ul>"
  },
  {
    "id": "S4348",
    "key": "java:S4348",
    "name": "\"iterator\" should not return \"this\"",
    "type": "bug",
    "severity": "major",
    "tags": [
      "pitfall"
    ],
    "why": "<p>An <code>Iterable</code> should not implement the <code>Iterator</code> interface or return <code>this</code> as an <code>Iterator</code>. The\nreason is that <code>Iterator</code> represents the iteration process itself, while <code>Iterable</code> represents the object we want to iterate\nover.</p>\n<p>The <code>Iterator</code> instance encapsulates state information of the iteration process, such as the current and next element. Consequently,\ndistinct iterations require distinct <code>Iterator</code> instances, for which <code>Iterable</code> provides the factory method\n<code>Iterable.iterator()</code>.</p>\n<p>This rule raises an issue when the <code>Iterable.iterator()</code> of a class implementing both <code>Iterable</code> and <code>Iterator</code>\nreturns <code>this</code>.</p>\n<h3>What is the potential impact?</h3>\n<p>The <code>Iterable.iterator()</code> method returning the same <code>Iterator</code> instance many times would have the following effects:</p>\n<ol>\n  <li> For subsequent iterations, e.g., two subsequent <code>for</code> loops with iterators over the same object, only the first one would iterate,\n  and the others would do nothing. </li>\n  <li> For nested iterations over the same object, the different iteration processes would affect each other because they only have a common, shared\n  state. </li>\n</ol>",
    "howToFix": "<h4>Noncompliant code example</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\nclass FooIterator implements Iterator&lt;Foo&gt;, Iterable&lt;Foo&gt; {\n  private Foo[] seq;\n  private int idx = 0;\n\n  public boolean hasNext() {\n    return idx &lt; seq.length;\n  }\n\n  public Foo next() {\n    return seq[idx++];\n  }\n\n  public Iterator&lt;Foo&gt; iterator() {\n    return this; // Noncompliant\n  }\n  // ...\n}\n</pre>\n<h4>Compliant solution</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\nclass FooSequence implements Iterable&lt;Foo&gt; {\n  private Foo[] seq;\n\n  public Iterator&lt;Foo&gt; iterator() {\n    return new Iterator&lt;Foo&gt;() { // Compliant\n      private int idx = 0;\n\n      public boolean hasNext() {\n        return idx &lt; seq.length;\n      }\n\n      public Foo next() {\n        return seq[idx++];\n      }\n    };\n  }\n  // ...\n}\n</pre>",
    "moreInfo": "<h3>Documentation</h3>\n<ul>\n  <li> <a href=\"https://docs.oracle.com/javase/7/docs/api/java/lang/Iterable.html\">Java SE 7 API Specification: java.lang.Iterable</a> </li>\n  <li> <a href=\"https://docs.oracle.com/javase/7/docs/api/java/util/Iterator.html\">Java SE 7 API Specification: java.util.Iterator</a> </li>\n  <li> <a href=\"https://docs.oracle.com/javase/specs/jls/se7/html/jls-14.html#jls-14.14.2\">Java 7 Language Specification: The enhanced for\n  statement</a> (since Java 1.5) </li>\n</ul>",
    "status": "READY",
    "name_ko": "\"iterator\"는 \"this\"를 반환하면 안 됩니다",
    "why_ko": "<p><code>Iterable</code>은 <code>Iterator</code> 인터페이스를 구현하거나 <code>Iterator</code>로 <code>this</code>를 반환해서는 안 됩니다. 이유는 <code>Iterator</code>가 반복 프로세스 자체를 나타내는 반면 <code>Iterable</code>은 반복하려는 객체를 나타내기 때문입니다.</p>\n<p><code>Iterator</code> 인스턴스는 현재 및 다음 요소와 같은 반복 프로세스의 상태 정보를 캡슐화합니다. 따라서 별개의 반복에는 별개의 <code>Iterator</code> 인스턴스가 필요하며, 이를 위해 <code>Iterable</code>은 팩토리 메서드 <code>Iterable.iterator()</code>를 제공합니다.</p>\n<p>이 규칙은 <code>Iterable</code>과 <code>Iterator</code>를 모두 구현하는 클래스의 <code>Iterable.iterator()</code>가 <code>this</code>를 반환할 때 문제를 제기합니다.</p>\n<h3>잠재적 영향은 무엇인가요?</h3>\n<p><code>Iterable.iterator()</code> 메서드가 동일한 <code>Iterator</code> 인스턴스를 여러 번 반환하면 다음과 같은 효과가 있습니다:</p>\n<ol>\n  <li> 후속 반복의 경우, 예를 들어 동일한 객체에 대한 iterator가 있는 두 개의 연속 <code>for</code> 루프의 경우 첫 번째 루프만 반복하고 나머지는 아무것도 하지 않습니다. </li>\n  <li> 동일한 객체에 대한 중첩된 반복의 경우 공통의 공유 상태만 있기 때문에 서로 다른 반복 프로세스가 서로 영향을 미칩니다. </li>\n</ol>",
    "howToFix_ko": "<h4>규칙을 준수하지 않는 코드 예시</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\nclass FooIterator implements Iterator&lt;Foo&gt;, Iterable&lt;Foo&gt; {\n  private Foo[] seq;\n  private int idx = 0;\n\n  public boolean hasNext() {\n    return idx &lt; seq.length;\n  }\n\n  public Foo next() {\n    return seq[idx++];\n  }\n\n  public Iterator&lt;Foo&gt; iterator() {\n    return this; // 규칙 위반\n  }\n  // ...\n}\n</pre>\n<h4>규칙을 준수하는 해결책</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\nclass FooSequence implements Iterable&lt;Foo&gt; {\n  private Foo[] seq;\n\n  public Iterator&lt;Foo&gt; iterator() {\n    return new Iterator&lt;Foo&gt;() { // 규칙 준수\n      private int idx = 0;\n\n      public boolean hasNext() {\n        return idx &lt; seq.length;\n      }\n\n      public Foo next() {\n        return seq[idx++];\n      }\n    };\n  }\n  // ...\n}\n</pre>",
    "moreInfo_ko": "<h3>문서</h3>\n<ul>\n  <li> <a href=\"https://docs.oracle.com/javase/7/docs/api/java/lang/Iterable.html\">Java SE 7 API 명세: java.lang.Iterable</a> </li>\n  <li> <a href=\"https://docs.oracle.com/javase/7/docs/api/java/util/Iterator.html\">Java SE 7 API 명세: java.util.Iterator</a> </li>\n  <li> <a href=\"https://docs.oracle.com/javase/specs/jls/se7/html/jls-14.html#jls-14.14.2\">Java 7 언어 명세: 향상된 for 문</a> (Java 1.5부터) </li>\n</ul>"
  },
  {
    "id": "S4036",
    "key": "java:S4036",
    "name": "Searching OS commands in PATH is security-sensitive",
    "type": "security-hotspot",
    "severity": "minor",
    "tags": [
      "cwe"
    ],
    "why": "<p>When you run an OS command, it is always important to protect yourself against the risk of accidental or malicious replacement of the executables\nin the production system.</p>\n<p>To do so, it is important to point to the specific executable that should be used.</p>\n<p>For example, if you call <code>git</code> (without specifying a path), the operating system will search for the executable in the directories\nspecified in the <code>PATH</code> environment variable.<br> An attacker could have added, in a permissive directory covered by <code>PATH</code> ,\nanother executable called <code>git</code>, but with a completely different behavior, for example exfiltrating data or exploiting a vulnerability in\nyour own code.</p>\n<p>However, by calling <code>/usr/bin/git</code> or <code>../git</code> (relative path) directly, the operating system will always use the intended\nexecutable.<br> Note that you still need to make sure that the executable is not world-writeable and potentially overwritten. This is not the scope of\nthis rule.</p>\n",
    "howToFix": "<h2>Recommended Secure Coding Practices</h2>\n<p>If you wish to rely on the <code>PATH</code> environment variable to locate the OS command, make sure that each of its listed directories is fixed,\nnot susceptible to change, and not writable by unprivileged users.</p>\n<p>If you determine that these folders cannot be altered, and that you are sure that the program you intended to use will be used, then you can\ndetermine that these risks are under your control.</p>\n<p>A good practice you can use is to also hardcode the <code>PATH</code> variable you want to use, if you can do so in the framework you use.</p>\n<p>If the previous recommendations cannot be followed due to their complexity or other requirements, then consider using the absolute path of the\ncommand instead.</p>\n<pre>\n$ whereis git\ngit: /usr/bin/git /usr/share/man/man1/git.1.gz\n$ ls -l /usr/bin/git\n-rwxr-xr-x 1 root root 3376112 Jan 28 10:13 /usr/bin/git\n</pre>\n<h2>Compliant Solution</h2>\n<p>The command is defined by its full path:</p>\n<pre>\nRuntime.getRuntime().exec(\"/usr/bin/make\");\nRuntime.getRuntime().exec(new String[]{\"~/bin/make\"});\n\nProcessBuilder builder = new ProcessBuilder(\"./bin/make\");\nbuilder.command(\"../bin/make\");\nbuilder.command(Arrays.asList(\"..\\bin\\make\", \"-j8\"));\n\nbuilder = new ProcessBuilder(Arrays.asList(\".\\make\"));\nbuilder.command(Arrays.asList(\"C:\\bin\\make\", \"-j8\"));\nbuilder.command(Arrays.asList(\"\\\\SERVER\\bin\\make\"));\n</pre>\n<h2>See</h2>\n<ul>\n  <li> OWASP - <a href=\"https://owasp.org/Top10/A08_2021-Software_and_Data_Integrity_Failures/\">Top 10 2021 Category A8 - Software and Data Integrity\n  Failures</a> </li>\n  <li> OWASP - <a href=\"https://owasp.org/www-project-top-ten/2017/A1_2017-Injection\">Top 10 2017 Category A1 - Injection</a> </li>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/426\">CWE-426 - Untrusted Search Path</a> </li>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/427\">CWE-427 - Uncontrolled Search Path Element</a> </li>\n</ul>",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "PATH에서 OS 명령어 검색은 보안에 민감합니다",
    "why_ko": "<p>OS 명령을 실행할 때 프로덕션 시스템에서 실수 또는 악의적인 실행 파일 교체 위험으로부터 자신을 보호하는 것이 항상 중요합니다.</p>\n<p>이를 위해 사용해야 하는 특정 실행 파일을 지정하는 것이 중요합니다.</p>\n<p>예를 들어, 경로를 지정하지 않고 <code>git</code>을 호출하면 운영 체제는 <code>PATH</code> 환경 변수에 지정된 디렉토리에서 실행 파일을 검색합니다.<br> 공격자는 <code>PATH</code>에 포함된 허용적인 디렉토리에 <code>git</code>이라는 다른 실행 파일을 추가했을 수 있지만 완전히 다른 동작을 합니다. 예를 들어 데이터를 유출하거나 코드의 취약점을 악용할 수 있습니다.</p>\n<p>그러나 <code>/usr/bin/git</code> 또는 <code>../git</code>(상대 경로)를 직접 호출하면 운영 체제는 항상 의도한 실행 파일을 사용합니다.<br> 실행 파일이 모든 사용자가 쓸 수 있고 잠재적으로 덮어쓸 수 있지 않은지 확인해야 합니다. 이것은 이 규칙의 범위가 아닙니다.</p>\n","howToFix_ko": "<h2>권장되는 보안 코딩 관행</h2>\n<p>OS 명령을 찾기 위해 <code>PATH</code> 환경 변수에 의존하려면 나열된 각 디렉토리가 고정되어 있고 변경될 수 없으며 권한 없는 사용자가 쓸 수 없는지 확인하세요.</p>\n<p>이러한 폴더를 변경할 수 없고 사용하려는 프로그램이 사용될 것이라고 확신한다면 이러한 위험이 통제하에 있다고 판단할 수 있습니다.</p>\n<p>사용할 수 있는 좋은 관행은 사용하는 프레임워크에서 가능하다면 사용하려는 <code>PATH</code> 변수를 하드코딩하는 것입니다.</p>\n<p>복잡성이나 기타 요구 사항으로 인해 이전 권장 사항을 따를 수 없는 경우 대신 명령의 절대 경로를 사용하는 것을 고려하세요.</p>\n<pre>\n$ whereis git\ngit: /usr/bin/git /usr/share/man/man1/git.1.gz\n$ ls -l /usr/bin/git\n-rwxr-xr-x 1 root root 3376112 Jan 28 10:13 /usr/bin/git\n</pre>\n<h2>규칙을 준수하는 해결책</h2>\n<p>명령은 전체 경로로 정의됩니다:</p>\n<pre>\nRuntime.getRuntime().exec(\"/usr/bin/make\");\nRuntime.getRuntime().exec(new String[]{\"~/bin/make\"});\n\nProcessBuilder builder = new ProcessBuilder(\"./bin/make\");\nbuilder.command(\"../bin/make\");\nbuilder.command(Arrays.asList(\"..\\bin\\make\", \"-j8\"));\n\nbuilder = new ProcessBuilder(Arrays.asList(\".\\make\"));\nbuilder.command(Arrays.asList(\"C:\\bin\\make\", \"-j8\"));\nbuilder.command(Arrays.asList(\"\\\\SERVER\\bin\\make\"));\n</pre>\n<h2>참고</h2>\n<ul>\n  <li> OWASP - <a href=\"https://owasp.org/Top10/A08_2021-Software_and_Data_Integrity_Failures/\">Top 10 2021 카테고리 A8 - 소프트웨어 및 데이터 무결성 실패</a> </li>\n  <li> OWASP - <a href=\"https://owasp.org/www-project-top-ten/2017/A1_2017-Injection\">Top 10 2017 카테고리 A1 - 인젝션</a> </li>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/426\">CWE-426 - 신뢰할 수 없는 검색 경로</a> </li>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/427\">CWE-427 - 제어되지 않는 검색 경로 요소</a> </li>\n</ul>",
    "moreInfo_ko": ""
  },
  {
    "id": "S5332",
    "key": "java:S5332",
    "name": "Using clear-text protocols is security-sensitive",
    "type": "security-hotspot",
    "severity": "critical",
    "tags": [
      "cwe",
      "android"
    ],
    "why": "<p>Clear-text protocols such as <code>ftp</code>, <code>telnet</code>, or <code>http</code> lack encryption of transported data, as well as the\ncapability to build an authenticated connection. It means that an attacker able to sniff traffic from the network can read, modify, or corrupt the\ntransported content. These protocols are not secure as they expose applications to an extensive range of risks:</p>\n<ul>\n  <li> sensitive data exposure </li>\n  <li> traffic redirected to a malicious endpoint </li>\n  <li> malware-infected software update or installer </li>\n  <li> execution of client-side code </li>\n  <li> corruption of critical information </li>\n</ul>\n<p>Even in the context of isolated networks like offline environments or segmented cloud environments, the insider threat exists. Thus, attacks\ninvolving communications being sniffed or tampered with can still happen.</p>\n<p>For example, attackers could successfully compromise prior security layers by:</p>\n<ul>\n  <li> bypassing isolation mechanisms </li>\n  <li> compromising a component of the network </li>\n  <li> getting the credentials of an internal IAM account (either from a service account or an actual person) </li>\n</ul>\n<p>In such cases, encrypting communications would decrease the chances of attackers to successfully leak data or steal credentials from other network\ncomponents. By layering various security practices (segmentation and encryption, for example), the application will follow the\n<em>defense-in-depth</em> principle.</p>\n<p>Note that using the <code>http</code> protocol is being deprecated by <a\nhref=\"https://blog.mozilla.org/security/2015/04/30/deprecating-non-secure-http\">major web browsers</a>.</p>\n<p>In the past, it has led to the following vulnerabilities:</p>\n<ul>\n  <li> <a href=\"https://nvd.nist.gov/vuln/detail/CVE-2019-6169\">CVE-2019-6169</a> </li>\n  <li> <a href=\"https://nvd.nist.gov/vuln/detail/CVE-2019-12327\">CVE-2019-12327</a> </li>\n  <li> <a href=\"https://nvd.nist.gov/vuln/detail/CVE-2019-11065\">CVE-2019-11065</a> </li>\n</ul>\n<h2>Exceptions</h2>\n<p>No issue is reported for the following cases because they are not considered sensitive:</p>\n<ul>\n  <li> Insecure protocol scheme followed by loopback addresses like 127.0.0.1 or <code>localhost</code>. </li>\n</ul>\n",
    "howToFix": "<h2>Recommended Secure Coding Practices</h2>\n<ul>\n  <li> Make application data transit over a secure, authenticated and encrypted protocol like TLS or SSH. Here are a few alternatives to the most\n  common clear-text protocols:\n    <ul>\n      <li> Use <code>ssh</code> as an alternative to <code>telnet</code>. </li>\n      <li> Use <code>sftp</code>, <code>scp</code>, or <code>ftps</code> instead of <code>ftp</code>. </li>\n      <li> Use <code>https</code> instead of <code>http</code>. </li>\n      <li> Use <code>SMTP</code> over <code>SSL/TLS</code> or <code>SMTP</code> with <code>STARTTLS</code> instead of clear-text SMTP. </li>\n    </ul>  </li>\n  <li> Enable encryption of cloud components communications whenever it is possible. </li>\n  <li> Configure your application to block mixed content when rendering web pages. </li>\n  <li> If available, enforce OS-level deactivation of all clear-text traffic. </li>\n</ul>\n<p>It is recommended to secure all transport channels, even on local networks, as it can take a single non-secure connection to compromise an entire\napplication or system.</p>\n<h2>Compliant Solution</h2>\n<p>Use instead these clients from <a href=\"https://commons.apache.org/proper/commons-net/\">Apache commons net</a> and <a\nhref=\"https://github.com/mwiede/jsch\">JSch</a> library:</p>\n<pre>\nJSch jsch = new JSch();\n\nif(implicit) {\n  // implicit mode is considered deprecated but offer the same security than explicit mode\n  FTPSClient ftpsClient = new FTPSClient(true);\n}\nelse {\n  FTPSClient ftpsClient = new FTPSClient();\n}\n\nif(implicit) {\n  // implicit mode is considered deprecated but offer the same security than explicit mode\n  SMTPSClient smtpsClient = new SMTPSClient(true);\n}\nelse {\n  SMTPSClient smtpsClient = new SMTPSClient();\n  smtpsClient.connect(\"127.0.0.1\", 25);\n  if (smtpsClient.execTLS()) {\n    // commands\n  }\n}\n</pre>\n<p>Perform HTTP encrypted connections, with <a href=\"https://square.github.io/okhttp/https/\">okhttp</a> library for instance:</p>\n<pre>\nConnectionSpec spec = new ConnectionSpec.Builder(ConnectionSpec.MODERN_TLS)\n  .build();\n</pre>\n<p>The most secure mode for Android WebView is <code>MIXED_CONTENT_NEVER_ALLOW</code>:</p>\n<pre>\nimport android.webkit.WebView\n\nWebView webView = findViewById(R.id.webview)\nwebView.getSettings().setMixedContentMode(MIXED_CONTENT_NEVER_ALLOW);\n</pre>\n<h2>See</h2>\n<h3>Documentation</h3>\n<ul>\n  <li> AWS Documentation - <a href=\"https://docs.aws.amazon.com/elasticloadbalancing/latest/application/load-balancer-listeners.html\">Listeners for\n  your Application Load Balancers</a> </li>\n  <li> AWS Documentation - <a\n  href=\"https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesis-stream-streamencryption.html\">Stream Encryption</a>\n  </li>\n</ul>\n<h3>Articles &amp; blog posts</h3>\n<ul>\n  <li> Google - <a href=\"https://security.googleblog.com/2016/09/moving-towards-more-secure-web.html\">Moving towards more secure web</a> </li>\n  <li> Mozilla - <a href=\"https://blog.mozilla.org/security/2015/04/30/deprecating-non-secure-http/\">Deprecating non secure http</a> </li>\n</ul>\n<h3>Standards</h3>\n<ul>\n  <li> OWASP - <a href=\"https://owasp.org/www-project-top-ten/2017/A3_2017-Sensitive_Data_Exposure\">Top 10 2017 Category A3 - Sensitive Data\n  Exposure</a> </li>\n  <li> OWASP - <a href=\"https://owasp.org/Top10/A02_2021-Cryptographic_Failures/\">Top 10 2021 Category A2 - Cryptographic Failures</a> </li>\n  <li> OWASP - <a href=\"https://mas.owasp.org/checklists/MASVS-NETWORK/\">Mobile AppSec Verification Standard - Network Communication Requirements</a>\n  </li>\n  <li> OWASP - <a href=\"https://owasp.org/www-project-mobile-top-10/2016-risks/m3-insecure-communication\">Mobile Top 10 2016 Category M3 - Insecure\n  Communication</a> </li>\n  <li> OWASP - <a href=\"https://owasp.org/www-project-mobile-top-10/2023-risks/m5-insecure-communication\">Mobile Top 10 2024 Category M5 - Insecure\n  Communication</a> </li>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/200\">CWE-200 - Exposure of Sensitive Information to an Unauthorized Actor</a> </li>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/319\">CWE-319 - Cleartext Transmission of Sensitive Information</a> </li>\n</ul>",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "평문 프로토콜 사용은 보안에 민감합니다",
    "why_ko": "<p><code>ftp</code>, <code>telnet</code> 또는 <code>http</code>와 같은 평문 프로토콜은 전송되는 데이터의 암호화와 인증된 연결 구축 기능이 부족합니다. 이는 네트워크에서 트래픽을 스니핑할 수 있는 공격자가 전송되는 내용을 읽거나 수정하거나 손상시킬 수 있다는 것을 의미합니다. 이러한 프로토콜은 애플리케이션을 광범위한 위험에 노출시키므로 안전하지 않습니다:</p>\n<ul>\n  <li> 민감한 데이터 노출 </li>\n  <li> 악의적인 엔드포인트로 트래픽 리디렉션 </li>\n  <li> 멀웨어 감염된 소프트웨어 업데이트 또는 설치 프로그램 </li>\n  <li> 클라이언트 측 코드 실행 </li>\n  <li> 중요 정보 손상 </li>\n</ul>\n<p>오프라인 환경이나 분리된 클라우드 환경과 같은 격리된 네트워크 컨텍스트에서도 내부자 위협이 존재합니다. 따라서 통신이 스니핑되거나 변조되는 공격은 여전히 발생할 수 있습니다.</p>\n<p>예를 들어, 공격자는 다음과 같은 방법으로 이전 보안 계층을 성공적으로 손상시킬 수 있습니다:</p>\n<ul>\n  <li> 격리 메커니즘 우회 </li>\n  <li> 네트워크의 구성 요소 손상 </li>\n  <li> 내부 IAM 계정의 자격 증명 획득(서비스 계정 또는 실제 사용자로부터) </li>\n</ul>\n<p>이러한 경우 통신을 암호화하면 공격자가 다른 네트워크 구성 요소에서 데이터를 성공적으로 유출하거나 자격 증명을 훔칠 가능성이 줄어듭니다. 다양한 보안 관행(예: 분리 및 암호화)을 계층화함으로써 애플리케이션은 <em>심층 방어</em> 원칙을 따르게 됩니다.</p>\n<p><code>http</code> 프로토콜 사용은 <a href=\"https://blog.mozilla.org/security/2015/04/30/deprecating-non-secure-http\">주요 웹 브라우저</a>에 의해 더 이상 사용되지 않습니다.</p>\n<p>과거에 이는 다음 취약점으로 이어졌습니다:</p>\n<ul>\n  <li> <a href=\"https://nvd.nist.gov/vuln/detail/CVE-2019-6169\">CVE-2019-6169</a> </li>\n  <li> <a href=\"https://nvd.nist.gov/vuln/detail/CVE-2019-12327\">CVE-2019-12327</a> </li>\n  <li> <a href=\"https://nvd.nist.gov/vuln/detail/CVE-2019-11065\">CVE-2019-11065</a> </li>\n</ul>\n<h2>예외</h2>\n<p>다음 경우에는 민감하지 않은 것으로 간주되므로 문제가 보고되지 않습니다:</p>\n<ul>\n  <li> 127.0.0.1 또는 <code>localhost</code>와 같은 루프백 주소가 뒤따르는 안전하지 않은 프로토콜 체계 </li>\n</ul>\n",
    "howToFix_ko": "<h2>권장 보안 코딩 방법</h2>\n<ul>\n  <li> 애플리케이션 데이터가 TLS 또는 SSH와 같은 안전하고 인증되고 암호화된 프로토콜을 통해 전송되도록 하세요. 다음은 가장 일반적인 평문 프로토콜의 몇 가지 대안입니다:\n    <ul>\n      <li> <code>telnet</code> 대신 <code>ssh</code>를 사용하세요. </li>\n      <li> <code>ftp</code> 대신 <code>sftp</code>, <code>scp</code> 또는 <code>ftps</code>를 사용하세요. </li>\n      <li> <code>http</code> 대신 <code>https</code>를 사용하세요. </li>\n      <li> 평문 SMTP 대신 <code>SSL/TLS</code> 위의 <code>SMTP</code> 또는 <code>STARTTLS</code>가 있는 <code>SMTP</code>를 사용하세요. </li>\n    </ul>  </li>\n  <li> 가능하면 클라우드 구성 요소 통신의 암호화를 활성화하세요. </li>\n  <li> 웹 페이지를 렌더링할 때 혼합 콘텐츠를 차단하도록 애플리케이션을 구성하세요. </li>\n  <li> 가능하면 OS 수준에서 모든 평문 트래픽을 비활성화하세요. </li>\n</ul>\n<p>단일 비보안 연결로 전체 애플리케이션이나 시스템이 손상될 수 있으므로 로컬 네트워크에서도 모든 전송 채널을 보호하는 것이 좋습니다.</p>\n<h2>규칙을 준수하는 해결책</h2>\n<p><a href=\"https://commons.apache.org/proper/commons-net/\">Apache commons net</a> 및 <a href=\"https://github.com/mwiede/jsch\">JSch</a> 라이브러리의 다음 클라이언트를 대신 사용하세요:</p>\n<pre>\nJSch jsch = new JSch();\n\nif(implicit) {\n  // implicit 모드는 더 이상 사용되지 않지만 explicit 모드와 동일한 보안을 제공합니다\n  FTPSClient ftpsClient = new FTPSClient(true);\n}\nelse {\n  FTPSClient ftpsClient = new FTPSClient();\n}\n\nif(implicit) {\n  // implicit 모드는 더 이상 사용되지 않지만 explicit 모드와 동일한 보안을 제공합니다\n  SMTPSClient smtpsClient = new SMTPSClient(true);\n}\nelse {\n  SMTPSClient smtpsClient = new SMTPSClient();\n  smtpsClient.connect(\"127.0.0.1\", 25);\n  if (smtpsClient.execTLS()) {\n    // 명령\n  }\n}\n</pre>\n<p>예를 들어 <a href=\"https://square.github.io/okhttp/https/\">okhttp</a> 라이브러리를 사용하여 HTTP 암호화 연결을 수행하세요:</p>\n<pre>\nConnectionSpec spec = new ConnectionSpec.Builder(ConnectionSpec.MODERN_TLS)\n  .build();\n</pre>\n<p>Android WebView의 가장 안전한 모드는 <code>MIXED_CONTENT_NEVER_ALLOW</code>입니다:</p>\n<pre>\nimport android.webkit.WebView\n\nWebView webView = findViewById(R.id.webview)\nwebView.getSettings().setMixedContentMode(MIXED_CONTENT_NEVER_ALLOW);\n</pre>\n<h2>참고</h2>\n<h3>문서</h3>\n<ul>\n  <li> AWS 문서 - <a href=\"https://docs.aws.amazon.com/elasticloadbalancing/latest/application/load-balancer-listeners.html\">Application Load Balancer용 리스너</a> </li>\n  <li> AWS 문서 - <a href=\"https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesis-stream-streamencryption.html\">스트림 암호화</a> </li>\n</ul>\n<h3>기사 및 블로그 게시물</h3>\n<ul>\n  <li> Google - <a href=\"https://security.googleblog.com/2016/09/moving-towards-more-secure-web.html\">더 안전한 웹으로의 이동</a> </li>\n  <li> Mozilla - <a href=\"https://blog.mozilla.org/security/2015/04/30/deprecating-non-secure-http/\">비보안 http 사용 중단</a> </li>\n</ul>\n<h3>표준</h3>\n<ul>\n  <li> OWASP - <a href=\"https://owasp.org/www-project-top-ten/2017/A3_2017-Sensitive_Data_Exposure\">상위 10가지 2017 카테고리 A3 - 민감한 데이터 노출</a> </li>\n  <li> OWASP - <a href=\"https://owasp.org/Top10/A02_2021-Cryptographic_Failures/\">상위 10가지 2021 카테고리 A2 - 암호화 실패</a> </li>\n  <li> OWASP - <a href=\"https://mas.owasp.org/checklists/MASVS-NETWORK/\">모바일 AppSec 검증 표준 - 네트워크 통신 요구 사항</a> </li>\n  <li> OWASP - <a href=\"https://owasp.org/www-project-mobile-top-10/2016-risks/m3-insecure-communication\">모바일 상위 10가지 2016 카테고리 M3 - 안전하지 않은 통신</a> </li>\n  <li> OWASP - <a href=\"https://owasp.org/www-project-mobile-top-10/2023-risks/m5-insecure-communication\">모바일 상위 10가지 2024 카테고리 M5 - 안전하지 않은 통신</a> </li>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/200\">CWE-200 - 무단 행위자에게 민감한 정보 노출</a> </li>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/319\">CWE-319 - 민감한 정보의 평문 전송</a> </li>\n</ul>",
    "moreInfo_ko": ""
  },
  {
    "id": "S2674",
    "key": "java:S2674",
    "name": "The value returned from a stream read should be checked",
    "type": "bug",
    "severity": "minor",
    "tags": [
      "cert"
    ],
    "why": "<p>You cannot assume that any given stream reading call will fill the <code>byte[]</code> passed in to the method. Instead, you must check the value\nreturned by the read method to see how many bytes were read. Fail to do so, and you introduce bug that is both harmful and difficult to reproduce.</p>\n<p>Similarly, you cannot assume that <code>InputStream.skip</code> will actually skip the requested number of bytes, but must check the value returned\nfrom the method.</p>\n<p>This rule raises an issue when an <code>InputStream.read</code> method that accepts a <code>byte[]</code> is called, but the return value is not\nchecked, and when the return value of <code>InputStream.skip</code> is not checked. The rule also applies to <code>InputStream</code> child\nclasses.</p>\n<h3>Noncompliant code example</h3>\n<pre>\npublic void doSomething(String fileName) {\n  try {\n    InputStream is = new InputStream(file);\n    byte [] buffer = new byte[1000];\n    is.read(buffer);  // Noncompliant\n    // ...\n  } catch (IOException e) { ... }\n}\n</pre>\n<h3>Compliant solution</h3>\n<pre>\npublic void doSomething(String fileName) {\n  try {\n    InputStream is = new InputStream(file);\n    byte [] buffer = new byte[1000];\n    int count = 0;\n    while (count = is.read(buffer) &gt; 0) {\n      // ...\n    }\n  } catch (IOException e) { ... }\n}\n</pre>",
    "howToFix": "",
    "moreInfo": "<ul>\n  <li> <a href=\"https://wiki.sei.cmu.edu/confluence/x/VzdGBQ\">CERT, FIO10-J.</a> - Ensure the array is filled when using read() to fill an array </li>\n</ul>",
    "status": "READY",
    "name_ko": "스트림 읽기에서 반환된 값을 확인해야 합니다",
    "why_ko": "<p>주어진 스트림 읽기 호출이 메서드에 전달된 <code>byte[]</code>를 채울 것이라고 가정할 수 없습니다. 대신 read 메서드가 반환한 값을 확인하여 얼마나 많은 바이트가 읽혔는지 확인해야 합니다. 그렇게 하지 않으면 해롭고 재현하기 어려운 버그를 도입합니다.</p>\n<p>마찬가지로 <code>InputStream.skip</code>이 실제로 요청된 바이트 수를 건너뛸 것이라고 가정할 수 없으며 메서드에서 반환된 값을 확인해야 합니다.</p>\n<p>이 규칙은 <code>byte[]</code>를 받는 <code>InputStream.read</code> 메서드가 호출되지만 반환 값이 확인되지 않을 때, 그리고 <code>InputStream.skip</code>의 반환 값이 확인되지 않을 때 문제를 제기합니다. 이 규칙은 <code>InputStream</code> 하위 클래스에도 적용됩니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\npublic void doSomething(String fileName) {\n  try {\n    InputStream is = new InputStream(file);\n    byte [] buffer = new byte[1000];\n    is.read(buffer);  // 규칙 위반\n    // ...\n  } catch (IOException e) { ... }\n}\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre>\npublic void doSomething(String fileName) {\n  try {\n    InputStream is = new InputStream(file);\n    byte [] buffer = new byte[1000];\n    int count = 0;\n    while (count = is.read(buffer) &gt; 0) {\n      // ...\n    }\n  } catch (IOException e) { ... }\n}\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": "<ul>\n  <li> <a href=\"https://wiki.sei.cmu.edu/confluence/x/VzdGBQ\">CERT, FIO10-J.</a> - read()를 사용하여 배열을 채울 때 배열이 채워졌는지 확인하세요 </li>\n</ul>"
  },
  {
    "id": "S7476",
    "key": "java:S7476",
    "name": "Comments should start with the appropriate number of slashes",
    "type": "code-smell",
    "severity": "minor",
    "tags": [
      "javadoc",
      "java23"
    ],
    "why": "<p>Starting in Java 23, comments beginning with three slashes <code>///</code> are interpreted as JavaDoc comments using Markdown syntax.</p>\n<p>In Java 22 and earlier, comments starting with more than 2 slashes were treated as normal comments. Accidentally writing comments with three or\nmore slashes can lead to unintended JavaDoc being generated, when migrating to Java 23.</p>\n<h3>What is the potential impact?</h3>\n<p>Comments starting with three or more slashes will increase the migration cost when upgrading to Java 23 or later. Moreover, IDE or other tools may\nhandle such comments as JavaDoc comments if they are not aware of the Java version.</p>\n<h3>Exceptions</h3>\n<ul>\n  <li> The rule does not raise issues on license headers at the start of files because they will not be considered as JavaDoc comments. </li>\n  <li> The rule only raises issues in projects using Java 17 or above, because those projects will likely be migrated to Java 23 or later. </li>\n</ul>",
    "howToFix": "<p>In versions of Java prior to 23, comments should not start with more than 2 slashes, and from Java 23 forward they should not start with more than\n3.</p>\n\n<h4>Noncompliant code example</h4>\n<p>The following code will generate unintended JavaDoc comments if migrated to Java 23:</p>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\n/// Some comment for the developers\npublic abstract void foo();\n//// public void foo(String s){}\npublic void foo(){}\n</pre>\n<h4>Compliant solution</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\n// Some comment for the developers\npublic abstract void foo();\n// public void foo(String s){}\npublic void foo(){}\n</pre>",
    "moreInfo": "<h3>Documentation</h3>\n<ul>\n  <li> OpenJDK - <a href=\"https://openjdk.org/jeps/467\">JEP 467: Markdown Documentation Comments</a> </li>\n</ul>",
    "status": "READY",
    "name_ko": "주석은 적절한 수의 슬래시로 시작해야 합니다",
    "why_ko": "<p>Java 23부터 세 개의 슬래시 <code>///</code>로 시작하는 주석은 Markdown 구문을 사용하는 JavaDoc 주석으로 해석됩니다.</p>\n<p>Java 22 이전에는 2개 이상의 슬래시로 시작하는 주석이 일반 주석으로 처리되었습니다. Java 23으로 마이그레이션할 때 실수로 3개 이상의 슬래시로 주석을 작성하면 의도하지 않은 JavaDoc이 생성될 수 있습니다.</p>\n<h3>잠재적 영향은 무엇인가요?</h3>\n<p>3개 이상의 슬래시로 시작하는 주석은 Java 23 이상으로 업그레이드할 때 마이그레이션 비용을 증가시킵니다. 또한 IDE나 다른 도구가 Java 버전을 인식하지 못하면 이러한 주석을 JavaDoc 주석으로 처리할 수 있습니다.</p>\n<h3>예외</h3>\n<ul>\n  <li> 이 규칙은 파일 시작 부분의 라이선스 헤더에 대해서는 이슈를 발생시키지 않습니다. 이것들은 JavaDoc 주석으로 간주되지 않기 때문입니다. </li>\n  <li> 이 규칙은 Java 17 이상을 사용하는 프로젝트에서만 이슈를 발생시킵니다. 이러한 프로젝트는 Java 23 이상으로 마이그레이션될 가능성이 높기 때문입니다. </li>\n</ul>",
    "howToFix_ko": "<p>Java 23 이전 버전에서는 주석이 2개 이상의 슬래시로 시작하면 안 되며, Java 23부터는 3개 이상의 슬래시로 시작하면 안 됩니다.</p>\n\n<h4>규칙을 준수하지 않는 코드 예시</h4>\n<p>다음 코드는 Java 23으로 마이그레이션하면 의도하지 않은 JavaDoc 주석을 생성합니다:</p>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\n/// Some comment for the developers\npublic abstract void foo();\n//// public void foo(String s){}\npublic void foo(){}\n</pre>\n<h4>규칙을 준수하는 해결책</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\n// Some comment for the developers\npublic abstract void foo();\n// public void foo(String s){}\npublic void foo(){}\n</pre>",
    "moreInfo_ko": "<h3>문서</h3>\n<ul>\n  <li> OpenJDK - <a href=\"https://openjdk.org/jeps/467\">JEP 467: Markdown 문서 주석</a> </li>\n</ul>"
  },
  {
    "id": "S818",
    "key": "java:S818",
    "name": "Literal suffixes should be upper case",
    "type": "code-smell",
    "severity": "minor",
    "tags": [
      "convention",
      "cert",
      "pitfall"
    ],
    "why": "<p>Using upper case literal suffixes removes the potential ambiguity between \"1\" (digit 1) and \"l\" (letter el) for declaring literals.</p>\n<h3>Noncompliant code example</h3>\n<pre>\nlong long1 = 1l; // Noncompliant\nfloat float1 = 1.0f; // Noncompliant\ndouble double1 = 1.0d; // Noncompliant\n</pre>\n<h3>Compliant solution</h3>\n<pre>\nlong long1 = 1L;\nfloat float1 = 1.0F;\ndouble double1 = 1.0D;\n</pre>",
    "howToFix": "",
    "moreInfo": "<ul>\n  <li> <a href=\"https://wiki.sei.cmu.edu/confluence/x/cdYxBQ\">CERT DCL16-C.</a> - Use \"L,\" not \"l,\" to indicate a long value </li>\n  <li> <a href=\"https://wiki.sei.cmu.edu/confluence/x/7DZGBQ\">CERT, DCL50-J.</a> - Use visually distinct identifiers </li>\n</ul>",
    "status": "READY",
    "name_ko": "리터럴 접미사는 대문자로 작성해야 합니다",
    "why_ko": "<p>대문자 리터럴 접미사를 사용하면 리터럴 선언 시 \"1\"(숫자 1)과 \"l\"(문자 el) 사이의 잠재적 모호성이 제거됩니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\nlong long1 = 1l; // 규칙 위반\nfloat float1 = 1.0f; // 규칙 위반\ndouble double1 = 1.0d; // 규칙 위반\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre>\nlong long1 = 1L;\nfloat float1 = 1.0F;\ndouble double1 = 1.0D;\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": "<ul>\n  <li> <a href=\"https://wiki.sei.cmu.edu/confluence/x/cdYxBQ\">CERT DCL16-C.</a> - long 값을 나타내려면 \"l\"이 아닌 \"L\"을 사용하세요 </li>\n  <li> <a href=\"https://wiki.sei.cmu.edu/confluence/x/7DZGBQ\">CERT, DCL50-J.</a> - 시각적으로 구별되는 식별자를 사용하세요 </li>\n</ul>"
  },
  {
    "id": "S3065",
    "key": "java:S3065",
    "name": "Min and max used in combination should not always return the same value",
    "type": "bug",
    "severity": "major",
    "tags": [
      "symbolic-execution"
    ],
    "why": "<p>When using <code>Math.min()</code> and <code>Math.max()</code> together for bounds checking, it's important to feed the right operands to each\nmethod. <code>Math.min()</code> should be used with the <strong>upper</strong> end of the range being checked, and <code>Math.max()</code> should be\nused with the <strong>lower</strong> end of the range. Get it backwards, and the result will always be the same end of the range.</p>\n<h3>Noncompliant code example</h3>\n<pre>\n  private static final int UPPER = 20;\n  private static final int LOWER = 0;\n\n  public int doRangeCheck(int num) {    // Let's say num = 12\n    int result = Math.min(LOWER, num);  // result = 0\n    return Math.max(UPPER, result);     // Noncompliant; result is now 20: even though 12 was in the range\n  }\n</pre>\n<h3>Compliant solution</h3>\n<p>Swapping method <code>min()</code> and <code>max()</code> invocations without changing parameters.</p>\n<pre>\n  private static final int UPPER = 20;\n  private static final int LOWER = 0;\n\n  public int doRangeCheck(int num) {    // Let's say num = 12\n    int result = Math.max(LOWER, num);  // result = 12\n    return Math.min(UPPER, result);     // Compliant; result is still 12\n  }\n</pre>\n<p>or swapping bounds <code>UPPER</code> and <code>LOWER</code> used as parameters without changing the invoked methods.</p>\n<pre>\n  private static final int UPPER = 20;\n  private static final int LOWER = 0;\n\n  public int doRangeCheck(int num) {    // Let's say num = 12\n    int result = Math.min(UPPER, num);  // result = 12\n    return Math.max(LOWER, result);     // Compliant; result is still 12\n  }\n</pre>",
    "howToFix": "",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "함께 사용된 min과 max는 항상 같은 값을 반환하면 안 됩니다",
    "why_ko": "<p>범위 검사를 위해 <code>Math.min()</code>과 <code>Math.max()</code>를 함께 사용할 때, 각 메서드에 올바른 피연산자를 전달하는 것이 중요합니다. <code>Math.min()</code>은 검사할 범위의 <strong>상한</strong>과 함께 사용해야 하고, <code>Math.max()</code>는 범위의 <strong>하한</strong>과 함께 사용해야 합니다. 이를 반대로 하면, 결과는 항상 범위의 같은 끝 값이 됩니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\n  private static final int UPPER = 20;\n  private static final int LOWER = 0;\n\n  public int doRangeCheck(int num) {    // num = 12라고 가정\n    int result = Math.min(LOWER, num);  // result = 0\n    return Math.max(UPPER, result);     // 규칙 위반; 12가 범위 내에 있었음에도 result는 이제 20입니다\n  }\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<p>매개변수를 변경하지 않고 <code>min()</code>과 <code>max()</code> 메서드 호출을 교체합니다.</p>\n<pre>\n  private static final int UPPER = 20;\n  private static final int LOWER = 0;\n\n  public int doRangeCheck(int num) {    // num = 12라고 가정\n    int result = Math.max(LOWER, num);  // result = 12\n    return Math.min(UPPER, result);     // 규칙 준수; result는 여전히 12입니다\n  }\n</pre>\n<p>또는 호출되는 메서드를 변경하지 않고 매개변수로 사용되는 <code>UPPER</code>와 <code>LOWER</code> 경계를 교체합니다.</p>\n<pre>\n  private static final int UPPER = 20;\n  private static final int LOWER = 0;\n\n  public int doRangeCheck(int num) {    // num = 12라고 가정\n    int result = Math.min(UPPER, num);  // result = 12\n    return Math.max(LOWER, result);     // 규칙 준수; result는 여전히 12입니다\n  }\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": ""
  },
  {
    "id": "S6288",
    "key": "java:S6288",
    "name": "Authorizing non-authenticated users to use keys in the Android KeyStore is security-sensitive",
    "type": "security-hotspot",
    "severity": "major",
    "tags": [
      "cwe",
      "android"
    ],
    "why": "<p>Android KeyStore is a secure container for storing key materials, in particular it prevents key materials extraction, i.e. when the application\nprocess is compromised, the attacker cannot extract keys but may still be able to use them. It's possible to enable an Android security feature, user\nauthentication, to restrict usage of keys to only authenticated users. The lock screen has to be unlocked with defined credentials\n(pattern/PIN/password, biometric).</p>\n",
    "howToFix": "<h2>Recommended Secure Coding Practices</h2>\n<p>It's recommended to enable user authentication (by setting <code>setUserAuthenticationRequired</code> to <code>true</code> during key generation)\nto use keys for a limited duration of time (by setting appropriate values to <code>setUserAuthenticationValidityDurationSeconds</code>), after which\nthe user must re-authenticate.</p>\n<h2>Compliant Solution</h2>\n<p>The use of the key is limited to authenticated users (for a duration of time defined to 60 seconds):</p>\n<pre>\nKeyGenerator keyGenerator = KeyGenerator.getInstance(KeyProperties.KEY_ALGORITHM_AES, \"AndroidKeyStore\");\n\nKeyGenParameterSpec builder = new KeyGenParameterSpec.Builder(\"test_secret_key\", KeyProperties.PURPOSE_ENCRYPT | KeyProperties.PURPOSE_DECRYPT)\n    .setBlockModes(KeyProperties.BLOCK_MODE_GCM)\n    .setEncryptionPaddings(KeyProperties.ENCRYPTION_PADDING_NONE)\n    .setUserAuthenticationRequired(true)\n    .setUserAuthenticationParameters (60, KeyProperties.AUTH_DEVICE_CREDENTIAL)\n    .build();\n\nkeyGenerator.init(builder)\n</pre>\n<h2>See</h2>\n<ul>\n  <li> OWASP - <a href=\"https://owasp.org/Top10/A04_2021-Insecure_Design/\">Top 10 2021 Category A4 - Insecure Design</a> </li>\n  <li> OWASP - <a href=\"https://mas.owasp.org/checklists/MASVS-STORAGE/\">Mobile AppSec Verification Standard - Authentication and Session Management\n  Requirements</a> </li>\n  <li> OWASP - <a href=\"https://owasp.org/www-project-mobile-top-10/2016-risks/m4-insecure-authentication\">Mobile Top 10 2016 Category M4 - Insecure\n  Authentication</a> </li>\n  <li> OWASP - <a href=\"https://owasp.org/www-project-mobile-top-10/2023-risks/m3-insecure-authentication-authorization\">Mobile Top 10 2024 Category\n  M3 - Insecure Authentication/Authorization</a> </li>\n  <li> OWASP - <a href=\"https://owasp.org/www-project-mobile-top-10/2023-risks/m10-insufficient-cryptography\">Mobile Top 10 2024 Category M10 -\n  Insufficient Cryptography</a> </li>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/522\">CWE-522 - Insufficiently Protected Credentials</a> </li>\n  <li> <a href=\"https://developer.android.com/privacy-and-security/keystore\">developer.android.com</a> - Android keystore system </li>\n  <li> <a href=\"https://developer.android.com/privacy-and-security/keystore#UserAuthentication\">developer.android.com</a> - Require user\n  authentication for key use </li>\n</ul>",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "인증되지 않은 사용자에게 Android KeyStore 키 사용을 허용하는 것은 보안에 민감합니다",
    "why_ko": "<p>Android KeyStore는 키 자료를 저장하기 위한 보안 컨테이너로, 특히 키 자료 추출을 방지합니다. 즉, 애플리케이션 프로세스가 손상되어도 공격자는 키를 추출할 수 없지만 여전히 사용할 수는 있습니다. 인증된 사용자만 키를 사용하도록 제한하기 위해 Android 보안 기능인 사용자 인증을 활성화할 수 있습니다. 잠금 화면은 정의된 자격 증명(패턴/PIN/비밀번호, 생체 인식)으로 잠금 해제해야 합니다.</p>\n","howToFix_ko": "<h2>권장 보안 코딩 관행</h2>\n<p>키 생성 중에 <code>setUserAuthenticationRequired</code>를 <code>true</code>로 설정하여 사용자 인증을 활성화하고 <code>setUserAuthenticationValidityDurationSeconds</code>에 적절한 값을 설정하여 제한된 시간 동안 키를 사용하도록 하는 것이 권장됩니다. 그 후 사용자는 다시 인증해야 합니다.</p>\n<h2>규칙을 준수하는 해결책</h2>\n<p>키 사용이 인증된 사용자로 제한됩니다(60초로 정의된 시간 동안):</p>\n<pre>\nKeyGenerator keyGenerator = KeyGenerator.getInstance(KeyProperties.KEY_ALGORITHM_AES, \"AndroidKeyStore\");\n\nKeyGenParameterSpec builder = new KeyGenParameterSpec.Builder(\"test_secret_key\", KeyProperties.PURPOSE_ENCRYPT | KeyProperties.PURPOSE_DECRYPT)\n    .setBlockModes(KeyProperties.BLOCK_MODE_GCM)\n    .setEncryptionPaddings(KeyProperties.ENCRYPTION_PADDING_NONE)\n    .setUserAuthenticationRequired(true)\n    .setUserAuthenticationParameters (60, KeyProperties.AUTH_DEVICE_CREDENTIAL)\n    .build();\n\nkeyGenerator.init(builder)\n</pre>\n<h2>참고</h2>\n<ul>\n  <li> OWASP - <a href=\"https://owasp.org/Top10/A04_2021-Insecure_Design/\">Top 10 2021 Category A4 - 안전하지 않은 설계</a> </li>\n  <li> OWASP - <a href=\"https://mas.owasp.org/checklists/MASVS-STORAGE/\">Mobile AppSec Verification Standard - 인증 및 세션 관리 요구사항</a> </li>\n  <li> OWASP - <a href=\"https://owasp.org/www-project-mobile-top-10/2016-risks/m4-insecure-authentication\">Mobile Top 10 2016 Category M4 - 안전하지 않은 인증</a> </li>\n  <li> OWASP - <a href=\"https://owasp.org/www-project-mobile-top-10/2023-risks/m3-insecure-authentication-authorization\">Mobile Top 10 2024 Category M3 - 안전하지 않은 인증/권한 부여</a> </li>\n  <li> OWASP - <a href=\"https://owasp.org/www-project-mobile-top-10/2023-risks/m10-insufficient-cryptography\">Mobile Top 10 2024 Category M10 - 불충분한 암호화</a> </li>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/522\">CWE-522 - 불충분하게 보호된 자격 증명</a> </li>\n  <li> <a href=\"https://developer.android.com/privacy-and-security/keystore\">developer.android.com</a> - Android keystore 시스템 </li>\n  <li> <a href=\"https://developer.android.com/privacy-and-security/keystore#UserAuthentication\">developer.android.com</a> - 키 사용을 위한 사용자 인증 요구 </li>\n</ul>",
    "moreInfo_ko": ""
  },
  {
    "id": "S5261",
    "key": "java:S5261",
    "name": "\"else\" statements should be clearly matched with an \"if\"",
    "type": "code-smell",
    "severity": "major",
    "tags": [
      "confusing"
    ],
    "why": "<p>The dangling <code>else</code> problem appears when nested <code>if</code>/<code>else</code>&nbsp;statements are written without curly braces. In\nthis case, <code>else</code> is associated with the nearest&nbsp;<code>if</code> but that is not always obvious and sometimes the indentation can also\nbe misleading.</p>\n<p>This rules reports <code>else</code> statements that are difficult to understand, because they are inside nested <code>if</code> statements without\ncurly braces.</p>\n<p>Adding curly braces can generally make the code clearer (see rule <a href='/coding_rules#rule_key=java%3AS121'>S121</a> ), and in this situation of dangling <code>else</code>, it\nreally clarifies the intention of the code.</p>\n<h3>Noncompliant code example</h3>\n<pre>\n if (a)\n   if (b)\n     d++;\n else     // Noncompliant, is the \"else\" associated with \"if(a)\" or \"if (b)\"? (the answer is \"if(b)\")\n   e++;\n</pre>\n<h3>Compliant solution</h3>\n<pre>\n if (a) {\n   if (b) {\n     d++;\n   }\n } else { // Compliant, there is no doubt the \"else\" is associated with \"if(a)\"\n   e++;\n }\n</pre>",
    "howToFix": "",
    "moreInfo": "<ul>\n  <li> <a href=\"https://en.wikipedia.org/wiki/Dangling_else\">https://en.wikipedia.org/wiki/Dangling_else</a> </li>\n</ul>",
    "status": "READY",
    "name_ko": "\"else\" 문은 \"if\"와 명확하게 매칭되어야 합니다",
    "why_ko": "<p>매달린 <code>else</code> 문제는 중첩된 <code>if</code>/<code>else</code> 문이 중괄호 없이 작성될 때 나타납니다. 이 경우 <code>else</code>는 가장 가까운 <code>if</code>와 연결되지만 이것이 항상 명확하지 않으며 때로는 들여쓰기도 오해의 소지가 있을 수 있습니다.</p>\n<p>이 규칙은 중괄호 없이 중첩된 <code>if</code> 문 내부에 있어 이해하기 어려운 <code>else</code> 문을 보고합니다.</p>\n<p>중괄호를 추가하면 일반적으로 코드를 더 명확하게 만들 수 있으며(<a href='/coding_rules#rule_key=java%3AS121'>S121</a> 규칙 참조), 이 매달린 <code>else</code> 상황에서는 코드의 의도를 정말로 명확하게 합니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\n if (a)\n   if (b)\n     d++;\n else     // 규칙 위반, \"else\"가 \"if(a)\"와 연결되어 있나요 아니면 \"if(b)\"와? (정답은 \"if(b)\")\n   e++;\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre>\n if (a) {\n   if (b) {\n     d++;\n   }\n } else { // 규칙 준수, \"else\"가 \"if(a)\"와 연결되어 있음이 확실함\n   e++;\n }\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": "<ul>\n  <li> <a href=\"https://en.wikipedia.org/wiki/Dangling_else\">https://en.wikipedia.org/wiki/Dangling_else</a> </li>\n</ul>"
  },
  {
    "id": "S4165",
    "key": "java:S4165",
    "name": "Assignments should not be redundant",
    "type": "code-smell",
    "severity": "major",
    "tags": [
      "symbolic-execution",
      "redundant"
    ],
    "why": "<p>The transitive property says that if <code>a == b</code> and <code>b == c</code>, then <code>a == c</code>. In such cases, there's no point in\nassigning <code>a</code> to <code>c</code> or vice versa because they're already equivalent.</p>\n<p>This rule raises an issue when an assignment is useless because the assigned-to variable already holds the value on all execution paths.</p>\n<h3>Noncompliant code example</h3>\n<pre>\na = b;\nc = a;\nb = c; // Noncompliant: c and b are already the same\n</pre>\n<h3>Compliant solution</h3>\n<pre>\na = b;\nc = a;\n</pre>",
    "howToFix": "",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "중복된 할당을 하면 안 됩니다",
    "why_ko": "<p>이행적 속성에 따르면 <code>a == b</code>이고 <code>b == c</code>이면 <code>a == c</code>입니다. 이러한 경우 이미 동일하므로 <code>a</code>를 <code>c</code>에 할당하거나 그 반대로 할당하는 것은 의미가 없습니다.</p>\n<p>이 규칙은 모든 실행 경로에서 할당 대상 변수가 이미 값을 보유하고 있어 할당이 쓸모없을 때 문제를 제기합니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\na = b;\nc = a;\nb = c; // 규칙 위반: c와 b는 이미 같습니다\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre>\na = b;\nc = a;\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": ""
  },
  {
    "id": "S5324",
    "key": "java:S5324",
    "name": "Accessing Android external storage is security-sensitive",
    "type": "security-hotspot",
    "severity": "critical",
    "tags": [
      "cwe",
      "android"
    ],
    "why": "<p>Storing data locally is a common task for mobile applications. Such data includes files among other things. One convenient way to store files is to\nuse the external file storage which usually offers a larger amount of disc space compared to internal storage.</p>\n<p>Files created on the external storage are globally readable and writable. Therefore, a malicious application having the permissions\n<code>WRITE_EXTERNAL_STORAGE</code> or <code>READ_EXTERNAL_STORAGE</code> could try to read sensitive information from the files that other\napplications have stored on the external storage.</p>\n<p>External storage can also be removed by the user (e.g. when based on SD card) making the files unavailable to the application.</p>\n",
    "howToFix": "<h2>Recommended Secure Coding Practices</h2>\n<ul>\n  <li> Use internal storage whenever possible as the system prevents other apps from accessing this location. </li>\n  <li> Only use external storage if you need to share non-sensitive files with other applications. </li>\n  <li> If your application has to use the external storage to store sensitive data, make sure it encrypts the files using <a\n  href=\"https://developer.android.com/reference/androidx/security/crypto/EncryptedFile\">EncryptedFile</a>. </li>\n  <li> Data coming from external storage should always be considered untrusted and should be validated. </li>\n  <li> As some external storage can be removed, make sure to never store files on it that are critical for the usability of your application. </li>\n</ul>\n<h2>Compliant Solution</h2>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\nimport android.content.Context;\n\npublic class AccessExternalFiles {\n\n    public void accessFiles(Context context) {\n        context.getFilesDir();\n    }\n}\n</pre>\n<h2>See</h2>\n<ul>\n  <li> OWASP - <a href=\"https://owasp.org/Top10/A04_2021-Insecure_Design/\">Top 10 2021 Category A4 - Insecure Design</a> </li>\n  <li> <a href=\"https://developer.android.com/privacy-and-security/security-tips#ExternalStorage\">Android Security tips on external file storage</a>\n  </li>\n  <li> OWASP - <a href=\"https://mas.owasp.org/checklists/MASVS-STORAGE/\">Mobile AppSec Verification Standard - Data Storage and Privacy\n  Requirements</a> </li>\n  <li> OWASP - <a href=\"https://owasp.org/www-project-mobile-top-10/2016-risks/m2-insecure-data-storage\">Mobile Top 10 2016 Category M2 - Insecure\n  Data Storage</a> </li>\n  <li> OWASP - <a href=\"https://owasp.org/www-project-mobile-top-10/2023-risks/m9-insecure-data-storage\">Mobile Top 10 2024 Category M9 - Insecure\n  Data Storage</a> </li>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/312\">CWE-312 - Cleartext Storage of Sensitive Information</a> </li>\n</ul>",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "Android 외부 저장소 접근은 보안에 민감합니다",
    "why_ko": "<p>로컬에 데이터를 저장하는 것은 모바일 애플리케이션의 일반적인 작업입니다. 이러한 데이터에는 파일 등이 포함됩니다. 파일을 저장하는 편리한 방법 중 하나는 일반적으로 내부 저장소에 비해 더 많은 디스크 공간을 제공하는 외부 파일 저장소를 사용하는 것입니다.</p>\n<p>외부 저장소에 생성된 파일은 전역적으로 읽기 및 쓰기가 가능합니다. 따라서 <code>WRITE_EXTERNAL_STORAGE</code> 또는 <code>READ_EXTERNAL_STORAGE</code> 권한이 있는 악성 애플리케이션이 다른 애플리케이션이 외부 저장소에 저장한 파일에서 민감한 정보를 읽으려고 시도할 수 있습니다.</p>\n<p>외부 저장소는 사용자에 의해 제거될 수도 있어(예: SD 카드 기반인 경우) 파일을 애플리케이션에서 사용할 수 없게 됩니다.</p>\n",
    "howToFix_ko": "<h2>권장 보안 코딩 방법</h2>\n<ul>\n  <li> 시스템이 다른 앱이 이 위치에 접근하는 것을 방지하므로 가능하면 내부 저장소를 사용하세요. </li>\n  <li> 민감하지 않은 파일을 다른 애플리케이션과 공유해야 하는 경우에만 외부 저장소를 사용하세요. </li>\n  <li> 애플리케이션이 민감한 데이터를 저장하기 위해 외부 저장소를 사용해야 하는 경우 <a href=\"https://developer.android.com/reference/androidx/security/crypto/EncryptedFile\">EncryptedFile</a>을 사용하여 파일을 암호화하세요. </li>\n  <li> 외부 저장소에서 오는 데이터는 항상 신뢰할 수 없는 것으로 간주하고 검증해야 합니다. </li>\n  <li> 일부 외부 저장소는 제거될 수 있으므로 애플리케이션의 사용성에 중요한 파일을 절대 저장하지 마세요. </li>\n</ul>\n<h2>규칙을 준수하는 해결책</h2>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\nimport android.content.Context;\n\npublic class AccessExternalFiles {\n\n    public void accessFiles(Context context) {\n        context.getFilesDir();\n    }\n}\n</pre>\n<h2>참고</h2>\n<ul>\n  <li> OWASP - <a href=\"https://owasp.org/Top10/A04_2021-Insecure_Design/\">상위 10가지 2021 카테고리 A4 - 안전하지 않은 설계</a> </li>\n  <li> <a href=\"https://developer.android.com/privacy-and-security/security-tips#ExternalStorage\">외부 파일 저장소에 대한 Android 보안 팁</a> </li>\n  <li> OWASP - <a href=\"https://mas.owasp.org/checklists/MASVS-STORAGE/\">모바일 AppSec 검증 표준 - 데이터 저장 및 개인 정보 요구 사항</a> </li>\n  <li> OWASP - <a href=\"https://owasp.org/www-project-mobile-top-10/2016-risks/m2-insecure-data-storage\">모바일 상위 10가지 2016 카테고리 M2 - 안전하지 않은 데이터 저장</a> </li>\n  <li> OWASP - <a href=\"https://owasp.org/www-project-mobile-top-10/2023-risks/m9-insecure-data-storage\">모바일 상위 10가지 2024 카테고리 M9 - 안전하지 않은 데이터 저장</a> </li>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/312\">CWE-312 - 민감한 정보의 평문 저장</a> </li>\n</ul>",
    "moreInfo_ko": ""
  },
  {
    "id": "S2232",
    "key": "java:S2232",
    "name": "\"ResultSet.isLast()\" should not be used",
    "type": "code-smell",
    "severity": "major",
    "tags": [
      "performance",
      "pitfall",
      "sql"
    ],
    "why": "<p>There are several reasons to avoid using this method:</p>\n<ol>\n  <li> It is optionally available only for result sets of type <code>ResultSet.TYPE_FORWARD_ONLY</code>. Database drivers will throw an exception if\n  not supported. </li>\n  <li> The method can be expensive to execute as the database driver may need to fetch ahead one row to determine whether the current row is the last\n  in the result set. The documentation of the method explicitly mentions this fact. </li>\n  <li> What \"the cursor is on the last row\" means for an empty <code>ResultSet</code> is unclear. Database drivers may return <code>true</code> or\n  <code>false</code> in this case . </li>\n</ol>\n<p><code>ResultSet.next()</code> is a good alternative to <code>ResultSet.isLast()</code> as it does not have the mentioned issues. It is always\nsupported and, as per specification, returns <code>false</code> for empty result sets.</p>",
    "howToFix": "<p>Refactor your code to use <code>ResultSet.next()</code> instead of <code>ResultSet.isLast()</code>. Be cautious of its different semantics and side\neffects on cursor positioning in the result set. Verify that your program logic is still valid under these side effects and otherwise adjust it.</p>\n\n<h4>Noncompliant code example</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\nResultSet results = stmt.executeQuery(\"SELECT name, address FROM PERSON\");\nStringBuilder sb = new StringBuilder();\nwhile (results.next() &amp;&amp; !results.isLast()) { // Noncompliant\n  sb.append(results.getString(\"name\") + \", \");\n}\nsb.append(results.getString(\"name\"));\nString formattedNames = sb.toString();\n</pre>\n<h4>Compliant solution</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\nResultSet results = stmt.executeQuery(\"SELECT name, address FROM PERSON\");\nList&lt;String&gt; names = new ArrayList&lt;&gt;();\nwhile (results.next()) { // Compliant, and program logic refactored\n  names.add(results.getString(\"name\"));\n}\nString formattedNames =  names.stream().collect(Collectors.joining(\", \"));\n</pre>",
    "moreInfo": "<h3>Documentation</h3>\n<ul>\n  <li> <a href=\"https://docs.oracle.com/javase/8/docs/api/java/sql/ResultSet.html#isLast--\">Java SE 8 API Specification: ResultSet.isLast()</a> </li>\n</ul>",
    "status": "READY",
    "name_ko": "\"ResultSet.isLast()\"를 사용하면 안 됩니다",
    "why_ko": "<p>이 메서드 사용을 피해야 하는 몇 가지 이유가 있습니다:</p>\n<ol>\n  <li> <code>ResultSet.TYPE_FORWARD_ONLY</code> 타입의 결과 집합에만 선택적으로 사용 가능합니다. 지원되지 않으면 데이터베이스 드라이버가 예외를 던집니다. </li>\n  <li> 데이터베이스 드라이버가 현재 행이 결과 집합의 마지막 행인지 확인하기 위해 한 행을 미리 가져와야 할 수 있으므로 이 메서드를 실행하는 데 비용이 많이 들 수 있습니다. 이 메서드의 문서에서 이 사실을 명시적으로 언급합니다. </li>\n  <li> 빈 <code>ResultSet</code>에서 \"커서가 마지막 행에 있다\"는 것이 무엇을 의미하는지 불분명합니다. 이 경우 데이터베이스 드라이버가 <code>true</code> 또는 <code>false</code>를 반환할 수 있습니다. </li>\n</ol>\n<p><code>ResultSet.next()</code>는 언급된 문제가 없으므로 <code>ResultSet.isLast()</code>의 좋은 대안입니다. 항상 지원되며 명세에 따르면 빈 결과 집합에 대해 <code>false</code>를 반환합니다.</p>",
    "howToFix_ko": "<p><code>ResultSet.isLast()</code> 대신 <code>ResultSet.next()</code>를 사용하도록 코드를 리팩토링하세요. 결과 집합에서 커서 위치에 대한 다른 의미와 부작용에 주의하세요. 이러한 부작용 하에서 프로그램 로직이 여전히 유효한지 확인하고 그렇지 않으면 조정하세요.</p>\n\n<h4>규칙을 준수하지 않는 코드 예시</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\nResultSet results = stmt.executeQuery(\"SELECT name, address FROM PERSON\");\nStringBuilder sb = new StringBuilder();\nwhile (results.next() &amp;&amp; !results.isLast()) { // 규칙 위반\n  sb.append(results.getString(\"name\") + \", \");\n}\nsb.append(results.getString(\"name\"));\nString formattedNames = sb.toString();\n</pre>\n<h4>규칙을 준수하는 해결책</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\nResultSet results = stmt.executeQuery(\"SELECT name, address FROM PERSON\");\nList&lt;String&gt; names = new ArrayList&lt;&gt;();\nwhile (results.next()) { // 규칙 준수, 프로그램 로직이 리팩토링됨\n  names.add(results.getString(\"name\"));\n}\nString formattedNames =  names.stream().collect(Collectors.joining(\", \"));\n</pre>",
    "moreInfo_ko": "<h3>문서</h3>\n<ul>\n  <li> <a href=\"https://docs.oracle.com/javase/8/docs/api/java/sql/ResultSet.html#isLast--\">Java SE 8 API 명세: ResultSet.isLast()</a> </li>\n</ul>"
  },
  {
    "id": "S5689",
    "key": "java:S5689",
    "name": "Disclosing fingerprints from web application technologies is security-sensitive",
    "type": "security-hotspot",
    "severity": "minor",
    "tags": [
      "cwe"
    ],
    "why": "<p>Disclosure of version information, usually overlooked by developers but disclosed by default by the systems and frameworks in use, can pose a\nsignificant security risk depending on the production environment.</p>\n<p>Once this information is public, attackers can use it to identify potential security holes or vulnerabilities specific to that version.</p>\n<p>Furthermore, if the published version information indicates the use of outdated or unsupported software, it becomes easier for attackers to exploit\nknown vulnerabilities. They can search for published vulnerabilities related to that version and launch attacks that specifically target those\nvulnerabilities.</p>\n",
    "howToFix": "<h2>Recommended Secure Coding Practices</h2>\n<p>In general, it is recommended to keep internal technical information within internal systems to control what attackers know about the underlying\narchitectures. This is known as the \"need to know\" principle.</p>\n<p>The most effective solution is to remove version information disclosure from what end users can see, such as the \"x-powered-by\" header.<br> This\ncan be achieved directly through the web application code, server (nginx, apache) or firewalls.</p>\n<p>Disabling the server signature provides additional protection by reducing the amount of information available to attackers. Note, however, that\nthis does not provide as much protection as regular updates and patches.<br> Security by obscurity is the least foolproof solution of all. It should\nnever be the only defense mechanism and should always be combined with other security measures.</p>\n<h2>Compliant Solution</h2>\n<p>Do not disclose version information unless necessary. The <code>x-powered-by</code> or <code>Server</code> HTTP headers should not be used.</p>\n<h2>See</h2>\n<ul>\n  <li> OWASP - <a href=\"https://owasp.org/Top10/A05_2021-Security_Misconfiguration/\">Top 10 2021 Category A5 - Security Misconfiguration</a> </li>\n  <li> <a\n  href=\"https://owasp.org/www-project-web-security-testing-guide/stable/4-Web_Application_Security_Testing/01-Information_Gathering/08-Fingerprint_Web_Application_Framework.html\">OWASP Testing Guide - OTG-INFO-008</a> - Fingerprint Web Application Framework </li>\n  <li> OWASP - <a href=\"https://owasp.org/www-project-top-ten/2017/A6_2017-Security_Misconfiguration\">Top 10 2017 Category A6 - Security\n  Misconfiguration</a> </li>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/200\">CWE-200 - Information Exposure</a> </li>\n</ul>",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "웹 애플리케이션 기술의 핑거프린트 노출은 보안에 민감합니다",
    "why_ko": "<p>개발자가 보통 간과하지만 사용 중인 시스템과 프레임워크에서 기본적으로 노출되는 버전 정보의 공개는 프로덕션 환경에 따라 심각한 보안 위험을 초래할 수 있습니다.</p>\n<p>이 정보가 공개되면 공격자는 해당 버전에 특정한 잠재적 보안 허점이나 취약점을 식별하는 데 사용할 수 있습니다.</p>\n<p>또한 공개된 버전 정보가 오래되거나 지원되지 않는 소프트웨어의 사용을 나타내면 공격자가 알려진 취약점을 악용하기가 더 쉬워집니다. 해당 버전과 관련된 공개된 취약점을 검색하고 해당 취약점을 특정적으로 대상으로 하는 공격을 시작할 수 있습니다.</p>\n",
    "howToFix_ko": "<h2>권장 보안 코딩 관행</h2>\n<p>일반적으로 공격자가 기본 아키텍처에 대해 알 수 있는 것을 제어하기 위해 내부 기술 정보를 내부 시스템 내에 유지하는 것이 좋습니다. 이것은 \"알 필요가 있는\" 원칙으로 알려져 있습니다.</p>\n<p>가장 효과적인 해결책은 \"x-powered-by\" 헤더와 같이 최종 사용자가 볼 수 있는 곳에서 버전 정보 노출을 제거하는 것입니다.<br> 이는 웹 애플리케이션 코드, 서버(nginx, apache) 또는 방화벽을 통해 직접 달성할 수 있습니다.</p>\n<p>서버 서명을 비활성화하면 공격자가 사용할 수 있는 정보의 양을 줄여 추가 보호를 제공합니다. 그러나 이것은 정기적인 업데이트와 패치만큼의 보호를 제공하지 않습니다.<br> 은폐에 의한 보안은 모든 것 중에서 가장 확실하지 않은 해결책입니다. 이것은 유일한 방어 메커니즘이 되어서는 안 되며 항상 다른 보안 조치와 결합해야 합니다.</p>\n<h2>규칙을 준수하는 해결책</h2>\n<p>필요하지 않은 한 버전 정보를 공개하지 마세요. <code>x-powered-by</code> 또는 <code>Server</code> HTTP 헤더를 사용해서는 안 됩니다.</p>\n<h2>참고</h2>\n<ul>\n  <li> OWASP - <a href=\"https://owasp.org/Top10/A05_2021-Security_Misconfiguration/\">Top 10 2021 Category A5 - Security Misconfiguration</a> </li>\n  <li> <a href=\"https://owasp.org/www-project-web-security-testing-guide/stable/4-Web_Application_Security_Testing/01-Information_Gathering/08-Fingerprint_Web_Application_Framework.html\">OWASP Testing Guide - OTG-INFO-008</a> - Fingerprint Web Application Framework </li>\n  <li> OWASP - <a href=\"https://owasp.org/www-project-top-ten/2017/A6_2017-Security_Misconfiguration\">Top 10 2017 Category A6 - Security Misconfiguration</a> </li>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/200\">CWE-200 - 정보 노출</a> </li>\n</ul>",
    "moreInfo_ko": ""
  },
  {
    "id": "S1449",
    "key": "java:S1449",
    "name": "String operations should not rely on the default system locale",
    "type": "code-smell",
    "severity": "minor",
    "tags": [
      "unpredictable",
      "cert"
    ],
    "why": "<p>Failure to specify a locale when calling the methods <code>toLowerCase()</code>, <code>toUpperCase()</code> or <code>format()</code> on\n<code>String</code> objects means the system default encoding will be used, possibly creating problems with international characters or number\nrepresentations. For instance with the Turkish language, when converting the small letter 'i' to upper case, the result is capital letter 'I' with a\ndot over it.</p>\n<p>Case conversion without a locale may work fine in its \"home\" environment, but break in ways that are extremely difficult to diagnose for customers\nwho use different encodings. Such bugs can be nearly, if not completely, impossible to reproduce when it's time to fix them. For locale-sensitive\nstrings, the correct locale should always be used, but <code>Locale.ROOT</code> can be used for case-insensitive ones.</p>\n<h3>Noncompliant code example</h3>\n<pre>\nmyString.toLowerCase()\n</pre>\n<h3>Compliant solution</h3>\n<pre>\nmyString.toLowerCase(Locale.TR)\n</pre>",
    "howToFix": "",
    "moreInfo": "<ul>\n  <li> <a href=\"https://wiki.sei.cmu.edu/confluence/x/4zdGBQ\">CERT, STR02-J.</a> - Specify an appropriate locale when comparing locale-dependent data\n  </li>\n</ul>",
    "status": "READY",
    "name_ko": "String 연산은 기본 시스템 로케일에 의존하면 안 됩니다",
    "why_ko": "<p><code>String</code> 객체에서 <code>toLowerCase()</code>, <code>toUpperCase()</code> 또는 <code>format()</code> 메서드를 호출할 때 로케일을 지정하지 않으면 시스템 기본 인코딩이 사용되어 국제 문자나 숫자 표현에 문제가 발생할 수 있습니다. 예를 들어 터키어에서 소문자 'i'를 대문자로 변환하면 결과는 위에 점이 있는 대문자 'I'가 됩니다.</p>\n<p>로케일 없는 대소문자 변환은 \"홈\" 환경에서는 잘 작동할 수 있지만, 다른 인코딩을 사용하는 고객에게는 진단하기 매우 어려운 방식으로 문제가 발생할 수 있습니다. 이러한 버그는 수정할 때가 되면 재현이 거의 불가능하거나 완전히 불가능할 수 있습니다. 로케일에 민감한 문자열의 경우 항상 올바른 로케일을 사용해야 하지만, 대소문자를 구분하지 않는 경우에는 <code>Locale.ROOT</code>를 사용할 수 있습니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\nmyString.toLowerCase()\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre>\nmyString.toLowerCase(Locale.TR)\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": "<ul>\n  <li> <a href=\"https://wiki.sei.cmu.edu/confluence/x/4zdGBQ\">CERT, STR02-J.</a> - 로케일에 의존하는 데이터를 비교할 때 적절한 로케일을 지정하세요 </li>\n</ul>"
  },
  {
    "id": "S3024",
    "key": "java:S3024",
    "name": "Arguments to \"append\" should not be concatenated",
    "type": "code-smell",
    "severity": "minor",
    "tags": [
      "performance",
      "clumsy"
    ],
    "why": "<p>The use of a <code>StringBuilder</code> or <code>StringBuffer</code> makes <code>String</code> assembly more efficient than plain concatenation\nwhen you perform a large number of appends. Using <code>String</code> concatenation within <code>StringBuilder.append</code> defeats the purpose of\nthe <code>StringBuilder</code>. If you concatenate only a few strings, use direct <code>String</code> concatenation. Otherwise, replace\n<code>String</code> concatenation with calls to <code>append</code>.</p>\n<p>This rule applies to String concatenations performed repeatedly, inside loops. In such scenarios, the performance penalty associated with\ninefficient StringBuilder.append usage can multiply significantly.</p>\n<h3>Noncompliant code example</h3>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\nStringBuilder sb = new StringBuilder();\nfor (String name : names) {\n  sb.append(\"Hello : \" + name); // Noncompliant\n}\n</pre>\n<h3>Compliant solution</h3>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\nStringBuilder sb = new StringBuilder();\nfor (String name : names) {\n  sb.append(\"Hello : \").append(name);\n}\n</pre>",
    "howToFix": "",
    "moreInfo": "<h3>Benchmarks</h3>\n<table>\n  <colgroup>\n    <col style=\"width: 25%;\">\n    <col style=\"width: 25%;\">\n    <col style=\"width: 25%;\">\n    <col style=\"width: 25%;\">\n  </colgroup>\n  <thead>\n    <tr>\n      <th>Method</th>\n      <th>Runtime</th>\n      <th>Average time</th>\n      <th>Error margin</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td><p>append</p></td>\n      <td><p>Temurin 21</p></td>\n      <td><p>14.26 ns/op</p></td>\n      <td><p>±0.50 ns/op</p></td>\n    </tr>\n    <tr>\n      <td><p>concat</p></td>\n      <td><p>Temurin 21</p></td>\n      <td><p>17.77 ns/op</p></td>\n      <td><p>±0.66 ns/op</p></td>\n    </tr>\n    <tr>\n      <td><p>concatWithinBuilder</p></td>\n      <td><p>Temurin 21</p></td>\n      <td><p>31.42 ns/op</p></td>\n      <td><p>±1.80 ns/op</p></td>\n    </tr>\n  </tbody>\n</table>\n<p>The results were generated by running the following snippet with <a href=\"https://github.com/openjdk/jmh\">jmh</a>:</p>\n<pre>\nprivate String name1 = \"John\";\nprivate String name2 = \"Jane\";\n\n@Benchmark\npublic String concat() {\n  return name1 + \", \" + name2;\n}\n\n@Benchmark\npublic String concatWithinBuilder() {\n  return new StringBuilder()\n    .append(name1 + \", \" + name2)\n    .toString();\n}\n\n@Benchmark\npublic String append() {\n  return new StringBuilder()\n    .append(name1)\n    .append(\", \")\n    .append(name2)\n    .toString();\n}\n</pre>",
    "status": "READY",
    "name_ko": "\"append\"의 인자는 연결하지 않아야 합니다",
    "why_ko": "<p><code>StringBuilder</code> 또는 <code>StringBuffer</code>를 사용하면 많은 수의 append를 수행할 때 단순 연결보다 <code>String</code> 조립이 더 효율적입니다. <code>StringBuilder.append</code> 내에서 <code>String</code> 연결을 사용하면 <code>StringBuilder</code>의 목적이 무효화됩니다. 몇 개의 문자열만 연결하는 경우 직접 <code>String</code> 연결을 사용하세요. 그렇지 않으면 <code>String</code> 연결을 <code>append</code> 호출로 대체하세요.</p>\n<p>이 규칙은 반복문 내에서 반복적으로 수행되는 String 연결에 적용됩니다. 이러한 시나리오에서는 비효율적인 StringBuilder.append 사용과 관련된 성능 저하가 크게 증가할 수 있습니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\nStringBuilder sb = new StringBuilder();\nfor (String name : names) {\n  sb.append(\"Hello : \" + name); // 규칙 위반\n}\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\nStringBuilder sb = new StringBuilder();\nfor (String name : names) {\n  sb.append(\"Hello : \").append(name);\n}\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": "<h3>벤치마크</h3>\n<table>\n  <colgroup>\n    <col style=\"width: 25%;\">\n    <col style=\"width: 25%;\">\n    <col style=\"width: 25%;\">\n    <col style=\"width: 25%;\">\n  </colgroup>\n  <thead>\n    <tr>\n      <th>메서드</th>\n      <th>런타임</th>\n      <th>평균 시간</th>\n      <th>오차 범위</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td><p>append</p></td>\n      <td><p>Temurin 21</p></td>\n      <td><p>14.26 ns/op</p></td>\n      <td><p>±0.50 ns/op</p></td>\n    </tr>\n    <tr>\n      <td><p>concat</p></td>\n      <td><p>Temurin 21</p></td>\n      <td><p>17.77 ns/op</p></td>\n      <td><p>±0.66 ns/op</p></td>\n    </tr>\n    <tr>\n      <td><p>concatWithinBuilder</p></td>\n      <td><p>Temurin 21</p></td>\n      <td><p>31.42 ns/op</p></td>\n      <td><p>±1.80 ns/op</p></td>\n    </tr>\n  </tbody>\n</table>\n<p>결과는 <a href=\"https://github.com/openjdk/jmh\">jmh</a>로 다음 스니펫을 실행하여 생성되었습니다:</p>\n<pre>\nprivate String name1 = \"John\";\nprivate String name2 = \"Jane\";\n\n@Benchmark\npublic String concat() {\n  return name1 + \", \" + name2;\n}\n\n@Benchmark\npublic String concatWithinBuilder() {\n  return new StringBuilder()\n    .append(name1 + \", \" + name2)\n    .toString();\n}\n\n@Benchmark\npublic String append() {\n  return new StringBuilder()\n    .append(name1)\n    .append(\", \")\n    .append(name2)\n    .toString();\n}\n</pre>"
  },
  {
    "id": "S6363",
    "key": "java:S6363",
    "name": "Enabling file access for WebViews is security-sensitive",
    "type": "security-hotspot",
    "severity": "major",
    "tags": [
      "cwe",
      "android"
    ],
    "why": "<p>Granting file access to WebViews, particularly through the <code>file://</code> scheme, introduces a risk of local file inclusion vulnerabilities.\nThe severity of this risk depends heavily on the specific settings configured for the WebView. Overly permissive settings can allow malicious scripts\nto access a wide range of local files, potentially exposing sensitive data such as Personally Identifiable Information (PII) or private application\ndata, leading to data breaches and other security compromises.</p>\n",
    "howToFix": "<h2>Recommended Secure Coding Practices</h2>\n<p>Avoid opening <code>file://</code> URLs from external sources in WebView components. If your application accepts arbitrary URLs from external\nsources, do not enable this functionality.</p>\n<p>On Android, it is recommended to use <code>androidx.webkit.WebViewAssetLoader</code> to access files, including assets and resources, via a custom,\ncontrollable scheme.</p>\n<p>On iOS, it is recommended to use Bundles to access local files, keeping access limited a controlled subset using the\n<code>allowingReadAccessTo</code> parameter of the <code>loadFileURL</code> method. If <code>allowFileAccessFromFileURLs</code> and\n<code>allowUniversalAccessFromFileURLs</code> are not enabled, it is not possible to access files outside the intended directory. It is also possible\nto create a custom scheme to access local files, but this is more complex and might lead to unintended security issues.</p>\n<p>For enhanced security, ensure that the options to load <code>file://</code> URLs are explicitly set to false.</p>\n<h2>Compliant Solution</h2>\n<pre>\nimport android.webkit.WebView;\n\nWebView webView = (WebView) findViewById(R.id.webview);\nwebView.getSettings().setAllowFileAccess(false);\nwebView.getSettings().setAllowContentAccess(false);\n</pre>\n<h2>See</h2>\n<ul>\n  <li> OWASP - <a href=\"https://owasp.org/Top10/A01_2021-Broken_Access_Control/\">Top 10 2021 Category A1 - Broken Access Control</a> </li>\n  <li> OWASP - <a href=\"https://owasp.org/www-project-top-ten/2017/A3_2017-Sensitive_Data_Exposure\">Top 10 2017 Category A3 - Sensitive Data\n  Exposure</a> </li>\n  <li> OWASP - <a href=\"https://owasp.org/www-project-top-ten/2017/A6_2017-Security_Misconfiguration\">Top 10 2017 Category A6 - Security\n  Misconfiguration</a> </li>\n  <li> OWASP - <a href=\"https://owasp.org/www-project-mobile-top-10/2023-risks/m8-security-misconfiguration\">Mobile Top 10 2024 Category M8 - Security\n  Misconfiguration</a> </li>\n  <li> OWASP - <a href=\"https://mas.owasp.org/checklists/MASVS-PLATFORM/\">Mobile AppSec Verification Standard - Platform Interaction Requirements</a>\n  </li>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/79\">CWE-79 - Improper Neutralization of Input During Web Page Generation ('Cross-site\n  Scripting')</a> </li>\n  <li> Android Documentation - <a href=\"https://developer.android.com/privacy-and-security/risks/webview-unsafe-file-inclusion\">WebViews - Unsafe File\n  Inclusion</a> </li>\n</ul>",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "WebView에서 파일 액세스를 활성화하는 것은 보안에 민감합니다",
    "why_ko": "<p>특히 <code>file://</code> 스키마를 통해 WebView에 파일 액세스를 부여하면 로컬 파일 포함 취약점의 위험이 발생합니다. 이 위험의 심각도는 WebView에 구성된 특정 설정에 크게 의존합니다. 지나치게 허용적인 설정은 악성 스크립트가 광범위한 로컬 파일에 접근할 수 있게 하여 개인 식별 정보(PII) 또는 비공개 애플리케이션 데이터와 같은 민감한 데이터를 노출시켜 데이터 유출 및 기타 보안 손상으로 이어질 수 있습니다.</p>\n",
    "howToFix_ko": "<h2>권장 보안 코딩 관행</h2>\n<p>WebView 컴포넌트에서 외부 소스의 <code>file://</code> URL을 열지 마세요. 애플리케이션이 외부 소스에서 임의의 URL을 허용하는 경우 이 기능을 활성화하지 마세요.</p>\n<p>Android에서는 <code>androidx.webkit.WebViewAssetLoader</code>를 사용하여 사용자 지정 가능한 제어 스키마를 통해 에셋 및 리소스를 포함한 파일에 접근하는 것이 권장됩니다.</p>\n<p>iOS에서는 Bundle을 사용하여 로컬 파일에 접근하고 <code>loadFileURL</code> 메서드의 <code>allowingReadAccessTo</code> 매개변수를 사용하여 접근을 제어된 하위 집합으로 제한하는 것이 권장됩니다. <code>allowFileAccessFromFileURLs</code>와 <code>allowUniversalAccessFromFileURLs</code>가 활성화되지 않은 경우 의도된 디렉토리 외부의 파일에 접근할 수 없습니다. 로컬 파일에 접근하기 위해 사용자 지정 스키마를 만들 수도 있지만 이는 더 복잡하고 의도하지 않은 보안 문제로 이어질 수 있습니다.</p>\n<p>향상된 보안을 위해 <code>file://</code> URL을 로드하는 옵션이 명시적으로 false로 설정되어 있는지 확인하세요.</p>\n<h2>규칙을 준수하는 해결책</h2>\n<pre>\nimport android.webkit.WebView;\n\nWebView webView = (WebView) findViewById(R.id.webview);\nwebView.getSettings().setAllowFileAccess(false);\nwebView.getSettings().setAllowContentAccess(false);\n</pre>\n<h2>참고</h2>\n<ul>\n  <li> OWASP - <a href=\"https://owasp.org/Top10/A01_2021-Broken_Access_Control/\">Top 10 2021 Category A1 - 취약한 접근 제어</a> </li>\n  <li> OWASP - <a href=\"https://owasp.org/www-project-top-ten/2017/A3_2017-Sensitive_Data_Exposure\">Top 10 2017 Category A3 - 민감한 데이터 노출</a> </li>\n  <li> OWASP - <a href=\"https://owasp.org/www-project-top-ten/2017/A6_2017-Security_Misconfiguration\">Top 10 2017 Category A6 - 보안 구성 오류</a> </li>\n  <li> OWASP - <a href=\"https://owasp.org/www-project-mobile-top-10/2023-risks/m8-security-misconfiguration\">Mobile Top 10 2024 Category M8 - 보안 구성 오류</a> </li>\n  <li> OWASP - <a href=\"https://mas.owasp.org/checklists/MASVS-PLATFORM/\">Mobile AppSec Verification Standard - 플랫폼 상호 작용 요구사항</a> </li>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/79\">CWE-79 - 웹 페이지 생성 중 입력의 부적절한 무력화('크로스 사이트 스크립팅')</a> </li>\n  <li> Android Documentation - <a href=\"https://developer.android.com/privacy-and-security/risks/webview-unsafe-file-inclusion\">WebViews - 안전하지 않은 파일 포함</a> </li>\n</ul>",
    "moreInfo_ko": ""
  },
  {
    "id": "S6877",
    "key": "java:S6877",
    "name": "Reverse view should be used instead of reverse copy in read-only cases",
    "type": "code-smell",
    "severity": "critical",
    "tags": [
      "java21"
    ],
    "why": "<p>Java 21 introduces the new Sequenced Collections API, which applies to all collections with a defined sequence on their elements, such as\n<code>LinkedList</code>, <code>TreeSet</code>, and others (see <a href=\"https://openjdk.org/jeps/431\">JEP 431</a>). For projects using Java 21 and\nonwards, use this API instead of workaround implementations that were necessary before Java 21. One of the features of the new Sequenced Collections\nAPI is <code>SequencedCollection.reversed()</code> which returns a lightweight view of the original collection, in the reverse order.</p>\n<p>This rule reports when reverse view would have been sufficient instead of a reverse copy of a sequenced collection created using a list constructor\nplus a <code>Collections.reverse(collection);</code> call.</p>\n<p>If feasible, a view should be preferred over a copy because a view is a lightweight iterator without modification of the list itself.</p>",
    "howToFix": "<p>Remove <code>Collections.reverse(list);</code> and replace <code>list</code> with <code>list.reversed()</code> after.</p>\n\n<h4>Noncompliant code example</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\nvoid foo() {\n  var list = new ArrayList&lt;String&gt;();\n  list.add(\"A\");\n  list.add(\"B\");\n  Collections.reverse(list); // Noncompliant\n  for (var e : list) {\n    // ...\n  }\n}\n</pre>\n<h4>Compliant solution</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\nvoid foo() {\n  var list = new ArrayList&lt;String&gt;();\n  list.add(\"A\");\n  list.add(\"B\");\n  for (var e : list.reversed()) {  // Compliant\n    // ...\n  }\n}\n</pre>\n<h4>Noncompliant code example</h4>\n<pre data-diff-id=\"2\" data-diff-type=\"noncompliant\">\nvoid foo(List&lt;String&gt; list) {\n  var copy = new ArrayList&lt;String&gt;(list);\n  Collections.reverse(copy); // Noncompliant\n  for (var e : copy) {\n    // ...\n  }\n}\n</pre>\n<h4>Compliant solution</h4>\n<pre data-diff-id=\"2\" data-diff-type=\"compliant\">\nvoid foo(List&lt;String&gt; list) {\n  for (var e : list.reversed()) {  // Compliant\n    // ...\n  }\n}\n</pre>",
    "moreInfo": "<h3>Documentation</h3>\n<ul>\n  <li> Java Documentation - <a href=\"https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/util/SequencedCollection.html\">Interface\n  SequencedCollection</a> </li>\n  <li> OpenJDK - <a href=\"https://openjdk.org/jeps/431\">JEP 431: Sequenced Collections</a> </li>\n  <li> Java Documentation - <a\n  href=\"https://docs.oracle.com/en/java/javase/21/core/creating-sequenced-collections-sets-and-maps.html#GUID-DCFE1D88-A0F5-47DE-A816-AEDA50B97523\">Creating Sequenced Collections, Sets, and Maps</a> </li>\n</ul>",
    "status": "READY",
    "name_ko": "읽기 전용의 경우 역방향 복사 대신 역방향 뷰를 사용해야 합니다",
    "why_ko": "<p>Java 21은 <code>LinkedList</code>, <code>TreeSet</code> 등과 같이 요소에 정의된 순서가 있는 모든 컬렉션에 적용되는 새로운 Sequenced Collections API를 도입합니다(<a href=\"https://openjdk.org/jeps/431\">JEP 431</a> 참조). Java 21 이상을 사용하는 프로젝트의 경우 Java 21 이전에 필요했던 우회 구현 대신 이 API를 사용하세요. 새로운 Sequenced Collections API의 기능 중 하나는 <code>SequencedCollection.reversed()</code>로 원본 컬렉션의 역순으로 경량 뷰를 반환합니다.</p>\n<p>이 규칙은 리스트 생성자와 <code>Collections.reverse(collection);</code> 호출을 사용하여 생성된 sequenced 컬렉션의 역방향 복사 대신 역방향 뷰로 충분했을 때 보고합니다.</p>\n<p>가능하다면 뷰는 리스트 자체를 수정하지 않는 경량 반복자이므로 복사보다 뷰를 선호해야 합니다.</p>",
    "howToFix_ko": "<p><code>Collections.reverse(list);</code>를 제거하고 이후에 <code>list</code>를 <code>list.reversed()</code>로 교체하세요.</p>\n\n<h4>규칙을 준수하지 않는 코드 예시</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\nvoid foo() {\n  var list = new ArrayList&lt;String&gt;();\n  list.add(\"A\");\n  list.add(\"B\");\n  Collections.reverse(list); // 규칙 위반\n  for (var e : list) {\n    // ...\n  }\n}\n</pre>\n<h4>규칙을 준수하는 해결책</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\nvoid foo() {\n  var list = new ArrayList&lt;String&gt;();\n  list.add(\"A\");\n  list.add(\"B\");\n  for (var e : list.reversed()) {  // 규칙 준수\n    // ...\n  }\n}\n</pre>\n<h4>규칙을 준수하지 않는 코드 예시</h4>\n<pre data-diff-id=\"2\" data-diff-type=\"noncompliant\">\nvoid foo(List&lt;String&gt; list) {\n  var copy = new ArrayList&lt;String&gt;(list);\n  Collections.reverse(copy); // 규칙 위반\n  for (var e : copy) {\n    // ...\n  }\n}\n</pre>\n<h4>규칙을 준수하는 해결책</h4>\n<pre data-diff-id=\"2\" data-diff-type=\"compliant\">\nvoid foo(List&lt;String&gt; list) {\n  for (var e : list.reversed()) {  // 규칙 준수\n    // ...\n  }\n}\n</pre>",
    "moreInfo_ko": "<h3>문서</h3>\n<ul>\n  <li> Java 문서 - <a href=\"https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/util/SequencedCollection.html\">SequencedCollection 인터페이스</a> </li>\n  <li> OpenJDK - <a href=\"https://openjdk.org/jeps/431\">JEP 431: Sequenced Collections</a> </li>\n  <li> Java 문서 - <a href=\"https://docs.oracle.com/en/java/javase/21/core/creating-sequenced-collections-sets-and-maps.html#GUID-DCFE1D88-A0F5-47DE-A816-AEDA50B97523\">Sequenced Collections, Sets, Maps 생성하기</a> </li>\n</ul>"
  },
  {
    "id": "S6898",
    "key": "java:S6898",
    "name": "High frame rates should not be used",
    "type": "code-smell",
    "severity": "major",
    "tags": [
      "android",
      "sustainability"
    ],
    "why": "<p>Standard applications don't require a display refresh rate above 60Hz, hence it is advisable to avoid higher frequencies to avoid unnecessary\nenergy consumption.</p>\n<p>The rule flags an issue when <code>setFrameRate()</code> is invoked with a frameRate higher than 60Hz for <code>android.view.Surface</code> and\n<code>android.view.SurfaceControl.Transaction</code>.</p>\n<p>It's important to note that the scheduler considers several factors when determining the display refresh rate. Therefore, using\n<code>setFrameRate()</code> doesn't guarantee your app will achieve the requested frame rate.</p>\n<h3>What is the potential impact?</h3>\n<ul>\n  <li> <em>Usability</em>: the device may run out of battery faster than expected. </li>\n  <li> <em>Sustainability</em>: the extra battery usage has a negative impact on the environment. </li>\n</ul>",
    "howToFix": "<p>Use a frame rate of maximum 60Hz, unless you have a strong reason to used higher rates. Valid exceptions are <em>gaming apps</em>, especially those\nwith fast-paced action or high-quality graphics, or <em>AR/VR apps</em>.</p>\n\n<h4>Noncompliant code example</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\npublic class MainActivity extends AppCompatActivity {\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n\n        SurfaceView surfaceView = findViewById(R.id.my_surface_view);\n        Surface surface = surfaceView.getHolder().getSurface();\n\n        surface.setFrameRate(90.0f, Surface.FRAME_RATE_COMPATIBILITY_FIXED_SOURCE); // Noncompliant\n    }\n}\n</pre>\n<h4>Compliant solution</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\npublic class MainActivity extends AppCompatActivity {\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n\n        SurfaceView surfaceView = findViewById(R.id.my_surface_view);\n        Surface surface = surfaceView.getHolder().getSurface();\n\n        surface.setFrameRate(60.0f, Surface.FRAME_RATE_COMPATIBILITY_FIXED_SOURCE); // Compliant\n    }\n}\n</pre>",
    "moreInfo": "<h3>Documentation</h3>\n<ul>\n  <li> <a href=\"https://developer.android.com/media/optimize/performance/frame-rate\">Android for Developers: Frame Rate</a> </li>\n  <li> <a\n  href=\"https://developer.apple.com/library/archive/documentation/3DDrawing/Conceptual/MTLBestPracticesGuide/FrameRate.html#//apple_ref/doc/uid/TP40016642-CH23-SW1\">Developer Apple - Frame Rate</a> </li>\n</ul>",
    "status": "READY",
    "name_ko": "높은 프레임 레이트를 사용하면 안 됩니다",
    "why_ko": "<p>표준 애플리케이션은 60Hz 이상의 디스플레이 새로 고침 빈도를 필요로 하지 않으므로 불필요한 에너지 소비를 피하기 위해 더 높은 주파수를 피하는 것이 좋습니다.</p>\n<p>이 규칙은 <code>android.view.Surface</code> 및 <code>android.view.SurfaceControl.Transaction</code>에서 60Hz보다 높은 프레임 레이트로 <code>setFrameRate()</code>가 호출될 때 문제를 발생시킵니다.</p>\n<p>스케줄러가 디스플레이 새로 고침 빈도를 결정할 때 여러 요소를 고려한다는 점에 유의해야 합니다. 따라서 <code>setFrameRate()</code>를 사용한다고 해서 앱이 요청한 프레임 레이트를 달성한다고 보장할 수 없습니다.</p>\n<h3>잠재적 영향은 무엇인가요?</h3>\n<ul>\n  <li> <em>사용성</em>: 장치의 배터리가 예상보다 빨리 소진될 수 있습니다. </li>\n  <li> <em>지속 가능성</em>: 추가 배터리 사용은 환경에 부정적인 영향을 미칩니다. </li>\n</ul>",
    "howToFix_ko": "<p>더 높은 비율을 사용해야 할 강력한 이유가 없는 한 최대 60Hz의 프레임 레이트를 사용하세요. 유효한 예외는 빠른 액션이나 고품질 그래픽을 가진 <em>게임 앱</em> 또는 <em>AR/VR 앱</em>입니다.</p>\n\n<h4>규칙을 준수하지 않는 코드 예시</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\npublic class MainActivity extends AppCompatActivity {\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n\n        SurfaceView surfaceView = findViewById(R.id.my_surface_view);\n        Surface surface = surfaceView.getHolder().getSurface();\n\n        surface.setFrameRate(90.0f, Surface.FRAME_RATE_COMPATIBILITY_FIXED_SOURCE); // 규칙 위반\n    }\n}\n</pre>\n<h4>규칙을 준수하는 해결책</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\npublic class MainActivity extends AppCompatActivity {\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n\n        SurfaceView surfaceView = findViewById(R.id.my_surface_view);\n        Surface surface = surfaceView.getHolder().getSurface();\n\n        surface.setFrameRate(60.0f, Surface.FRAME_RATE_COMPATIBILITY_FIXED_SOURCE); // 규칙 준수\n    }\n}\n</pre>",
    "moreInfo_ko": "<h3>문서</h3>\n<ul>\n  <li> <a href=\"https://developer.android.com/media/optimize/performance/frame-rate\">Android 개발자: 프레임 레이트</a> </li>\n  <li> <a href=\"https://developer.apple.com/library/archive/documentation/3DDrawing/Conceptual/MTLBestPracticesGuide/FrameRate.html#//apple_ref/doc/uid/TP40016642-CH23-SW1\">Apple 개발자 - 프레임 레이트</a> </li>\n</ul>"
  },
  {
    "id": "S5867",
    "key": "java:S5867",
    "name": "Unicode-aware versions of character classes should be preferred",
    "type": "code-smell",
    "severity": "minor",
    "tags": [
      "regex"
    ],
    "why": "<p>When using POSIX classes like <code>\\p{Alpha}</code> without the <code>UNICODE_CHARACTER_CLASS</code> flag or when using hard-coded character\nclasses like <code>\"[a-zA-Z]\"</code>, letters outside of the ASCII range, such as umlauts, accented letters or letter from non-Latin languages, won't\nbe matched. This may cause code to incorrectly handle input containing such letters.</p>\n<p>To correctly handle non-ASCII input, it is recommended to use Unicode classes like <code>\\p{IsAlphabetic}</code>. When using POSIX classes, Unicode\nsupport should be enabled by either passing <code>Pattern.UNICODE_CHARACTER_CLASS</code> as a flag to <code>Pattern.compile</code> or by using\n<code>(?U)</code> inside the regex.</p>\n<h3>Noncompliant code example</h3>\n<pre>\nPattern.compile(\"[a-zA-Z]\");\nPattern.compile(\"\\\\p{Alpha}\");\n</pre>\n<h3>Compliant solution</h3>\n<pre>\nPattern.compile(\"\\\\p{IsAlphabetic}\"); // matches all letters from all languages\nPattern.compile(\"\\\\p{IsLatin}\"); // matches latin letters, including umlauts and other non-ASCII variations\nPattern.compile(\"\\\\p{Alpha}\", Pattern.UNICODE_CHARACTER_CLASS);\nPattern.compile(\"(?U)\\\\p{Alpha}\");\n</pre>",
    "howToFix": "",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "Unicode 인식 문자 클래스 버전을 사용해야 합니다",
    "why_ko": "<p><code>UNICODE_CHARACTER_CLASS</code> 플래그 없이 <code>\\p{Alpha}</code>와 같은 POSIX 클래스를 사용하거나 <code>\"[a-zA-Z]\"</code>와 같은 하드코딩된 문자 클래스를 사용할 때, 움라우트, 악센트가 있는 문자 또는 비라틴 언어의 문자와 같이 ASCII 범위 밖의 문자는 일치하지 않습니다. 이로 인해 코드가 이러한 문자를 포함하는 입력을 잘못 처리할 수 있습니다.</p>\n<p>비ASCII 입력을 올바르게 처리하려면 <code>\\p{IsAlphabetic}</code>과 같은 Unicode 클래스를 사용하는 것이 좋습니다. POSIX 클래스를 사용할 때는 <code>Pattern.compile</code>에 <code>Pattern.UNICODE_CHARACTER_CLASS</code>를 플래그로 전달하거나 정규식 내에서 <code>(?U)</code>를 사용하여 Unicode 지원을 활성화해야 합니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\nPattern.compile(\"[a-zA-Z]\");\nPattern.compile(\"\\\\p{Alpha}\");\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre>\nPattern.compile(\"\\\\p{IsAlphabetic}\"); // 모든 언어의 모든 문자와 일치\nPattern.compile(\"\\\\p{IsLatin}\"); // 움라우트 및 기타 비ASCII 변형을 포함한 라틴 문자와 일치\nPattern.compile(\"\\\\p{Alpha}\", Pattern.UNICODE_CHARACTER_CLASS);\nPattern.compile(\"(?U)\\\\p{Alpha}\");\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": ""
  },
  {
    "id": "S5164",
    "key": "java:S5164",
    "name": "\"ThreadLocal\" variables should be cleaned up when no longer used",
    "type": "bug",
    "severity": "major",
    "tags": [
      "leak",
      "performance"
    ],
    "why": "<p><code>ThreadLocal</code> variables are supposed to be garbage collected once the holding thread is no longer alive. Memory leaks can occur when\nholding threads are re-used which is the case on application servers using pool of threads.</p>\n<p>To avoid such problems, it is recommended to always clean up <code>ThreadLocal</code> variables using the <code>remove()</code> method to remove\nthe current thread's value for the <code>ThreadLocal</code> variable.</p>\n<p>In addition, calling <code>set(null)</code> to remove the value might keep the reference to <code>this</code> pointer in the map, which can cause\nmemory leak in some scenarios. Using <code>remove</code> is safer to avoid this issue.</p>\n<h3>Noncompliant code example</h3>\n<pre>\npublic class ThreadLocalUserSession implements UserSession {\n\n  private static final ThreadLocal&lt;UserSession&gt; DELEGATE = new ThreadLocal&lt;&gt;();\n\n  public UserSession get() {\n    UserSession session = DELEGATE.get();\n    if (session != null) {\n      return session;\n    }\n    throw new UnauthorizedException(\"User is not authenticated\");\n  }\n\n  public void set(UserSession session) {\n    DELEGATE.set(session);\n  }\n\n   public void incorrectCleanup() {\n     DELEGATE.set(null); // Noncompliant\n   }\n\n  // some other methods without a call to DELEGATE.remove()\n}\n</pre>\n<h3>Compliant solution</h3>\n<pre>\npublic class ThreadLocalUserSession implements UserSession {\n\n  private static final ThreadLocal&lt;UserSession&gt; DELEGATE = new ThreadLocal&lt;&gt;();\n\n  public UserSession get() {\n    UserSession session = DELEGATE.get();\n    if (session != null) {\n      return session;\n    }\n    throw new UnauthorizedException(\"User is not authenticated\");\n  }\n\n  public void set(UserSession session) {\n    DELEGATE.set(session);\n  }\n\n  public void unload() {\n    DELEGATE.remove(); // Compliant\n  }\n\n  // ...\n}\n</pre>\n<h3>Exceptions</h3>\n<p>Rule will not detect non-private <code>ThreadLocal</code> variables, because <code>remove()</code> can be called from another class.</p>",
    "howToFix": "",
    "moreInfo": "<ul>\n  <li> <a href=\"https://www.baeldung.com/java-memory-leaks\">Understanding Memory Leaks in Java</a> </li>\n</ul>",
    "status": "READY",
    "name_ko": "\"ThreadLocal\" 변수는 더 이상 사용되지 않을 때 정리해야 합니다",
    "why_ko": "<p><code>ThreadLocal</code> 변수는 보유 스레드가 더 이상 활성화되지 않으면 가비지 컬렉션되어야 합니다. 스레드 풀을 사용하는 애플리케이션 서버에서와 같이 보유 스레드가 재사용될 때 메모리 누수가 발생할 수 있습니다.</p>\n<p>이러한 문제를 피하려면 <code>remove()</code> 메서드를 사용하여 <code>ThreadLocal</code> 변수의 현재 스레드 값을 제거하고 항상 <code>ThreadLocal</code> 변수를 정리하는 것이 좋습니다.</p>\n<p>또한 값을 제거하기 위해 <code>set(null)</code>을 호출하면 맵에 <code>this</code> 포인터에 대한 참조가 유지될 수 있으며, 이는 일부 시나리오에서 메모리 누수를 일으킬 수 있습니다. 이 문제를 피하려면 <code>remove</code>를 사용하는 것이 더 안전합니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\npublic class ThreadLocalUserSession implements UserSession {\n\n  private static final ThreadLocal&lt;UserSession&gt; DELEGATE = new ThreadLocal&lt;&gt;();\n\n  public UserSession get() {\n    UserSession session = DELEGATE.get();\n    if (session != null) {\n      return session;\n    }\n    throw new UnauthorizedException(\"User is not authenticated\");\n  }\n\n  public void set(UserSession session) {\n    DELEGATE.set(session);\n  }\n\n   public void incorrectCleanup() {\n     DELEGATE.set(null); // 규칙 위반\n   }\n\n  // DELEGATE.remove() 호출이 없는 다른 메서드들\n}\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre>\npublic class ThreadLocalUserSession implements UserSession {\n\n  private static final ThreadLocal&lt;UserSession&gt; DELEGATE = new ThreadLocal&lt;&gt;();\n\n  public UserSession get() {\n    UserSession session = DELEGATE.get();\n    if (session != null) {\n      return session;\n    }\n    throw new UnauthorizedException(\"User is not authenticated\");\n  }\n\n  public void set(UserSession session) {\n    DELEGATE.set(session);\n  }\n\n  public void unload() {\n    DELEGATE.remove(); // 규칙 준수\n  }\n\n  // ...\n}\n</pre>\n<h3>예외</h3>\n<p>이 규칙은 비공개가 아닌 <code>ThreadLocal</code> 변수를 감지하지 않습니다. <code>remove()</code>가 다른 클래스에서 호출될 수 있기 때문입니다.</p>",
    "howToFix_ko": "",
    "moreInfo_ko": "<ul>\n  <li> <a href=\"https://www.baeldung.com/java-memory-leaks\">Java에서 메모리 누수 이해하기</a> </li>\n</ul>"
  },
  {
    "id": "S121",
    "key": "java:S121",
    "name": "Control structures should use curly braces",
    "type": "code-smell",
    "severity": "critical",
    "tags": [
      "cert",
      "pitfall"
    ],
    "why": "<p>While not technically incorrect, the omission of curly braces can be misleading and may lead to the introduction of errors during maintenance.</p>\n<p>In the following example, the two calls seem to be attached to the <code>if</code> statement, but only the first one is, and\n<code>checkSomething</code> will always be executed:</p>\n<pre>\nif (condition)  // Noncompliant\n  executeSomething();\n  checkSomething();\n</pre>\n<p>Adding curly braces improves the code readability and its robustness:</p>\n<pre>\nif (condition) {\n  executeSomething();\n  checkSomething();\n}\n</pre>\n<p>The rule raises an issue when a control structure has no curly braces.</p>\n<h3>Exceptions</h3>\n<p>The rule doesn't raise an issue when the body of an <code>if</code> statement is a single <code>return</code>, <code>break</code>, or\n<code>continue</code> and is on the same line.</p>",
    "howToFix": "",
    "moreInfo": "<ul>\n  <li> <a href=\"https://wiki.sei.cmu.edu/confluence/x/MzZGBQ\">CERT, EXP52-J.</a> - Use braces for the body of an if, for, or while statement </li>\n</ul>",
    "status": "READY",
    "name_ko": "제어 구조는 중괄호를 사용해야 합니다",
    "why_ko": "<p>기술적으로 잘못된 것은 아니지만, 중괄호를 생략하면 오해를 불러일으킬 수 있고 유지 관리 중에 오류가 발생할 수 있습니다.</p>\n<p>다음 예시에서 두 호출은 <code>if</code> 문에 연결된 것처럼 보이지만, 실제로는 첫 번째 호출만 연결되어 있고 <code>checkSomething</code>은 항상 실행됩니다:</p>\n<pre>\nif (condition)  // 규칙 위반\n  executeSomething();\n  checkSomething();\n</pre>\n<p>중괄호를 추가하면 코드 가독성과 견고성이 향상됩니다:</p>\n<pre>\nif (condition) {\n  executeSomething();\n  checkSomething();\n}\n</pre>\n<p>규칙은 제어 구조에 중괄호가 없을 때 이슈를 발생시킵니다.</p>\n<h3>예외</h3>\n<p><code>if</code> 문의 본문이 단일 <code>return</code>, <code>break</code> 또는 <code>continue</code>이고 같은 줄에 있는 경우 이 규칙은 이슈를 발생시키지 않습니다.</p>",
    "howToFix_ko": "",
    "moreInfo_ko": "<ul>\n  <li> <a href=\"https://wiki.sei.cmu.edu/confluence/x/MzZGBQ\">CERT, EXP52-J.</a> - if, for 또는 while 문의 본문에 중괄호를 사용하세요 </li>\n</ul>"
  },
  {
    "id": "S1598",
    "key": "java:S1598",
    "name": "Package declaration should match source file directory",
    "type": "code-smell",
    "severity": "critical",
    "tags": [
      "pitfall"
    ],
    "why": "<p>The purpose of Java packages is to give structure to your project. A structure helps to mentally break down a project into smaller parts,\nsimplifying readers' understanding of how components are connected and how they interact.</p>\n<p>By convention, the source files' directory structure should replicate the project's package structure. This is for the following reasons:</p>\n<ol>\n  <li> The mapping between the package name and the location of the source file of a class is straightforward. That is, the path to the source file is\n  easier to find for a given fully qualified class name. </li>\n  <li> If two different structures are applied to the same project - one to the packages but another to the source file directories - this confuses\n  developers while not providing any benefit. </li>\n  <li> The directory structure of the class files generated by the compiler will match the package structure, no matter the source file's directory.\n  It would not make sense to have one directory structure for the generated class files but a different one for the associated source files. </li>\n</ol>\n<p>Similarly, a source directory should not have the character <code>.</code> in its name, as this would make it impossible to match the directory to\nthe package structure.</p>",
    "howToFix": "<p>Either move the source file so that the relative file path within the source directory matches the package name, or change the package name so that\nit matches the relative file path.</p>\n\n<h4>Noncompliant code example</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\n// file: src/main/foo/Fubar.java\npackage com.foo.bar;\n\nclass Fubar {\n}\n</pre>\n<h4>Compliant solution</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\n// file: src/main/com/foo/bar/Fubar.java\npackage com.foo.bar;\n\nclass Fubar {\n}\n</pre>\n<pre>\n// file: src/main/foo/Fubar.java\npackage foo;\n\nclass Fubar {\n}\n</pre>",
    "moreInfo": "<h3>Articles &amp; blog posts</h3>\n<ul>\n  <li> <a href=\"https://www.baeldung.com/java-declared-expected-package-error\">Baeldung - Fixing the \"Declared package does not match the expected\n  package\" Error</a> </li>\n  <li> <a href=\"https://www.baeldung.com/java-file-vs-file-path-separator\">Stackoverflow - Why do java source files require package declarations?</a>\n  </li>\n  <li> <a\n  href=\"https://www.tutorialspoint.com/what-are-the-best-practices-to-keep-in-mind-while-using-packages-in-java#:~:text=Naming%20conventions%20and%20best%20practices%20for%20packages\">tutorialspoint - What are the best practices to keep in mind while using packages in Java?</a> </li>\n</ul>",
    "status": "READY",
    "name_ko": "패키지 선언은 소스 파일 디렉토리와 일치해야 합니다",
    "why_ko": "<p>Java 패키지의 목적은 프로젝트에 구조를 제공하는 것입니다. 구조는 프로젝트를 더 작은 부분으로 정신적으로 분해하는 데 도움이 되어 구성 요소가 어떻게 연결되어 있고 어떻게 상호 작용하는지에 대한 독자의 이해를 단순화합니다.</p>\n<p>관례적으로 소스 파일의 디렉토리 구조는 프로젝트의 패키지 구조를 복제해야 합니다. 이유는 다음과 같습니다:</p>\n<ol>\n  <li> 패키지 이름과 클래스의 소스 파일 위치 간의 매핑이 간단합니다. 즉, 주어진 정규화된 클래스 이름에 대한 소스 파일 경로를 찾기 쉽습니다. </li>\n  <li> 동일한 프로젝트에 두 가지 다른 구조가 적용되면 - 하나는 패키지에, 다른 하나는 소스 파일 디렉토리에 - 이는 어떤 이점도 제공하지 않으면서 개발자를 혼란스럽게 합니다. </li>\n  <li> 컴파일러가 생성하는 클래스 파일의 디렉토리 구조는 소스 파일의 디렉토리와 관계없이 패키지 구조와 일치합니다. 생성된 클래스 파일에 대한 디렉토리 구조와 관련 소스 파일에 대한 다른 디렉토리 구조를 갖는 것은 의미가 없습니다. </li>\n</ol>\n<p>마찬가지로 소스 디렉토리 이름에 <code>.</code> 문자가 있으면 안 됩니다. 이렇게 하면 디렉토리를 패키지 구조와 일치시킬 수 없게 됩니다.</p>",
    "howToFix_ko": "<p>소스 디렉토리 내의 상대 파일 경로가 패키지 이름과 일치하도록 소스 파일을 이동하거나, 패키지 이름을 상대 파일 경로와 일치하도록 변경하세요.</p>\n\n<h4>규칙을 준수하지 않는 코드 예시</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\n// file: src/main/foo/Fubar.java\npackage com.foo.bar;\n\nclass Fubar {\n}\n</pre>\n<h4>규칙을 준수하는 해결책</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\n// file: src/main/com/foo/bar/Fubar.java\npackage com.foo.bar;\n\nclass Fubar {\n}\n</pre>\n<pre>\n// file: src/main/foo/Fubar.java\npackage foo;\n\nclass Fubar {\n}\n</pre>",
    "moreInfo_ko": "<h3>기사 및 블로그 포스트</h3>\n<ul>\n  <li> <a href=\"https://www.baeldung.com/java-declared-expected-package-error\">Baeldung - \"선언된 패키지가 예상 패키지와 일치하지 않음\" 오류 수정하기</a> </li>\n  <li> <a href=\"https: //www.baeldung.com/java-file-vs-file-path-separator\">Stackoverflow - Java 소스 파일에 패키지 선언이 필요한 이유는?</a> </li>\n  <li> <a href=\"https://www.tutorialspoint.com/what-are-the-best-practices-to-keep-in-mind-while-using-packages-in-java#:~:text=Naming%20conventions%20and%20best%20practices%20for%20packages\">tutorialspoint - Java에서 패키지를 사용할 때 염두에 두어야 할 모범 사례는?</a> </li>\n</ul>"
  },
  {
    "id": "S2160",
    "key": "java:S2160",
    "name": "Subclasses that add fields to classes that override \"equals\" should also override \"equals\"",
    "type": "code-smell",
    "severity": "minor",
    "tags": [
      "suspicious"
    ],
    "why": "<p>When a class overrides <code>Object.equals</code>, this indicates that the class not just considers object identity as equal (the default\nimplementation of <code>Object.equals</code>) but implements another logic for what is considered equal in the context of this class. Usually (but not\nnecessarily), the semantics of <code>equals</code> in this case is that two objects are equal when their state is equal field by field.</p>\n<p>Because of this, adding new fields to a subclass of a class that overrides <code>Object.equals</code> but not updating the implementation of\n<code>equals</code> in the subclass is most likely an error.</p>",
    "howToFix": "<p>Consider the following example:</p>\n<pre>\nclass Foo {\n\n  final int a;\n\n  @Override\n  public boolean equals(Object other) {\n    if (other == null) return false;\n    if (getClass() != other.getClass()) return false;\n    return a == ((Foo) other).a;\n  }\n}\n</pre>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\nclass Bar extends Foo { // Noncompliant, `equals` ignores the value of `b`\n  final int b;\n}\n</pre>\n<p>Override the <code>equals</code> method in the subclass to incorporate the new fields into the comparison:</p>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\nclass Bar extends Foo { // Compliant, `equals` now also considers `b`\n\n  final int b;\n\n  @Override\n  public boolean equals(Object other) {\n    if (!super.equals(other)) return false;\n    return b == ((Bar) other).b;\n  }\n}\n</pre>\n<p>In case the new fields should not be part of the comparison because they are, for example, auxiliary variables not contributing to the object value\n(), still override the method to make the point clear that this was not just forgotten:</p>\n<pre>\nclass Bar extends Foo { // Compliant, we do explicitly not want to take `b` into account\n\n  final int b;\n\n  @Override\n  public boolean equals(Object other) {\n    return super.equals(other);\n  }\n}\n</pre>",
    "moreInfo": "<h3>Documentation</h3>\n<ul>\n  <li> <a href=\"https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html#equals-java.lang.Object-\">Object.equals - Java SE 8 API\n  Specification</a> </li>\n</ul>",
    "status": "READY",
    "name_ko": "\"equals\"를 오버라이드한 클래스에 필드를 추가하는 하위 클래스도 \"equals\"를 오버라이드해야 합니다",
    "why_ko": "<p>클래스가 <code>Object.equals</code>를 오버라이드하면, 이는 해당 클래스가 단순히 객체 동일성만을 동등으로 간주하지 않고(<code>Object.equals</code>의 기본 구현), 해당 클래스의 컨텍스트에서 동등으로 간주되는 것에 대한 다른 로직을 구현한다는 것을 나타냅니다. 일반적으로(반드시 그런 것은 아니지만), 이 경우 <code>equals</code>의 의미는 두 객체의 상태가 필드별로 동일할 때 두 객체가 동등하다는 것입니다.</p>\n<p>이 때문에 <code>Object.equals</code>를 오버라이드한 클래스의 하위 클래스에 새 필드를 추가하면서 하위 클래스의 <code>equals</code> 구현을 업데이트하지 않는 것은 대부분 오류입니다.</p>",
    "howToFix_ko": "<p>다음 예제를 고려하세요:</p>\n<pre>\nclass Foo {\n\n  final int a;\n\n  @Override\n  public boolean equals(Object other) {\n    if (other == null) return false;\n    if (getClass() != other.getClass()) return false;\n    return a == ((Foo) other).a;\n  }\n}\n</pre>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\nclass Bar extends Foo { // 규칙 위반, `equals`가 `b`의 값을 무시함\n  final int b;\n}\n</pre>\n<p>하위 클래스에서 <code>equals</code> 메서드를 오버라이드하여 새 필드를 비교에 포함시키세요:</p>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\nclass Bar extends Foo { // 규칙 준수, `equals`가 이제 `b`도 고려함\n\n  final int b;\n\n  @Override\n  public boolean equals(Object other) {\n    if (!super.equals(other)) return false;\n    return b == ((Bar) other).b;\n  }\n}\n</pre>\n<p>새 필드가 비교에 포함되지 않아야 하는 경우(예: 객체 값에 기여하지 않는 보조 변수인 경우), 이것이 단순히 잊어버린 것이 아님을 명확히 하기 위해 메서드를 오버라이드하세요:</p>\n<pre>\nclass Bar extends Foo { // 규칙 준수, `b`를 고려하지 않음을 명시적으로 표현\n\n  final int b;\n\n  @Override\n  public boolean equals(Object other) {\n    return super.equals(other);\n  }\n}\n</pre>",
    "moreInfo_ko": "<h3>문서</h3>\n<ul>\n  <li> <a href=\"https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html#equals-java.lang.Object-\">Object.equals - Java SE 8 API Specification</a> </li>\n</ul>"
  },
  {
    "id": "S1170",
    "key": "java:S1170",
    "name": "Public constants and fields initialized at declaration should be \"static final\" rather than merely \"final\"",
    "type": "code-smell",
    "severity": "minor",
    "tags": [
      "convention"
    ],
    "why": "<p>Making a <code>public</code> constant just <code>final</code> as opposed to <code>static final</code> leads to duplicating its value for every\ninstance of the class, uselessly increasing the amount of memory required to execute the application.</p>\n<p>Further, when a non-<code>public</code>, <code>final</code> field isn't also <code>static</code>, it implies that different instances can have\ndifferent values. However, initializing a non-<code>static final</code> field in its declaration forces every instance to have the same value. So such\nfields should either be made <code>static</code> or initialized in the constructor.</p>\n<h3>Noncompliant code example</h3>\n<pre>\npublic class Myclass {\n  public final int THRESHOLD = 3;\n}\n</pre>\n<h3>Compliant solution</h3>\n<pre>\npublic class Myclass {\n  public static final int THRESHOLD = 3;    // Compliant\n}\n</pre>\n<h3>Exceptions</h3>\n<p>No issues are reported on final fields of inner classes whose type is not a primitive or a String. Indeed according to the Java specification:</p>\n<blockquote>\n  <p>An inner class is a nested class that is not explicitly or implicitly declared static. Inner classes may not declare static initializers (§8.7)\n  or member interfaces. Inner classes may not declare static members, unless they are compile-time constant fields (§15.28).</p>\n</blockquote>",
    "howToFix": "",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "선언 시 초기화되는 public 상수와 필드는 단순히 \"final\"이 아닌 \"static final\"이어야 합니다",
    "why_ko": "<p><code>public</code> 상수를 <code>static final</code> 대신 단순히 <code>final</code>로 만들면 클래스의 모든 인스턴스에 대해 값이 복제되어 애플리케이션 실행에 필요한 메모리 양이 불필요하게 증가합니다.</p>\n<p>또한 <code>public</code>이 아닌 <code>final</code> 필드가 <code>static</code>이 아니면 다른 인스턴스가 다른 값을 가질 수 있음을 암시합니다. 그러나 <code>static</code>이 아닌 <code>final</code> 필드를 선언 시 초기화하면 모든 인스턴스가 같은 값을 갖도록 강제합니다. 따라서 이러한 필드는 <code>static</code>으로 만들거나 생성자에서 초기화해야 합니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\npublic class Myclass {\n  public final int THRESHOLD = 3;\n}\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre>\npublic class Myclass {\n  public static final int THRESHOLD = 3;    // 규칙 준수\n}\n</pre>\n<h3>예외 사항</h3>\n<p>타입이 기본 타입이나 String이 아닌 내부 클래스의 final 필드에 대해서는 이슈가 보고되지 않습니다. Java 명세에 따르면:</p>\n<blockquote>\n  <p>내부 클래스는 명시적으로 또는 암시적으로 static으로 선언되지 않은 중첩 클래스입니다. 내부 클래스는 static 초기화자(§8.7)나 멤버 인터페이스를 선언할 수 없습니다. 내부 클래스는 컴파일 타임 상수 필드(§15.28)가 아닌 한 static 멤버를 선언할 수 없습니다.</p>\n</blockquote>",
    "howToFix_ko": "",
    "moreInfo_ko": ""
  },
  {
    "id": "S3008",
    "key": "java:S3008",
    "name": "Static non-final field names should comply with a naming convention",
    "type": "code-smell",
    "severity": "minor",
    "tags": [
      "convention"
    ],
    "why": "<p>The Java Language Specification defines a set of rules called naming conventions that apply to Java programs. These conventions provide\nrecommendations for naming packages, classes, methods, and variables.</p>\n<p>By following shared naming conventions, teams can collaborate more efficiently.</p>\n<p>This rule checks that static non-final field names match a provided regular expression.</p>\n<h3>Noncompliant code example</h3>\n<p>The default regular expression applied by the rule is <code>^[a-z][a-zA-Z0-9]*$</code>:</p>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\npublic class MyClass {\n   private static String foo_bar; // Noncompliant\n}\n</pre>\n<h3>Compliant solution</h3>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\npublic class MyClass {\n   private static String fooBar;\n}\n</pre>",
    "howToFix": "",
    "moreInfo": "<ul>\n  <li> <a href=\"https://www.oreilly.com/library/view/java-8-pocket/9781491901083/ch01.html\">O'Reilly - Java 8 in pocket - Naming Conventions</a> </li>\n  <li> <a href=\"https://www.educative.io/answers/what-are-the-naming-conventions-in-java\">Educative - Naming conventions in Java</a> </li>\n</ul>",
    "status": "READY",
    "name_ko": "static non-final 필드 이름은 명명 규칙을 준수해야 합니다",
    "why_ko": "<p>Java 언어 명세서는 Java 프로그램에 적용되는 명명 규칙이라는 규칙 집합을 정의합니다. 이 규칙은 패키지, 클래스, 메서드 및 변수의 이름 지정에 대한 권장 사항을 제공합니다.</p>\n<p>공유된 명명 규칙을 따르면 팀이 더 효율적으로 협업할 수 있습니다.</p>\n<p>이 규칙은 static non-final 필드 이름이 제공된 정규 표현식과 일치하는지 확인합니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<p>규칙에 적용되는 기본 정규 표현식은 <code>^[a-z][a-zA-Z0-9]*$</code>입니다:</p>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\npublic class MyClass {\n   private static String foo_bar; // 규칙 위반\n}\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\npublic class MyClass {\n   private static String fooBar;\n}\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": "<ul>\n  <li> <a href=\"https://www.oreilly.com/library/view/java-8-pocket/9781491901083/ch01.html\">O'Reilly - Java 8 in pocket - Naming Conventions</a> </li>\n  <li> <a href=\"https://www.educative.io/answers/what-are-the-naming-conventions-in-java\">Educative - Naming conventions in Java</a> </li>\n</ul>"
  },
  {
    "id": "S2176",
    "key": "java:S2176",
    "name": "Class names should not shadow interfaces or superclasses",
    "type": "code-smell",
    "severity": "critical",
    "tags": [
      "pitfall"
    ],
    "why": "<p>Two classes can have the same simple name if they are in two different packages.</p>\n<pre>\npackage org.foo.domain;\n\npublic class User {\n  // ..\n}\n</pre>\n<pre>\npackage org.foo.presentation;\n\npublic class User {\n  // ..\n}\n</pre>\n<p>However, this becomes an issue when a class has the same name as the superclass it extends or the interfaces it implements, also known as class\nname shadowing. It is problematic because it can be unclear which class is being referred to in the code, leading to ambiguity and potential bugs.</p>\n<p>Therefore, it is recommended to use unique and descriptive class names that do not conflict with the names of the superclass or interfaces.</p>\n<p>This rule raises an issue when a class name shadows its superclass or interface names.</p>",
    "howToFix": "<p>Rename the class using a more descriptive name.</p>\n\n<h4>Noncompliant code example</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\npackage org.foo.presentation;\n\npublic class User implements org.foo.domain.User { // Noncompliant\n  // ...\n}\n</pre>\n<h4>Compliant solution</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\npackage org.foo.presentation;\n\nimport org.foo.domain.User;\n\npublic class UserView implements User { // Compliant\n  // ...\n}\n</pre>",
    "moreInfo": "<h3>Documentation</h3>\n<ul>\n  <li> <a href=\"https://docs.oracle.com/javase/specs/jls/se17/html/jls-6.html#jls-6.4.1\">Java SE Specifications &gt; Java Language Specification &gt;\n  6.4.1. Shadowing</a> </li>\n</ul>",
    "status": "READY",
    "name_ko": "클래스 이름은 인터페이스나 상위 클래스를 가리면 안 됩니다",
    "why_ko": "<p>두 클래스가 서로 다른 패키지에 있으면 같은 단순 이름을 가질 수 있습니다.</p>\n<pre>\npackage org.foo.domain;\n\npublic class User {\n  // ..\n}\n</pre>\n<pre>\npackage org.foo.presentation;\n\npublic class User {\n  // ..\n}\n</pre>\n<p>그러나 클래스가 확장하는 상위 클래스 또는 구현하는 인터페이스와 같은 이름을 가질 때 문제가 됩니다. 이를 클래스 이름 섀도잉이라고도 합니다. 코드에서 어떤 클래스를 참조하는지 불분명할 수 있어 모호함과 잠재적인 버그를 초래하기 때문에 문제가 됩니다.</p>\n<p>따라서 상위 클래스나 인터페이스의 이름과 충돌하지 않는 고유하고 설명적인 클래스 이름을 사용하는 것이 권장됩니다.</p>\n<p>이 규칙은 클래스 이름이 상위 클래스나 인터페이스 이름을 가릴 때 문제를 제기합니다.</p>",
    "howToFix_ko": "<p>더 설명적인 이름으로 클래스 이름을 변경하세요.</p>\n\n<h4>규칙을 준수하지 않는 코드 예시</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\npackage org.foo.presentation;\n\npublic class User implements org.foo.domain.User { // 규칙 위반\n  // ...\n}\n</pre>\n<h4>규칙을 준수하는 해결책</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\npackage org.foo.presentation;\n\nimport org.foo.domain.User;\n\npublic class UserView implements User { // 규칙 준수\n  // ...\n}\n</pre>",
    "moreInfo_ko": "<h3>문서</h3>\n<ul>\n  <li> <a href=\"https://docs.oracle.com/javase/specs/jls/se17/html/jls-6.html#jls-6.4.1\">Java SE Specifications &gt; Java Language Specification &gt; 6.4.1. Shadowing</a> </li>\n</ul>"
  },
  {
    "id": "S6070",
    "key": "java:S6070",
    "name": "The regex escape sequence \\cX should only be used with characters in the @-_ range",
    "type": "bug",
    "severity": "major",
    "tags": [
      "regex"
    ],
    "why": "<p>In regular expressions the escape sequence <code>\\cX</code>, where the X stands for any character that's either <code>@</code>, any capital ASCII\nletter, <code>[</code>, <code>\\</code>, <code>]</code>, <code>^</code> or <code>_</code>, represents the control character that \"corresponds\" to the\ncharacter following <code>\\c</code>, meaning the control character that comes 64 bytes before the given character in the ASCII encoding.</p>\n<p>In some other regex engines (for example in that of Perl) this escape sequence is case insensitive and <code>\\cd</code> produces the same control\ncharacter as <code>\\cD</code>. Further using <code>\\c</code> with a character that's neither <code>@</code>, any ASCII letter, <code>[</code>,\n<code>\\</code>, <code>]</code>, <code>^</code> nor <code>_</code>, will produce a warning or error in those engines. Neither of these things is true\nin Java, where the value of the character is always XORed with 64 without checking that this operation makes sense. Since this won't lead to a\nsensible result for characters that are outside of the <code>@</code> to <code>_</code> range, using <code>\\c</code> with such characters is almost\ncertainly a mistake.</p>\n<h3>Noncompliant code example</h3>\n<pre>\nPattern.compile(\"\\\\ca\"); // Noncompliant, 'a' is not an upper case letter\nPattern.compile(\"\\\\c!\"); // Noncompliant, '!' is outside of the '@'-'_' range\n</pre>\n<h3>Compliant solution</h3>\n<pre>\nPattern.compile(\"\\\\cA\"); // Compliant, this will match the \"start of heading\" control character\nPattern.compile(\"\\\\c^\"); // Compliant, this will match the \"record separator\" control character\n</pre>",
    "howToFix": "",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "정규 표현식 이스케이프 시퀀스 \\cX는 @-_ 범위의 문자에만 사용해야 합니다","why_ko": "<p>정규 표현식에서 이스케이프 시퀀스 <code>\\cX</code>(X는 <code>@</code>, 대문자 ASCII 문자, <code>[</code>, <code>\\</code>, <code>]</code>, <code>^</code> 또는 <code>_</code>)는 <code>\\c</code> 뒤에 오는 문자에 \"해당하는\" 제어 문자를 나타냅니다. 즉, ASCII 인코딩에서 주어진 문자보다 64바이트 앞에 오는 제어 문자입니다.</p>\n<p>다른 정규식 엔진(예: Perl)에서는 이 이스케이프 시퀀스가 대소문자를 구분하지 않아 <code>\\cd</code>가 <code>\\cD</code>와 동일한 제어 문자를 생성합니다. 또한 <code>@</code>, ASCII 문자, <code>[</code>, <code>\\</code>, <code>]</code>, <code>^</code>, <code>_</code>가 아닌 문자와 함께 <code>\\c</code>를 사용하면 해당 엔진에서 경고나 오류가 발생합니다. Java에서는 이러한 것들이 해당되지 않으며, 문자 값은 항상 64와 XOR 연산되고 이 연산이 의미 있는지 확인하지 않습니다. <code>@</code>에서 <code>_</code> 범위 밖의 문자에 대해서는 의미 있는 결과를 생성하지 않으므로, 그러한 문자와 함께 <code>\\c</code>를 사용하는 것은 거의 확실히 실수입니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\nPattern.compile(\"\\\\ca\"); // 규칙 위반, 'a'는 대문자가 아님\nPattern.compile(\"\\\\c!\"); // 규칙 위반, '!'는 '@'-'_' 범위 밖임\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre>\nPattern.compile(\"\\\\cA\"); // 규칙 준수, \"start of heading\" 제어 문자와 일치\nPattern.compile(\"\\\\c^\"); // 규칙 준수, \"record separator\" 제어 문자와 일치\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": ""
  },
  {
    "id": "S5826",
    "key": "java:S5826",
    "name": "Methods setUp() and tearDown() should be correctly annotated starting with JUnit4",
    "type": "code-smell",
    "severity": "critical",
    "tags": [
      "junit",
      "tests"
    ],
    "why": "<p>The <code>setUp()</code> and <code>tearDown()</code> methods (initially introduced with JUnit3 to execute a block of code before and after each\ntest) need to be correctly annotated with the equivalent annotation in order to preserve the same behavior when migrating from JUnit3 to JUnit4 or\nJUnit5.</p>\n<p>This rule consequently raise issues on <code>setUp()</code> and <code>tearDown()</code> methods which are not annotated in test classes.</p>\n<h3>Noncompliant code example</h3>\n<ul>\n  <li> JUnit4: </li>\n</ul>\n<pre>\npublic void setUp() { ... } // Noncompliant; should be annotated with @Before\npublic void tearDown() { ... }  // Noncompliant; should be annotated with @After\n</pre>\n<ul>\n  <li> JUnit5: </li>\n</ul>\n<pre>\npublic void setUp() { ... } // Noncompliant; should be annotated with @BeforeEach\npublic void tearDown() { ... }  // Noncompliant; should be annotated with @AfterEach\n</pre>\n<h3>Compliant solution</h3>\n<ul>\n  <li> JUnit4: </li>\n</ul>\n<pre>\n@Before\npublic void setUp() { ... }\n\n@After\npublic void tearDown() { ... }\n</pre>\n<ul>\n  <li> JUnit5: </li>\n</ul>\n<pre>\n@BeforeEach\nvoid setUp() { ... }\n\n@AfterEach\nvoid tearDown() { ... }\n</pre>",
    "howToFix": "",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "JUnit4부터 setUp()과 tearDown() 메서드에 올바른 어노테이션을 달아야 합니다",
    "why_ko": "<p><code>setUp()</code> 및 <code>tearDown()</code> 메서드(각 테스트 전후에 코드 블록을 실행하기 위해 JUnit3에서 처음 도입됨)는 JUnit3에서 JUnit4 또는 JUnit5로 마이그레이션할 때 동일한 동작을 유지하려면 해당 어노테이션으로 올바르게 주석을 달아야 합니다.</p>\n<p>따라서 이 규칙은 테스트 클래스에서 어노테이션이 없는 <code>setUp()</code> 및 <code>tearDown()</code> 메서드에 대해 문제를 제기합니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<ul>\n  <li> JUnit4: </li>\n</ul>\n<pre>\npublic void setUp() { ... } // 규칙 위반; @Before로 어노테이션해야 함\npublic void tearDown() { ... }  // 규칙 위반; @After로 어노테이션해야 함\n</pre>\n<ul>\n  <li> JUnit5: </li>\n</ul>\n<pre>\npublic void setUp() { ... } // 규칙 위반; @BeforeEach로 어노테이션해야 함\npublic void tearDown() { ... }  // 규칙 위반; @AfterEach로 어노테이션해야 함\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<ul>\n  <li> JUnit4: </li>\n</ul>\n<pre>\n@Before\npublic void setUp() { ... }\n\n@After\npublic void tearDown() { ... }\n</pre>\n<ul>\n  <li> JUnit5: </li>\n</ul>\n<pre>\n@BeforeEach\nvoid setUp() { ... }\n\n@AfterEach\nvoid tearDown() { ... }\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": ""
  },
  {
    "id": "S1166",
    "key": "java:S1166",
    "name": "Exception handlers should preserve the original exceptions",
    "type": "code-smell",
    "severity": "major",
    "tags": [
      "cwe",
      "error-handling",
      "cert",
      "suspicious"
    ],
    "why": "<p>When handling a caught exception, the original exception's message and stack trace should be logged or passed forward.</p>\n<h3>Noncompliant code example</h3>\n<pre>\ntry {\n  /* ... */\n} catch (Exception e) {   // Noncompliant - exception is lost\n  LOGGER.info(\"context\");\n}\n\ntry {\n  /* ... */\n} catch (Exception e) {  // Noncompliant - exception is lost (only message is preserved)\n  LOGGER.info(e.getMessage());\n}\n\ntry {\n  /* ... */\n} catch (Exception e) {  // Noncompliant - original exception is lost\n  throw new RuntimeException(\"context\");\n}\n</pre>\n<h3>Compliant solution</h3>\n<pre>\ntry {\n  /* ... */\n} catch (Exception e) {\n  LOGGER.info(e);  // exception is logged\n}\n\ntry {\n  /* ... */\n} catch (Exception e) {\n  throw new RuntimeException(e);   // exception stack trace is propagated\n}\n\ntry {\n  /* ... */\n} catch (RuntimeException e) {\n  doSomething();\n  throw e;  // original exception passed forward\n} catch (Exception e) {\n  throw new RuntimeException(e);  // Conversion into unchecked exception is also allowed\n}\n</pre>\n<h3>Exceptions</h3>\n<p><code>InterruptedException</code>, <code>NumberFormatException</code>, <code>DateTimeParseException</code>, <code>ParseException</code> and\n<code>MalformedURLException</code> exceptions are arguably used to indicate nonexceptional outcomes. Similarly, handling\n<code>NoSuchMethodException</code> is often required when dealing with the Java reflection API.</p>\n<p>Because they are part of Java, developers have no choice but to deal with them. This rule does not verify that those particular exceptions are\ncorrectly handled.</p>\n<pre>\nint myInteger;\ntry {\n  myInteger = Integer.parseInt(myString);\n} catch (NumberFormatException e) {\n  // It is perfectly acceptable to not handle \"e\" here\n  myInteger = 0;\n}\n</pre>\n<p>Furthermore, no issue will be raised if the exception message is logged with additional information, as it shows that the developer added some\ncontext to the error message.</p>\n<pre>\ntry {\n  /* ... */\n} catch (Exception e) {\n  String message = \"Exception raised while authenticating user: \" + e.getMessage();\n  LOGGER.warn(message); // Compliant - exception message logged with some contextual information\n}\n</pre>",
    "howToFix": "",
    "moreInfo": "<ul>\n  <li> OWASP - <a href=\"https://owasp.org/Top10/A09_2021-Security_Logging_and_Monitoring_Failures/\">Top 10 2021 Category A9 - Security Logging and\n  Monitoring Failures</a> </li>\n  <li> OWASP - <a href=\"https://owasp.org/www-project-top-ten/2017/A10_2017-Insufficient_Logging%2526Monitoring\">Top 10 2017 Category A10 -\n  Insufficient Logging &amp; Monitoring</a> </li>\n  <li> <a href=\"https://wiki.sei.cmu.edu/confluence/x/xDdGBQ\">CERT, ERR00-J.</a> - Do not suppress or ignore checked exceptions </li>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/778\">CWE-778 - Insufficient Logging</a> </li>\n</ul>",
    "status": "READY",
    "name_ko": "Exception 핸들러는 원본 exception을 보존해야 합니다",
    "why_ko": "<p>catch된 예외를 처리할 때 원본 예외의 메시지와 스택 트레이스를 로그에 기록하거나 전달해야 합니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\ntry {\n  /* ... */\n} catch (Exception e) {   // 규칙 위반 - 예외가 손실됨\n  LOGGER.info(\"context\");\n}\n\ntry {\n  /* ... */\n} catch (Exception e) {  // 규칙 위반 - 예외가 손실됨 (메시지만 보존됨)\n  LOGGER.info(e.getMessage());\n}\n\ntry {\n  /* ... */\n} catch (Exception e) {  // 규칙 위반 - 원본 예외가 손실됨\n  throw new RuntimeException(\"context\");\n}\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre>\ntry {\n  /* ... */\n} catch (Exception e) {\n  LOGGER.info(e);  // 예외가 로그에 기록됨\n}\n\ntry {\n  /* ... */\n} catch (Exception e) {\n  throw new RuntimeException(e);   // 예외 스택 트레이스가 전파됨\n}\n\ntry {\n  /* ... */\n} catch (RuntimeException e) {\n  doSomething();\n  throw e;  // 원본 예외가 전달됨\n} catch (Exception e) {\n  throw new RuntimeException(e);  // unchecked 예외로 변환도 허용됨\n}\n</pre>\n<h3>예외</h3>\n<p><code>InterruptedException</code>, <code>NumberFormatException</code>, <code>DateTimeParseException</code>, <code>ParseException</code> 및 <code>MalformedURLException</code> 예외는 예외적이지 않은 결과를 나타내는 데 사용되는 것으로 볼 수 있습니다. 마찬가지로 Java reflection API를 다룰 때 <code>NoSuchMethodException</code> 처리가 종종 필요합니다.</p>\n<p>이들은 Java의 일부이므로 개발자는 이를 처리해야 합니다. 이 규칙은 이러한 특정 예외가 올바르게 처리되는지 확인하지 않습니다.</p>\n<pre>\nint myInteger;\ntry {\n  myInteger = Integer.parseInt(myString);\n} catch (NumberFormatException e) {\n  // 여기서 \"e\"를 처리하지 않는 것은 완전히 허용됩니다\n  myInteger = 0;\n}\n</pre>\n<p>또한 예외 메시지가 추가 정보와 함께 로그에 기록되면 개발자가 오류 메시지에 일부 컨텍스트를 추가했음을 보여주므로 이슈가 발생하지 않습니다.</p>\n<pre>\ntry {\n  /* ... */\n} catch (Exception e) {\n  String message = \"사용자 인증 중 예외 발생: \" + e.getMessage();\n  LOGGER.warn(message); // 규칙 준수 - 예외 메시지가 일부 컨텍스트 정보와 함께 로그에 기록됨\n}\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": "<ul>\n  <li> OWASP - <a href=\"https://owasp.org/Top10/A09_2021-Security_Logging_and_Monitoring_Failures/\">Top 10 2021 카테고리 A9 - 보안 로깅 및 모니터링 실패</a> </li>\n  <li> OWASP - <a href=\"https://owasp.org/www-project-top-ten/2017/A10_2017-Insufficient_Logging%2526Monitoring\">Top 10 2017 카테고리 A10 - 불충분한 로깅 및 모니터링</a> </li>\n  <li> <a href=\"https://wiki.sei.cmu.edu/confluence/x/xDdGBQ\">CERT, ERR00-J.</a> - checked exception을 억제하거나 무시하지 마세요 </li>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/778\">CWE-778 - 불충분한 로깅</a> </li>\n</ul>"
  },
  {
    "id": "S2121",
    "key": "java:S2121",
    "name": "String operations with predictable outcomes should be avoided",
    "type": "bug",
    "severity": "major",
    "tags": [
      "clumsy"
    ],
    "why": "<p>Operations performed on a string with predictable outcomes should be avoided. For example:</p>\n<ul>\n  <li> checking if a string contains itself </li>\n  <li> comparing a string with itself </li>\n  <li> matching a string against itself </li>\n  <li> creating a substring from 0 to the end of the string </li>\n  <li> creating a substring from the end of the string </li>\n  <li> replacing a string with itself </li>\n  <li> replacing a substring with the exact substring </li>\n</ul>",
    "howToFix": "<p>Avoid performing the operation that has a predictable outcome.</p>\n\n<h4>Noncompliant code example</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\nString speech = \"SonarQube is the best static code analysis tool.\"\n\nString s1 = speech.substring(0); // Noncompliant - yields the whole string\nString s2 = speech.substring(speech.length()); // Noncompliant - yields \"\";\nString s3 = speech.substring(5, speech.length()); // Noncompliant - use the 1-arg version instead\n\nif (speech.contains(speech)) { // Noncompliant - always true\n    // ...\n}\n</pre>\n<h4>Compliant solution</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\nString speech = \"SonarQube is the best static code analysis tool.\"\n\nString s1 = speech;\nString s2 = \"\";\nString s3 = speech.substring(5);\n\n// ...\n</pre>",
    "moreInfo": "<ul>\n  <li> <a href=\"https://docs.oracle.com/en/java/javase/20/docs/api/java.base/java/lang/String.html\">Oracle Java SE - String</a> </li>\n</ul>",
    "status": "READY",
    "name_ko": "결과가 예측 가능한 String 연산은 피해야 합니다",
    "why_ko": "<p>결과가 예측 가능한 문자열 연산은 피해야 합니다. 예를 들어:</p>\n<ul>\n  <li> 문자열이 자기 자신을 포함하는지 확인 </li>\n  <li> 문자열을 자기 자신과 비교 </li>\n  <li> 문자열을 자기 자신과 매칭 </li>\n  <li> 0부터 문자열 끝까지 부분 문자열 생성 </li>\n  <li> 문자열 끝부터 부분 문자열 생성 </li>\n  <li> 문자열을 자기 자신으로 대체 </li>\n  <li> 부분 문자열을 정확히 같은 부분 문자열로 대체 </li>\n</ul>",
    "howToFix_ko": "<p>결과가 예측 가능한 연산을 수행하지 마세요.</p>\n\n<h4>규칙을 준수하지 않는 코드 예시</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\nString speech = \"SonarQube is the best static code analysis tool.\"\n\nString s1 = speech.substring(0); // 규칙 위반 - 전체 문자열을 반환\nString s2 = speech.substring(speech.length()); // 규칙 위반 - \"\"를 반환;\nString s3 = speech.substring(5, speech.length()); // 규칙 위반 - 대신 1개 인수 버전 사용\n\nif (speech.contains(speech)) { // 규칙 위반 - 항상 true\n    // ...\n}\n</pre>\n<h4>규칙을 준수하는 해결책</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\nString speech = \"SonarQube is the best static code analysis tool.\"\n\nString s1 = speech;\nString s2 = \"\";\nString s3 = speech.substring(5);\n\n// ...\n</pre>",
    "moreInfo_ko": "<ul>\n  <li> <a href=\"https://docs.oracle.com/en/java/javase/20/docs/api/java.base/java/lang/String.html\">Oracle Java SE - String</a> </li>\n</ul>"
  },
  {
    "id": "S4276",
    "key": "java:S4276",
    "name": "Functional Interfaces should be as specialised as possible",
    "type": "code-smell",
    "severity": "minor",
    "tags": [
      "performance"
    ],
    "why": "<p>The <code>java.util.function</code> package provides a large array of functional interface definitions for use in lambda expressions and method\nreferences. In general it is recommended to use the more specialised form to avoid auto-boxing. For instance <code>IntFunction&lt;Foo&gt;</code>\nshould be preferred over <code>Function&lt;Integer, Foo&gt;</code>.</p>\n<p>This rule raises an issue when any of the following substitution is possible:</p>\n<table>\n  <colgroup>\n    <col style=\"width: 50%;\">\n    <col style=\"width: 50%;\">\n  </colgroup>\n  <thead>\n    <tr>\n      <th>Current Interface</th>\n      <th>Preferred Interface</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td><p><code>Function&lt;Integer, R&gt;</code></p></td>\n      <td><p><code>IntFunction&lt;R&gt;</code></p></td>\n    </tr>\n    <tr>\n      <td><p><code>Function&lt;Long, R&gt;</code></p></td>\n      <td><p><code>LongFunction&lt;R&gt;</code></p></td>\n    </tr>\n    <tr>\n      <td><p><code>Function&lt;Double, R&gt;</code></p></td>\n      <td><p><code>DoubleFunction&lt;R&gt;</code></p></td>\n    </tr>\n    <tr>\n      <td><p><code>Function&lt;Double,Integer&gt;</code></p></td>\n      <td><p><code>DoubleToIntFunction</code></p></td>\n    </tr>\n    <tr>\n      <td><p><code>Function&lt;Double,Long&gt;</code></p></td>\n      <td><p><code>DoubleToLongFunction</code></p></td>\n    </tr>\n    <tr>\n      <td><p><code>Function&lt;Long,Double&gt;</code></p></td>\n      <td><p><code>LongToDoubleFunction</code></p></td>\n    </tr>\n    <tr>\n      <td><p><code>Function&lt;Long,Integer&gt;</code></p></td>\n      <td><p><code>LongToIntFunction</code></p></td>\n    </tr>\n    <tr>\n      <td><p><code>Function&lt;R,Integer&gt;</code></p></td>\n      <td><p><code>ToIntFunction&lt;R&gt;</code></p></td>\n    </tr>\n    <tr>\n      <td><p><code>Function&lt;R,Long&gt;</code></p></td>\n      <td><p><code>ToLongFunction&lt;R&gt;</code></p></td>\n    </tr>\n    <tr>\n      <td><p><code>Function&lt;R,Double&gt;</code></p></td>\n      <td><p><code>ToDoubleFunction&lt;R&gt;</code></p></td>\n    </tr>\n    <tr>\n      <td><p><code>Function&lt;T,T&gt;</code></p></td>\n      <td><p><code>UnaryOperator&lt;T&gt;</code></p></td>\n    </tr>\n    <tr>\n      <td><p><code>BiFunction&lt;T,T,T&gt;</code></p></td>\n      <td><p><code>BinaryOperator&lt;T&gt;</code></p></td>\n    </tr>\n    <tr>\n      <td><p><code>Consumer&lt;Integer&gt;</code></p></td>\n      <td><p><code>IntConsumer</code></p></td>\n    </tr>\n    <tr>\n      <td><p><code>Consumer&lt;Double&gt;</code></p></td>\n      <td><p><code>DoubleConsumer</code></p></td>\n    </tr>\n    <tr>\n      <td><p><code>Consumer&lt;Long&gt;</code></p></td>\n      <td><p><code>LongConsumer</code></p></td>\n    </tr>\n    <tr>\n      <td><p><code>BiConsumer&lt;T,Integer&gt;</code></p></td>\n      <td><p><code>ObjIntConsumer&lt;T&gt;</code></p></td>\n    </tr>\n    <tr>\n      <td><p><code>BiConsumer&lt;T,Long&gt;</code></p></td>\n      <td><p><code>ObjLongConsumer&lt;T&gt;</code></p></td>\n    </tr>\n    <tr>\n      <td><p><code>BiConsumer&lt;T,Double&gt;</code></p></td>\n      <td><p><code>ObjDoubleConsumer&lt;T&gt;</code></p></td>\n    </tr>\n    <tr>\n      <td><p><code>Predicate&lt;Integer&gt;</code></p></td>\n      <td><p><code>IntPredicate</code></p></td>\n    </tr>\n    <tr>\n      <td><p><code>Predicate&lt;Double&gt;</code></p></td>\n      <td><p><code>DoublePredicate</code></p></td>\n    </tr>\n    <tr>\n      <td><p><code>Predicate&lt;Long&gt;</code></p></td>\n      <td><p><code>LongPredicate</code></p></td>\n    </tr>\n    <tr>\n      <td><p><code>Supplier&lt;Integer&gt;</code></p></td>\n      <td><p><code>IntSupplier</code></p></td>\n    </tr>\n    <tr>\n      <td><p><code>Supplier&lt;Double&gt;</code></p></td>\n      <td><p><code>DoubleSupplier</code></p></td>\n    </tr>\n    <tr>\n      <td><p><code>Supplier&lt;Long&gt;</code></p></td>\n      <td><p><code>LongSupplier</code></p></td>\n    </tr>\n    <tr>\n      <td><p><code>Supplier&lt;Boolean&gt;</code></p></td>\n      <td><p><code>BooleanSupplier</code></p></td>\n    </tr>\n    <tr>\n      <td><p><code>UnaryOperator&lt;Integer&gt;</code></p></td>\n      <td><p><code>IntUnaryOperator</code></p></td>\n    </tr>\n    <tr>\n      <td><p><code>UnaryOperator&lt;Double&gt;</code></p></td>\n      <td><p><code>DoubleUnaryOperator</code></p></td>\n    </tr>\n    <tr>\n      <td><p><code>UnaryOperator&lt;Long&gt;</code></p></td>\n      <td><p><code>LongUnaryOperator</code></p></td>\n    </tr>\n    <tr>\n      <td><p><code>BinaryOperator&lt;Integer&gt;</code></p></td>\n      <td><p><code>IntBinaryOperator</code></p></td>\n    </tr>\n    <tr>\n      <td><p><code>BinaryOperator&lt;Long&gt;</code></p></td>\n      <td><p><code>LongBinaryOperator</code></p></td>\n    </tr>\n    <tr>\n      <td><p><code>BinaryOperator&lt;Double&gt;</code></p></td>\n      <td><p><code>DoubleBinaryOperator</code></p></td>\n    </tr>\n    <tr>\n      <td><p><code>Function&lt;T, Boolean&gt;</code></p></td>\n      <td><p><code>Predicate&lt;T&gt;</code></p></td>\n    </tr>\n    <tr>\n      <td><p><code>BiFunction&lt;T,U,Boolean&gt;</code></p></td>\n      <td><p><code>BiPredicate&lt;T,U&gt;</code></p></td>\n    </tr>\n  </tbody>\n</table>\n<h3>Noncompliant code example</h3>\n<pre>\npublic class Foo implements Supplier&lt;Integer&gt; {  // Noncompliant\n    @Override\n    public Integer get() {\n      // ...\n    }\n}\n</pre>\n<h3>Compliant solution</h3>\n<pre>\npublic class Foo implements IntSupplier {\n\n  @Override\n  public int getAsInt() {\n    // ...\n  }\n}\n</pre>",
    "howToFix": "",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "Functional Interface는 가능한 한 특화되어야 합니다",
    "why_ko": "<p><code>java.util.function</code> 패키지는 람다 표현식 및 메서드 참조에 사용할 수 있는 다양한 함수형 인터페이스 정의를 제공합니다. 일반적으로 auto-boxing을 피하기 위해 더 특화된 형태를 사용하는 것이 권장됩니다. 예를 들어 <code>Function&lt;Integer, Foo&gt;</code>보다 <code>IntFunction&lt;Foo&gt;</code>가 선호됩니다.</p>\n<p>이 규칙은 다음 대체 중 하나가 가능할 때 문제를 제기합니다:</p>\n<table>\n  <colgroup>\n    <col style=\"width: 50%;\">\n    <col style=\"width: 50%;\">\n  </colgroup>\n  <thead>\n    <tr>\n      <th>현재 인터페이스</th>\n      <th>권장 인터페이스</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td><p><code>Function&lt;Integer, R&gt;</code></p></td>\n      <td><p><code>IntFunction&lt;R&gt;</code></p></td>\n    </tr>\n    <tr>\n      <td><p><code>Function&lt;Long, R&gt;</code></p></td>\n      <td><p><code>LongFunction&lt;R&gt;</code></p></td>\n    </tr>\n    <tr>\n      <td><p><code>Function&lt;Double, R&gt;</code></p></td>\n      <td><p><code>DoubleFunction&lt;R&gt;</code></p></td>\n    </tr>\n    <tr>\n      <td><p><code>Function&lt;Double,Integer&gt;</code></p></td>\n      <td><p><code>DoubleToIntFunction</code></p></td>\n    </tr>\n    <tr>\n      <td><p><code>Function&lt;Double,Long&gt;</code></p></td>\n      <td><p><code>DoubleToLongFunction</code></p></td>\n    </tr>\n    <tr>\n      <td><p><code>Function&lt;Long,Double&gt;</code></p></td>\n      <td><p><code>LongToDoubleFunction</code></p></td>\n    </tr>\n    <tr>\n      <td><p><code>Function&lt;Long,Integer&gt;</code></p></td>\n      <td><p><code>LongToIntFunction</code></p></td>\n    </tr>\n    <tr>\n      <td><p><code>Function&lt;R,Integer&gt;</code></p></td>\n      <td><p><code>ToIntFunction&lt;R&gt;</code></p></td>\n    </tr>\n    <tr>\n      <td><p><code>Function&lt;R,Long&gt;</code></p></td>\n      <td><p><code>ToLongFunction&lt;R&gt;</code></p></td>\n    </tr>\n    <tr>\n      <td><p><code>Function&lt;R,Double&gt;</code></p></td>\n      <td><p><code>ToDoubleFunction&lt;R&gt;</code></p></td>\n    </tr>\n    <tr>\n      <td><p><code>Function&lt;T,T&gt;</code></p></td>\n      <td><p><code>UnaryOperator&lt;T&gt;</code></p></td>\n    </tr>\n    <tr>\n      <td><p><code>BiFunction&lt;T,T,T&gt;</code></p></td>\n      <td><p><code>BinaryOperator&lt;T&gt;</code></p></td>\n    </tr>\n    <tr>\n      <td><p><code>Consumer&lt;Integer&gt;</code></p></td>\n      <td><p><code>IntConsumer</code></p></td>\n    </tr>\n    <tr>\n      <td><p><code>Consumer&lt;Double&gt;</code></p></td>\n      <td><p><code>DoubleConsumer</code></p></td>\n    </tr>\n    <tr>\n      <td><p><code>Consumer&lt;Long&gt;</code></p></td>\n      <td><p><code>LongConsumer</code></p></td>\n    </tr>\n    <tr>\n      <td><p><code>BiConsumer&lt;T,Integer&gt;</code></p></td>\n      <td><p><code>ObjIntConsumer&lt;T&gt;</code></p></td>\n    </tr>\n    <tr>\n      <td><p><code>BiConsumer&lt;T,Long&gt;</code></p></td>\n      <td><p><code>ObjLongConsumer&lt;T&gt;</code></p></td>\n    </tr>\n    <tr>\n      <td><p><code>BiConsumer&lt;T,Double&gt;</code></p></td>\n      <td><p><code>ObjDoubleConsumer&lt;T&gt;</code></p></td>\n    </tr>\n    <tr>\n      <td><p><code>Predicate&lt;Integer&gt;</code></p></td>\n      <td><p><code>IntPredicate</code></p></td>\n    </tr>\n    <tr>\n      <td><p><code>Predicate&lt;Double&gt;</code></p></td>\n      <td><p><code>DoublePredicate</code></p></td>\n    </tr>\n    <tr>\n      <td><p><code>Predicate&lt;Long&gt;</code></p></td>\n      <td><p><code>LongPredicate</code></p></td>\n    </tr>\n    <tr>\n      <td><p><code>Supplier&lt;Integer&gt;</code></p></td>\n      <td><p><code>IntSupplier</code></p></td>\n    </tr>\n    <tr>\n      <td><p><code>Supplier&lt;Double&gt;</code></p></td>\n      <td><p><code>DoubleSupplier</code></p></td>\n    </tr>\n    <tr>\n      <td><p><code>Supplier&lt;Long&gt;</code></p></td>\n      <td><p><code>LongSupplier</code></p></td>\n    </tr>\n    <tr>\n      <td><p><code>Supplier&lt;Boolean&gt;</code></p></td>\n      <td><p><code>BooleanSupplier</code></p></td>\n    </tr>\n    <tr>\n      <td><p><code>UnaryOperator&lt;Integer&gt;</code></p></td>\n      <td><p><code>IntUnaryOperator</code></p></td>\n    </tr>\n    <tr>\n      <td><p><code>UnaryOperator&lt;Double&gt;</code></p></td>\n      <td><p><code>DoubleUnaryOperator</code></p></td>\n    </tr>\n    <tr>\n      <td><p><code>UnaryOperator&lt;Long&gt;</code></p></td>\n      <td><p><code>LongUnaryOperator</code></p></td>\n    </tr>\n    <tr>\n      <td><p><code>BinaryOperator&lt;Integer&gt;</code></p></td>\n      <td><p><code>IntBinaryOperator</code></p></td>\n    </tr>\n    <tr>\n      <td><p><code>BinaryOperator&lt;Long&gt;</code></p></td>\n      <td><p><code>LongBinaryOperator</code></p></td>\n    </tr>\n    <tr>\n      <td><p><code>BinaryOperator&lt;Double&gt;</code></p></td>\n      <td><p><code>DoubleBinaryOperator</code></p></td>\n    </tr>\n    <tr>\n      <td><p><code>Function&lt;T, Boolean&gt;</code></p></td>\n      <td><p><code>Predicate&lt;T&gt;</code></p></td>\n    </tr>\n    <tr>\n      <td><p><code>BiFunction&lt;T,U,Boolean&gt;</code></p></td>\n      <td><p><code>BiPredicate&lt;T,U&gt;</code></p></td>\n    </tr>\n  </tbody>\n</table>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\npublic class Foo implements Supplier&lt;Integer&gt; {  // 규칙 위반\n    @Override\n    public Integer get() {\n      // ...\n    }\n}\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre>\npublic class Foo implements IntSupplier {\n\n  @Override\n  public int getAsInt() {\n    // ...\n  }\n}\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": ""
  },
  {
    "id": "S2658",
    "key": "java:S2658",
    "name": "Classes should not be loaded dynamically",
    "type": "vulnerability",
    "severity": "critical",
    "tags": [],
    "why": "<p>Dynamically loaded classes could contain malicious code executed by a static class initializer. I.E. you wouldn't even have to instantiate or\nexplicitly invoke methods on such classes to be vulnerable to an attack.</p>\n<p>This rule raises an issue for each use of dynamic class loading.</p>\n<h3>Noncompliant code example</h3>\n<pre>\nString className = System.getProperty(\"messageClassName\");\nClass clazz = Class.forName(className);  // Noncompliant\n</pre>",
    "howToFix": "",
    "moreInfo": "<ul>\n  <li> OWASP - <a href=\"https://owasp.org/www-project-top-ten/2017/A1_2017-Injection\">Top 10 2017 Category A1 - Injection</a> </li>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/470\">CWE-470 - Use of Externally-Controlled Input to Select Classes or Code ('Unsafe\n  Reflection')</a> </li>\n</ul>",
    "status": "DEPRECATED",
    "name_ko": "클래스를 동적으로 로드하면 안 됩니다",
    "why_ko": "<p>동적으로 로드된 클래스에는 정적 클래스 초기화에 의해 실행되는 악성 코드가 포함될 수 있습니다. 즉, 공격에 취약하기 위해 이러한 클래스를 인스턴스화하거나 메서드를 명시적으로 호출할 필요도 없습니다.</p>\n<p>이 규칙은 동적 클래스 로딩을 사용할 때마다 문제를 제기합니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\nString className = System.getProperty(\"messageClassName\");\nClass clazz = Class.forName(className);  // 규칙 위반\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": "<ul>\n  <li> OWASP - <a href=\"https://owasp.org/www-project-top-ten/2017/A1_2017-Injection\">Top 10 2017 Category A1 - Injection</a> </li>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/470\">CWE-470 - Use of Externally-Controlled Input to Select Classes or Code ('Unsafe Reflection')</a> </li>\n</ul>"
  },
  {
    "id": "S2208",
    "key": "java:S2208",
    "name": "Wildcard imports should not be used",
    "type": "code-smell",
    "severity": "critical",
    "tags": [
      "pitfall"
    ],
    "why": "<p>Using wildcards in imports may look cleaner as it reduces the number of lines in the import section and simplifies the code.<br> On the other hand,\nit makes the code harder to maintain:</p>\n<ul>\n  <li> It reduces code readability as developers will have a hard time knowing where names come from. </li>\n  <li> It could lead to conflicts between names defined locally and the ones imported. </li>\n  <li> It could later raise conflicts on dependency upgrade or Java version migration, as a wildcard import that works today might be broken tomorrow.\n  </li>\n</ul>\n<p>That is why it is better to import only the specific classes or modules you need.</p>\n<h3>Exceptions</h3>\n<p>Static imports are ignored by this rule. For example:</p>\n<pre>\nimport static java.lang.Math.*;\n</pre>\n<p>will not raise an issue;</p>",
    "howToFix": "<p>Depending on your IDE you can solve this issue almost <strong>automatically</strong>:<br> Look for <strong>Organize/Optimize imports</strong>\nactions. These actions can also often be applied automatically on save.<br> <em>Note:</em> To make this work properly, you must adjust IDE settings to\nuse a very high <code>allowed class count usage</code> before using wildcards.</p>\n<p>Resolving this issue <strong>manually</strong> will require a step-by-step approach:</p>\n<ol>\n  <li> Remove one wildcard import and note down compilation failures. </li>\n  <li> For each missing class, import it back with the package prefix. </li>\n  <li> When the code compiles again, proceed with the next wildcard import. </li>\n</ol>\n\n<h4>Noncompliant code example</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\nimport java.sql.*; // Noncompliant\nimport java.util.*; // Noncompliant\n\nprivate Date date; // Date class exists in java.sql and java.util. Which one is this?\n</pre>\n<h4>Compliant solution</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\nimport java.sql.Date;\nimport java.util.List;\nimport java.util.ArrayList;\n\nprivate Date date;\n</pre>",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "와일드카드 import를 사용하면 안 됩니다",
    "why_ko": "<p>import에서 와일드카드를 사용하면 import 섹션의 줄 수가 줄어들고 코드가 단순해져 더 깔끔해 보일 수 있습니다.<br> 반면에 코드를 유지보수하기 어렵게 만듭니다:</p>\n<ul>\n  <li> 개발자가 이름이 어디에서 오는지 알기 어려워져 코드 가독성이 떨어집니다. </li>\n  <li> 로컬에서 정의된 이름과 import된 이름 사이에 충돌이 발생할 수 있습니다. </li>\n  <li> 오늘 작동하는 와일드카드 import가 내일 깨질 수 있으므로 의존성 업그레이드나 Java 버전 마이그레이션 시 나중에 충돌이 발생할 수 있습니다. </li>\n</ul>\n<p>그래서 필요한 특정 클래스나 모듈만 import하는 것이 더 좋습니다.</p>\n<h3>예외</h3>\n<p>static import는 이 규칙에서 무시됩니다. 예를 들어:</p>\n<pre>\nimport static java.lang.Math.*;\n</pre>\n<p>은 이슈를 발생시키지 않습니다;</p>",
    "howToFix_ko": "<p>IDE에 따라 이 문제를 거의 <strong>자동으로</strong> 해결할 수 있습니다:<br> <strong>import 정리/최적화</strong> 기능을 찾아보세요. 이러한 기능은 저장 시 자동으로 적용될 수도 있습니다.<br> <em>참고:</em> 이것이 제대로 작동하려면 와일드카드를 사용하기 전에 IDE 설정에서 매우 높은 <code>허용 클래스 카운트 사용량</code>을 설정해야 합니다.</p>\n<p>이 문제를 <strong>수동으로</strong> 해결하려면 단계별 접근이 필요합니다:</p>\n<ol>\n  <li> 하나의 와일드카드 import를 제거하고 컴파일 실패를 기록합니다. </li>\n  <li> 누락된 각 클래스에 대해 패키지 접두사와 함께 다시 import합니다. </li>\n  <li> 코드가 다시 컴파일되면 다음 와일드카드 import를 진행합니다. </li>\n</ol>\n\n<h4>규칙을 준수하지 않는 코드 예시</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\nimport java.sql.*; // 규칙 위반\nimport java.util.*; // 규칙 위반\n\nprivate Date date; // Date 클래스는 java.sql과 java.util에 존재합니다. 이것은 어느 것인가요?\n</pre>\n<h4>규칙을 준수하는 해결책</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\nimport java.sql.Date;\nimport java.util.List;\nimport java.util.ArrayList;\n\nprivate Date date;\n</pre>",
    "moreInfo_ko": ""
  },
  {
    "id": "S6396",
    "key": "java:S6396",
    "name": "Superfluous curly brace quantifiers should be avoided",
    "type": "code-smell",
    "severity": "major",
    "tags": [
      "regex"
    ],
    "why": "<p>Curly brace quantifiers in regular expressions can be used to have a more fine-grained control over how many times the character or the\nsub-expression preceeding them should occur. They can be used to match an expression exactly n times with <code>{n}</code>, between n and m times with\n<code>{n,m}</code>, or at least n times with <code>{n,}</code>. In some cases, using such a quantifier is superfluous for the semantic of the regular\nexpression, and it can be removed to improve readability. This rule raises an issue when one of the following quantifiers is encountered:</p>\n<ul>\n  <li> <code>{1,1}</code> or <code>{1}</code>: they match the expression exactly once. The same behavior can be achieved without the quantifier. </li>\n  <li> <code>{0,0}</code> or <code>{0}</code>: they match the expression zero times. The same behavior can be achieved by removing the expression.\n  </li>\n</ul>\n<h3>Noncompliant code example</h3>\n<pre>\n\"ab{1,1}c\"\n\"ab{1}c\"\n\"ab{0,0}c\"\n\"ab{0}c\"\n</pre>\n<h3>Compliant solution</h3>\n<pre>\n\"abc\"\n\"ac\"\n</pre>",
    "howToFix": "",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "불필요한 중괄호 수량자는 피해야 합니다",
    "why_ko": "<p>정규 표현식의 중괄호 수량자는 앞에 있는 문자나 서브 표현식이 얼마나 발생해야 하는지 더 세밀하게 제어하는 데 사용할 수 있습니다. <code>{n}</code>으로 표현식을 정확히 n번 매칭하거나, <code>{n,m}</code>으로 n번과 m번 사이를 매칭하거나, <code>{n,}</code>으로 최소 n번을 매칭하는 데 사용할 수 있습니다. 일부 경우 이러한 수량자를 사용하는 것은 정규 표현식의 의미상 불필요하며 가독성을 향상시키기 위해 제거할 수 있습니다. 이 규칙은 다음 수량자 중 하나가 발견될 때 문제를 발생시킵니다:</p>\n<ul>\n  <li> <code>{1,1}</code> 또는 <code>{1}</code>: 표현식을 정확히 한 번 매칭합니다. 수량자 없이도 동일한 동작을 달성할 수 있습니다. </li>\n  <li> <code>{0,0}</code> 또는 <code>{0}</code>: 표현식을 0번 매칭합니다. 표현식을 제거하여 동일한 동작을 달성할 수 있습니다. </li>\n</ul>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\n\"ab{1,1}c\"\n\"ab{1}c\"\n\"ab{0,0}c\"\n\"ab{0}c\"\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre>\n\"abc\"\n\"ac\"\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": ""
  },
  {
    "id": "S4201",
    "key": "java:S4201",
    "name": "Null checks should not be used with \"instanceof\"",
    "type": "code-smell",
    "severity": "minor",
    "tags": [
      "redundant"
    ],
    "why": "<p>There's no need to null test in conjunction with an <code>instanceof</code> test. <code>null</code> is not an <code>instanceof</code> anything, so\na null check is redundant.</p>\n<h3>Noncompliant code example</h3>\n<pre>\nif (x != null &amp;&amp; x instanceof MyClass) { ... }  // Noncompliant\n\nif (x == null || ! x instanceof MyClass) { ... } // Noncompliant\n</pre>\n<h3>Compliant solution</h3>\n<pre>\nif (x instanceof MyClass) { ... }\n\nif (! x instanceof MyClass) { ... }\n</pre>",
    "howToFix": "",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "\"instanceof\"와 함께 null 검사를 사용하면 안 됩니다",
    "why_ko": "<p><code>instanceof</code> 테스트와 함께 null 테스트를 할 필요가 없습니다. <code>null</code>은 어떤 것의 <code>instanceof</code>도 아니므로 null 검사는 중복입니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\nif (x != null &amp;&amp; x instanceof MyClass) { ... }  // 규칙 위반\n\nif (x == null || ! x instanceof MyClass) { ... } // 규칙 위반\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre>\nif (x instanceof MyClass) { ... }\n\nif (! x instanceof MyClass) { ... }\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": ""
  },
  {
    "id": "S1845",
    "key": "java:S1845",
    "name": "Methods and field names should not be the same or differ only by capitalization",
    "type": "code-smell",
    "severity": "blocker",
    "tags": [
      "confusing"
    ],
    "why": "<p>Looking at the set of methods in a class, including superclass methods, and finding two methods or fields that differ only by capitalization is\nconfusing to users of the class. It is similarly confusing to have a method and a field which differ only in capitalization or a method and a field\nwith exactly the same name and visibility.</p>\n<p>In the case of methods, it may have been a mistake on the part of the original developer, who intended to override a superclass method, but instead\nadded a new method with nearly the same name.</p>\n<p>Otherwise, this situation simply indicates poor naming. Method names should be action-oriented, and thus contain a verb, which is unlikely in the\ncase where both a method and a member have the same name (with or without capitalization differences). However, renaming a public method could be\ndisruptive to callers. Therefore renaming the member is the recommended action.</p>\n\n<h4>Noncompliant code example</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\npublic class Car{\n\n  public DriveTrain drive;\n\n  public void tearDown(){...}\n\n  public void drive() {...}  // Noncompliant; duplicates field name\n}\n\npublic class MyCar extends Car{\n  public void teardown(){...}  // Noncompliant; not an override. It it really what's intended?\n\n  public void drivefast(){...}\n\n  public void driveFast(){...} //Huh?\n}\n</pre>\n<h4>Compliant solution</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\npublic class Car{\n\n  private DriveTrain drive;\n\n  public void tearDown(){...}\n\n  public void drive() {...}  // field visibility reduced\n}\n\npublic class MyCar extends Car{\n  @Override\n  public void tearDown(){...}\n\n  public void drivefast(){...}\n\n  public void driveReallyFast(){...}\n\n}\n</pre>",
    "howToFix": "",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "메서드와 필드 이름이 동일하거나 대소문자만 다르면 안 됩니다",
    "why_ko": "<p>클래스의 메서드 집합(상위 클래스 메서드 포함)을 보면서 대소문자만 다른 두 개의 메서드나 필드를 발견하면 해당 클래스 사용자에게 혼란을 줍니다. 마찬가지로 대소문자만 다른 메서드와 필드, 또는 정확히 동일한 이름과 가시성을 가진 메서드와 필드가 있으면 혼란스럽습니다.</p>\n<p>메서드의 경우, 원래 개발자가 상위 클래스 메서드를 오버라이드하려고 했으나 실수로 거의 동일한 이름의 새 메서드를 추가했을 수 있습니다.</p>\n<p>그렇지 않으면, 이 상황은 단순히 좋지 않은 명명을 나타냅니다. 메서드 이름은 행위 지향적이어야 하므로 동사를 포함해야 하는데, 메서드와 멤버가 동일한 이름을 가지는 경우(대소문자 차이 유무와 관계없이) 이것은 거의 불가능합니다. 그러나 public 메서드의 이름을 변경하면 호출자에게 방해가 될 수 있습니다. 따라서 멤버의 이름을 변경하는 것이 권장되는 조치입니다.</p>\n\n<h4>규칙을 준수하지 않는 코드 예시</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\npublic class Car{\n\n  public DriveTrain drive;\n\n  public void tearDown(){...}\n\n  public void drive() {...}  // 규칙 위반; 필드 이름과 중복\n}\n\npublic class MyCar extends Car{\n  public void teardown(){...}  // 규칙 위반; 오버라이드가 아님. 정말 의도한 것인가요?\n\n  public void drivefast(){...}\n\n  public void driveFast(){...} //혼란스러움\n}\n</pre>\n<h4>규칙을 준수하는 해결책</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\npublic class Car{\n\n  private DriveTrain drive;\n\n  public void tearDown(){...}\n\n  public void drive() {...}  // 필드 가시성 축소\n}\n\npublic class MyCar extends Car{\n  @Override\n  public void tearDown(){...}\n\n  public void drivefast(){...}\n\n  public void driveReallyFast(){...}\n\n}\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": ""
  },
  {
    "id": "S3878",
    "key": "java:S3878",
    "name": "Arrays should not be created for varargs parameters",
    "type": "code-smell",
    "severity": "minor",
    "tags": [
      "clumsy"
    ],
    "why": "<p>There's no point in creating an array solely for the purpose of passing it as a varargs (<code>...</code>) argument; varargs <em>is</em> an array.\nSimply pass the elements directly. They will be consolidated into an array automatically. Incidentally passing an array where <code>Object ...</code>\nis expected makes the intent ambiguous: Is the array supposed to be one object or a collection of objects?</p>\n<h3>Noncompliant code example</h3>\n<pre>\npublic void callTheThing() {\n  //...\n  doTheThing(new String[] { \"s1\", \"s2\"});  // Noncompliant: unnecessary\n  doTheThing(new String[12]);  // Compliant\n  doTheOtherThing(new String[8]);  // Noncompliant: ambiguous\n  // ...\n}\n\npublic void doTheThing (String ... args) {\n  // ...\n}\n\npublic void doTheOtherThing(Object ... args) {\n  // ...\n}\n</pre>\n<h3>Compliant solution</h3>\n<pre>\npublic void callTheThing() {\n  //...\n  doTheThing(\"s1\", \"s2\");\n  doTheThing(new String[12]);\n  doTheOtherThing((Object[]) new String[8]);\n   // ...\n}\n\npublic void doTheThing (String ... args) {\n  // ...\n}\n\npublic void doTheOtherThing(Object ... args) {\n  // ...\n}\n</pre>",
    "howToFix": "",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "가변 인수 매개변수를 위해 배열을 생성하면 안 됩니다",
    "why_ko": "<p>varargs(<code>...</code>) 인수로 전달하기 위해서만 배열을 생성하는 것은 의미가 없습니다. varargs <em>자체가</em> 배열입니다. 요소를 직접 전달하세요. 자동으로 배열로 통합됩니다. <code>Object ...</code>가 예상되는 곳에 배열을 전달하면 의도가 모호해집니다: 배열이 하나의 객체인지 객체 컬렉션인지?</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\npublic void callTheThing() {\n  //...\n  doTheThing(new String[] { \"s1\", \"s2\"});  // 규칙 위반: 불필요함\n  doTheThing(new String[12]);  // 규칙 준수\n  doTheOtherThing(new String[8]);  // 규칙 위반: 모호함\n  // ...\n}\n\npublic void doTheThing (String ... args) {\n  // ...\n}\n\npublic void doTheOtherThing(Object ... args) {\n  // ...\n}\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre>\npublic void callTheThing() {\n  //...\n  doTheThing(\"s1\", \"s2\");\n  doTheThing(new String[12]);\n  doTheOtherThing((Object[]) new String[8]);\n   // ...\n}\n\npublic void doTheThing (String ... args) {\n  // ...\n}\n\npublic void doTheOtherThing(Object ... args) {\n  // ...\n}\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": ""
  },
  {
    "id": "S3252",
    "key": "java:S3252",
    "name": "\"static\" base class members should not be accessed via derived types",
    "type": "code-smell",
    "severity": "critical",
    "tags": [
      "confusing"
    ],
    "why": "<p>In object-oriented programming, inappropriately accessing static members of a base class via derived types is considered a code smell.</p>\n<p>Static members are associated with the class itself, not with any specific instance of the class or its children classes. Accessing through the\nwrong type suggests a misunderstanding of the ownership and role of this member. This can make the maintenance of the code more complicated.</p>\n<p>Therefore, the access should be done directly through the base class to maintain clarity and avoid potential misunderstandings.</p>\n<h3>Noncompliant code example</h3>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\nclass Parent {\n  public static int counter;\n}\n\nclass Child extends Parent {\n  public Child() {\n    Child.counter++;  // Noncompliant\n  }\n}\n</pre>\n<h3>Compliant solution</h3>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\nclass Parent {\n  public static int counter;\n}\n\nclass Child extends Parent {\n  public Child() {\n    Parent.counter++;\n  }\n}\n</pre>",
    "howToFix": "",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "\"static\" 기본 클래스 멤버는 파생 타입을 통해 접근하면 안 됩니다","why_ko": "<p>객체 지향 프로그래밍에서, 기본 클래스의 static 멤버에 파생 타입을 통해 부적절하게 접근하는 것은 코드 스멜로 간주됩니다.</p>\n<p>static 멤버는 클래스의 특정 인스턴스나 자식 클래스가 아닌 클래스 자체와 연관됩니다. 잘못된 타입을 통한 접근은 이 멤버의 소유권과 역할에 대한 오해를 암시합니다. 이로 인해 코드 유지 관리가 더 복잡해질 수 있습니다.</p>\n<p>따라서 명확성을 유지하고 잠재적인 오해를 피하기 위해 기본 클래스를 통해 직접 접근해야 합니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\nclass Parent {\n  public static int counter;\n}\n\nclass Child extends Parent {\n  public Child() {\n    Child.counter++;  // 규칙 위반\n  }\n}\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\nclass Parent {\n  public static int counter;\n}\n\nclass Child extends Parent {\n  public Child() {\n    Parent.counter++;\n  }\n}\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": ""
  },
  {
    "id": "S6816",
    "key": "java:S6816",
    "name": "Nullable injected fields and parameters should provide a default value",
    "type": "bug",
    "severity": "critical",
    "tags": [
      "spring"
    ],
    "why": "<p>The <code>@Value</code> annotation does not guarantee that the property is defined. Particularly if a field or parameter is annotated as nullable,\nit indicates that the developer assumes that the property may be undefined.</p>\n<p>An undefined property may lead to runtime exceptions when the Spring framework tries to inject the autowired dependency during bean creation.</p>\n<p>This rule raises an issue when a nullable field or parameter is annotated with <code>@Value</code> and no default value is provided.</p>",
    "howToFix": "<p>Add a default value to the <code>@Value</code> annotation. A default value can be supplied by using the colon (<code>:</code>) operator. As the\nfield is nullable, the default value should most likely be <code>#{null}</code>.</p>\n\n<h4>Noncompliant code example</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\n@Nullable\n@Value(\"${my.property}\") // Noncompliant, no default value is provided, even though the field is nullable\nprivate String myProperty;\n</pre>\n<h4>Compliant solution</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\n@Nullable\n@Value(\"${my.property:#{null}}\") // Compliant, a default value is provided\nprivate String myProperty;\n</pre>",
    "moreInfo": "<h3>Articles &amp; blog posts</h3>\n<ul>\n  <li> Baeldung - <a href=\"https://www.baeldung.com/spring-value-defaults\">Using Spring @Value With Defaults</a> </li>\n</ul>",
    "status": "READY",
    "name_ko": "Nullable로 주입된 필드와 파라미터는 기본값을 제공해야 합니다",
    "why_ko": "<p><code>@Value</code> 어노테이션은 프로퍼티가 정의되어 있음을 보장하지 않습니다. 특히 필드나 파라미터가 nullable로 어노테이션되어 있으면 개발자가 프로퍼티가 정의되지 않을 수 있다고 가정한다는 것을 나타냅니다.</p>\n<p>정의되지 않은 프로퍼티는 Spring 프레임워크가 빈 생성 중에 자동 주입 의존성을 주입하려고 할 때 런타임 예외가 발생할 수 있습니다.</p>\n<p>이 규칙은 nullable 필드나 파라미터에 <code>@Value</code> 어노테이션이 있고 기본값이 제공되지 않을 때 문제를 발생시킵니다.</p>",
    "howToFix_ko": "<p><code>@Value</code> 어노테이션에 기본값을 추가하세요. 기본값은 콜론(<code>:</code>) 연산자를 사용하여 제공할 수 있습니다. 필드가 nullable이므로 기본값은 대부분 <code>#{null}</code>이어야 합니다.</p>\n\n<h4>규칙을 준수하지 않는 코드 예시</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\n@Nullable\n@Value(\"${my.property}\") // 규칙 위반, 필드가 nullable임에도 불구하고 기본값이 제공되지 않음\nprivate String myProperty;\n</pre>\n<h4>규칙을 준수하는 해결책</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\n@Nullable\n@Value(\"${my.property:#{null}}\") // 규칙 준수, 기본값이 제공됨\nprivate String myProperty;\n</pre>",
    "moreInfo_ko": "<h3>기사 및 블로그 게시물</h3>\n<ul>\n  <li> Baeldung - <a href=\"https://www.baeldung.com/spring-value-defaults\">기본값과 함께 Spring @Value 사용하기</a> </li>\n</ul>"
  },
  {
    "id": "S5693",
    "key": "java:S5693",
    "name": "Allowing requests with excessive content length is security-sensitive",
    "type": "security-hotspot",
    "severity": "major",
    "tags": [
      "cwe"
    ],
    "why": "<p>Rejecting requests with significant content length is a good practice to control the network traffic intensity and thus resource consumption in\norder to prevent DoS attacks.</p>\n",
    "howToFix": "<h2>Recommended Secure Coding Practices</h2>\n<ul>\n  <li> For most of the features of an application, it is recommended to limit the size of requests to:\n    <ul>\n      <li> lower or equal to 8mb for file uploads. </li>\n      <li> lower or equal to 2mb for other requests. </li>\n    </ul>  </li>\n</ul>\n<p>It is recommended to customize the rule with the limit values that correspond to the web application.</p>\n<h2>Compliant Solution</h2>\n<p>File upload size is limited to 8 MB:</p>\n<pre>\n@Bean(name = \"multipartResolver\")\npublic CommonsMultipartResolver multipartResolver() {\n  multipartResolver.setMaxUploadSize(8388608); // Compliant (8 MB)\n  return multipartResolver;\n}\n</pre>\n<h2>See</h2>\n<ul>\n  <li> OWASP - <a href=\"https://owasp.org/Top10/A05_2021-Security_Misconfiguration/\">Top 10 2021 Category A5 - Security Misconfiguration</a> </li>\n  <li> <a href=\"https://cheatsheetseries.owasp.org/cheatsheets/Denial_of_Service_Cheat_Sheet.html\">Owasp Cheat Sheet</a> - Owasp Denial of Service\n  Cheat Sheet </li>\n  <li> OWASP - <a href=\"https://owasp.org/www-project-top-ten/2017/A6_2017-Security_Misconfiguration\">Top 10 2017 Category A6 - Security\n  Misconfiguration</a> </li>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/770\">CWE-770 - Allocation of Resources Without Limits or Throttling</a> </li>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/400\">CWE-400 - Uncontrolled Resource Consumption</a> </li>\n</ul>",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "과도한 콘텐츠 길이의 요청 허용은 보안에 민감합니다",
    "why_ko": "<p>상당한 콘텐츠 길이를 가진 요청을 거부하는 것은 DoS 공격을 방지하기 위해 네트워크 트래픽 강도와 리소스 소비를 제어하는 좋은 관행입니다.</p>\n",
    "howToFix_ko": "<h2>권장 보안 코딩 관행</h2>\n<ul>\n  <li> 애플리케이션의 대부분의 기능에 대해 요청 크기를 다음으로 제한하는 것이 좋습니다:\n    <ul>\n      <li> 파일 업로드의 경우 8MB 이하. </li>\n      <li> 기타 요청의 경우 2MB 이하. </li>\n    </ul>  </li>\n</ul>\n<p>웹 애플리케이션에 해당하는 제한 값으로 규칙을 사용자 정의하는 것이 좋습니다.</p>\n<h2>규칙을 준수하는 해결책</h2>\n<p>파일 업로드 크기가 8MB로 제한됨:</p>\n<pre>\n@Bean(name = \"multipartResolver\")\npublic CommonsMultipartResolver multipartResolver() {\n  multipartResolver.setMaxUploadSize(8388608); // 규칙 준수 (8 MB)\n  return multipartResolver;\n}\n</pre>\n<h2>참고</h2>\n<ul>\n  <li> OWASP - <a href=\"https://owasp.org/Top10/A05_2021-Security_Misconfiguration/\">Top 10 2021 Category A5 - Security Misconfiguration</a> </li>\n  <li> <a href=\"https://cheatsheetseries.owasp.org/cheatsheets/Denial_of_Service_Cheat_Sheet.html\">Owasp Cheat Sheet</a> - Owasp Denial of Service Cheat Sheet </li>\n  <li> OWASP - <a href=\"https://owasp.org/www-project-top-ten/2017/A6_2017-Security_Misconfiguration\">Top 10 2017 Category A6 - Security Misconfiguration</a> </li>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/770\">CWE-770 - 제한 또는 조절 없는 리소스 할당</a> </li>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/400\">CWE-400 - 제어되지 않는 리소스 소비</a> </li>\n</ul>",
    "moreInfo_ko": ""
  },
  {
    "id": "S2156",
    "key": "java:S2156",
    "name": "\"final\" classes should not have \"protected\" members",
    "type": "code-smell",
    "severity": "minor",
    "tags": [
      "confusing"
    ],
    "why": "<p>The difference between <code>private</code> and <code>protected</code> visibility is that child classes can see and use <code>protected</code>\nmembers, but they cannot see <code>private</code> ones. Since a <code>final</code> class will have no children, marking the members of a\n<code>final</code> class <code>protected</code> is confusingly pointless.</p>\n<p>Note that the <code>protected</code> members of a class can also be seen and used by other classes that are placed within the same package, this\ncould lead to accidental, unintended access to otherwise private members.</p>\n<h3>Noncompliant code example</h3>\n<pre>\npublic final class MyFinalClass {\n\n  protected String name = \"Fred\";  // Noncompliant\n  protected void setName(String name) {  // Noncompliant\n    // ...\n  }\n</pre>\n<h3>Compliant solution</h3>\n<pre>\npublic final class MyFinalClass {\n\n  private String name = \"Fred\";\n  public void setName(String name) {\n    // ...\n  }\n</pre>\n<h3>Exceptions</h3>\n<p>Members annotated with&nbsp;<code>@VisibleForTesting</code> annotation are ignored, as it indicates that visibility has been purposely relaxed to\nmake the code testable.</p>\n<pre>\npublic final class MyFinalClass {\n  @VisibleForTesting\n  protected Logger logger; // Compliant\n\n  @VisibleForTesting\n  protected int calculateSomethingComplex(String input) { // Compliant\n    // ...\n  }\n}\n</pre>",
    "howToFix": "",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "\"final\" 클래스는 \"protected\" 멤버를 가지면 안 됩니다",
    "why_ko": "<p><code>private</code>과 <code>protected</code> 가시성의 차이점은 자식 클래스가 <code>protected</code> 멤버를 보고 사용할 수 있지만 <code>private</code> 멤버는 볼 수 없다는 것입니다. <code>final</code> 클래스는 자식 클래스가 없으므로 <code>final</code> 클래스의 멤버를 <code>protected</code>로 표시하는 것은 혼란스럽고 무의미합니다.</p>\n<p>클래스의 <code>protected</code> 멤버는 동일한 패키지 내에 있는 다른 클래스에서도 보고 사용할 수 있으며, 이로 인해 원래 private이어야 할 멤버에 대한 우발적이고 의도하지 않은 접근이 발생할 수 있습니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\npublic final class MyFinalClass {\n\n  protected String name = \"Fred\";  // 규칙 위반\n  protected void setName(String name) {  // 규칙 위반\n    // ...\n  }\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre>\npublic final class MyFinalClass {\n\n  private String name = \"Fred\";\n  public void setName(String name) {\n    // ...\n  }\n</pre>\n<h3>예외</h3>\n<p><code>@VisibleForTesting</code> 어노테이션이 붙은 멤버는 코드를 테스트 가능하게 만들기 위해 가시성이 의도적으로 완화되었음을 나타내므로 무시됩니다.</p>\n<pre>\npublic final class MyFinalClass {\n  @VisibleForTesting\n  protected Logger logger; // 규칙 준수\n\n  @VisibleForTesting\n  protected int calculateSomethingComplex(String input) { // 규칙 준수\n    // ...\n  }\n}\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": ""
  },
  {
    "id": "S7180",
    "key": "java:S7180",
    "name": "\"@Cache*\" annotations should only be applied on concrete classes",
    "type": "code-smell",
    "severity": "major",
    "tags": [
      "spring"
    ],
    "why": "<p>Annotating interfaces or interface methods with <code>@Cache*</code> annotations is not recommended by the official Spring documentation:</p>\n<pre>\nSpring recommends that you only annotate concrete classes (and methods of concrete classes) with the @Cache* annotations, as opposed to annotating interfaces. You certainly can place an @Cache* annotation on an interface (or an interface method), but this works only if you use the proxy mode (mode=\"proxy\"). If you use the weaving-based aspect (mode=\"aspectj\"), the caching settings are not recognized on interface-level declarations by the weaving infrastructure.\n</pre>\n<p>Also, when a method is annotated as cacheable inside an interface, if two different implementations of that method exist, the first one to be\ninvoked will populate the cache. Subsequent calls will always return the cached value, even if it's the other implementation being called.</p>\n<h3>What is the potential impact?</h3>\n<ul>\n  <li> <strong>Confusing Code</strong>: Developers may mistakenly believe that caching is in effect, leading to confusion and incorrect assumptions\n  about application performance. </li>\n  <li> <strong>Unreliable Code</strong>: Annotating interface methods as <code>@Cacheable</code> hides the cache name from the implementing classes,\n  making it hard to detect where a conflict of names might occur, causing unexpected results at runtime. </li>\n</ul>\n<p>This rule raises an issue when an interface or an interface method is annotated with a <code>@Cache*</code> annotation.</p>",
    "howToFix": "<p>Move <code>@Cache*</code> annotation from interface or interface method to the concrete class.</p>\n\n<h4>Noncompliant code example</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\npublic interface ExampleService {\n\n    @Cacheable(\"exampleCache\") // Noncompliant: interface method is annotated with @Cacheable\n    String getData(String id);\n}\n</pre>\n<p>In the following example, if our application has two different rest APIs to query the most popular animal in two different zoos, the first zoo to\nbe queried will populate the cache.</p>\n<p>Calls to a different API to query the other zoo will produce the same cached output, invalidating our application's business logic.</p>\n<pre data-diff-id=\"2\" data-diff-type=\"noncompliant\">\npublic interface Zoo {\n    @Cacheable(\"popAnimal\") //non compliant, interface method is annotated with @Cacheable\n    Animal getMostPopularAnimal();\n}\n\npublic class SanDiegoZoo implements Zoo {\n    @Override\n    public Animal getMostPopularAnimal() {\n        return new Lion();\n    }\n}\n\npublic class RomeBioparc implements Zoo {\n    @Override\n    public Animal getMostPopularAnimal() {\n        return new Pantegana();\n    }\n}\n</pre>\n<h4>Compliant solution</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\n@Service\npublic class ExampleServiceImpl implements ExampleService {\n\n    @Cacheable(\"exampleCache\")\n    @Override\n    public String getData(String id) {\n        // Implementation here\n    }\n}\n</pre>\n<p>With the following solution, we are granted that the two implementations will have separate caches.</p>\n<pre data-diff-id=\"2\" data-diff-type=\"compliant\">\npublic interface Zoo {\n    Animal getMostPopularAnimal();\n}\n\npublic class SanDiegoZoo implements Zoo {\n    @Override\n    @Cacheable(\"sanDiegoPopAnimal\")\n    public Animal getMostPopularAnimal() {\n        return new Lion();\n    }\n}\n\npublic class RomeBioparc implements Zoo {\n    @Override\n    @Cacheable(\"romePopAnimal\")\n    public Animal getMostPopularAnimal() {\n        return new Pantegana();\n    }\n}\n</pre>",
    "moreInfo": "<h3>Documentation</h3>\n<ul>\n  <li> Spring - <a href=\"https://docs.spring.io/spring-framework/reference/integration/cache/annotations.html#cache-annotation-enable\">Declarative\n  Annotation-based Caching</a> </li>\n</ul>",
    "status": "READY",
    "name_ko": "\"@Cache*\" 어노테이션은 구체 클래스에만 적용해야 합니다",
    "why_ko": "<p>공식 Spring 문서에서는 인터페이스나 인터페이스 메서드에 <code>@Cache*</code> 어노테이션을 적용하는 것을 권장하지 않습니다:</p>\n<pre>\nSpring은 인터페이스에 어노테이션을 적용하는 것이 아니라 구체 클래스(및 구체 클래스의 메서드)에만 @Cache* 어노테이션을 적용하는 것을 권장합니다. 인터페이스(또는 인터페이스 메서드)에 @Cache* 어노테이션을 배치할 수 있지만, 이는 프록시 모드(mode=\"proxy\")를 사용하는 경우에만 작동합니다. 위빙 기반 aspect(mode=\"aspectj\")를 사용하는 경우 위빙 인프라에서 인터페이스 레벨 선언의 캐싱 설정을 인식하지 못합니다.\n</pre>\n<p>또한 인터페이스 내부에서 메서드가 캐시 가능으로 어노테이션된 경우, 해당 메서드의 두 가지 다른 구현이 존재하면 먼저 호출된 구현이 캐시를 채웁니다. 다른 구현이 호출되더라도 후속 호출은 항상 캐시된 값을 반환합니다.</p>\n<h3>잠재적 영향은 무엇인가요?</h3>\n<ul>\n  <li> <strong>혼란스러운 코드</strong>: 개발자들이 캐싱이 적용되고 있다고 잘못 믿어 애플리케이션 성능에 대한 혼란과 잘못된 가정을 하게 될 수 있습니다. </li>\n  <li> <strong>신뢰할 수 없는 코드</strong>: 인터페이스 메서드를 <code>@Cacheable</code>로 어노테이션하면 구현 클래스에서 캐시 이름이 숨겨져 이름 충돌이 어디서 발생할 수 있는지 감지하기 어려워지고 런타임에 예기치 않은 결과가 발생합니다. </li>\n</ul>\n<p>이 규칙은 인터페이스 또는 인터페이스 메서드에 <code>@Cache*</code> 어노테이션이 적용될 때 문제를 발생시킵니다.</p>",
    "howToFix_ko": "<p><code>@Cache*</code> 어노테이션을 인터페이스 또는 인터페이스 메서드에서 구체 클래스로 이동하세요.</p>\n\n<h4>규칙을 준수하지 않는 코드 예시</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\npublic interface ExampleService {\n\n    @Cacheable(\"exampleCache\") // 규칙 위반: 인터페이스 메서드에 @Cacheable이 적용됨\n    String getData(String id);\n}\n</pre>\n<p>다음 예시에서 애플리케이션에 두 개의 다른 동물원에서 가장 인기 있는 동물을 조회하는 두 개의 다른 REST API가 있는 경우, 먼저 조회되는 동물원이 캐시를 채웁니다.</p>\n<p>다른 동물원을 조회하는 다른 API에 대한 호출은 동일한 캐시된 출력을 생성하여 애플리케이션의 비즈니스 로직을 무효화합니다.</p>\n<pre data-diff-id=\"2\" data-diff-type=\"noncompliant\">\npublic interface Zoo {\n    @Cacheable(\"popAnimal\") // 규칙 위반, 인터페이스 메서드에 @Cacheable이 적용됨\n    Animal getMostPopularAnimal();\n}\n\npublic class SanDiegoZoo implements Zoo {\n    @Override\n    public Animal getMostPopularAnimal() {\n        return new Lion();\n    }\n}\n\npublic class RomeBioparc implements Zoo {\n    @Override\n    public Animal getMostPopularAnimal() {\n        return new Pantegana();\n    }\n}\n</pre>\n<h4>규칙을 준수하는 해결책</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\n@Service\npublic class ExampleServiceImpl implements ExampleService {\n\n    @Cacheable(\"exampleCache\")\n    @Override\n    public String getData(String id) {\n        // 구현\n    }\n}\n</pre>\n<p>다음 해결책으로 두 구현이 별도의 캐시를 갖게 됩니다.</p>\n<pre data-diff-id=\"2\" data-diff-type=\"compliant\">\npublic interface Zoo {\n    Animal getMostPopularAnimal();\n}\n\npublic class SanDiegoZoo implements Zoo {\n    @Override\n    @Cacheable(\"sanDiegoPopAnimal\")\n    public Animal getMostPopularAnimal() {\n        return new Lion();\n    }\n}\n\npublic class RomeBioparc implements Zoo {\n    @Override\n    @Cacheable(\"romePopAnimal\")\n    public Animal getMostPopularAnimal() {\n        return new Pantegana();\n    }\n}\n</pre>",
    "moreInfo_ko": "<h3>문서</h3>\n<ul>\n  <li> Spring - <a href=\"https://docs.spring.io/spring-framework/reference/integration/cache/annotations.html#cache-annotation-enable\">선언적 어노테이션 기반 캐싱</a> </li>\n</ul>"
  },
  {
    "id": "S117",
    "key": "java:S117",
    "name": "Local variable and method parameter names should comply with a naming convention",
    "type": "code-smell",
    "severity": "minor",
    "tags": [
      "convention"
    ],
    "why": "<p>A naming convention in software development is a set of guidelines for naming code elements like variables, functions, and classes.<br> Local\nvariables and method parameters hold the meaning of the written code. Their names should be meaningful and follow a consistent and easily recognizable\npattern.<br> Adhering to a consistent naming convention helps to make the code more readable and understandable, which makes it easier to maintain and\ndebug. It also ensures consistency in the code, especially when multiple developers are working on the same project.</p>\n<p>This rule checks that local variable and method parameter names match a provided regular expression.</p>\n<h3>What is the potential impact?</h3>\n<p>Inconsistent naming of local variables and method parameters can lead to several issues in your code:</p>\n<ul>\n  <li> <strong>Reduced Readability</strong>: Inconsistent local variable and method parameter names make the code harder to read and understand;\n  consequently, it is more difficult to identify the purpose of each variable, spot errors, or comprehend the logic. </li>\n  <li> <strong>Difficulty in Identifying Variables</strong>: The local variables and method parameters that don't adhere to a standard naming\n  convention are challenging to identify; thus, the coding process slows down, especially when dealing with a large codebase. </li>\n  <li> <strong>Increased Risk of Errors</strong>: Inconsistent or unclear local variable and method parameter names lead to misunderstandings about\n  what the variable represents. This ambiguity leads to incorrect assumptions and, consequently, bugs in the code. </li>\n  <li> <strong>Collaboration Difficulties</strong>: In a team setting, inconsistent naming conventions lead to confusion and miscommunication among\n  team members. </li>\n  <li> <strong>Difficulty in Code Maintenance</strong>: Inconsistent naming leads to an inconsistent codebase. The code is difficult to understand,\n  and making changes feels like refactoring constantly, as you face different naming methods. Ultimately, it makes the codebase harder to maintain.\n  </li>\n</ul>\n<p>In summary, not adhering to a naming convention for local variables and method parameters can lead to confusion, errors, and inefficiencies, making\nthe code harder to read, understand, and maintain.</p>\n<h3>Exceptions</h3>\n<p>Loop counters are ignored by this rule.</p>\n<pre>\nfor (int i_1 = 0; i_1 &lt; limit; i_1++) {  // Compliant\n  // ...\n}\n</pre>\n<p>as well as one-character <code>catch</code> variables:</p>\n<pre>\ntry {\n//...\n} catch (Exception e) { // Compliant\n}\n</pre>",
    "howToFix": "<p>First, familiarize yourself with the particular naming convention of the project in question. Then, update the name to match the convention, as\nwell as all usages of the name. For many IDEs, you can use built-in renaming and refactoring features to update all usages at once.</p>\n\n<h4>Noncompliant code example</h4>\n<p>With the default regular expression <code>^[a-z][a-zA-Z0-9]*$</code>:</p>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\npublic class MyClass {\n    public void doSomething(int myParam) {\n      int LOCAL;    // Noncompliant\n      // ...\n    }\n}\n</pre>\n<h4>Compliant solution</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\npublic class MyClass {\n    public void doSomething(int my_param) {\n      int local;\n      // ...\n    }\n}\n</pre>",
    "moreInfo": "<h3>Documentation</h3>\n<ul>\n  <li> Oracle - <a href=\"https://www.oracle.com/java/technologies/javase/codeconventions-namingconventions.html\">Java SE Naming Conventions</a> </li>\n  <li> Geeksforgeeks - <a href=\"https://www.geeksforgeeks.org/java-naming-conventions/\">Java Naming Conventions</a> </li>\n  <li> Wikipedia - <a href=\"https://en.wikipedia.org/wiki/Naming_convention_(programming)\">Naming Convention (programming)</a> </li>\n</ul>\n<h3>Related rules</h3>\n<ul>\n  <li> <a href='/coding_rules#rule_key=java%3AS100'>S100</a> - Method names should comply with a naming convention </li>\n  <li> <a href='/coding_rules#rule_key=java%3AS101'>S101</a> - Class names should comply with a naming convention </li>\n  <li> <a href='/coding_rules#rule_key=java%3AS114'>S114</a> - Interface names should comply with a naming convention </li>\n  <li> <a href='/coding_rules#rule_key=java%3AS115'>S115</a> - Constant names should comply with a naming convention </li>\n  <li> <a href='/coding_rules#rule_key=java%3AS116'>S116</a> - Field names should comply with a naming convention </li>\n  <li> <a href='/coding_rules#rule_key=java%3AS118'>S118</a> - Abstract class names should comply with a naming convention </li>\n  <li> <a href='/coding_rules#rule_key=java%3AS119'>S119</a> - Type parameter names should comply with a naming convention </li>\n  <li> <a href='/coding_rules#rule_key=java%3AS120'>S120</a> - Package names should comply with a naming convention </li>\n  <li> <a href='/coding_rules#rule_key=java%3AS1312'>S1312</a> - Loggers should be \"private static final\" and should share a naming convention </li>\n  <li> <a href='/coding_rules#rule_key=java%3AS3008'>S3008</a> - Static non-final field names should comply with a naming convention </li>\n  <li> <a href='/coding_rules#rule_key=java%3AS3577'>S3577</a> - Test classes should comply with a naming convention </li>\n  <li> <a href='/coding_rules#rule_key=java%3AS3578'>S3578</a> - Test methods should comply with a naming convention </li>\n  <li> <a href='/coding_rules#rule_key=java%3AS4174'>S4174</a> - Local constants should follow naming conventions for constants </li>\n</ul>",
    "status": "READY",
    "name_ko": "지역 변수와 메서드 매개변수 이름은 명명 규칙을 준수해야 합니다",
    "why_ko": "<p>소프트웨어 개발에서 명명 규칙은 변수, 함수, 클래스와 같은 코드 요소의 이름을 지정하기 위한 가이드라인 집합입니다.<br> 지역 변수와 메서드 매개변수는 작성된 코드의 의미를 담고 있습니다. 이름은 의미 있어야 하며 일관되고 쉽게 인식할 수 있는 패턴을 따라야 합니다.<br> 일관된 명명 규칙을 준수하면 코드를 더 읽기 쉽고 이해하기 쉽게 만들어 유지 관리하고 디버그하기 쉽게 합니다. 또한 특히 여러 개발자가 같은 프로젝트에서 작업할 때 코드의 일관성을 보장합니다.</p>\n<p>이 규칙은 지역 변수와 메서드 매개변수 이름이 제공된 정규 표현식과 일치하는지 확인합니다.</p>\n<h3>잠재적 영향은 무엇인가요?</h3>\n<p>지역 변수와 메서드 매개변수의 일관성 없는 명명은 코드에서 여러 문제를 일으킬 수 있습니다:</p>\n<ul>\n  <li> <strong>가독성 저하</strong>: 일관성 없는 지역 변수와 메서드 매개변수 이름은 코드를 읽고 이해하기 어렵게 만듭니다. 결과적으로 각 변수의 목적을 식별하거나 오류를 발견하거나 로직을 이해하기가 더 어려워집니다. </li>\n  <li> <strong>변수 식별의 어려움</strong>: 표준 명명 규칙을 따르지 않는 지역 변수와 메서드 매개변수는 식별하기 어렵습니다. 따라서 특히 대규모 코드베이스를 다룰 때 코딩 프로세스가 느려집니다. </li>\n  <li> <strong>오류 위험 증가</strong>: 일관성 없거나 불명확한 지역 변수와 메서드 매개변수 이름은 변수가 무엇을 나타내는지에 대한 오해를 초래합니다. 이러한 모호함은 잘못된 가정과 결과적으로 코드의 버그로 이어집니다. </li>\n  <li> <strong>협업의 어려움</strong>: 팀 환경에서 일관성 없는 명명 규칙은 팀원 간의 혼란과 의사소통 오류를 초래합니다. </li>\n  <li> <strong>코드 유지 관리의 어려움</strong>: 일관성 없는 명명은 일관성 없는 코드베이스로 이어집니다. 코드를 이해하기 어렵고, 다른 명명 방법에 직면하면서 변경하는 것이 지속적인 리팩터링처럼 느껴집니다. 궁극적으로 코드베이스를 유지 관리하기 어렵게 만듭니다. </li>\n</ul>\n<p>요약하면, 지역 변수와 메서드 매개변수에 대한 명명 규칙을 준수하지 않으면 혼란, 오류, 비효율성을 초래하여 코드를 읽고 이해하고 유지 관리하기 어렵게 만들 수 있습니다.</p>\n<h3>예외</h3>\n<p>루프 카운터는 이 규칙에서 무시됩니다.</p>\n<pre>\nfor (int i_1 = 0; i_1 &lt; limit; i_1++) {  // 규칙 준수\n  // ...\n}\n</pre>\n<p>단일 문자 <code>catch</code> 변수도 마찬가지입니다:</p>\n<pre>\ntry {\n//...\n} catch (Exception e) { // 규칙 준수\n}\n</pre>",
    "howToFix_ko": "<p>먼저 해당 프로젝트의 특정 명명 규칙을 숙지하세요. 그런 다음 이름과 이름의 모든 사용을 규칙에 맞게 업데이트하세요. 많은 IDE에서 내장된 이름 바꾸기 및 리팩터링 기능을 사용하여 모든 사용을 한 번에 업데이트할 수 있습니다.</p>\n\n<h4>규칙을 준수하지 않는 코드 예시</h4>\n<p>기본 정규 표현식 <code>^[a-z][a-zA-Z0-9]*$</code>의 경우:</p>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\npublic class MyClass {\n    public void doSomething(int myParam) {\n      int LOCAL;    // 규칙 위반\n      // ...\n    }\n}\n</pre>\n<h4>규칙을 준수하는 해결책</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\npublic class MyClass {\n    public void doSomething(int my_param) {\n      int local;\n      // ...\n    }\n}\n</pre>",
    "moreInfo_ko": "<h3>문서</h3>\n<ul>\n  <li> Oracle - <a href=\"https://www.oracle.com/java/technologies/javase/codeconventions-namingconventions.html\">Java SE 명명 규칙</a> </li>\n  <li> Geeksforgeeks - <a href=\"https://www.geeksforgeeks.org/java-naming-conventions/\">Java 명명 규칙</a> </li>\n  <li> Wikipedia - <a href=\"https://en.wikipedia.org/wiki/Naming_convention_(programming)\">명명 규칙 (프로그래밍)</a> </li>\n</ul>\n<h3>관련 규칙</h3>\n<ul>\n  <li> <a href='/coding_rules#rule_key=java%3AS100'>S100</a> - 메서드 이름은 명명 규칙을 준수해야 합니다 </li>\n  <li> <a href='/coding_rules#rule_key=java%3AS101'>S101</a> - 클래스 이름은 명명 규칙을 준수해야 합니다 </li>\n  <li> <a href='/coding_rules#rule_key=java%3AS114'>S114</a> - 인터페이스 이름은 명명 규칙을 준수해야 합니다 </li>\n  <li> <a href='/coding_rules#rule_key=java%3AS115'>S115</a> - 상수 이름은 명명 규칙을 준수해야 합니다 </li>\n  <li> <a href='/coding_rules#rule_key=java%3AS116'>S116</a> - 필드 이름은 명명 규칙을 준수해야 합니다 </li>\n  <li> <a href='/coding_rules#rule_key=java%3AS118'>S118</a> - 추상 클래스 이름은 명명 규칙을 준수해야 합니다 </li>\n  <li> <a href='/coding_rules#rule_key=java%3AS119'>S119</a> - 타입 매개변수 이름은 명명 규칙을 준수해야 합니다 </li>\n  <li> <a href='/coding_rules#rule_key=java%3AS120'>S120</a> - 패키지 이름은 명명 규칙을 준수해야 합니다 </li>\n  <li> <a href='/coding_rules#rule_key=java%3AS1312'>S1312</a> - 로거는 \"private static final\"이어야 하며 명명 규칙을 공유해야 합니다 </li>\n  <li> <a href='/coding_rules#rule_key=java%3AS3008'>S3008</a> - static non-final 필드 이름은 명명 규칙을 준수해야 합니다 </li>\n  <li> <a href='/coding_rules#rule_key=java%3AS3577'>S3577</a> - 테스트 클래스는 명명 규칙을 준수해야 합니다 </li>\n  <li> <a href='/coding_rules#rule_key=java%3AS3578'>S3578</a> - 테스트 메서드는 명명 규칙을 준수해야 합니다 </li>\n  <li> <a href='/coding_rules#rule_key=java%3AS4174'>S4174</a> - 지역 상수는 상수에 대한 명명 규칙을 따라야 합니다 </li>\n</ul>"
  },
  {
    "id": "S3985",
    "key": "java:S3985",
    "name": "Unused \"private\" classes should be removed",
    "type": "code-smell",
    "severity": "major",
    "tags": [
      "unused"
    ],
    "why": "<p><code>private</code> classes that are never used are dead code: unnecessary, inoperative code that should be removed. Cleaning out dead code\ndecreases the size of the maintained codebase, making it easier to understand the program and preventing bugs from being introduced.</p>\n\n<h3>Noncompliant code example</h3>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\npublic class TopLevel\n{\n  private class Nested {...} // Noncompliant: Nested is never used\n}\n</pre>\n<h4>Compliant solution</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\npublic class TopLevel\n{\n  void doSomething() {\n    Nested a = new Nested();\n    ...\n  }\n  private class Nested {...}\n}\n</pre>",
    "howToFix": "",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "사용되지 않는 \"private\" 클래스는 제거해야 합니다",
    "why_ko": "<p>사용되지 않는 <code>private</code> 클래스는 죽은 코드입니다: 불필요하고 작동하지 않는 코드로 제거해야 합니다. 죽은 코드를 정리하면 유지 관리되는 코드베이스의 크기가 줄어들어 프로그램을 이해하기 쉽고 버그가 도입되는 것을 방지합니다.</p>\n\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\npublic class TopLevel\n{\n  private class Nested {...} // 규칙 위반: Nested가 사용되지 않습니다\n}\n</pre>\n<h4>규칙을 준수하는 해결책</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\npublic class TopLevel\n{\n  void doSomething() {\n    Nested a = new Nested();\n    ...\n  }\n  private class Nested {...}\n}\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": ""
  },
  {
    "id": "S1111",
    "key": "java:S1111",
    "name": "The \"Object.finalize()\" method should not be called",
    "type": "bug",
    "severity": "major",
    "tags": [
      "cwe",
      "cert"
    ],
    "why": "<p>Before it reclaims storage from an object that is no longer referenced, the garbage collector calls <code>finalize()</code> on the object.</p>\n<p>This is a good time to release resources held by the object.</p>\n<p>Because the general contract is that the <code>finalize</code> method should only be called once per object, calling this method explicitly is\nmisleading and does not respect this contract.</p>\n<h3>What is the potential impact?</h3>\n<p>An explicit call to an object's finalize method will perform operations that most likely were supposed to be performed only when the object was not\nreferenced anymore by any thread.</p>\n<p>Since it is an acceptable practice to override the finalize method in any subclass of <code>Object</code>, by invoking it explicitly, we will run\ncode that was designed to only be ran at a different time.</p>\n<h3>Noncompliant code example</h3>\n<pre>\npublic void dispose() throws Throwable {\n  this.finalize();                       // Noncompliant\n}\n</pre>",
    "howToFix": "",
    "moreInfo": "<ul>\n  <li> <a href=\"https://docs.oracle.com/javase/specs/jls/se17/html/jls-12.html#jls-12.6\">docs.oracle.com</a> - Finalization of Class Instances </li>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/586\">CWE-586 - Explicit Call to Finalize()</a> </li>\n  <li> <a href=\"https://wiki.sei.cmu.edu/confluence/x/4jZGBQ\">CERT, MET12-J.</a> - Do not use finalizers </li>\n</ul>",
    "status": "READY",
    "name_ko": "\"Object.finalize()\" 메서드는 호출하면 안 됩니다",
    "why_ko": "<p>가비지 컬렉터는 더 이상 참조되지 않는 객체에서 저장소를 회수하기 전에 해당 객체의 <code>finalize()</code>를 호출합니다.</p>\n<p>이는 객체가 보유한 리소스를 해제하기에 좋은 시점입니다.</p>\n<p><code>finalize</code> 메서드는 객체당 한 번만 호출되어야 한다는 일반적인 계약이 있으므로, 이 메서드를 명시적으로 호출하는 것은 오해를 불러일으키고 이 계약을 준수하지 않는 것입니다.</p>\n<h3>잠재적 영향은 무엇인가요?</h3>\n<p>객체의 finalize 메서드를 명시적으로 호출하면 어떤 스레드에서도 객체가 더 이상 참조되지 않을 때만 수행되어야 했던 작업이 수행됩니다.</p>\n<p><code>Object</code>의 모든 서브클래스에서 finalize 메서드를 오버라이드하는 것이 허용되는 관행이므로, 명시적으로 호출하면 다른 시점에서만 실행되도록 설계된 코드가 실행됩니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\npublic void dispose() throws Throwable {\n  this.finalize();                       // 규칙 위반\n}\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": "<ul>\n  <li> <a href=\"https://docs.oracle.com/javase/specs/jls/se17/html/jls-12.html#jls-12.6\">docs.oracle.com</a> - 클래스 인스턴스의 종료화 </li>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/586\">CWE-586 - Finalize()의 명시적 호출</a> </li>\n  <li> <a href=\"https://wiki.sei.cmu.edu/confluence/x/4jZGBQ\">CERT, MET12-J.</a> - finalizer를 사용하지 마세요 </li>\n</ul>"
  },
  {
    "id": "S1541",
    "key": "java:S1541",
    "name": "Methods should not be too complex",
    "type": "code-smell",
    "severity": "critical",
    "tags": [
      "brain-overload"
    ],
    "why": "<p>The cyclomatic complexity of methods should not exceed a defined threshold.</p>\n<p>Complex code can perform poorly and will in any case be difficult to understand and therefore to maintain.</p>\n<h3>Exceptions</h3>\n<p>While having a large number of fields in a class may indicate that it should be split, this rule nonetheless ignores high complexity in\n<code>equals</code> and <code>hashCode</code> methods.</p>",
    "howToFix": "",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "메서드는 너무 복잡하면 안 됩니다",
    "why_ko": "<p>메서드의 순환 복잡도는 정의된 임계값을 초과하면 안 됩니다.</p>\n<p>복잡한 코드는 성능이 저하될 수 있으며 어떤 경우에도 이해하기 어렵고 따라서 유지보수하기 어렵습니다.</p>\n<h3>예외</h3>\n<p>클래스에 많은 필드가 있으면 분할해야 함을 나타낼 수 있지만, 이 규칙은 <code>equals</code> 및 <code>hashCode</code> 메서드의 높은 복잡도는 무시합니다.</p>",
    "howToFix_ko": "",
    "moreInfo_ko": ""
  },
  {
    "id": "S6904",
    "key": "java:S6904",
    "name": "Avoid using \"FetchType.EAGER\"",
    "type": "code-smell",
    "severity": "major",
    "tags": [
      "jpa",
      "sustainability",
      "sql"
    ],
    "why": "<p>Using <code>FetchType.EAGER</code> can lead to inefficient data loading and potential performance issues. Eager Loading initializes associated data\non the spot, potentially fetching more data than needed.</p>",
    "howToFix": "<p>Remove or replace <code>FetchType.EAGER</code> with <code>FetchType.LAZY</code> in JPA annotations.</p>\n\n<h4>Noncompliant code example</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\n@OneToMany(mappedBy = \"parent\", fetch = FetchType.EAGER) // Noncompliant\nprivate List&lt;ChildEntity&gt; children;\n\n@OneToMany(mappedBy = \"child\", fetch = FetchType.EAGER) // Noncompliant\nprivate List&lt;ParentEntity&gt; parents;\n</pre>\n<h4>Compliant solution</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\n@OneToMany(mappedBy = \"parent\", fetch = FetchType.LAZY) // Compliant\nprivate List&lt;ChildEntity&gt; children;\n\n@OneToMany(mappedBy = \"child\") // Compliant\nprivate List&lt;ParentEntity&gt; parents;\n</pre>",
    "moreInfo": "<h3>Documentation</h3>\n<ul>\n  <li> <a href=\"https://docs.oracle.com/javaee/7/api/javax/persistence/FetchType.html\">Java EE 7 API - FetchType</a> </li>\n</ul>",
    "status": "READY",
    "name_ko": "FetchType.EAGER 사용을 피해야 합니다",
    "why_ko": "<p><code>FetchType.EAGER</code>를 사용하면 비효율적인 데이터 로딩과 잠재적인 성능 문제가 발생할 수 있습니다. Eager 로딩은 연관된 데이터를 즉시 초기화하여 필요한 것보다 더 많은 데이터를 가져올 수 있습니다.</p>",
    "howToFix_ko": "<p>JPA 어노테이션에서 <code>FetchType.EAGER</code>를 제거하거나 <code>FetchType.LAZY</code>로 교체하세요.</p>\n\n<h4>규칙을 준수하지 않는 코드 예시</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\n@OneToMany(mappedBy = \"parent\", fetch = FetchType.EAGER) // 규칙 위반\nprivate List&lt;ChildEntity&gt; children;\n\n@OneToMany(mappedBy = \"child\", fetch = FetchType.EAGER) // 규칙 위반\nprivate List&lt;ParentEntity&gt; parents;\n</pre>\n<h4>규칙을 준수하는 해결책</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\n@OneToMany(mappedBy = \"parent\", fetch = FetchType.LAZY) // 규칙 준수\nprivate List&lt;ChildEntity&gt; children;\n\n@OneToMany(mappedBy = \"child\") // 규칙 준수\nprivate List&lt;ParentEntity&gt; parents;\n</pre>",
    "moreInfo_ko": "<h3>문서</h3>\n<ul>\n  <li> <a href=\"https://docs.oracle.com/javaee/7/api/javax/persistence/FetchType.html\">Java EE 7 API - FetchType</a> </li>\n</ul>"
  },
  {
    "id": "S3655",
    "key": "java:S3655",
    "name": "Optional value should only be accessed after calling isPresent()",
    "type": "bug",
    "severity": "major",
    "tags": [
      "cwe",
      "symbolic-execution"
    ],
    "why": "<p><code>Optional</code> value can hold either a value or not. The value held in the <code>Optional</code> can be accessed using the\n<code>get()</code> method, but it will throw a</p>\n<p><code>NoSuchElementException</code> if there is no value present. To avoid the exception, calling the <code>isPresent()</code> or <code>!\nisEmpty()</code> method should always be done before any call to <code>get()</code>.</p>\n<p>Alternatively, note that other methods such as <code>orElse(...)</code>, <code>orElseGet(...)</code> or <code>orElseThrow(...)</code> can be used\nto specify what to do with an empty <code>Optional</code>.</p>\n<h3>Noncompliant code example</h3>\n<pre>\nOptional&lt;String&gt; value = this.getOptionalValue();\n\n// ...\n\nString stringValue = value.get(); // Noncompliant\n</pre>\n<pre>\nif (methodThatReturnsOptional().isEmpty()) {\n  throw new NotFoundException();\n}\nString value = methodThatReturnsOptional().get(); // Noncompliant: indirect access, we consider that two consecutive calls can return different values.\n</pre>\n<h3>Compliant solution</h3>\n<pre>\nthis.getOptionalValue().ifPresent(stringValue -&gt;\n  // Do something with stringValue\n);\n</pre>\n<p>or</p>\n<pre>\nOptional&lt;String&gt; value = this.getOptionalValue();\n\n// ...\n\nif (value.isPresent()) {\n  String stringValue = value.get();\n}\n</pre>\n<p>or</p>\n<pre>\nOptional&lt;String&gt; value = this.getOptionalValue();\n\n// ...\n\nString stringValue = value.orElse(\"default\");\n</pre>\n<pre>\nOptional&lt;String&gt; optional = methodThatReturnsOptional();\nif (optional.isEmpty()) {\n  throw new NotFoundException();\n}\nString value = optional.get();\n</pre>",
    "howToFix": "",
    "moreInfo": "<ul>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/476\">CWE-476 - NULL Pointer Dereference</a> </li>\n</ul>",
    "status": "READY",
    "name_ko": "Optional 값은 isPresent() 호출 후에만 접근해야 합니다",
    "why_ko": "<p><code>Optional</code> 값은 값을 가지거나 가지지 않을 수 있습니다. <code>Optional</code>에 저장된 값은 <code>get()</code> 메서드를 사용하여 접근할 수 있지만, 값이 없으면</p>\n<p><code>NoSuchElementException</code>이 발생합니다. 예외를 피하려면 <code>get()</code>을 호출하기 전에 항상 <code>isPresent()</code> 또는 <code>!isEmpty()</code> 메서드를 호출해야 합니다.</p>\n<p>또는 <code>orElse(...)</code>, <code>orElseGet(...)</code> 또는 <code>orElseThrow(...)</code>와 같은 다른 메서드를 사용하여 빈 <code>Optional</code>에 대해 수행할 작업을 지정할 수 있습니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\nOptional&lt;String&gt; value = this.getOptionalValue();\n\n// ...\n\nString stringValue = value.get(); // 규칙 위반\n</pre>\n<pre>\nif (methodThatReturnsOptional().isEmpty()) {\n  throw new NotFoundException();\n}\nString value = methodThatReturnsOptional().get(); // 규칙 위반: 간접 접근, 두 번의 연속 호출이 다른 값을 반환할 수 있다고 간주\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre>\nthis.getOptionalValue().ifPresent(stringValue -&gt;\n  // stringValue로 무언가 수행\n);\n</pre>\n<p>또는</p>\n<pre>\nOptional&lt;String&gt; value = this.getOptionalValue();\n\n// ...\n\nif (value.isPresent()) {\n  String stringValue = value.get();\n}\n</pre>\n<p>또는</p>\n<pre>\nOptional&lt;String&gt; value = this.getOptionalValue();\n\n// ...\n\nString stringValue = value.orElse(\"default\");\n</pre>\n<pre>\nOptional&lt;String&gt; optional = methodThatReturnsOptional();\nif (optional.isEmpty()) {\n  throw new NotFoundException();\n}\nString value = optional.get();\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": "<ul>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/476\">CWE-476 - NULL Pointer Dereference</a> </li>\n</ul>"
  },
  {
    "id": "S101",
    "key": "java:S101",
    "name": "Class names should comply with a naming convention",
    "type": "code-smell",
    "severity": "minor",
    "tags": [
      "convention"
    ],
    "why": "<p>Shared naming conventions allow teams to collaborate efficiently.</p>\n<p>This rule raises an issue when a class name does not match a provided regular expression.</p>\n<p>For example, with the default provided regular expression <code>^[A-Z][a-zA-Z0-9]*$</code>, the class:</p>\n<pre>\nclass my_class {...} // Noncompliant\n</pre>\n<p>should be renamed to</p>\n<pre>\nclass MyClass {...}\n</pre>",
    "howToFix": "",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "클래스 이름은 명명 규칙을 준수해야 합니다",
    "why_ko": "<p>공유된 명명 규칙은 팀이 효율적으로 협업할 수 있게 합니다.</p>\n<p>이 규칙은 클래스 이름이 제공된 정규 표현식과 일치하지 않을 때 이슈를 제기합니다.</p>\n<p>예를 들어, 기본 제공 정규 표현식 <code>^[A-Z][a-zA-Z0-9]*$</code>을 사용하면, 다음 클래스는:</p>\n<pre>\nclass my_class {...} // 규칙 위반\n</pre>\n<p>다음과 같이 이름을 변경해야 합니다</p>\n<pre>\nclass MyClass {...}\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": ""
  },
  {
    "id": "S1941",
    "key": "java:S1941",
    "name": "Variables should not be declared before they are relevant",
    "type": "code-smell",
    "severity": "minor",
    "tags": [
      "brain-overload"
    ],
    "why": "<p>For the sake of clarity, variables should be declared as close to where they're used as possible. This is particularly true when considering\nmethods that contain early returns and the potential to throw exceptions. In these cases, it is not only pointless, but also confusing to declare a\nvariable that may never be used because conditions for an early return are met first.</p>\n<h3>Noncompliant code example</h3>\n<pre>\npublic boolean isConditionMet(int a, int b) {\n  int difference = a - b;\n  MyClass foo = new MyClass(a);  // Noncompliant; not used before early return\n\n  if (difference &lt; 0) {\n    return false;\n  }\n\n  // ...\n\n  if (foo.doTheThing()) {\n    return true;\n  }\n  return false;\n}\n</pre>\n<h3>Compliant solution</h3>\n<pre>\npublic boolean isConditionMet(int a, int b) {\n  int difference = a - b;\n\n  if (difference &lt; 0) {\n    return false;\n  }\n\n  // ...\n\n  MyClass foo = new MyClass(a);\n  if (foo.doTheThing()) {\n    return true;\n  }\n  return false;\n}\n</pre>",
    "howToFix": "",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "변수는 필요한 시점보다 먼저 선언하면 안 됩니다",
    "why_ko": "<p>명확성을 위해 변수는 사용되는 곳에 최대한 가깝게 선언해야 합니다. 이것은 특히 조기 반환과 예외 발생 가능성이 있는 메서드를 고려할 때 그렇습니다. 이러한 경우, 조기 반환 조건이 먼저 충족되어 사용되지 않을 수 있는 변수를 선언하는 것은 무의미할 뿐만 아니라 혼란스럽습니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\npublic boolean isConditionMet(int a, int b) {\n  int difference = a - b;\n  MyClass foo = new MyClass(a);  // 규칙 위반; 조기 반환 전에 사용되지 않음\n\n  if (difference &lt; 0) {\n    return false;\n  }\n\n  // ...\n\n  if (foo.doTheThing()) {\n    return true;\n  }\n  return false;\n}\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre>\npublic boolean isConditionMet(int a, int b) {\n  int difference = a - b;\n\n  if (difference &lt; 0) {\n    return false;\n  }\n\n  // ...\n\n  MyClass foo = new MyClass(a);\n  if (foo.doTheThing()) {\n    return true;\n  }\n  return false;\n}\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": ""
  },
  {
    "id": "S1107",
    "key": "java:S1107",
    "name": "Close curly brace and the next \"else\", \"catch\" and \"finally\" keywords should be located on the same line",
    "type": "code-smell",
    "severity": "minor",
    "tags": [
      "convention"
    ],
    "why": "<p>Shared coding conventions make it possible for a team to collaborate efficiently.</p>\n<p>This rule makes it mandatory to place closing curly braces on the same line as the next <code>else</code>, <code>catch</code> or\n<code>finally</code> keywords.</p>\n<h3>Noncompliant code example</h3>\n<pre>\npublic void myMethod() {\n  if(something) {\n    executeTask();\n  } else if (somethingElse) {\n    doSomethingElse();\n  }\n  else {                               // Noncompliant\n     generateError();\n  }\n\n  try {\n    generateOrder();\n  } catch (Exception e) {\n    log(e);\n  }\n  finally {                            // Noncompliant\n    closeConnection();\n  }\n}\n</pre>\n<h3>Compliant solution</h3>\n<pre>\npublic void myMethod() {\n  if(something) {\n    executeTask();\n  } else if (somethingElse) {\n    doSomethingElse();\n  } else {\n     generateError();\n  }\n\n  try {\n    generateOrder();\n  } catch (Exception e) {\n    log(e);\n  } finally {\n    closeConnection();\n  }\n}\n</pre>",
    "howToFix": "",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "닫는 중괄호와 다음 \"else\", \"catch\", \"finally\" 키워드는 같은 줄에 위치해야 합니다",
    "why_ko": "<p>공유된 코딩 규칙은 팀이 효율적으로 협업할 수 있게 해줍니다.</p>\n<p>이 규칙은 닫는 중괄호를 다음 <code>else</code>, <code>catch</code> 또는 <code>finally</code> 키워드와 같은 줄에 배치하도록 의무화합니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\npublic void myMethod() {\n  if(something) {\n    executeTask();\n  } else if (somethingElse) {\n    doSomethingElse();\n  }\n  else {                               // 규칙 위반\n     generateError();\n  }\n\n  try {\n    generateOrder();\n  } catch (Exception e) {\n    log(e);\n  }\n  finally {                            // 규칙 위반\n    closeConnection();\n  }\n}\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre>\npublic void myMethod() {\n  if(something) {\n    executeTask();\n  } else if (somethingElse) {\n    doSomethingElse();\n  } else {\n     generateError();\n  }\n\n  try {\n    generateOrder();\n  } catch (Exception e) {\n    log(e);\n  } finally {\n    closeConnection();\n  }\n}\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": ""
  },
  {
    "id": "S7179",
    "key": "java:S7179",
    "name": "@Cacheable and @CachePut should not be combined",
    "type": "code-smell",
    "severity": "major",
    "tags": [
      "spring"
    ],
    "why": "<p><code>@Cacheable</code> annotation is used to store the result of a method and avoid executing it for the same inputs. <code>@CachePut</code>\ninstead is used to force the execution of a method and store the result in the cache. Annotating a method with both will produce unreliable behavior,\nexcept for specific corner-cases when their <code>condition()</code> or <code>unless()</code> expressions are mutually exclusive. Hence this pattern\nis strongly discouraged and an issue will be raised on such cases.</p>",
    "howToFix": "<h4>Noncompliant code example</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\n@Cacheable\n@CachePut\nvoid getBook(String isbn){ // Non compliant, methods annotated with both @Cacheable and @CachePut will not behave as intended\n    ...\n}\n</pre>\n<h4>Compliant solution</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\n@Cacheable\nvoid getBook(String isbn){\n    ...\n}\n</pre>",
    "moreInfo": "<h3>Documentation</h3>\n<ul>\n  <li> Spring Documentation - <a\n  href=\"https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/cache/annotation/CachePut.html\">@CachePut</a> </li>\n  <li> Spring Documentation - <a\n  href=\"https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/cache/annotation/Cacheable.html\">@Cacheable</a> </li>\n</ul>",
    "status": "READY",
    "name_ko": "@Cacheable과 @CachePut을 함께 사용하면 안 됩니다",
    "why_ko": "<p><code>@Cacheable</code> 어노테이션은 메서드의 결과를 저장하고 동일한 입력에 대해 실행을 피하는 데 사용됩니다. 반면 <code>@CachePut</code>은 메서드의 실행을 강제하고 결과를 캐시에 저장하는 데 사용됩니다. 두 어노테이션으로 메서드에 동시에 적용하면 <code>condition()</code> 또는 <code>unless()</code> 표현식이 상호 배타적인 특정 경우를 제외하고는 신뢰할 수 없는 동작이 발생합니다. 따라서 이 패턴은 강력히 권장되지 않으며 이러한 경우에 문제가 발생합니다.</p>",
    "howToFix_ko": "<h4>규칙을 준수하지 않는 코드 예시</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\n@Cacheable\n@CachePut\nvoid getBook(String isbn){ // 규칙 위반, @Cacheable과 @CachePut 둘 다 적용된 메서드는 의도대로 동작하지 않습니다\n    ...\n}\n</pre>\n<h4>규칙을 준수하는 해결책</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\n@Cacheable\nvoid getBook(String isbn){\n    ...\n}\n</pre>",
    "moreInfo_ko": "<h3>문서</h3>\n<ul>\n  <li> Spring 문서 - <a href=\"https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/cache/annotation/CachePut.html\">@CachePut</a> </li>\n  <li> Spring 문서 - <a href=\"https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/cache/annotation/Cacheable.html\">@Cacheable</a> </li>\n</ul>"
  },
  {
    "id": "S2681",
    "key": "java:S2681",
    "name": "Multiline blocks should be enclosed in curly braces",
    "type": "code-smell",
    "severity": "major",
    "tags": [
      "cwe",
      "cert"
    ],
    "why": "<p>Having inconsistent indentation and omitting curly braces from a control structure, such as an <code>if</code> statement or <code>for</code> loop,\nis misleading and can induce bugs.</p>\n<p>This rule raises an issue when the indentation of the lines after a control structure indicates an intent to include those lines in the block, but\nthe omission of curly braces means the lines will be unconditionally executed once.</p>\n<p>The following patterns are recognized:</p>\n<pre>\nif (condition)\n  firstActionInBlock();\n  secondAction();  // Noncompliant: secondAction is executed unconditionally\nthirdAction();\n</pre>\n<pre>\nif (condition) firstActionInBlock(); secondAction();  // Noncompliant: secondAction is executed unconditionally\n</pre>\n<pre>\nif (condition) firstActionInBlock();\n  secondAction();  // Noncompliant: secondAction is executed unconditionally\n</pre>\n<pre>\nif (condition); secondAction();  // Noncompliant: secondAction is executed unconditionally\n</pre>\n<pre>\nfor (int i = 0; i &lt; array.length; i++)\n  str = array[i];\n  doTheThing(str);  // Noncompliant: executed only on the last element\n</pre>\n<p>Note that this rule considers tab characters to be equivalent to 1 space. When mixing spaces and tabs, a code may look fine in one editor but be\nconfusing in another configured differently.</p>",
    "howToFix": "",
    "moreInfo": "<ul>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/483\">CWE-483 - Incorrect Block Delimitation</a> </li>\n  <li> <a href=\"https://wiki.sei.cmu.edu/confluence/x/MzZGBQ\">CERT, EXP52-J.</a> - Use braces for the body of an if, for, or while statement </li>\n</ul>",
    "status": "READY",
    "name_ko": "여러 줄 블록은 중괄호로 감싸야 합니다",
    "why_ko": "<p><code>if</code> 문이나 <code>for</code> 루프와 같은 제어 구조에서 일관성 없는 들여쓰기와 중괄호를 생략하면 오해의 소지가 있고 버그를 유발할 수 있습니다.</p>\n<p>이 규칙은 제어 구조 뒤의 줄 들여쓰기가 해당 줄을 블록에 포함시키려는 의도를 나타내지만, 중괄호가 생략되어 줄이 한 번 무조건 실행될 때 문제를 제기합니다.</p>\n<p>다음 패턴이 인식됩니다:</p>\n<pre>\nif (condition)\n  firstActionInBlock();\n  secondAction();  // 규칙 위반: secondAction이 무조건 실행됨\nthirdAction();\n</pre>\n<pre>\nif (condition) firstActionInBlock(); secondAction();  // 규칙 위반: secondAction이 무조건 실행됨\n</pre>\n<pre>\nif (condition) firstActionInBlock();\n  secondAction();  // 규칙 위반: secondAction이 무조건 실행됨\n</pre>\n<pre>\nif (condition); secondAction();  // 규칙 위반: secondAction이 무조건 실행됨\n</pre>\n<pre>\nfor (int i = 0; i &lt; array.length; i++)\n  str = array[i];\n  doTheThing(str);  // 규칙 위반: 마지막 요소에서만 실행됨\n</pre>\n<p>이 규칙은 탭 문자를 1개의 공백과 동일하게 간주합니다. 공백과 탭을 혼합할 때 코드가 한 편집기에서는 괜찮아 보이지만 다르게 구성된 다른 편집기에서는 혼란스러울 수 있습니다.</p>",
    "howToFix_ko": "",
    "moreInfo_ko": "<ul>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/483\">CWE-483 - 잘못된 블록 구분</a> </li>\n  <li> <a href=\"https://wiki.sei.cmu.edu/confluence/x/MzZGBQ\">CERT, EXP52-J.</a> - if, for 또는 while 문의 본문에 중괄호를 사용하십시오 </li>\n</ul>"
  },
  {
    "id": "S6912",
    "key": "java:S6912",
    "name": "Use batch Processing in JDBC",
    "type": "code-smell",
    "severity": "major",
    "tags": [
      "sustainability",
      "sql"
    ],
    "why": "<p>Executing a batch of SQL queries instead of individual queries improves performance by reducing communication overhead with the database.</p>\n<p>Batching SQL statements is beneficial in common situations where a SQL statement is executed within a loop. In such cases, adding the statement to\na batch and subsequently executing it reduces the number of interactions with the database. This results in improved efficiency and faster execution\ntimes.</p>\n<p>The rule raises an issue when it detects a <code>java.sql.Statement</code> being executed within a loop instruction, such as <code>for</code>,\n<code>while</code> or the <code>forEach</code> method of <code>java.lang.Iterable</code>, <code>java.util.Map</code> and\n<code>java.util.stream.Stream</code>.</p>",
    "howToFix": "<p>Group SQL statements by using the method <code>addBatch</code> to add them to a batch and then execute them using <code>executeBatch</code> to send\nthem to the database in a single call.</p>\n\n<h4>Noncompliant code example</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\npublic void execute(Connection connection) {\n  try {\n    Statement statement = connection.createStatement();\n\n    for (int i = 0; i &lt; 10; i++) {\n      statement.execute(\"INSERT INTO myTable (column1, column2) VALUES (\" + i + \", 'value\" + i + \"')\"); // Noncompliant\n    }\n\n    statement.close();\n    connection.close();\n  } catch (SQLException e) {\n    e.printStackTrace();\n  }\n}\n</pre>\n<h4>Compliant solution</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\npublic void execute(Connection connection) {\n  try {\n    Statement statement = connection.createStatement();\n\n    for (int i = 0; i &lt; 10; i++) {\n      statement.addBatch(\"INSERT INTO myTable (column1, column2) VALUES (\" + i + \", 'value\" + i + \"')\"); // Compliant\n    }\n    statement.executeBatch();\n\n    statement.close();\n    connection.close();\n  } catch (SQLException e) {\n    e.printStackTrace();\n  }\n}\n</pre>",
    "moreInfo": "<h3>Documentation</h3>\n<ul>\n  <li> <a href=\"https://docs.oracle.com/en/java/javase/21/docs/api/java.sql/java/sql/Statement.html\">Oracle Java SE 21 API - java.sql.Statement</a>\n  </li>\n  <li> <a href=\"https://docs.oracle.com/en/java/javase/21/docs/api/java.sql/java/sql/PreparedStatement.html\">Oracle Java SE 21 API -\n  java.sql.PreparedStatement</a> </li>\n</ul>\n<h3>Articles &amp; blog posts</h3>\n<ul>\n  <li> <a href=\"https://www.baeldung.com/jdbc-batch-processing\">Baeldung - JDBC Batch Processing</a> </li>\n</ul>",
    "status": "READY",
    "name_ko": "JDBC에서 배치 처리를 사용해야 합니다",
    "why_ko": "<p>개별 쿼리 대신 SQL 쿼리 배치를 실행하면 데이터베이스와의 통신 오버헤드를 줄여 성능이 향상됩니다.</p>\n<p>SQL 문을 배치 처리하는 것은 루프 내에서 SQL 문이 실행되는 일반적인 상황에서 유용합니다. 이러한 경우 문을 배치에 추가한 다음 실행하면 데이터베이스와의 상호 작용 횟수가 줄어듭니다. 이로 인해 효율성이 향상되고 실행 시간이 빨라집니다.</p>\n<p>이 규칙은 <code>for</code>, <code>while</code> 또는 <code>java.lang.Iterable</code>, <code>java.util.Map</code>, <code>java.util.stream.Stream</code>의 <code>forEach</code> 메서드와 같은 루프 명령 내에서 <code>java.sql.Statement</code>가 실행되는 것을 감지할 때 문제를 발생시킵니다.</p>",
    "howToFix_ko": "<p><code>addBatch</code> 메서드를 사용하여 SQL 문을 배치에 추가한 다음 <code>executeBatch</code>를 사용하여 단일 호출로 데이터베이스에 전송하세요.</p>\n\n<h4>규칙을 준수하지 않는 코드 예시</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\npublic void execute(Connection connection) {\n  try {\n    Statement statement = connection.createStatement();\n\n    for (int i = 0; i &lt; 10; i++) {\n      statement.execute(\"INSERT INTO myTable (column1, column2) VALUES (\" + i + \", 'value\" + i + \"')\"); // 규칙 위반\n    }\n\n    statement.close();\n    connection.close();\n  } catch (SQLException e) {\n    e.printStackTrace();\n  }\n}\n</pre>\n<h4>규칙을 준수하는 해결책</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\npublic void execute(Connection connection) {\n  try {\n    Statement statement = connection.createStatement();\n\n    for (int i = 0; i &lt; 10; i++) {\n      statement.addBatch(\"INSERT INTO myTable (column1, column2) VALUES (\" + i + \", 'value\" + i + \"')\"); // 규칙 준수\n    }\n    statement.executeBatch();\n\n    statement.close();\n    connection.close();\n  } catch (SQLException e) {\n    e.printStackTrace();\n  }\n}\n</pre>",
    "moreInfo_ko": "<h3>문서</h3>\n<ul>\n  <li> <a href=\"https://docs.oracle.com/en/java/javase/21/docs/api/java.sql/java/sql/Statement.html\">Oracle Java SE 21 API - java.sql.Statement</a> </li>\n  <li> <a href=\"https://docs.oracle.com/en/java/javase/21/docs/api/java.sql/java/sql/PreparedStatement.html\">Oracle Java SE 21 API - java.sql.PreparedStatement</a> </li>\n</ul>\n<h3>기사 및 블로그 게시물</h3>\n<ul>\n  <li> <a href=\"https://www.baeldung.com/jdbc-batch-processing\">Baeldung - JDBC 배치 처리</a> </li>\n</ul>"
  },
  {
    "id": "S6857",
    "key": "java:S6857",
    "name": "SpEL expression should have a valid syntax",
    "type": "bug",
    "severity": "critical",
    "tags": [
      "spring"
    ],
    "why": "<p>Only the Spring framework, not the Java compiler, parses <code>SpEL</code> expression inside Spring annotations. This means that the Java compiler\ndoes not detect invalid <code>SpEL</code> expressions during compile time. They will cause exceptions during runtime instead, or even fail silently\nwhen Spring interprets the expression as a simple string literal.</p>\n<h3>Exceptions</h3>\n<p>This rule reports syntactical errors in <code>SpEL</code> expressions but does not consider semantic errors, such as unknown identifiers or\nincompatible operand data types.</p>",
    "howToFix": "<p>Correct the syntax error in the SpEL expression.</p>\n\n<h4>Noncompliant code example</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\n@Value(\"#{systemProperties['user.region'}\") // Noncompliant: unclosed \"[\"\nprivate String region;\n</pre>\n<pre data-diff-id=\"2\" data-diff-type=\"noncompliant\">\n@Value(\"#{'${listOfValues}' split(',')}\") // Noncompliant: missing operator\nprivate List&lt;String&gt; valuesList;\n</pre>\n<pre data-diff-id=\"3\" data-diff-type=\"noncompliant\">\n@Value(\"#{T(java.lang.Math).random() * 64h}\") // Noncompliant: invalid number\nprivate Double randPercent;\n</pre>\n<pre data-diff-id=\"4\" data-diff-type=\"noncompliant\">\n@Query(\"SELECT u FROM User u WHERE u.status = :#{#status+}\") // Noncompliant: missing operand for \"+\"\nList&lt;User&gt; findUsersByStatus(@Param(\"status\") String status);\n</pre>\n<pre data-diff-id=\"5\" data-diff-type=\"noncompliant\">\n@Value(\"${myapp.!prop}\") // Noncompliant: property key contains an exclamation mark \"!\"\nprivate String myProperty;\n</pre>\n<pre data-diff-id=\"6\" data-diff-type=\"noncompliant\">\n@Value(\"${my.property:#{1**1}}\") // Noncompliant: invalid SpEL expression \"1**1\"\nprivate Integer myValue;\n</pre>\n<h4>Compliant solution</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\n@Value(\"#{systemProperties['user.region']}\") // Compliant\nprivate String region;\n</pre>\n<pre data-diff-id=\"2\" data-diff-type=\"compliant\">\n@Value(\"#{'${listOfValues}'.split(',')}\") // Compliant\nprivate List&lt;String&gt; valuesList;\n</pre>\n<pre data-diff-id=\"3\" data-diff-type=\"compliant\">\n@Value(\"#{T(java.lang.Math).random() * 100.0}\") // Compliant\nprivate Double randPercent;\n</pre>\n<pre data-diff-id=\"4\" data-diff-type=\"compliant\">\n@Query(\"SELECT u FROM User u WHERE u.status = :#{#status+42}\") // Compliant\nList&lt;User&gt; findUsersByStatus(@Param(\"status\") String status);\n</pre>\n<pre data-diff-id=\"5\" data-diff-type=\"compliant\">\n@Value(\"${myapp.prop}\") // Compliant\nprivate String myProperty;\n</pre>\n<pre data-diff-id=\"6\" data-diff-type=\"compliant\">\n@Value(\"${my.property:#{1*1}}\") // Compliant\nprivate Integer myValue;\n</pre>",
    "moreInfo": "<h3>Documentation</h3>\n<ul>\n  <li> Spring Framework Documentation - <a href=\"https://docs.spring.io/spring-framework/reference/core/expressions.html\">Spring Expression Language\n  (SpEL)</a> </li>\n</ul>",
    "status": "READY",
    "name_ko": "SpEL 표현식은 유효한 구문이어야 합니다",
    "why_ko": "<p>Java 컴파일러가 아닌 Spring 프레임워크만 Spring 어노테이션 내의 <code>SpEL</code> 표현식을 파싱합니다. 이는 Java 컴파일러가 컴파일 시점에 유효하지 않은 <code>SpEL</code> 표현식을 감지하지 못한다는 것을 의미합니다. 대신 런타임에 예외가 발생하거나 Spring이 표현식을 단순 문자열 리터럴로 해석하여 조용히 실패할 수 있습니다.</p>\n<h3>예외</h3>\n<p>이 규칙은 <code>SpEL</code> 표현식의 구문 오류를 보고하지만 알 수 없는 식별자나 호환되지 않는 피연산자 데이터 타입과 같은 의미 오류는 고려하지 않습니다.</p>",
    "howToFix_ko": "<p>SpEL 표현식의 구문 오류를 수정하세요.</p>\n\n<h4>규칙을 준수하지 않는 코드 예시</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\n@Value(\"#{systemProperties['user.region'}\") // 규칙 위반: 닫히지 않은 \"[\"\nprivate String region;\n</pre>\n<pre data-diff-id=\"2\" data-diff-type=\"noncompliant\">\n@Value(\"#{'${listOfValues}' split(',')}\") // 규칙 위반: 연산자 누락\nprivate List&lt;String&gt; valuesList;\n</pre>\n<pre data-diff-id=\"3\" data-diff-type=\"noncompliant\">\n@Value(\"#{T(java.lang.Math).random() * 64h}\") // 규칙 위반: 유효하지 않은 숫자\nprivate Double randPercent;\n</pre>\n<pre data-diff-id=\"4\" data-diff-type=\"noncompliant\">\n@Query(\"SELECT u FROM User u WHERE u.status = :#{#status+}\") // 규칙 위반: \"+\"에 대한 피연산자 누락\nList&lt;User&gt; findUsersByStatus(@Param(\"status\") String status);\n</pre>\n<pre data-diff-id=\"5\" data-diff-type=\"noncompliant\">\n@Value(\"${myapp.!prop}\") // 규칙 위반: 속성 키에 느낌표 \"!\" 포함\nprivate String myProperty;\n</pre>\n<pre data-diff-id=\"6\" data-diff-type=\"noncompliant\">\n@Value(\"${my.property:#{1**1}}\") // 규칙 위반: 유효하지 않은 SpEL 표현식 \"1**1\"\nprivate Integer myValue;\n</pre>\n<h4>규칙을 준수하는 해결책</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\n@Value(\"#{systemProperties['user.region']}\") // 규칙 준수\nprivate String region;\n</pre>\n<pre data-diff-id=\"2\" data-diff-type=\"compliant\">\n@Value(\"#{'${listOfValues}'.split(',')}\") // 규칙 준수\nprivate List&lt;String&gt; valuesList;\n</pre>\n<pre data-diff-id=\"3\" data-diff-type=\"compliant\">\n@Value(\"#{T(java.lang.Math).random() * 100.0}\") // 규칙 준수\nprivate Double randPercent;\n</pre>\n<pre data-diff-id=\"4\" data-diff-type=\"compliant\">\n@Query(\"SELECT u FROM User u WHERE u.status = :#{#status+42}\") // 규칙 준수\nList&lt;User&gt; findUsersByStatus(@Param(\"status\") String status);\n</pre>\n<pre data-diff-id=\"5\" data-diff-type=\"compliant\">\n@Value(\"${myapp.prop}\") // 규칙 준수\nprivate String myProperty;\n</pre>\n<pre data-diff-id=\"6\" data-diff-type=\"compliant\">\n@Value(\"${my.property:#{1*1}}\") // 규칙 준수\nprivate Integer myValue;\n</pre>",
    "moreInfo_ko": "<h3>문서</h3>\n<ul>\n  <li> Spring Framework 문서 - <a href=\"https://docs.spring.io/spring-framework/reference/core/expressions.html\">Spring 표현식 언어 (SpEL)</a> </li>\n</ul>"
  },
  {
    "id": "S5778",
    "key": "java:S5778",
    "name": "Only one method invocation is expected when testing runtime exceptions",
    "type": "code-smell",
    "severity": "major",
    "tags": [
      "junit",
      "tests"
    ],
    "why": "<p>When verifying that code raises a runtime exception, a good practice is to avoid having multiple method calls inside the tested code, to be\nexplicit about which method call is expected to raise the exception.</p>\n<p>It increases the clarity of the test, and avoid incorrect testing when another method is actually raising the exception.</p>\n<h3>Noncompliant code example</h3>\n<pre>\n@Test\npublic void testToString() {\n  // Do you expect get() or toString() throwing the exception?\n  org.junit.Assert.assertThrows(IndexOutOfBoundsException.class, () -&gt; get().toString());\n}\n\n@Test\npublic void testToStringTryCatchIdiom() {\n  try {\n    // Do you expect get() or toString() throwing the exception?\n    get().toString();\n    Assert.fail(\"Expected an IndexOutOfBoundsException to be thrown\");\n  } catch (IndexOutOfBoundsException e) {\n    // Test exception message...\n  }\n}\n</pre>\n<h3>Compliant solution</h3>\n<pre>\n@Test\npublic void testToString() {\n   Object obj = get();\n   Assert.assertThrows(IndexOutOfBoundsException.class, () -&gt; obj.toString());\n}\n\n@Test\npublic void testToStringTryCatchIdiom() {\n  Object obj = get();\n  try {\n    obj.toString();\n    Assert.fail(\"Expected an IndexOutOfBoundsException to be thrown\");\n  } catch (IndexOutOfBoundsException e) {\n    // Test exception message...\n  }\n}\n</pre>",
    "howToFix": "",
    "moreInfo": "<ul>\n  <li> <a href=\"https://github.com/junit-team/junit4/wiki/Exception-testing\">JUnit exception testing documentation</a> </li>\n</ul>",
    "status": "READY",
    "name_ko": "런타임 예외 테스트 시 하나의 메서드 호출만 있어야 합니다",
    "why_ko": "<p>코드가 런타임 예외를 발생시키는지 확인할 때 테스트되는 코드 내에 여러 메서드 호출이 있는 것을 피하는 것이 좋은 관행입니다. 어떤 메서드 호출이 예외를 발생시킬 것으로 예상되는지 명시적으로 하기 위해서입니다.</p>\n<p>이는 테스트의 명확성을 높이고 다른 메서드가 실제로 예외를 발생시킬 때 잘못된 테스트를 피합니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\n@Test\npublic void testToString() {\n  // get() 또는 toString() 중 어느 것이 예외를 던질 것으로 예상합니까?\n  org.junit.Assert.assertThrows(IndexOutOfBoundsException.class, () -&gt; get().toString());\n}\n\n@Test\npublic void testToStringTryCatchIdiom() {\n  try {\n    // get() 또는 toString() 중 어느 것이 예외를 던질 것으로 예상합니까?\n    get().toString();\n    Assert.fail(\"IndexOutOfBoundsException이 발생해야 합니다\");\n  } catch (IndexOutOfBoundsException e) {\n    // 예외 메시지 테스트...\n  }\n}\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre>\n@Test\npublic void testToString() {\n   Object obj = get();\n   Assert.assertThrows(IndexOutOfBoundsException.class, () -&gt; obj.toString());\n}\n\n@Test\npublic void testToStringTryCatchIdiom() {\n  Object obj = get();\n  try {\n    obj.toString();\n    Assert.fail(\"IndexOutOfBoundsException이 발생해야 합니다\");\n  } catch (IndexOutOfBoundsException e) {\n    // 예외 메시지 테스트...\n  }\n}\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": "<ul>\n  <li> <a href=\"https://github.com/junit-team/junit4/wiki/Exception-testing\">JUnit 예외 테스트 문서</a> </li>\n</ul>"
  },
  {
    "id": "S2639",
    "key": "java:S2639",
    "name": "Inappropriate regular expressions should not be used",
    "type": "bug",
    "severity": "major",
    "tags": [],
    "why": "<p>Regular expressions are powerful but tricky, and even those long used to using them can make mistakes.</p>\n<p>The following should not be used as regular expressions:</p>\n<ul>\n  <li> <code>.</code> - matches any single character. Used in <code>replaceAll</code>, it matches <em>everything</em> </li>\n  <li> <code>|</code> - normally used as an option delimiter. Used stand-alone, it matches the space between characters </li>\n  <li> <code>File.separator</code> - matches the platform-specific file path delimiter. On Windows, this will be taken as an escape character </li>\n</ul>\n<h3>Noncompliant code example</h3>\n<pre>\nString str = \"/File|Name.txt\";\n\nString clean = str.replaceAll(\".\",\"\"); // Noncompliant; probably meant to remove only dot chars, but returns an empty string\nString clean2 = str.replaceAll(\"|\",\"_\"); // Noncompliant; yields _/_F_i_l_e_|_N_a_m_e_._t_x_t_\nString clean3 = str.replaceAll(File.separator,\"\"); // Noncompliant; exception on Windows\n\nString clean4 = str.replaceFirst(\".\",\"\"); // Noncompliant;\nString clean5 = str.replaceFirst(\"|\",\"_\"); // Noncompliant;\nString clean6 = str.replaceFirst(File.separator,\"\"); // Noncompliant;\n</pre>",
    "howToFix": "",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "부적절한 정규 표현식을 사용하면 안 됩니다",
    "why_ko": "<p>정규 표현식은 강력하지만 까다로우며, 오랫동안 사용해 온 사람들도 실수를 할 수 있습니다.</p>\n<p>다음은 정규 표현식으로 사용해서는 안 됩니다:</p>\n<ul>\n  <li> <code>.</code> - 모든 단일 문자와 일치합니다. <code>replaceAll</code>에서 사용하면 <em>모든 것</em>과 일치합니다 </li>\n  <li> <code>|</code> - 일반적으로 옵션 구분자로 사용됩니다. 단독으로 사용하면 문자 사이의 공백과 일치합니다 </li>\n  <li> <code>File.separator</code> - 플랫폼별 파일 경로 구분자와 일치합니다. Windows에서는 이스케이프 문자로 처리됩니다 </li>\n</ul>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\nString str = \"/File|Name.txt\";\n\nString clean = str.replaceAll(\".\",\"\"); // 규칙 위반; 점 문자만 제거하려 했지만 빈 문자열을 반환함\nString clean2 = str.replaceAll(\"|\",\"_\"); // 규칙 위반; _/_F_i_l_e_|_N_a_m_e_._t_x_t_를 생성함\nString clean3 = str.replaceAll(File.separator,\"\"); // 규칙 위반; Windows에서 예외 발생\n\nString clean4 = str.replaceFirst(\".\",\"\"); // 규칙 위반;\nString clean5 = str.replaceFirst(\"|\",\"_\"); // 규칙 위반;\nString clean6 = str.replaceFirst(File.separator,\"\"); // 규칙 위반;\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": ""
  },
  {
    "id": "S1150",
    "key": "java:S1150",
    "name": "\"Enumeration\" should not be implemented",
    "type": "code-smell",
    "severity": "major",
    "tags": [
      "obsolete"
    ],
    "why": "<p>As documented in <code>Enumeration</code> 's Javadoc, you should favor the <code>Iterator</code> interface over <code>Enumeration</code>.\n<code>Iterator</code> offers a similar contract to <code>Enumeration</code> with the addition of a method for removal and shorter method names.</p>\n<h3>Noncompliant code example</h3>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\npublic class MyClass implements Enumeration {  // Noncompliant\n  /* ... */\n}\n</pre>\n<h3>Compliant solution</h3>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\npublic class MyClass implements Iterator {     // Compliant\n  /* ... */\n}\n</pre>",
    "howToFix": "",
    "moreInfo": "<ul>\n  <li> <a href=\"https://docs.oracle.com/javase/8/docs/api/java/util/Enumeration.html\">docs.oracle.com</a> - Enumeration </li>\n</ul>",
    "status": "READY",
    "name_ko": "\"Enumeration\"을 구현하면 안 됩니다",
    "why_ko": "<p><code>Enumeration</code>의 Javadoc에 문서화된 대로 <code>Enumeration</code>보다 <code>Iterator</code> 인터페이스를 선호해야 합니다. <code>Iterator</code>는 <code>Enumeration</code>과 유사한 계약을 제공하면서 제거 메서드와 더 짧은 메서드 이름이 추가되었습니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\npublic class MyClass implements Enumeration {  // 규칙 위반\n  /* ... */\n}\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\npublic class MyClass implements Iterator {     // 규칙 준수\n  /* ... */\n}\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": "<ul>\n  <li> <a href=\"https://docs.oracle.com/javase/8/docs/api/java/util/Enumeration.html\">docs.oracle.com</a> - Enumeration </li>\n</ul>"
  },
  {
    "id": "S5810",
    "key": "java:S5810",
    "name": "JUnit5 test classes and methods should not be silently ignored",
    "type": "bug",
    "severity": "major",
    "tags": [
      "junit",
      "tests"
    ],
    "why": "<p>JUnit5 is more tolerant regarding the visibilities of Test classes and methods than JUnit4, which required everything to be public. JUnit5 supports\ndefault package, public and protected visibility, even if it is recommended to use the default package visibility, which improves the readability of\ncode.</p>\n<p>But JUnit5 ignores without any warning:</p>\n<ul>\n  <li> private classes and private methods </li>\n  <li> static methods </li>\n  <li> methods returning a value without being a TestFactory </li>\n</ul>\n<h3>Noncompliant code example</h3>\n<pre>\nimport org.junit.jupiter.api.Test;\n\nclass MyClassTest {\n  @Test\n  private void test1() { // Noncompliant - ignored by JUnit5\n    // ...\n  }\n  @Test\n  static void test2() { // Noncompliant - ignored by JUnit5\n    // ...\n  }\n  @Test\n  boolean test3() { // Noncompliant - ignored by JUnit5\n    // ...\n  }\n  @Nested\n  private class MyNestedClass { // Noncompliant - ignored by JUnit5\n    @Test\n    void test() {\n      // ...\n    }\n  }\n}\n</pre>\n<h3>Compliant solution</h3>\n<pre>\nimport org.junit.jupiter.api.Test;\n\nclass MyClassTest {\n  @Test\n  void test1() {\n    // ...\n  }\n  @Test\n  void test2() {\n    // ...\n  }\n  @Test\n  void test3() {\n    // ...\n  }\n  @Nested\n  class MyNestedClass {\n    @Test\n    void test() {\n      // ...\n    }\n  }\n}\n</pre>",
    "howToFix": "",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "JUnit5 테스트 클래스와 메서드가 조용히 무시되면 안 됩니다",
    "why_ko": "<p>JUnit5는 모든 것이 public이어야 했던 JUnit4보다 테스트 클래스와 메서드의 가시성에 대해 더 관대합니다. JUnit5는 기본 패키지, public 및 protected 가시성을 지원하지만 코드 가독성을 향상시키는 기본 패키지 가시성을 사용하는 것이 권장됩니다.</p>\n<p>그러나 JUnit5는 경고 없이 다음을 무시합니다:</p>\n<ul>\n  <li> private 클래스와 private 메서드 </li>\n  <li> static 메서드 </li>\n  <li> TestFactory가 아닌데 값을 반환하는 메서드 </li>\n</ul>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\nimport org.junit.jupiter.api.Test;\n\nclass MyClassTest {\n  @Test\n  private void test1() { // 규칙 위반 - JUnit5에서 무시됨\n    // ...\n  }\n  @Test\n  static void test2() { // 규칙 위반 - JUnit5에서 무시됨\n    // ...\n  }\n  @Test\n  boolean test3() { // 규칙 위반 - JUnit5에서 무시됨\n    // ...\n  }\n  @Nested\n  private class MyNestedClass { // 규칙 위반 - JUnit5에서 무시됨\n    @Test\n    void test() {\n      // ...\n    }\n  }\n}\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre>\nimport org.junit.jupiter.api.Test;\n\nclass MyClassTest {\n  @Test\n  void test1() {\n    // ...\n  }\n  @Test\n  void test2() {\n    // ...\n  }\n  @Test\n  void test3() {\n    // ...\n  }\n  @Nested\n  class MyNestedClass {\n    @Test\n    void test() {\n      // ...\n    }\n  }\n}\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": ""
  },
  {
    "id": "S3751",
    "key": "java:S3751",
    "name": "\"@RequestMapping\" methods should not be \"private\"",
    "type": "code-smell",
    "severity": "major",
    "tags": [
      "spring"
    ],
    "why": "<p>A method with a <code>@RequestMapping</code> annotation part of a class annotated with <code>@Controller</code> (directly or indirectly through a\nmeta annotation - <code>@RestController</code> from Spring Boot is a good example) will be called to handle matching web requests. That will happen\neven if the method is <code>private</code>, because Spring invokes such methods via reflection, without checking visibility.</p>\n<p>So marking a sensitive method <code>private</code> may seem like a good way to control how such code is called. Unfortunately, not all Spring\nframeworks ignore visibility in this way. For instance, if you've tried to control web access to your sensitive, <code>private</code>,\n<code>@RequestMapping</code> method by marking it <code>@Secured</code> …​ it will still be called, whether or not the user is authorized to access\nit. That's because AOP proxies are not applied to private methods.</p>\n<p>In addition to <code>@RequestMapping</code>, this rule also considers the annotations introduced in Spring Framework 4.3: <code>@GetMapping</code>,\n<code>@PostMapping</code>, <code>@PutMapping</code>, <code>@DeleteMapping</code>, <code>@PatchMapping</code>.</p>\n<h3>Noncompliant code example</h3>\n<pre>\n@RequestMapping(\"/greet\", method = GET)\nprivate String greet(String greetee) {  // Noncompliant\n</pre>\n<h3>Compliant solution</h3>\n<pre>\n@RequestMapping(\"/greet\", method = GET)\npublic String greet(String greetee) {\n</pre>",
    "howToFix": "",
    "moreInfo": "<ul>\n  <li> OWASP - <a href=\"https://owasp.org/www-project-top-ten/2017/A6_2017-Security_Misconfiguration\">Top 10 2017 Category A6 - Security\n  Misconfiguration</a> </li>\n</ul>",
    "status": "READY",
    "name_ko": "@RequestMapping 메서드는 private이면 안 됩니다",
    "why_ko": "<p><code>@Controller</code>로 어노테이션된 클래스(직접 또는 메타 어노테이션을 통해 간접적으로 - Spring Boot의 <code>@RestController</code>가 좋은 예)의 일부인 <code>@RequestMapping</code> 어노테이션이 있는 메서드는 일치하는 웹 요청을 처리하기 위해 호출됩니다. 메서드가 <code>private</code>이더라도 Spring은 리플렉션을 통해 가시성을 검사하지 않고 이러한 메서드를 호출하기 때문에 이러한 일이 발생합니다.</p>\n<p>따라서 민감한 메서드를 <code>private</code>으로 표시하는 것은 이러한 코드가 호출되는 방식을 제어하는 좋은 방법처럼 보일 수 있습니다. 불행히도 모든 Spring 프레임워크가 이런 방식으로 가시성을 무시하는 것은 아닙니다. 예를 들어, 민감한 <code>private</code> <code>@RequestMapping</code> 메서드에 <code>@Secured</code>를 표시하여 웹 접근을 제어하려고 했다면... 사용자가 접근 권한이 있든 없든 여전히 호출됩니다. 이는 AOP 프록시가 private 메서드에 적용되지 않기 때문입니다.</p>\n<p><code>@RequestMapping</code> 외에도 이 규칙은 Spring Framework 4.3에서 도입된 어노테이션도 고려합니다: <code>@GetMapping</code>, <code>@PostMapping</code>, <code>@PutMapping</code>, <code>@DeleteMapping</code>, <code>@PatchMapping</code>.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\n@RequestMapping(\"/greet\", method = GET)\nprivate String greet(String greetee) {  // 규칙 위반\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre>\n@RequestMapping(\"/greet\", method = GET)\npublic String greet(String greetee) {\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": "<ul>\n  <li> OWASP - <a href=\"https://owasp.org/www-project-top-ten/2017/A6_2017-Security_Misconfiguration\">Top 10 2017 카테고리 A6 - 보안 설정 오류</a> </li>\n</ul>"
  },
  {
    "id": "S6103",
    "key": "java:S6103",
    "name": "AssertJ assertions with \"Consumer\" arguments should contain assertion inside consumers",
    "type": "bug",
    "severity": "major",
    "tags": [
      "tests"
    ],
    "why": "<p>AssertJ assertions taking <code>Consumer</code> objects as arguments are expected to contain \"requirements\", which should themselves be expressed\nas assertions. This concerns the following methods: <a\nhref=\"http://joel-costigliola.github.io/assertj/core-8/api/org/assertj/core/api/AbstractIterableAssert.html#allSatisfy-java.util.function.Consumer-\">allSatisfy</a>,\n<a\nhref=\"http://joel-costigliola.github.io/assertj/core-8/api/org/assertj/core/api/AbstractIterableAssert.html#anySatisfy-java.util.function.Consumer-\">anySatisfy</a>,\n<a\nhref=\"http://joel-costigliola.github.io/assertj/core-8/api/org/assertj/core/api/AbstractIterableAssert.html#hasOnlyOneElementSatisfying-java.util.function.Consumer-\">hasOnlyOneElementSatisfying</a>,&nbsp;<a\nhref=\"https://tinyurl.com/yxnzt6pj\">isInstanceOfSatisfying</a>,&nbsp;<a\nhref=\"http://joel-costigliola.github.io/assertj/core-8/api/org/assertj/core/api/AbstractIterableAssert.html#noneSatisfy-java.util.function.Consumer-\">noneSatisfy</a>,\n<a\nhref=\"http://joel-costigliola.github.io/assertj/core-8/api/org/assertj/core/api/AbstractAssert.html#satisfies-java.util.function.Consumer-\">satisfies</a>,\n<a\nhref=\"http://joel-costigliola.github.io/assertj/core-8/api/org/assertj/core/api/AbstractAssert.html#satisfiesAnyOf-java.util.function.Consumer-java.util.function.Consumer-\">satisfiesAnyOf</a>,&nbsp;<a\nhref=\"http://joel-costigliola.github.io/assertj/core-8/api/org/assertj/core/api/AbstractIterableAssert.html#zipSatisfy-java.lang.Iterable-java.util.function.BiConsumer-\">zipSatisfy</a>.</p>\n<p>These methods are assuming the&nbsp;<code>Consumer</code>&nbsp;will do the assertions itself. If you do not do any assertion in the\n<code>Consumer</code>, it probably means that you are inadvertently only partially testing your object.</p>\n<p>This rule raises an issue when a <code>Consumer</code> argument of any of the above methods does not contain any assertion.</p>\n<h3>Noncompliant code example</h3>\n<pre>\nassertThat(myObject).isInstanceOfSatisfying(String.class, s -&gt; \"Hello\".equals(s)); // Noncompliant - not testing the string value\nassertThat(myObject).satisfies(\"Hello\"::equals); // Noncompliant - not testing the string value\n</pre>\n<h3>Compliant solution</h3>\n<pre>\nassertThat(myObject).isInstanceOfSatisfying(String.class, s -&gt; assertThat(s).isEqualTo(\"Hello\"));\nassertThat(myObject).satisfies(obj -&gt; assertThat(obj).isEqualTo(\"Hello\"));\n</pre>",
    "howToFix": "",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "\"Consumer\" 인자를 가진 AssertJ 단언문은 consumer 내부에 단언을 포함해야 합니다",
    "why_ko": "<p><code>Consumer</code> 객체를 인자로 받는 AssertJ 단언문은 \"요구사항\"을 포함해야 하며, 이는 그 자체로 단언으로 표현되어야 합니다. 해당되는 메서드: <a\nhref=\"http://joel-costigliola.github.io/assertj/core-8/api/org/assertj/core/api/AbstractIterableAssert.html#allSatisfy-java.util.function.Consumer-\">allSatisfy</a>,\n<a\nhref=\"http://joel-costigliola.github.io/assertj/core-8/api/org/assertj/core/api/AbstractIterableAssert.html#anySatisfy-java.util.function.Consumer-\">anySatisfy</a>,\n<a\nhref=\"http://joel-costigliola.github.io/assertj/core-8/api/org/assertj/core/api/AbstractIterableAssert.html#hasOnlyOneElementSatisfying-java.util.function.Consumer-\">hasOnlyOneElementSatisfying</a>,&nbsp;<a\nhref=\"https://tinyurl.com/yxnzt6pj\">isInstanceOfSatisfying</a>,&nbsp;<a\nhref=\"http://joel-costigliola.github.io/assertj/core-8/api/org/assertj/core/api/AbstractIterableAssert.html#noneSatisfy-java.util.function.Consumer-\">noneSatisfy</a>,\n<a\nhref=\"http://joel-costigliola.github.io/assertj/core-8/api/org/assertj/core/api/AbstractAssert.html#satisfies-java.util.function.Consumer-\">satisfies</a>,\n<a\nhref=\"http://joel-costigliola.github.io/assertj/core-8/api/org/assertj/core/api/AbstractAssert.html#satisfiesAnyOf-java.util.function.Consumer-java.util.function.Consumer-\">satisfiesAnyOf</a>,&nbsp;<a\nhref=\"http://joel-costigliola.github.io/assertj/core-8/api/org/assertj/core/api/AbstractIterableAssert.html#zipSatisfy-java.lang.Iterable-java.util.function.BiConsumer-\">zipSatisfy</a>.</p>\n<p>이 메서드들은 <code>Consumer</code>가 자체적으로 단언을 수행할 것으로 가정합니다. <code>Consumer</code>에서 단언을 수행하지 않으면, 의도치 않게 객체를 부분적으로만 테스트하고 있을 가능성이 높습니다.</p>\n<p>이 규칙은 위 메서드의 <code>Consumer</code> 인자가 단언을 포함하지 않을 때 문제를 보고합니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\nassertThat(myObject).isInstanceOfSatisfying(String.class, s -&gt; \"Hello\".equals(s)); // 규칙 위반 - 문자열 값을 테스트하지 않음\nassertThat(myObject).satisfies(\"Hello\"::equals); // 규칙 위반 - 문자열 값을 테스트하지 않음\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre>\nassertThat(myObject).isInstanceOfSatisfying(String.class, s -&gt; assertThat(s).isEqualTo(\"Hello\"));\nassertThat(myObject).satisfies(obj -&gt; assertThat(obj).isEqualTo(\"Hello\"));\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": ""
  },
  {
    "id": "S2140",
    "key": "java:S2140",
    "name": "Methods of \"Random\" that return floating point values should not be used in random integer generation",
    "type": "code-smell",
    "severity": "minor",
    "tags": [
      "performance",
      "clumsy"
    ],
    "why": "<p>Generating random floating point values to cast them into integers is inefficient. A random bounded integer value can be generated with a single\nproper method call. Use <code>nextInt</code> to make the code more efficient and the intent clearer.</p>\n<h3>Noncompliant code example</h3>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\nRandom r = new Random();\nint rand = (int) (r.nextDouble() * 50);  // Noncompliant way to get a pseudo-random value between 0 and 50\nint rand2 = (int) r.nextFloat(); // Noncompliant; will always be 0;\n</pre>\n<h3>Compliant solution</h3>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\nRandom r = new Random();\nint rand = r.nextInt(50);  // returns pseudo-random value between 0 and 50\nint rand2 = 0;\n</pre>",
    "howToFix": "",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "부동 소수점 값을 반환하는 \"Random\" 메서드는 랜덤 정수 생성에 사용하면 안 됩니다",
    "why_ko": "<p>랜덤 부동 소수점 값을 생성하여 정수로 캐스팅하는 것은 비효율적입니다. 범위가 지정된 랜덤 정수 값은 단일 적절한 메서드 호출로 생성할 수 있습니다. 코드를 더 효율적으로 만들고 의도를 더 명확하게 하려면 <code>nextInt</code>를 사용하세요.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\nRandom r = new Random();\nint rand = (int) (r.nextDouble() * 50);  // 규칙 위반 - 0과 50 사이의 의사 랜덤 값을 얻는 방법\nint rand2 = (int) r.nextFloat(); // 규칙 위반; 항상 0이 됨;\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\nRandom r = new Random();\nint rand = r.nextInt(50);  // 0과 50 사이의 의사 랜덤 값 반환\nint rand2 = 0;\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": ""
  },
  {
    "id": "S3546",
    "key": "java:S3546",
    "name": "Custom resources should be closed",
    "type": "bug",
    "severity": "blocker",
    "tags": [
      "symbolic-execution",
      "denial-of-service"
    ],
    "why": "<p>Leaking resources in an application is never a good idea, as it can lead to memory issues, and even the crash of the application. This rule\ntemplate allows you to specify which constructions open a resource and how it is closed in order to raise issue within a method scope when custom\nresources are leaked.</p>",
    "howToFix": "",
    "moreInfo": "<h3>Related rules</h3>\n<ul>\n  <li> <a href='/coding_rules#rule_key=java%3AS2095'>S2095</a> - Resources should be closed </li>\n</ul>",
    "status": "READY",
    "name_ko": "사용자 정의 리소스는 닫아야 합니다",
    "why_ko": "<p>애플리케이션에서 리소스를 누수하는 것은 결코 좋은 생각이 아닙니다. 메모리 문제와 애플리케이션 충돌로 이어질 수 있기 때문입니다. 이 규칙 템플릿을 사용하면 리소스를 여는 구문과 닫는 방법을 지정하여 사용자 정의 리소스가 누수될 때 메서드 범위 내에서 문제를 제기할 수 있습니다.</p>",
    "howToFix_ko": "",
    "moreInfo_ko": "<h3>관련 규칙</h3>\n<ul>\n  <li> <a href='/coding_rules#rule_key=java%3AS2095'>S2095</a> - 리소스는 닫아야 합니다 </li>\n</ul>"
  },
  {
    "id": "S4684",
    "key": "java:S4684",
    "name": "Persistent entities should not be used as arguments of \"@RequestMapping\" methods",
    "type": "vulnerability",
    "severity": "critical",
    "tags": [
      "spring",
      "cwe"
    ],
    "why": "<p>By accepting persistent entities as method arguments, the application allows clients to manipulate the object's properties directly.</p>\n<h3>What is the potential impact?</h3>\n<p>Attackers could forge malicious HTTP requests that will alter unexpected properties of persistent objects. This can lead to unauthorized\nmodifications of the entity's state. This is known as a <strong>mass assignment</strong> attack.</p>\n<p>Depending on the affected objects and properties, the consequences can vary.</p>\n<h4>Privilege escalation</h4>\n<p>If the affected object is used to store the client's identity or permissions, the attacker could alter it to change their entitlement on the\napplication. This can lead to horizontal or vertical privilege escalation.</p>\n<h4>Security checks bypass</h4>\n<p>Because persistent objects are modified directly without prior logic, attackers could exploit this issue to bypass security measures otherwise\nenforced by the application. For example, an attacker might be able to change their e-mail address to an invalid one by directly setting it without\ngoing through the application's email validation process.</p>\n<p>The same could also apply to passwords that attackers could change without complexity validation or knowledge of their current value.</p>",
    "howToFix": "<p>The following code is vulnerable to a mass assignment attack because it allows modifying the <code>User</code> persistent entities thanks to\nmaliciously forged <code>Wish</code> object properties.</p>\n<h4>Noncompliant code example</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\nimport javax.persistence.Entity;\n\n@Entity\npublic class Wish {\n  Long productId;\n  Long quantity;\n  Client client;\n}\n\n@Entity\npublic class Client {\n  String clientId;\n  String name;\n  String password;\n}\n\nimport org.springframework.stereotype.Controller;\nimport org.springframework.web.bind.annotation.RequestMapping;\n\n@Controller\npublic class PurchaseOrderController {\n\n  @RequestMapping(path = \"/saveForLater\", method = RequestMethod.POST)\n  public String saveForLater(Wish wish) { // Noncompliant\n    session.save(wish);\n  }\n}\n</pre>\n<h4>Compliant solution</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\npublic class WishDTO {\n  Long productId;\n  Long quantity;\n  Long clientId;\n}\n\nimport org.springframework.stereotype.Controller;\nimport org.springframework.web.bind.annotation.RequestMapping;\n\n@Controller\npublic class PurchaseOrderController {\n\n  @RequestMapping(path = \"/saveForLater\", method = RequestMethod.POST)\n  public String saveForLater(WishDTO wish) {\n    Wish persistentWish = new Wish();\n    persistentWish.productId = wish.productId\n    persistentWish.quantity = wish.quantity\n    persistentWish.client = getClientById(with.clientId)\n    session.save(persistentWish);\n  }\n}\n</pre>\n<h3>How does this work?</h3>\n<p>The compliant code implements a Data Transfer Object (DTO) layer. Instead of accepting a persistent <code>Wish</code> entity as a parameter, the\nvulnerable method accepts a <code>WishDTO</code> object with a safe, minimal set of properties. It then instantiates a persistent entity and\ninitializes it based on the DTO properties' values. The resulting object can safely be persisted in the database.</p>",
    "moreInfo": "<h3>Documentation</h3>\n<ul>\n  <li> OWASP - <a href=\"https://cheatsheetseries.owasp.org/cheatsheets/Mass_Assignment_Cheat_Sheet.html\">Mass Assignment Cheat Sheet</a> </li>\n</ul>\n<h3>Standards</h3>\n<ul>\n  <li> OWASP - <a href=\"https://owasp.org/Top10/A08_2021-Software_and_Data_Integrity_Failures/\">Top 10 2021 - Category A8 - Software and Data\n  Integrity Failures</a> </li>\n  <li> OWASP - <a href=\"https://owasp.org/www-project-top-ten/2017/A5_2017-Broken_Access_Control\">Top 10 2017 - Category A5 - Broken Access\n  Control</a> </li>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/915\">CWE-915 - Improperly Controlled Modification of Dynamically-Determined Object\n  Attributes</a> </li>\n</ul>\n<h3>Articles &amp; blog posts</h3>\n<p>OWASP O2 Platform Blog - <a href=\"https://o2platform.files.wordpress.com/2011/07/ounce_springframework_vulnerabilities.pdf\">Two Security\nVulnerabilities in the Spring Framework's MVC</a></p>",
    "status": "READY",
    "name_ko": "영속 엔티티를 \"@RequestMapping\" 메서드의 인수로 사용하면 안 됩니다",
    "why_ko": "<p>영속 엔티티를 메서드 인수로 수락하면 애플리케이션이 클라이언트가 객체의 속성을 직접 조작할 수 있게 됩니다.</p>\n<h3>잠재적 영향은 무엇인가요?</h3>\n<p>공격자는 영속 객체의 예상치 못한 속성을 변경하는 악성 HTTP 요청을 위조할 수 있습니다. 이는 엔티티 상태의 무단 수정으로 이어질 수 있습니다. 이를 <strong>대량 할당(mass assignment)</strong> 공격이라고 합니다.</p>\n<p>영향을 받는 객체와 속성에 따라 결과는 다양할 수 있습니다.</p>\n<h4>권한 상승</h4>\n<p>영향을 받는 객체가 클라이언트의 신원이나 권한을 저장하는 데 사용되는 경우, 공격자는 이를 변경하여 애플리케이션에서의 자격을 변경할 수 있습니다. 이는 수평적 또는 수직적 권한 상승으로 이어질 수 있습니다.</p>\n<h4>보안 검사 우회</h4>\n<p>영속 객체가 사전 로직 없이 직접 수정되기 때문에, 공격자는 이 문제를 악용하여 애플리케이션에서 적용되는 보안 조치를 우회할 수 있습니다. 예를 들어, 공격자는 애플리케이션의 이메일 유효성 검사 프로세스를 거치지 않고 직접 설정하여 이메일 주소를 유효하지 않은 것으로 변경할 수 있습니다.</p>\n<p>비밀번호에도 동일하게 적용될 수 있으며, 공격자는 복잡성 유효성 검사나 현재 값에 대한 지식 없이 변경할 수 있습니다.</p>",
    "howToFix_ko": "<p>다음 코드는 악의적으로 위조된 <code>Wish</code> 객체 속성 덕분에 <code>User</code> 영속 엔티티를 수정할 수 있기 때문에 대량 할당 공격에 취약합니다.</p>\n<h4>규칙을 준수하지 않는 코드 예시</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\nimport javax.persistence.Entity;\n\n@Entity\npublic class Wish {\n  Long productId;\n  Long quantity;\n  Client client;\n}\n\n@Entity\npublic class Client {\n  String clientId;\n  String name;\n  String password;\n}\n\nimport org.springframework.stereotype.Controller;\nimport org.springframework.web.bind.annotation.RequestMapping;\n\n@Controller\npublic class PurchaseOrderController {\n\n  @RequestMapping(path = \"/saveForLater\", method = RequestMethod.POST)\n  public String saveForLater(Wish wish) { // 규칙 위반\n    session.save(wish);\n  }\n}\n</pre>\n<h4>규칙을 준수하는 해결책</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\npublic class WishDTO {\n  Long productId;\n  Long quantity;\n  Long clientId;\n}\n\nimport org.springframework.stereotype.Controller;\nimport org.springframework.web.bind.annotation.RequestMapping;\n\n@Controller\npublic class PurchaseOrderController {\n\n  @RequestMapping(path = \"/saveForLater\", method = RequestMethod.POST)\n  public String saveForLater(WishDTO wish) {\n    Wish persistentWish = new Wish();\n    persistentWish.productId = wish.productId\n    persistentWish.quantity = wish.quantity\n    persistentWish.client = getClientById(with.clientId)\n    session.save(persistentWish);\n  }\n}\n</pre>\n<h3>어떻게 작동하나요?</h3>\n<p>규칙을 준수하는 코드는 데이터 전송 객체(DTO) 레이어를 구현합니다. 취약한 메서드는 영속 <code>Wish</code> 엔티티를 매개변수로 수락하는 대신 안전하고 최소한의 속성 집합을 가진 <code>WishDTO</code> 객체를 수락합니다. 그런 다음 영속 엔티티를 인스턴스화하고 DTO 속성 값을 기반으로 초기화합니다. 결과 객체는 데이터베이스에 안전하게 영속화될 수 있습니다.</p>",
    "moreInfo_ko": "<h3>문서</h3>\n<ul>\n  <li> OWASP - <a href=\"https://cheatsheetseries.owasp.org/cheatsheets/Mass_Assignment_Cheat_Sheet.html\">Mass Assignment Cheat Sheet</a> </li>\n</ul>\n<h3>표준</h3>\n<ul>\n  <li> OWASP - <a href=\"https://owasp.org/Top10/A08_2021-Software_and_Data_Integrity_Failures/\">Top 10 2021 - Category A8 - Software and Data Integrity Failures</a> </li>\n  <li> OWASP - <a href=\"https://owasp.org/www-project-top-ten/2017/A5_2017-Broken_Access_Control\">Top 10 2017 - Category A5 - Broken Access Control</a> </li>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/915\">CWE-915 - Improperly Controlled Modification of Dynamically-Determined Object Attributes</a> </li>\n</ul>\n<h3>기사 및 블로그 게시물</h3>\n<p>OWASP O2 Platform Blog - <a href=\"https://o2platform.files.wordpress.com/2011/07/ounce_springframework_vulnerabilities.pdf\">Two Security Vulnerabilities in the Spring Framework's MVC</a></p>"
  },
  {
    "id": "S5996",
    "key": "java:S5996",
    "name": "Regex boundaries should not be used in a way that can never be matched",
    "type": "bug",
    "severity": "critical",
    "tags": [
      "regex"
    ],
    "why": "<p>In regular expressions the boundaries <code>^</code> and <code>\\A</code> can only match at the beginning of the input (or, in case of\n<code>^</code> in combination with the <code>MULTILINE</code> flag, the beginning of the line) and <code>$</code>, <code>\\Z</code> and <code>\\z</code>\nonly at the end.</p>\n<p>These patterns can be misused, by accidentally switching <code>^</code> and <code>$</code> for example, to create a pattern that can never\nmatch.</p>\n<h3>Noncompliant code example</h3>\n<pre>\n// This can never match because $ and ^ have been switched around\nPattern.compile(\"$[a-z]+^\"); // Noncompliant\n</pre>\n<h3>Compliant solution</h3>\n<pre>\nPattern.compile(\"^[a-z]+$\");\n</pre>",
    "howToFix": "",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "정규식 경계는 절대 일치할 수 없는 방식으로 사용하면 안 됩니다",
    "why_ko": "<p>정규 표현식에서 경계 <code>^</code>와 <code>\\A</code>는 입력의 시작에서만 일치할 수 있고(<code>^</code>가 <code>MULTILINE</code> 플래그와 함께 사용되는 경우 줄의 시작), <code>$</code>, <code>\\Z</code> 및 <code>\\z</code>는 끝에서만 일치할 수 있습니다.</p>\n<p>이러한 패턴은 예를 들어 실수로 <code>^</code>와 <code>$</code>를 바꾸어 절대 일치할 수 없는 패턴을 만드는 식으로 오용될 수 있습니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\n// $와 ^가 뒤바뀌어서 절대 일치할 수 없음\nPattern.compile(\"$[a-z]+^\"); // 규칙 위반\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre>\nPattern.compile(\"^[a-z]+$\");\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": ""
  },
  {
    "id": "S2245",
    "key": "java:S2245",
    "name": "Using pseudorandom number generators (PRNGs) is security-sensitive",
    "type": "security-hotspot",
    "severity": "critical",
    "tags": [
      "cwe"
    ],
    "why": "<p>PRNGs are algorithms that produce sequences of numbers that only approximate true randomness. While they are suitable for applications like\nsimulations or modeling, they are not appropriate for security-sensitive contexts because their outputs can be predictable if the internal state is\nknown.</p>\n<p>In contrast, cryptographically secure pseudorandom number generators (CSPRNGs) are designed to be secure against prediction attacks. CSPRNGs use\ncryptographic algorithms to ensure that the generated sequences are not only random but also unpredictable, even if part of the sequence or the\ninternal state becomes known. This unpredictability is crucial for security-related tasks such as generating encryption keys, tokens, or any other\nvalues that must remain confidential and resistant to guessing attacks.</p>\n<p>For example, the use of non-cryptographic PRNGs has led to vulnerabilities such as:</p>\n<ul>\n  <li> <a href=\"https://www.cve.org/CVERecord?id=CVE-2013-6386\">CVE-2013-6386</a> </li>\n  <li> <a href=\"https://www.cve.org/CVERecord?id=CVE-2006-3419\">CVE-2006-3419</a> </li>\n  <li> <a href=\"https://www.cve.org/CVERecord?id=CVE-2008-4102\">CVE-2008-4102</a> </li>\n</ul>\n<p>When software generates predictable values in a context requiring unpredictability, it may be possible for an attacker to guess the next value that\nwill be generated, and use this guess to impersonate another user or access sensitive information. Therefore, it is critical to use CSPRNGs in any\nsecurity-sensitive application to ensure the robustness and security of the system.</p>\n<p>As the <code>java.util.Random</code> class relies on a non-cryptographic pseudorandom number generator, this class and relating\n<code>java.lang.Math.random()</code> method should not be used for security-critical applications or for protecting sensitive data. In such context,\nthe <code>java.security.SecureRandom</code> class which relies on a CSPRNG should be used in place.</p>\n",
    "howToFix": "<h2>Recommended Secure Coding Practices</h2>\n<ul>\n  <li> Use a cryptographically secure pseudo random number generator (CSPRNG) like \"java.security.SecureRandom\" in place of a non-cryptographic PRNG.\n  </li>\n  <li> Use the generated random values only once. </li>\n  <li> You should not expose the generated random value. If you have to store it, make sure that the database or file is secure. </li>\n</ul>\n<h2>Compliant Solution</h2>\n<pre>\nSecureRandom random = new SecureRandom();\nbyte bytes[] = new byte[20];\nrandom.nextBytes(bytes);\n</pre>\n<h2>See</h2>\n<ul>\n  <li> OWASP - <a href=\"https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html#secure-random-number-generation\">Secure\n  Random Number Generation Cheat Sheet</a> </li>\n  <li> OWASP - <a href=\"https://owasp.org/Top10/A02_2021-Cryptographic_Failures/\">Top 10 2021 Category A2 - Cryptographic Failures</a> </li>\n  <li> OWASP - <a href=\"https://owasp.org/www-project-top-ten/2017/A3_2017-Sensitive_Data_Exposure\">Top 10 2017 Category A3 - Sensitive Data\n  Exposure</a> </li>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/338\">CWE-338 - Use of Cryptographically Weak Pseudo-Random Number Generator (PRNG)</a>\n  </li>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/330\">CWE-330 - Use of Insufficiently Random Values</a> </li>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/326\">CWE-326 - Inadequate Encryption Strength</a> </li>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/1241\">CWE-1241 - Use of Predictable Algorithm in Random Number Generator</a> </li>\n  <li> OWASP - <a href=\"https://mas.owasp.org/checklists/MASVS-CRYPTO/\">Mobile AppSec Verification Standard - Cryptography Requirements</a> </li>\n  <li> OWASP - <a href=\"https://owasp.org/www-project-mobile-top-10/2016-risks/m5-insufficient-cryptography\">Mobile Top 10 2016 Category M5 -\n  Insufficient Cryptography</a> </li>\n  <li> OWASP - <a href=\"https://owasp.org/www-project-mobile-top-10/2023-risks/m10-insufficient-cryptography\">Mobile Top 10 2024 Category M10 -\n  Insufficient Cryptography</a> </li>\n  <li> <a href=\"https://wiki.sei.cmu.edu/confluence/x/oTdGBQ\">CERT, MSC02-J.</a> - Generate strong random numbers </li>\n</ul>",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "의사 난수 생성기(PRNG) 사용은 보안에 민감합니다",
    "why_ko": "<p>PRNG는 진정한 무작위성에만 근접하는 숫자 시퀀스를 생성하는 알고리즘입니다. 시뮬레이션이나 모델링과 같은 애플리케이션에는 적합하지만 내부 상태가 알려지면 출력을 예측할 수 있기 때문에 보안에 민감한 컨텍스트에는 적합하지 않습니다.</p>\n<p>반면에 암호학적으로 안전한 의사 난수 생성기(CSPRNG)는 예측 공격에 대해 안전하도록 설계되었습니다. CSPRNG는 시퀀스의 일부 또는 내부 상태가 알려지더라도 생성된 시퀀스가 무작위일 뿐만 아니라 예측 불가능하도록 암호화 알고리즘을 사용합니다. 이러한 예측 불가능성은 암호화 키, 토큰 또는 기밀을 유지하고 추측 공격에 저항해야 하는 기타 값을 생성하는 것과 같은 보안 관련 작업에 중요합니다.</p>\n<p>예를 들어 비암호화 PRNG의 사용은 다음과 같은 취약점을 초래했습니다:</p>\n<ul>\n  <li> <a href=\"https://www.cve.org/CVERecord?id=CVE-2013-6386\">CVE-2013-6386</a> </li>\n  <li> <a href=\"https://www.cve.org/CVERecord?id=CVE-2006-3419\">CVE-2006-3419</a> </li>\n  <li> <a href=\"https://www.cve.org/CVERecord?id=CVE-2008-4102\">CVE-2008-4102</a> </li>\n</ul>\n<p>소프트웨어가 예측 불가능성이 필요한 컨텍스트에서 예측 가능한 값을 생성하면 공격자가 생성될 다음 값을 추측하고 이 추측을 사용하여 다른 사용자를 가장하거나 민감한 정보에 접근할 수 있습니다. 따라서 시스템의 견고성과 보안을 보장하기 위해 보안에 민감한 애플리케이션에서는 CSPRNG를 사용하는 것이 중요합니다.</p>\n<p><code>java.util.Random</code> 클래스는 비암호화 의사 난수 생성기에 의존하므로 이 클래스와 관련된 <code>java.lang.Math.random()</code> 메서드는 보안에 중요한 애플리케이션이나 민감한 데이터 보호에 사용해서는 안 됩니다. 그러한 컨텍스트에서는 CSPRNG에 의존하는 <code>java.security.SecureRandom</code> 클래스를 대신 사용해야 합니다.</p>",
    "howToFix_ko": "<h2>권장되는 보안 코딩 관행</h2>\n<ul>\n  <li> 비암호화 PRNG 대신 \"java.security.SecureRandom\"과 같은 암호학적으로 안전한 의사 난수 생성기(CSPRNG)를 사용하세요. </li>\n  <li> 생성된 난수 값을 한 번만 사용하세요. </li>\n  <li> 생성된 난수 값을 노출해서는 안 됩니다. 저장해야 하는 경우 데이터베이스나 파일이 안전한지 확인하세요. </li>\n</ul>\n<h2>규칙을 준수하는 해결책</h2>\n<pre>\nSecureRandom random = new SecureRandom();\nbyte bytes[] = new byte[20];\nrandom.nextBytes(bytes);\n</pre>\n<h2>참조</h2>\n<ul>\n  <li> OWASP - <a href=\"https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html#secure-random-number-generation\">안전한 난수 생성 치트 시트</a> </li>\n  <li> OWASP - <a href=\"https://owasp.org/Top10/A02_2021-Cryptographic_Failures/\">Top 10 2021 카테고리 A2 - 암호화 실패</a> </li>\n  <li> OWASP - <a href=\"https://owasp.org/www-project-top-ten/2017/A3_2017-Sensitive_Data_Exposure\">Top 10 2017 카테고리 A3 - 민감한 데이터 노출</a> </li>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/338\">CWE-338 - 암호학적으로 취약한 의사 난수 생성기(PRNG) 사용</a> </li>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/330\">CWE-330 - 불충분하게 무작위인 값 사용</a> </li>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/326\">CWE-326 - 부적절한 암호화 강도</a> </li>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/1241\">CWE-1241 - 난수 생성기에서 예측 가능한 알고리즘 사용</a> </li>\n  <li> OWASP - <a href=\"https://mas.owasp.org/checklists/MASVS-CRYPTO/\">Mobile AppSec 검증 표준 - 암호화 요구사항</a> </li>\n  <li> OWASP - <a href=\"https://owasp.org/www-project-mobile-top-10/2016-risks/m5-insufficient-cryptography\">Mobile Top 10 2016 카테고리 M5 - 불충분한 암호화</a> </li>\n  <li> OWASP - <a href=\"https://owasp.org/www-project-mobile-top-10/2023-risks/m10-insufficient-cryptography\">Mobile Top 10 2024 카테고리 M10 - 불충분한 암호화</a> </li>\n  <li> <a href=\"https://wiki.sei.cmu.edu/confluence/x/oTdGBQ\">CERT, MSC02-J.</a> - 강력한 난수 생성 </li>\n</ul>",
    "moreInfo_ko": ""
  },
  {
    "id": "S1193",
    "key": "java:S1193",
    "name": "Exception types should not be tested using \"instanceof\" in catch blocks",
    "type": "code-smell",
    "severity": "major",
    "tags": [
      "error-handling",
      "cert",
      "clumsy"
    ],
    "why": "<p>A <code>try-catch</code> block is used to handle exceptions or errors that may occur during the execution of a block of code. It allows you to\ncatch and handle exceptions gracefully, preventing your program from terminating abruptly.</p>\n<p>The code that may throw an exception is enclosed within the <code>try</code> block, while each <code>catch</code> block specifies the type of\nexception it can handle. The corresponding catch block is executed if the exception matches the type specified in any catch block. It is unnecessary\nto manually check the types using <code>instanceof</code> because Java automatically matches the exception type to the appropriate catch block based\non the declared exception type in the catch clauses.</p>",
    "howToFix": "<p>Replace <code>if</code> statements that check the exception type using <code>instanceof</code> with corresponding <code>catch</code> blocks.</p>\n\n<h4>Noncompliant code example</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\ntry {\n  /* ... */\n} catch (Exception e) {\n  if(e instanceof IOException) { /* ... */ }         // Noncompliant\n  if(e instanceof NullPointerException{ /* ... */ }  // Noncompliant\n}\n</pre>\n<h4>Compliant solution</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\ntry {\n  /* ... */\n} catch (IOException e) { /* ... */ }                // Compliant\n} catch (NullPointerException e) { /* ... */ }       // Compliant\n</pre>",
    "moreInfo": "<ul>\n  <li> <a href=\"https://wiki.sei.cmu.edu/confluence/display/java/ERR51-J.+Prefer+user-defined+exceptions+over+more+general+exception+types\">CERT,\n  ERR51-J.</a> - Prefer user-defined exceptions over more general exception types </li>\n  <li> <a href=\"https://docs.oracle.com/javase/tutorial/essential/exceptions/catch.html\">Oracle - Exceptions</a> </li>\n</ul>",
    "status": "READY",
    "name_ko": "catch 블록에서 Exception 타입을 \"instanceof\"로 검사하면 안 됩니다",
    "why_ko": "<p><code>try-catch</code> 블록은 코드 블록의 실행 중에 발생할 수 있는 예외나 오류를 처리하는 데 사용됩니다. 이를 통해 예외를 우아하게 catch하고 처리하여 프로그램이 갑자기 종료되는 것을 방지할 수 있습니다.</p>\n<p>예외를 던질 수 있는 코드는 <code>try</code> 블록 내에 포함되고, 각 <code>catch</code> 블록은 처리할 수 있는 예외 타입을 지정합니다. 예외가 catch 블록에 지정된 타입과 일치하면 해당 catch 블록이 실행됩니다. Java는 catch 절에 선언된 예외 타입을 기반으로 예외 타입을 적절한 catch 블록에 자동으로 매칭하므로 <code>instanceof</code>를 사용하여 수동으로 타입을 확인할 필요가 없습니다.</p>",
    "howToFix_ko": "<p><code>instanceof</code>를 사용하여 예외 타입을 확인하는 <code>if</code> 문을 해당 <code>catch</code> 블록으로 대체하세요.</p>\n\n<h4>규칙을 준수하지 않는 코드 예시</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\ntry {\n  /* ... */\n} catch (Exception e) {\n  if(e instanceof IOException) { /* ... */ }         // 규칙 위반\n  if(e instanceof NullPointerException{ /* ... */ }  // 규칙 위반\n}\n</pre>\n<h4>규칙을 준수하는 해결책</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\ntry {\n  /* ... */\n} catch (IOException e) { /* ... */ }                // 규칙 준수\n} catch (NullPointerException e) { /* ... */ }       // 규칙 준수\n</pre>",
    "moreInfo_ko": "<ul>\n  <li> <a href=\"https://wiki.sei.cmu.edu/confluence/display/java/ERR51-J.+Prefer+user-defined+exceptions+over+more+general+exception+types\">CERT, ERR51-J.</a> - 더 일반적인 예외 타입보다 사용자 정의 예외를 선호하세요 </li>\n  <li> <a href=\"https://docs.oracle.com/javase/tutorial/essential/exceptions/catch.html\">Oracle - 예외</a> </li>\n</ul>"
  },
  {
    "id": "S5979",
    "key": "java:S5979",
    "name": "Annotated Mockito objects should be initialized",
    "type": "bug",
    "severity": "blocker",
    "tags": [
      "tests",
      "mockito"
    ],
    "why": "<p>Objects annotated with Mockito annotations <code>@Mock</code>,&nbsp;<code>@Spy</code>,&nbsp;<code>@Captor</code>,&nbsp;or <code>@InjectMocks</code>\nneed to be initialized explicitly.</p>\n<p>There are several ways to do this:</p>\n<ul>\n  <li> Call <code>MockitoAnnotations.openMocks(this)</code> or&nbsp;<code>MockitoAnnotations.initMocks(this)</code>&nbsp;in a setup method </li>\n  <li> Annotate test class with&nbsp;<code>@RunWith(MockitoJUnitRunner.class)</code>&nbsp;(JUnit 4) </li>\n  <li> Annotate test class with&nbsp;<code>@ExtendWith(MockitoExtension.class)</code>&nbsp;(JUnit 5 Jupiter) </li>\n  <li> Use&nbsp;<code>@Rule public MockitoRule rule = MockitoJUnit.rule();</code> </li>\n</ul>\n<p>Test using uninitialized mocks will fail.</p>\n<p>Note that this only applies to annotated Mockito objects. It is not necessary to initialize objects instantiated via <code>Mockito.mock()</code> or\n<code>Mockito.spy()</code>.</p>\n<p>This rule raises an issue when a test class uses uninitialized mocks.</p>\n<h3>Noncompliant code example</h3>\n<pre>\npublic class FooTest { // Noncompliant: Mockito initialization missing\n  @Mock private Bar bar;\n\n  @Spy private Baz baz;\n\n  @InjectMocks private Foo fooUnderTest;\n\n  @Test\n  void someTest() {\n    // test something ...\n  }\n\n  @Nested\n  public class Nested {\n    @Mock\n    private Bar bar;\n  }\n</pre>\n<h3>Compliant solution</h3>\n<pre>\n@RunWith(MockitoJUnitRunner.class)\npublic class FooTest {\n  @Mock private Bar bar;\n  // ...\n}\n</pre>\n<pre>\n@ExtendWith(MockitoExtension.class)\npublic class FooTest {\n  @Mock private Bar bar;\n  // ...\n}\n</pre>\n<pre>\npublic class FooTest {\n  @Rule\n  public MockitoRule rule = MockitoJUnit.rule();\n\n  @Mock private Bar bar;\n  // ...\n}\n</pre>\n<pre>\npublic class FooTest {\n  @Mock private Bar bar;\n  // ...\n\n  @BeforeEach\n  void setUp() {\n    MockitoAnnotations.openMocks(this);\n  }\n  // ...\n}\n</pre>\n<pre>\npublic class FooTest {\n  @Mock private Bar bar;\n  // ...\n\n  @Before\n  void setUp() {\n    MockitoAnnotations.initMocks(this);\n  }\n  // ...\n}\n</pre>\n<pre>\n@ExtendWith(MockitoExtension.class)\npublic class FooTest {\n  @Nested\n  public class Nested {\n    @Mock\n    private Bar bar;\n  }\n}\n</pre>",
    "howToFix": "",
    "moreInfo": "<ul>\n  <li> <a href=\"https://site.mockito.org/javadoc/current/org/mockito/MockitoAnnotations.html\">Mockito documentation - MockitoAnnotations</a> </li>\n  <li> <a href=\"https://site.mockito.org/javadoc/current/org/mockito/junit/MockitoRule.html\">Mockito documentation - MockitoRule </a> </li>\n</ul>",
    "status": "READY",
    "name_ko": "어노테이션이 달린 Mockito 객체는 초기화해야 합니다",
    "why_ko": "<p>Mockito 어노테이션 <code>@Mock</code>, <code>@Spy</code>, <code>@Captor</code> 또는 <code>@InjectMocks</code>로 주석이 달린 객체는 명시적으로 초기화해야 합니다.</p>\n<p>이를 수행하는 여러 방법이 있습니다:</p>\n<ul>\n  <li> 설정 메서드에서 <code>MockitoAnnotations.openMocks(this)</code> 또는 <code>MockitoAnnotations.initMocks(this)</code> 호출 </li>\n  <li> 테스트 클래스에 <code>@RunWith(MockitoJUnitRunner.class)</code> 주석 달기 (JUnit 4) </li>\n  <li> 테스트 클래스에 <code>@ExtendWith(MockitoExtension.class)</code> 주석 달기 (JUnit 5 Jupiter) </li>\n  <li> <code>@Rule public MockitoRule rule = MockitoJUnit.rule();</code> 사용 </li>\n</ul>\n<p>초기화되지 않은 mock을 사용하는 테스트는 실패합니다.</p>\n<p>이것은 어노테이션이 달린 Mockito 객체에만 적용됩니다. <code>Mockito.mock()</code> 또는 <code>Mockito.spy()</code>를 통해 인스턴스화된 객체는 초기화할 필요가 없습니다.</p>\n<p>이 규칙은 테스트 클래스가 초기화되지 않은 mock을 사용할 때 문제를 제기합니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\npublic class FooTest { // 규칙 위반: Mockito 초기화 누락\n  @Mock private Bar bar;\n\n  @Spy private Baz baz;\n\n  @InjectMocks private Foo fooUnderTest;\n\n  @Test\n  void someTest() {\n    // 테스트 ...\n  }\n\n  @Nested\n  public class Nested {\n    @Mock\n    private Bar bar;\n  }\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre>\n@RunWith(MockitoJUnitRunner.class)\npublic class FooTest {\n  @Mock private Bar bar;\n  // ...\n}\n</pre>\n<pre>\n@ExtendWith(MockitoExtension.class)\npublic class FooTest {\n  @Mock private Bar bar;\n  // ...\n}\n</pre>\n<pre>\npublic class FooTest {\n  @Rule\n  public MockitoRule rule = MockitoJUnit.rule();\n\n  @Mock private Bar bar;\n  // ...\n}\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": "<ul>\n  <li> <a href=\"https://site.mockito.org/javadoc/current/org/mockito/MockitoAnnotations.html\">Mockito 문서 - MockitoAnnotations</a> </li>\n  <li> <a href=\"https://site.mockito.org/javadoc/current/org/mockito/junit/MockitoRule.html\">Mockito 문서 - MockitoRule</a> </li>\n</ul>"
  },
  {
    "id": "S6206",
    "key": "java:S6206",
    "name": "Records should be used instead of ordinary classes when representing immutable data structure",
    "type": "code-smell",
    "severity": "major",
    "tags": [
      "java16"
    ],
    "why": "<p>In Java 16 <code>records</code> are finalized and can be safely used in production code. <code>Records</code> represent immutable read-only data\nstructure and should be used instead of creating immutable classes. Immutability of records is guaranteed by the Java language itself, while\nimplementing immutable classes on your own might lead to some bugs.</p>\n<p>One of the important aspects of <code>records</code> is that final fields can't be overwritten using reflection.</p>\n<p>This rule reports an issue on classes for which all these statements are true:</p>\n<ul>\n  <li> all instance fields are private and final </li>\n  <li> has only one constructor with a parameter for all fields </li>\n  <li> has getters for all fields </li>\n</ul>\n<h3>Noncompliant code example</h3>\n<pre>\nfinal class Person { // Noncompliant\n  private final String name;\n  private final int age;\n\n  public Person(String name, int age) {\n    this.name = name;\n    this.age = age;\n  }\n\n  public String getName() {...}\n\n  public int getAge() {...}\n\n  @Override\n  public boolean equals(Object o) {...}\n\n  @Override\n  public int hashCode() {...}\n\n  @Override\n  public String toString() {...}\n}\n</pre>\n<h3>Compliant solution</h3>\n<pre>\nrecord Person(String name, int age) { }\n</pre>",
    "howToFix": "",
    "moreInfo": "<ul>\n  <li> <a href=\"https://docs.oracle.com/javase/specs/jls/se16/html/jls-8.html#jls-8.10\">Records specification</a> </li>\n</ul>",
    "status": "READY",
    "name_ko": "불변 데이터 구조를 표현할 때는 일반 클래스 대신 Record를 사용해야 합니다",
    "why_ko": "<p>Java 16에서 <code>record</code>가 완성되어 프로덕션 코드에서 안전하게 사용할 수 있습니다. <code>Record</code>는 불변 읽기 전용 데이터 구조를 나타내며 불변 클래스를 만드는 대신 사용해야 합니다. Record의 불변성은 Java 언어 자체에서 보장되지만, 직접 불변 클래스를 구현하면 버그가 발생할 수 있습니다.</p>\n<p><code>record</code>의 중요한 측면 중 하나는 final 필드를 리플렉션으로 덮어쓸 수 없다는 것입니다.</p>\n<p>이 규칙은 다음 조건이 모두 참인 클래스에 대해 문제를 보고합니다:</p>\n<ul>\n  <li> 모든 인스턴스 필드가 private이고 final임 </li>\n  <li> 모든 필드에 대한 매개변수가 있는 생성자가 하나만 있음 </li>\n  <li> 모든 필드에 대한 getter가 있음 </li>\n</ul>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\nfinal class Person { // 규칙 위반\n  private final String name;\n  private final int age;\n\n  public Person(String name, int age) {\n    this.name = name;\n    this.age = age;\n  }\n\n  public String getName() {...}\n\n  public int getAge() {...}\n\n  @Override\n  public boolean equals(Object o) {...}\n\n  @Override\n  public int hashCode() {...}\n\n  @Override\n  public String toString() {...}\n}\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre>\nrecord Person(String name, int age) { }\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": "<ul>\n  <li> <a href=\"https://docs.oracle.com/javase/specs/jls/se16/html/jls-8.html#jls-8.10\">Record 명세</a> </li>\n</ul>"
  },
  {
    "id": "S1310",
    "key": "java:S1310",
    "name": "Track uses of \"NOPMD\" suppression comments",
    "type": "code-smell",
    "severity": "minor",
    "tags": [
      "bad-practice"
    ],
    "why": "<p>This rule allows you to track the use of the PMD suppression comment mechanism.</p>\n<h3>Noncompliant code example</h3>\n<pre>\n// NOPMD\n</pre>",
    "howToFix": "",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "\"NOPMD\" 억제 주석 사용을 추적합니다",
    "why_ko": "<p>이 규칙을 사용하면 PMD 억제 주석 메커니즘의 사용을 추적할 수 있습니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\n// NOPMD\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": ""
  },
  {
    "id": "S2183",
    "key": "java:S2183",
    "name": "Ints and longs should not be shifted by zero or more than their number of bits-1",
    "type": "bug",
    "severity": "minor",
    "tags": [],
    "why": "<p>Since an <code>int</code> is a 32-bit variable, shifting by more than +/-31 is confusing at best and an error at worst. When the runtime shifts\n32-bit integers, it uses the lowest 5 bits of the shift count operand. In other words, shifting an <code>int</code> by 32 is the same as shifting it\nby 0, and shifting it by 33 is the same as shifting it by 1.</p>\n<p>Similarly, when shifting 64-bit integers, the runtime uses the lowest 6 bits of the shift count operand and shifting <code>long</code> by 64 is the\nsame as shifting it by 0, and shifting it by 65 is the same as shifting it by 1.</p>",
    "howToFix": "<h4>Noncompliant code example</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\npublic int shift(int a) {\n  int x = a &gt;&gt; 32; // Noncompliant\n  return a &lt;&lt; 48;  // Noncompliant\n}\n</pre>\n<h4>Compliant solution</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\npublic int shift(int a) {\n  int x = a &gt;&gt; 31;\n  return a &lt;&lt; 16;\n}\n</pre>",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "int와 long을 0 또는 비트 수-1 이상으로 시프트하면 안 됩니다",
    "why_ko": "<p><code>int</code>는 32비트 변수이므로 +/-31 이상으로 시프트하는 것은 최선의 경우 혼란스럽고 최악의 경우 오류입니다. 런타임이 32비트 정수를 시프트할 때 시프트 카운트 피연산자의 가장 낮은 5비트를 사용합니다. 다시 말해서, <code>int</code>를 32로 시프트하는 것은 0으로 시프트하는 것과 같고, 33으로 시프트하는 것은 1로 시프트하는 것과 같습니다.</p>\n<p>마찬가지로 64비트 정수를 시프트할 때 런타임은 시프트 카운트 피연산자의 가장 낮은 6비트를 사용하며, <code>long</code>을 64로 시프트하는 것은 0으로 시프트하는 것과 같고, 65로 시프트하는 것은 1로 시프트하는 것과 같습니다.</p>",
    "howToFix_ko": "<h4>규칙을 준수하지 않는 코드 예시</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\npublic int shift(int a) {\n  int x = a &gt;&gt; 32; // 규칙 위반\n  return a &lt;&lt; 48;  // 규칙 위반\n}\n</pre>\n<h4>규칙을 준수하는 해결책</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\npublic int shift(int a) {\n  int x = a &gt;&gt; 31;\n  return a &lt;&lt; 16;\n}\n</pre>",
    "moreInfo_ko": ""
  },
  {
    "id": "S2479",
    "key": "java:S2479",
    "name": "Whitespace and control characters in literals should be explicit",
    "type": "code-smell",
    "severity": "critical",
    "tags": [
      "pitfall"
    ],
    "why": "<p>Non-encoded control characters and whitespace characters are often injected in the source code because of a bad manipulation. They are either\ninvisible or difficult to recognize, which can result in bugs when the string is not what the developer expects. If you actually need to use a control\ncharacter use their encoded version (ex: ASCII <code>\\n,\\t,</code>…​ or Unicode <code>U+000D, U+0009,</code>…​).</p>\n<p>This rule raises an issue when the following characters are seen in a literal string:</p>\n<ul>\n  <li> <a href=\"https://en.wikipedia.org/wiki/ASCII#Control_characters\">ASCII control character</a>. (character index &lt; 32 or = 127) </li>\n  <li> Unicode <a href=\"https://en.wikipedia.org/wiki/Unicode_character_property#Whitespace\">whitespace characters</a>. </li>\n  <li> Unicode <a href=\"https://en.wikipedia.org/wiki/C0_and_C1_control_codes\">C0 control characters</a> </li>\n  <li> Unicode characters <code>U+200B, U+200C, U+200D, U+2060, U+FEFF, U+2028, U+2029</code> </li>\n</ul>\n<p>No issue will be raised on the simple space character. Unicode <code>U+0020</code>, ASCII 32.</p>\n<h3>Noncompliant code example</h3>\n<pre>\nString tabInside = \"A\tB\";  // Noncompliant, contains a tabulation\nString zeroWidthSpaceInside = \"foo​bar\"; // Noncompliant, it contains a U+200B character inside\nchar tab = '\t';\n</pre>\n<h3>Compliant solution</h3>\n<pre>\nString tabInside = \"A\\tB\";  // Compliant, uses escaped value\nString zeroWidthSpaceInside = \"foo\\u200Bbar\";  // Compliant, uses escaped value\nchar tab = '\\t';\n</pre>",
    "howToFix": "",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "리터럴의 공백 문자와 제어 문자는 명시적이어야 합니다",
    "why_ko": "<p>인코딩되지 않은 제어 문자와 공백 문자는 잘못된 조작으로 인해 소스 코드에 주입되는 경우가 많습니다. 이들은 보이지 않거나 인식하기 어려워서 문자열이 개발자가 예상한 것과 다를 때 버그가 발생할 수 있습니다. 제어 문자를 실제로 사용해야 하는 경우 인코딩된 버전을 사용하세요(예: ASCII <code>\\n,\\t,</code>…​ 또는 Unicode <code>U+000D, U+0009,</code>…​).</p>\n<p>이 규칙은 리터럴 문자열에서 다음 문자가 발견되면 문제를 제기합니다:</p>\n<ul>\n  <li> <a href=\"https://en.wikipedia.org/wiki/ASCII#Control_characters\">ASCII 제어 문자</a>. (문자 인덱스 &lt; 32 또는 = 127) </li>\n  <li> Unicode <a href=\"https://en.wikipedia.org/wiki/Unicode_character_property#Whitespace\">공백 문자</a>. </li>\n  <li> Unicode <a href=\"https://en.wikipedia.org/wiki/C0_and_C1_control_codes\">C0 제어 문자</a> </li>\n  <li> Unicode 문자 <code>U+200B, U+200C, U+200D, U+2060, U+FEFF, U+2028, U+2029</code> </li>\n</ul>\n<p>단순 공백 문자에 대해서는 문제가 제기되지 않습니다. Unicode <code>U+0020</code>, ASCII 32.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\nString tabInside = \"A\tB\";  // 규칙 위반, 탭 문자 포함\nString zeroWidthSpaceInside = \"foo​bar\"; // 규칙 위반, 내부에 U+200B 문자 포함\nchar tab = '\t';\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre>\nString tabInside = \"A\\tB\";  // 규칙 준수, 이스케이프 값 사용\nString zeroWidthSpaceInside = \"foo\\u200Bbar\";  // 규칙 준수, 이스케이프 값 사용\nchar tab = '\\t';\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": ""
  },
  {
    "id": "S6355",
    "key": "java:S6355",
    "name": "Deprecated annotations should include explanations",
    "type": "code-smell",
    "severity": "major",
    "tags": [
      "java9"
    ],
    "why": "<p>Since Java 9, <code>@Deprecated</code> has two additional arguments to the annotation:</p>\n<ul>\n  <li> <code>since</code> allows you to describe when the deprecation took place </li>\n  <li> <code>forRemoval</code>, indicates whether the deprecated element will be removed at some future date </li>\n</ul>\n<p>In order to ease the maintainers work, it is recommended to always add one or both of these arguments.</p>\n<p>This rule reports an issue when <code>@Deprecated</code> is used without any argument.</p>\n<h3>Noncompliant code example</h3>\n<pre>\n@Deprecated\n</pre>\n<h3>Compliant solution</h3>\n<pre>\n@Deprecated(since=\"4.2\", forRemoval=true)\n</pre>\n<h3>Exceptions</h3>\n<p>The members and methods of a deprecated class or interface are ignored by this rule. The classes and interfaces themselves are still subject to\nit.</p>",
    "howToFix": "",
    "moreInfo": "<h3>Related rules</h3>\n<ul>\n  <li> <a href='/coding_rules#rule_key=java%3AS1123'>S1123</a> </li>\n</ul>",
    "status": "READY",
    "name_ko": "Deprecated 어노테이션에는 설명을 포함해야 합니다",
    "why_ko": "<p>Java 9부터 <code>@Deprecated</code>에는 어노테이션에 두 가지 추가 인수가 있습니다:</p>\n<ul>\n  <li> <code>since</code>는 사용 중단이 언제 발생했는지 설명할 수 있게 합니다 </li>\n  <li> <code>forRemoval</code>은 사용 중단된 요소가 미래의 어느 시점에 제거될 것인지를 나타냅니다 </li>\n</ul>\n<p>유지 관리자의 작업을 쉽게 하기 위해 이러한 인수 중 하나 또는 둘 다를 항상 추가하는 것이 권장됩니다.</p>\n<p>이 규칙은 <code>@Deprecated</code>가 인수 없이 사용될 때 문제를 보고합니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\n@Deprecated\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre>\n@Deprecated(since=\"4.2\", forRemoval=true)\n</pre>\n<h3>예외</h3>\n<p>사용 중단된 클래스나 인터페이스의 멤버와 메서드는 이 규칙에서 무시됩니다. 클래스와 인터페이스 자체는 여전히 적용됩니다.</p>",
    "howToFix_ko": "",
    "moreInfo_ko": "<h3>관련 규칙</h3>\n<ul>\n  <li> <a href='/coding_rules#rule_key=java%3AS1123'>S1123</a> </li>\n</ul>"
  },
  {
    "id": "S4738",
    "key": "java:S4738",
    "name": "Java features should be preferred to Guava",
    "type": "code-smell",
    "severity": "major",
    "tags": [
      "java9",
      "java8"
    ],
    "why": "<p>Some Guava features were really useful for Java 7 application because Guava was bringing APIs missing in the JDK. Java 8 fixed some of these\nlimitations. When migrating an application to Java 8 or even when starting a new one, it's recommended to prefer Java 8 APIs over Guava ones to ease\nits maintenance: developers don't need to learn how to use two APIs and can stick to the standard one.</p>\n<p>Java 9 brought even more useful methods to the standard Java library and if Java version is equal to or higher than 9, these standard methods\nshould be used.</p>\n<p>This rule raises an issue when the following Guava APIs are used:</p>\n<table>\n  <colgroup>\n    <col style=\"width: 50%;\">\n    <col style=\"width: 50%;\">\n  </colgroup>\n  <thead>\n    <tr>\n      <th>Guava API</th>\n      <th>Java 8 API</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td><p>com.google.common.io.BaseEncoding#base64()</p></td>\n      <td><p>java.util.Base64</p></td>\n    </tr>\n    <tr>\n      <td><p>com.google.common.io.BaseEncoding#base64Url()</p></td>\n      <td><p>java.util.Base64</p></td>\n    </tr>\n    <tr>\n      <td><p>com.google.common.base.Joiner.on()</p></td>\n      <td><p>java.lang.String#join() or java.util.stream.Collectors#joining()</p></td>\n    </tr>\n    <tr>\n      <td><p>com.google.common.base.Optional#of()</p></td>\n      <td><p>java.util.Optional#of()</p></td>\n    </tr>\n    <tr>\n      <td><p>com.google.common.base.Optional#absent()</p></td>\n      <td><p>java.util.Optional#empty()</p></td>\n    </tr>\n    <tr>\n      <td><p>com.google.common.base.Optional#fromNullable()</p></td>\n      <td><p>java.util.Optional#ofNullable()</p></td>\n    </tr>\n    <tr>\n      <td><p>com.google.common.base.Optional</p></td>\n      <td><p>java.util.Optional</p></td>\n    </tr>\n    <tr>\n      <td><p>com.google.common.base.Predicate</p></td>\n      <td><p>java.util.function.Predicate</p></td>\n    </tr>\n    <tr>\n      <td><p>com.google.common.base.Function</p></td>\n      <td><p>java.util.function.Function</p></td>\n    </tr>\n    <tr>\n      <td><p>com.google.common.base.Supplier</p></td>\n      <td><p>java.util.function.Supplier</p></td>\n    </tr>\n    <tr>\n      <td><p>com.google.common.io.Files.createTempDir</p></td>\n      <td><p>java.nio.file.Files.createTempDirectory</p></td>\n    </tr>\n  </tbody>\n</table>\n<table>\n  <colgroup>\n    <col style=\"width: 50%;\">\n    <col style=\"width: 50%;\">\n  </colgroup>\n  <thead>\n    <tr>\n      <th>Guava API</th>\n      <th>Java 9 API</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td><p>com.google.common.collect.ImmutableSet#of()</p></td>\n      <td><p>java.util.Set#of()</p></td>\n    </tr>\n    <tr>\n      <td><p>com.google.common.collect.ImmutableList#of()</p></td>\n      <td><p>java.util.List#of()</p></td>\n    </tr>\n    <tr>\n      <td><p>com.google.common.collect.ImmutableMap#of()</p></td>\n      <td><p>java.util.Map#of() or java.util.Map#ofEntries()</p></td>\n    </tr>\n  </tbody>\n</table>",
    "howToFix": "",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "Guava보다 Java 기본 기능을 사용해야 합니다",
    "why_ko": "<p>일부 Guava 기능은 JDK에 없는 API를 Guava가 제공했기 때문에 Java 7 애플리케이션에 정말 유용했습니다. Java 8은 이러한 제한 사항 중 일부를 수정했습니다. 애플리케이션을 Java 8로 마이그레이션하거나 새로운 애플리케이션을 시작할 때, 유지 관리를 용이하게 하기 위해 Guava API보다 Java 8 API를 선호하는 것이 권장됩니다: 개발자는 두 API를 사용하는 방법을 배울 필요가 없으며 표준 API를 사용할 수 있습니다.</p>\n<p>Java 9는 표준 Java 라이브러리에 더 많은 유용한 메서드를 가져왔으며 Java 버전이 9 이상인 경우 이러한 표준 메서드를 사용해야 합니다.</p>\n<p>이 규칙은 다음 Guava API가 사용될 때 문제를 제기합니다:</p>\n<table>\n  <colgroup>\n    <col style=\"width: 50%;\">\n    <col style=\"width: 50%;\">\n  </colgroup>\n  <thead>\n    <tr>\n      <th>Guava API</th>\n      <th>Java 8 API</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td><p>com.google.common.io.BaseEncoding#base64()</p></td>\n      <td><p>java.util.Base64</p></td>\n    </tr>\n    <tr>\n      <td><p>com.google.common.io.BaseEncoding#base64Url()</p></td>\n      <td><p>java.util.Base64</p></td>\n    </tr>\n    <tr>\n      <td><p>com.google.common.base.Joiner.on()</p></td>\n      <td><p>java.lang.String#join() 또는 java.util.stream.Collectors#joining()</p></td>\n    </tr>\n    <tr>\n      <td><p>com.google.common.base.Optional#of()</p></td>\n      <td><p>java.util.Optional#of()</p></td>\n    </tr>\n    <tr>\n      <td><p>com.google.common.base.Optional#absent()</p></td>\n      <td><p>java.util.Optional#empty()</p></td>\n    </tr>\n    <tr>\n      <td><p>com.google.common.base.Optional#fromNullable()</p></td>\n      <td><p>java.util.Optional#ofNullable()</p></td>\n    </tr>\n    <tr>\n      <td><p>com.google.common.base.Optional</p></td>\n      <td><p>java.util.Optional</p></td>\n    </tr>\n    <tr>\n      <td><p>com.google.common.base.Predicate</p></td>\n      <td><p>java.util.function.Predicate</p></td>\n    </tr>\n    <tr>\n      <td><p>com.google.common.base.Function</p></td>\n      <td><p>java.util.function.Function</p></td>\n    </tr>\n    <tr>\n      <td><p>com.google.common.base.Supplier</p></td>\n      <td><p>java.util.function.Supplier</p></td>\n    </tr>\n    <tr>\n      <td><p>com.google.common.io.Files.createTempDir</p></td>\n      <td><p>java.nio.file.Files.createTempDirectory</p></td>\n    </tr>\n  </tbody>\n</table>\n<table>\n  <colgroup>\n    <col style=\"width: 50%;\">\n    <col style=\"width: 50%;\">\n  </colgroup>\n  <thead>\n    <tr>\n      <th>Guava API</th>\n      <th>Java 9 API</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td><p>com.google.common.collect.ImmutableSet#of()</p></td>\n      <td><p>java.util.Set#of()</p></td>\n    </tr>\n    <tr>\n      <td><p>com.google.common.collect.ImmutableList#of()</p></td>\n      <td><p>java.util.List#of()</p></td>\n    </tr>\n    <tr>\n      <td><p>com.google.common.collect.ImmutableMap#of()</p></td>\n      <td><p>java.util.Map#of() 또는 java.util.Map#ofEntries()</p></td>\n    </tr>\n  </tbody>\n</table>",
    "howToFix_ko": "",
    "moreInfo_ko": ""
  },
  {
    "id": "S3012",
    "key": "java:S3012",
    "name": "Arrays and lists should not be copied using loops",
    "type": "code-smell",
    "severity": "minor",
    "tags": [
      "clumsy"
    ],
    "why": "<p>The JDK provides a set of built-in methods to copy the contents of an array into another array. Using a loop to perform the same operation is less\nclear, more verbose and should be avoided.</p>\n<h3>Exceptions</h3>\n<p>The rule detects only the most idiomatic patterns, it will not consider loops with non-trivial control flow. For example, loops that copy array\nelements conditionally are ignored.</p>",
    "howToFix": "<p>You can use:</p>\n<ul>\n  <li> <code>Arrays.copyOf</code> to copy an entire array into another array </li>\n  <li> <code>System.arraycopy</code> to copy only a subset of an array into another array </li>\n  <li> <code>Arrays.asList</code> to create a new list with the contents of the array </li>\n  <li> <code>Collections.addAll</code> to add the elements of a collection into another collection </li>\n</ul>\n<p>Note that <code>Arrays.asList</code> returns a fixed-size <code>List</code>, so further steps are required if a non-fixed-size <code>List</code> is\nneeded.</p>\n\n<h4>Noncompliant code example</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\npublic void copyArray(String[] source){\n  String[] array = new String[source.length];\n  for (int i = 0; i &lt; source.length; i++) {\n    array[i] = source[i]; // Noncompliant\n  }\n}\n\npublic void copyList(List&lt;String&gt; source) {\n  List&lt;String&gt; list = new ArrayList&lt;&gt;();\n  for (String s : source) {\n    list.add(s); // Noncompliant\n  }\n}\n</pre>\n<h4>Compliant solution</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\npublic void copyArray(String[] source){\n  String[] array = Arrays.copyOf(source, source.length);\n}\n\npublic void copyList(List&lt;String&gt; source) {\n  List&lt;String&gt; list = new ArrayList&lt;&gt;();\n  Collections.addAll(list, source);\n}\n</pre>\n<pre>\npublic void makeCopiesConditional(int[] source) {\n  int[] dest = new int[source.length];\n  for (int i = 0; i &lt; source.length; i++) {\n    if (source[i] &gt; 10) {\n      dest[i] = source[i];  // Compliant, since the array elements are conditionally copied to the dest array\n    }\n  }\n}\n</pre>",
    "moreInfo": "<h3>Documentation</h3>\n<ul>\n  <li> <a\n  href=\"https://docs.oracle.com/javase/8/docs/api/java/util/Arrays.html#copyOf-T:A-int-:~:text=1.6-,copyOf,-public%20static%C2%A0byte\">docs.oracle</a>\n  - Arrays.copyOf documentation </li>\n  <li> <a\n  href=\"https://docs.oracle.com/javase/8/docs/api/java/util/Arrays.html#asList-T…​-:~:text=1.6-,asList,-%40SafeVarargs%0Apublic%20static\">docs.oracle</a> - Arrays.asList documentation </li>\n  <li> <a\n  href=\"https://docs.oracle.com/javase/8/docs/api/java/lang/System.html#arraycopy-java.lang.Object-int-java.lang.Object-int-int-:~:text=1.5-,arraycopy,-public%20static%C2%A0void\">docs.oracle</a> - System.arraycopy documentation </li>\n</ul>",
    "status": "READY",
    "name_ko": "배열과 리스트는 반복문으로 복사하면 안 됩니다",
    "why_ko": "<p>JDK는 배열의 내용을 다른 배열로 복사하는 내장 메서드 세트를 제공합니다. 동일한 작업을 수행하기 위해 반복문을 사용하는 것은 덜 명확하고 더 장황하므로 피해야 합니다.</p>\n<h3>예외</h3>\n<p>이 규칙은 가장 관용적인 패턴만 감지하며, 복잡한 제어 흐름이 있는 반복문은 고려하지 않습니다. 예를 들어, 배열 요소를 조건부로 복사하는 반복문은 무시됩니다.</p>",
    "howToFix_ko": "<p>다음을 사용할 수 있습니다:</p>\n<ul>\n  <li> <code>Arrays.copyOf</code> - 전체 배열을 다른 배열로 복사 </li>\n  <li> <code>System.arraycopy</code> - 배열의 일부만 다른 배열로 복사 </li>\n  <li> <code>Arrays.asList</code> - 배열의 내용으로 새 리스트 생성 </li>\n  <li> <code>Collections.addAll</code> - 컬렉션의 요소를 다른 컬렉션에 추가 </li>\n</ul>\n<p><code>Arrays.asList</code>는 고정 크기 <code>List</code>를 반환하므로 고정 크기가 아닌 <code>List</code>가 필요한 경우 추가 단계가 필요합니다.</p>\n\n<h4>규칙을 준수하지 않는 코드 예시</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\npublic void copyArray(String[] source){\n  String[] array = new String[source.length];\n  for (int i = 0; i &lt; source.length; i++) {\n    array[i] = source[i]; // 규칙 위반\n  }\n}\n\npublic void copyList(List&lt;String&gt; source) {\n  List&lt;String&gt; list = new ArrayList&lt;&gt;();\n  for (String s : source) {\n    list.add(s); // 규칙 위반\n  }\n}\n</pre>\n<h4>규칙을 준수하는 해결책</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\npublic void copyArray(String[] source){\n  String[] array = Arrays.copyOf(source, source.length);\n}\n\npublic void copyList(List&lt;String&gt; source) {\n  List&lt;String&gt; list = new ArrayList&lt;&gt;();\n  Collections.addAll(list, source);\n}\n</pre>\n<pre>\npublic void makeCopiesConditional(int[] source) {\n  int[] dest = new int[source.length];\n  for (int i = 0; i &lt; source.length; i++) {\n    if (source[i] &gt; 10) {\n      dest[i] = source[i];  // 규칙 준수, 배열 요소가 조건부로 dest 배열에 복사되므로\n    }\n  }\n}\n</pre>",
    "moreInfo_ko": "<h3>문서</h3>\n<ul>\n  <li> <a href=\"https://docs.oracle.com/javase/8/docs/api/java/util/Arrays.html#copyOf-T:A-int-:~:text=1.6-,copyOf,-public%20static%C2%A0byte\">docs.oracle</a> - Arrays.copyOf 문서 </li>\n  <li> <a href=\"https://docs.oracle.com/javase/8/docs/api/java/util/Arrays.html#asList-T…​-:~:text=1.6-,asList,-%40SafeVarargs%0Apublic%20static\">docs.oracle</a> - Arrays.asList 문서 </li>\n  <li> <a href=\"https://docs.oracle.com/javase/8/docs/api/java/lang/System.html#arraycopy-java.lang.Object-int-java.lang.Object-int-int-:~:text=1.5-,arraycopy,-public%20static%C2%A0void\">docs.oracle</a> - System.arraycopy 문서 </li>\n</ul>"
  },
  {
    "id": "S1185",
    "key": "java:S1185",
    "name": "Overriding methods should do more than simply call the same method in the super class",
    "type": "code-smell",
    "severity": "minor",
    "tags": [
      "redundant",
      "clumsy"
    ],
    "why": "<p>Overriding a method just to call the same method from the super class without performing any other actions is useless and misleading. The only time\nthis is justified is in <code>final</code> overriding methods, where the effect is to lock in the parent class behavior. This rule ignores such\noverrides of <code>equals</code>, <code>hashCode</code> and <code>toString</code>.</p>\n<h3>Noncompliant code example</h3>\n<pre>\npublic void doSomething() {\n  super.doSomething();\n}\n\n@Override\npublic boolean isLegal(Action action) {\n  return super.isLegal(action);\n}\n</pre>\n<h3>Compliant solution</h3>\n<pre>\n@Override\npublic boolean isLegal(Action action) {         // Compliant - not simply forwarding the call\n  return super.isLegal(new Action(/* ... */));\n}\n\n@Id\n@Override\npublic int getId() {                            // Compliant - there is annotation different from @Override\n  return super.getId();\n}\n</pre>",
    "howToFix": "",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "오버라이딩 메서드는 부모 클래스의 같은 메서드를 단순히 호출하는 것 이상을 해야 합니다",
    "why_ko": "<p>다른 작업을 수행하지 않고 부모 클래스에서 동일한 메서드를 호출하기 위해서만 메서드를 오버라이드하는 것은 쓸모없고 오해를 불러일으킵니다. 이것이 정당화되는 유일한 경우는 <code>final</code> 오버라이딩 메서드에서 부모 클래스 동작을 고정하는 효과가 있는 경우입니다. 이 규칙은 <code>equals</code>, <code>hashCode</code> 및 <code>toString</code>의 그러한 오버라이드를 무시합니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\npublic void doSomething() {\n  super.doSomething();\n}\n\n@Override\npublic boolean isLegal(Action action) {\n  return super.isLegal(action);\n}\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre>\n@Override\npublic boolean isLegal(Action action) {         // 규칙 준수 - 단순히 호출을 전달하지 않음\n  return super.isLegal(new Action(/* ... */));\n}\n\n@Id\n@Override\npublic int getId() {                            // 규칙 준수 - @Override와 다른 어노테이션이 있음\n  return super.getId();\n}\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": ""
  },
  {
    "id": "S2253",
    "key": "java:S2253",
    "name": "Track uses of disallowed methods",
    "type": "code-smell",
    "severity": "major",
    "tags": [],
    "why": "<p>This rule allows banning certain methods.</p>\n<h3>Noncompliant code example</h3>\n<p>Given parameters:</p>\n<ul>\n  <li> className:java.lang.String </li>\n  <li> methodName: replace </li>\n  <li> argumentTypes: java.lang.CharSequence, java.lang.CharSequence </li>\n</ul>\n<pre>\nString name;\nname.replace(\"A\",\"a\");  // Noncompliant\n</pre>",
    "howToFix": "",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "허용되지 않는 메서드 사용을 추적해야 합니다",
    "why_ko": "<p>이 규칙은 특정 메서드를 금지할 수 있게 합니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<p>주어진 매개변수:</p>\n<ul>\n  <li> className:java.lang.String </li>\n  <li> methodName: replace </li>\n  <li> argumentTypes: java.lang.CharSequence, java.lang.CharSequence </li>\n</ul>\n<pre>\nString name;\nname.replace(\"A\",\"a\");  // 규칙 위반\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": ""
  },
  {
    "id": "S1994",
    "key": "java:S1994",
    "name": "\"for\" loop increment clauses should modify the loops' counters",
    "type": "code-smell",
    "severity": "critical",
    "tags": [
      "confusing"
    ],
    "why": "<p>The counter of a <code>for</code> loop should be updated in the loop's increment clause. The purpose of a <code>for</code> loop is to iterate over\na range using a counter variable. It should not be used for other purposes, and alternative loops should be used in those cases.</p>\n<p>If the counter is not updated, the loop will be infinite with a constant counter variable. If this is intentional, use a <code>while</code> or\n<code>do</code> <code>while</code> loop instead of a <code>for</code> loop.</p>\n<p>If the counter variable is updated within the loop's body, try to move it to the increment clause. If this is impossible due to certain conditions,\nreplace the <code>for</code> loop with a <code>while</code> or <code>do</code> <code>while</code> loop.</p>",
    "howToFix": "<h4>Noncompliant code example</h4>\n<p>Move the counter variable update to the loop's increment clause.</p>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\nfor (int i = 0; i &lt; 10; ) { // Noncompliant, i not updated in increment clause\n  // ...\n  i++;\n}\n</pre>\n<pre data-diff-id=\"2\" data-diff-type=\"noncompliant\">\nint sum = 0\nfor (int i = 0; i &lt; 10; sum++) { // Noncompliant, i not updated in increment clause\n  // ...\n  i++;\n}\n</pre>\n<h4>Compliant solution</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\nfor (i = 0; i &lt; 10; i++) { // Compliant\n  // ...\n}\n</pre>\n<pre data-diff-id=\"2\" data-diff-type=\"compliant\">\nint sum = 0\nfor (int i = 0; i &lt; 10; i++) { // Compliant\n  // ...\n  sum++;\n}\n</pre>\n<h4>Noncompliant code example</h4>\n<p>If this is impossible and the counter variable must be updated in the loop's body, use a <code>while</code> or <code>do</code> <code>while</code>\nloop instead.</p>\n<pre data-diff-id=\"3\" data-diff-type=\"noncompliant\">\nfor (int sum = 0; sum &lt; 10) { // Noncompliant, sum not updated in increment clause\n  // ...\n  if (condition) sum++;\n  // ...\n}\n</pre>\n<h4>Compliant solution</h4>\n<pre data-diff-id=\"3\" data-diff-type=\"compliant\">\nint sum = 0;\nwhile (sum &lt; 10) { // Compliant\n  // ...\n  if (condition) sum++;\n  // ...\n}\n</pre>",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "\"for\" 루프 증감 절은 루프 카운터를 수정해야 합니다",
    "why_ko": "<p><code>for</code> 루프의 카운터는 루프의 증감 절에서 업데이트해야 합니다. <code>for</code> 루프의 목적은 카운터 변수를 사용하여 범위를 반복하는 것입니다. 다른 목적으로 사용해서는 안 되며, 그러한 경우에는 대체 루프를 사용해야 합니다.</p>\n<p>카운터가 업데이트되지 않으면 카운터 변수가 상수인 채로 무한 루프가 됩니다. 이것이 의도적이라면 <code>for</code> 루프 대신 <code>while</code> 또는 <code>do</code> <code>while</code> 루프를 사용하세요.</p>\n<p>카운터 변수가 루프 본문 내에서 업데이트된다면 증감 절로 이동하려고 시도하세요. 특정 조건으로 인해 불가능하다면 <code>for</code> 루프를 <code>while</code> 또는 <code>do</code> <code>while</code> 루프로 대체하세요.</p>",
    "howToFix_ko": "<h4>규칙을 준수하지 않는 코드 예시</h4>\n<p>카운터 변수 업데이트를 루프의 증감 절로 이동하세요.</p>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\nfor (int i = 0; i &lt; 10; ) { // 규칙 위반, i가 증감 절에서 업데이트되지 않음\n  // ...\n  i++;\n}\n</pre>\n<pre data-diff-id=\"2\" data-diff-type=\"noncompliant\">\nint sum = 0\nfor (int i = 0; i &lt; 10; sum++) { // 규칙 위반, i가 증감 절에서 업데이트되지 않음\n  // ...\n  i++;\n}\n</pre>\n<h4>규칙을 준수하는 해결책</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\nfor (i = 0; i &lt; 10; i++) { // 규칙 준수\n  // ...\n}\n</pre>\n<pre data-diff-id=\"2\" data-diff-type=\"compliant\">\nint sum = 0\nfor (int i = 0; i &lt; 10; i++) { // 규칙 준수\n  // ...\n  sum++;\n}\n</pre>\n<h4>규칙을 준수하지 않는 코드 예시</h4>\n<p>불가능하고 카운터 변수가 루프 본문에서 업데이트되어야 한다면 대신 <code>while</code> 또는 <code>do</code> <code>while</code> 루프를 사용하세요.</p>\n<pre data-diff-id=\"3\" data-diff-type=\"noncompliant\">\nfor (int sum = 0; sum &lt; 10) { // 규칙 위반, sum이 증감 절에서 업데이트되지 않음\n  // ...\n  if (condition) sum++;\n  // ...\n}\n</pre>\n<h4>규칙을 준수하는 해결책</h4>\n<pre data-diff-id=\"3\" data-diff-type=\"compliant\">\nint sum = 0;\nwhile (sum &lt; 10) { // 규칙 준수\n  // ...\n  if (condition) sum++;\n  // ...\n}\n</pre>",
    "moreInfo_ko": ""
  },
  {
    "id": "S2204",
    "key": "java:S2204",
    "name": "\".equals()\" should not be used to test the values of \"Atomic\" classes",
    "type": "bug",
    "severity": "major",
    "tags": [
      "multi-threading"
    ],
    "why": "<p>The <code>equals</code> method in <code>AtomicInteger</code> and <code>AtomicLong</code> returns <code>true</code> only if two instances are\nidentical, not if they represent the same number value.</p>\n<p>This is because <code>equals</code> is not part of the API contract of these classes, and they do not override the method inherited from\n<code>java.lang.Object</code>. Although both classes implement the <code>Number</code> interface, assertions about <code>equals</code> comparing\nnumber values are not part of that interface either. Only the API contract of implementing classes like <code>Integer</code>, <code>Long</code>,\n<code>Float</code>, <code>BigInteger</code>, etc., provides such assertions.</p>",
    "howToFix": "<ul>\n  <li> To compare the number value of two instances <code>a</code> and <code>b</code> of <code>AtomicInteger</code> or <code>AtomicLong</code>, use\n  <code>a.get() == b.get()</code> instead of <code>a.equals(b)</code>. </li>\n  <li> If you want to check for object identity, use <code>a == b</code> instead of <code>a.equals(b)</code> to clarify your intention. </li>\n</ul>\n\n<h4>Noncompliant code example</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\nBoolean isSameNumberValue(AtomicLong a, AtomicLong b) {\n  return a.equals(b); // Noncompliant, this is true only if a == b\n}\n\nBoolean isSameReference(AtomicLong a, AtomicLong b) {\n  return a.equals(b); // Noncompliant, because misleading\n}\n</pre>\n<h4>Compliant solution</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\nBoolean isSameNumberValue(AtomicLong a, AtomicLong b) {\n  return a.get() == b.get(); // Compliant\n}\n\nBoolean isSameReference(AtomicLong a, AtomicLong b) {\n  return a == b; // Compliant\n}\n</pre>",
    "moreInfo": "<h3>Documentation</h3>\n<ul>\n  <li> <a href=\"https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/atomic/package-summary.html\">Java SE 8 API Specification: Package\n  \"java.util.concurrent.atomic\"</a> </li>\n</ul>\n<h3>Articles &amp; blog posts</h3>\n<ul>\n  <li> <a href=\"https://programming.guide/java/atomicinteger-equals.html\">Programming.Guide: AtomicInteger and equals / Comparable</a> </li>\n</ul>",
    "status": "READY",
    "name_ko": "\"Atomic\" 클래스의 값 비교에 \".equals()\"를 사용하면 안 됩니다",
    "why_ko": "<p><code>AtomicInteger</code>와 <code>AtomicLong</code>의 <code>equals</code> 메서드는 두 인스턴스가 동일할 때만 <code>true</code>를 반환하며, 같은 숫자 값을 나타내는지 여부가 아닙니다.</p>\n<p>이는 <code>equals</code>가 이러한 클래스의 API 계약의 일부가 아니며 <code>java.lang.Object</code>에서 상속받은 메서드를 재정의하지 않기 때문입니다. 두 클래스 모두 <code>Number</code> 인터페이스를 구현하지만 숫자 값을 비교하는 <code>equals</code>에 대한 주장은 해당 인터페이스의 일부도 아닙니다. <code>Integer</code>, <code>Long</code>, <code>Float</code>, <code>BigInteger</code> 등과 같은 구현 클래스의 API 계약만이 그러한 주장을 제공합니다.</p>",
    "howToFix_ko": "<ul>\n  <li> <code>AtomicInteger</code> 또는 <code>AtomicLong</code>의 두 인스턴스 <code>a</code>와 <code>b</code>의 숫자 값을 비교하려면 <code>a.equals(b)</code> 대신 <code>a.get() == b.get()</code>을 사용하세요. </li>\n  <li> 객체 동일성을 확인하려면 의도를 명확히 하기 위해 <code>a.equals(b)</code> 대신 <code>a == b</code>를 사용하세요. </li>\n</ul>\n\n<h4>규칙을 준수하지 않는 코드 예시</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\nBoolean isSameNumberValue(AtomicLong a, AtomicLong b) {\n  return a.equals(b); // 규칙 위반, a == b일 때만 true\n}\n\nBoolean isSameReference(AtomicLong a, AtomicLong b) {\n  return a.equals(b); // 규칙 위반, 오해의 소지가 있음\n}\n</pre>\n<h4>규칙을 준수하는 해결책</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\nBoolean isSameNumberValue(AtomicLong a, AtomicLong b) {\n  return a.get() == b.get(); // 규칙 준수\n}\n\nBoolean isSameReference(AtomicLong a, AtomicLong b) {\n  return a == b; // 규칙 준수\n}\n</pre>",
    "moreInfo_ko": "<h3>문서</h3>\n<ul>\n  <li> <a href=\"https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/atomic/package-summary.html\">Java SE 8 API 명세: \"java.util.concurrent.atomic\" 패키지</a> </li>\n</ul>\n<h3>관련 문서 및 블로그 게시물</h3>\n<ul>\n  <li> <a href=\"https://programming.guide/java/atomicinteger-equals.html\">Programming.Guide: AtomicInteger와 equals / Comparable</a> </li>\n</ul>"
  },
  {
    "id": "S3415",
    "key": "java:S3415",
    "name": "Assertion arguments should be passed in the correct order",
    "type": "code-smell",
    "severity": "major",
    "tags": [
      "junit",
      "tests",
      "suspicious"
    ],
    "why": "<p>The standard assertions library methods such as <code>org.junit.Assert.assertEquals</code>, and <code>org.junit.Assert.assertSame</code> expect the\nfirst argument to be the expected value and the second argument to be the actual value. For AssertJ instead, the argument of\n<code>org.assertj.core.api.Assertions.assertThat</code> is the actual value, and the subsequent calls contain the expected values.</p>\n<h3>What is the potential impact?</h3>\n<p>Having the expected value and the actual value in the wrong order will not alter the outcome of tests, (succeed/fail when it should) but the error\nmessages will contain misleading information.</p>\n<p>This rule raises an issue when the actual argument to an assertions library method is a hard-coded value and the expected argument is not.</p>",
    "howToFix": "<p>You should provide the assertion methods with a hard-coded value as the expected value, while the actual value of the assertion should derive from\nthe portion of code that you want to test.</p>\n<p>Supported frameworks:</p>\n<ul>\n  <li> <a href=\"https://junit.org/junit4/\">JUnit4</a> </li>\n  <li> <a href=\"https://junit.org/junit5/docs/current/user-guide/\">JUnit5</a> </li>\n  <li> <a href=\"https://assertj.github.io/doc/\">AssertJ</a> </li>\n</ul>\n\n<h4>Noncompliant code example</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\norg.junit.Assert.assertEquals(runner.exitCode(), 0, \"Unexpected exit code\");  // Noncompliant; Yields error message like: Expected:&lt;-1&gt;. Actual:&lt;0&gt;.\norg.assertj.core.api.Assertions.assertThat(0).isEqualTo(runner.exitCode()); // Noncompliant\n</pre>\n<h4>Compliant solution</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\norg.junit.Assert.assertEquals(0, runner.exitCode(), \"Unexpected exit code\");\norg.assertj.core.api.Assertions.assertThat(runner.exitCode()).isEqualTo(0);\n</pre>",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "Assertion 인수는 올바른 순서로 전달해야 합니다",
    "why_ko": "<p><code>org.junit.Assert.assertEquals</code>, <code>org.junit.Assert.assertSame</code>과 같은 표준 assertion 라이브러리 메서드는 첫 번째 인수가 기대 값이고 두 번째 인수가 실제 값이어야 합니다. AssertJ의 경우 <code>org.assertj.core.api.Assertions.assertThat</code>의 인수가 실제 값이고, 후속 호출에 기대 값이 포함됩니다.</p>\n<h3>잠재적 영향은 무엇인가요?</h3>\n<p>기대 값과 실제 값이 잘못된 순서로 있어도 테스트 결과(성공/실패해야 할 때)는 변경되지 않지만, 오류 메시지에 잘못된 정보가 포함됩니다.</p>\n<p>이 규칙은 assertion 라이브러리 메서드에 대한 실제 인수가 하드코딩된 값이고 기대 인수가 그렇지 않을 때 문제를 제기합니다.</p>",
    "howToFix_ko": "<p>assertion 메서드에는 기대 값으로 하드코딩된 값을 제공해야 하며, assertion의 실제 값은 테스트하려는 코드 부분에서 파생되어야 합니다.</p>\n<p>지원되는 프레임워크:</p>\n<ul>\n  <li> <a href=\"https://junit.org/junit4/\">JUnit4</a> </li>\n  <li> <a href=\"https://junit.org/junit5/docs/current/user-guide/\">JUnit5</a> </li>\n  <li> <a href=\"https://assertj.github.io/doc/\">AssertJ</a> </li>\n</ul>\n\n<h4>규칙을 준수하지 않는 코드 예시</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\norg.junit.Assert.assertEquals(runner.exitCode(), 0, \"Unexpected exit code\");  // 규칙 위반; 다음과 같은 오류 메시지 생성: Expected:&lt;-1&gt;. Actual:&lt;0&gt;.\norg.assertj.core.api.Assertions.assertThat(0).isEqualTo(runner.exitCode()); // 규칙 위반\n</pre>\n<h4>규칙을 준수하는 해결책</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\norg.junit.Assert.assertEquals(0, runner.exitCode(), \"Unexpected exit code\");\norg.assertj.core.api.Assertions.assertThat(runner.exitCode()).isEqualTo(0);\n</pre>",
    "moreInfo_ko": ""
  },
  {
    "id": "S1214",
    "key": "java:S1214",
    "name": "Interfaces should not solely consist of constants",
    "type": "code-smell",
    "severity": "critical",
    "tags": [
      "bad-practice"
    ],
    "why": "<p>An interface that consists solely of constant definitions is a bad practice. The purpose of interfaces is to provide an API, not implementation\ndetails. That is, they should provide functions in the first place and constants only to assist these functions, for example, as possible\narguments.</p>\n<p>If an interface contains constants only, move them either to somewhere else, or replace the interface with an <em>Enum</em> or a final class with a\nprivate constructor.</p>",
    "howToFix": "<p>If the concrete value of the constants is not essential, and they serve as mere identifiers, replace the interface with an <code>enum</code> like\nin the following example:</p>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\npublic interface Status { // Noncompliant, enum should be used\n  int OPEN = 1;\n  int CLOSED = 2;\n}\n</pre>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\npublic enum Status {      // Compliant\n  OPEN,\n  CLOSED\n}\n</pre>\n<p>In some cases, enums are not a suitable option because the concrete constant value is important. Then you should check whether it is appropriate to\nmove them to a specific existing class, for example, if that class is the primary user of the constants:</p>\n<pre data-diff-id=\"2\" data-diff-type=\"noncompliant\">\ninterface AuxiliaryConstants { // Noncompliant, implementation detail of WordPacker\n  int BITS_PER_WORD = 16;\n  int WORD_MASK = (1 &lt;&lt; BITS_PER_WORD) - 1;\n  int HI_WORD_BK_MASK = ~(WORD_MASK &lt;&lt; BITS_PER_WORD);\n}\n\nclass WordPacker {\n  public static int getHiWord(int value) {\n    return (value &gt;&gt;&gt; AuxiliaryConstants.BITS_PER_WORD);\n  }\n\n  public static int setHiWord(int value, int wordValue) {\n    return (value &amp; AuxiliaryConstants.HI_WORD_BK_MASK) |\n      (wordValue &lt;&lt; AuxiliaryConstants.BITS_PER_WORD);\n  }\n}\n</pre>\n<pre data-diff-id=\"2\" data-diff-type=\"compliant\">\nclass WordPacker { // Compliant\n  private static final int BITS_PER_WORD = 16;\n  private static final int WORD_MASK = (1 &lt;&lt; BITS_PER_WORD) - 1;\n  private static final int HI_WORD_BK_MASK = ~(WORD_MASK &lt;&lt; BITS_PER_WORD);\n\n  public static int getHiWord(int value) {\n      return (value &gt;&gt;&gt; BITS_PER_WORD);\n  }\n\n  public static int setHiWord(int value, int wordValue) {\n    return (value &amp; HI_WORD_BK_MASK) | (wordValue &lt;&lt; BITS_PER_WORD);\n  }\n}\n</pre>\n<p>If this is not the case and several classes are using the constants equally, you should use a final class with a private constructor. Unlike\ninterfaces, they can neither be inherited from nor instantiated.</p>\n<pre data-diff-id=\"3\" data-diff-type=\"noncompliant\">\npublic interface ColorTheme { // Noncomplient, final class should be used\n  int COLOR_ERROR = 0xff0000;   // red\n  int COLOR_WARNING = 0xffff00; // yellow\n  int COLOR_OK = 0x00cf00;      // green\n}\n</pre>\n<pre data-diff-id=\"3\" data-diff-type=\"compliant\">\npublic final class ColorTheme { // Compliant\n  public static final int COLOR_ERROR = 0xff0000;   // red\n  public static final int COLOR_WARNING = 0xffff00; // yellow\n  public static final int COLOR_OK = 0x00cf00;      // green\n\n  private ColorTheme() {}\n}\n</pre>",
    "moreInfo": "<h3>Articles &amp; blog posts</h3>\n<ul>\n  <li> <a href=\"https://dzone.com/articles/reasons-why-the-constant-interface-pattern-is-disc\">Mohammad Nadeem - Why the Constant Interface Pattern\n  Should Be Discouraged</a> </li>\n  <li> Joshua Bloch - Effective Java, ISBN 9780134686097 </li>\n</ul>",
    "status": "READY",
    "name_ko": "인터페이스는 상수로만 구성되면 안 됩니다",
    "why_ko": "<p>상수 정의로만 구성된 인터페이스는 나쁜 관행입니다. 인터페이스의 목적은 구현 세부 사항이 아닌 API를 제공하는 것입니다. 즉, 우선 함수를 제공하고 상수는 예를 들어 가능한 인수로서 이러한 함수를 지원하기 위해서만 제공해야 합니다.</p>\n<p>인터페이스가 상수만 포함하는 경우, 상수를 다른 곳으로 이동하거나 인터페이스를 <em>Enum</em> 또는 private 생성자가 있는 final 클래스로 대체하세요.</p>",
    "howToFix_ko": "<p>상수의 구체적인 값이 필수적이지 않고 단순한 식별자 역할을 하는 경우, 다음 예시처럼 인터페이스를 <code>enum</code>으로 대체하세요:</p>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\npublic interface Status { // 규칙 위반, enum을 사용해야 함\n  int OPEN = 1;\n  int CLOSED = 2;\n}\n</pre>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\npublic enum Status {      // 규칙 준수\n  OPEN,\n  CLOSED\n}\n</pre>\n<p>어떤 경우에는 구체적인 상수 값이 중요하기 때문에 enum이 적합한 옵션이 아닙니다. 그런 경우 상수를 특정 기존 클래스로 이동하는 것이 적절한지 확인해야 합니다. 예를 들어, 해당 클래스가 상수의 주요 사용자인 경우:</p>\n<pre data-diff-id=\"2\" data-diff-type=\"noncompliant\">\ninterface AuxiliaryConstants { // 규칙 위반, WordPacker의 구현 세부 사항\n  int BITS_PER_WORD = 16;\n  int WORD_MASK = (1 &lt;&lt; BITS_PER_WORD) - 1;\n  int HI_WORD_BK_MASK = ~(WORD_MASK &lt;&lt; BITS_PER_WORD);\n}\n\nclass WordPacker {\n  public static int getHiWord(int value) {\n    return (value &gt;&gt;&gt; AuxiliaryConstants.BITS_PER_WORD);\n  }\n\n  public static int setHiWord(int value, int wordValue) {\n    return (value &amp; AuxiliaryConstants.HI_WORD_BK_MASK) |\n      (wordValue &lt;&lt; AuxiliaryConstants.BITS_PER_WORD);\n  }\n}\n</pre>\n<pre data-diff-id=\"2\" data-diff-type=\"compliant\">\nclass WordPacker { // 규칙 준수\n  private static final int BITS_PER_WORD = 16;\n  private static final int WORD_MASK = (1 &lt;&lt; BITS_PER_WORD) - 1;\n  private static final int HI_WORD_BK_MASK = ~(WORD_MASK &lt;&lt; BITS_PER_WORD);\n\n  public static int getHiWord(int value) {\n      return (value &gt;&gt;&gt; BITS_PER_WORD);\n  }\n\n  public static int setHiWord(int value, int wordValue) {\n    return (value &amp; HI_WORD_BK_MASK) | (wordValue &lt;&lt; BITS_PER_WORD);\n  }\n}\n</pre>\n<p>이것이 해당되지 않고 여러 클래스가 상수를 동등하게 사용하는 경우, private 생성자가 있는 final 클래스를 사용해야 합니다. 인터페이스와 달리, 이들은 상속받거나 인스턴스화할 수 없습니다.</p>\n<pre data-diff-id=\"3\" data-diff-type=\"noncompliant\">\npublic interface ColorTheme { // 규칙 위반, final 클래스를 사용해야 함\n  int COLOR_ERROR = 0xff0000;   // 빨강\n  int COLOR_WARNING = 0xffff00; // 노랑\n  int COLOR_OK = 0x00cf00;      // 초록\n}\n</pre>\n<pre data-diff-id=\"3\" data-diff-type=\"compliant\">\npublic final class ColorTheme { // 규칙 준수\n  public static final int COLOR_ERROR = 0xff0000;   // 빨강\n  public static final int COLOR_WARNING = 0xffff00; // 노랑\n  public static final int COLOR_OK = 0x00cf00;      // 초록\n\n  private ColorTheme() {}\n}\n</pre>",
    "moreInfo_ko": "<h3>관련 글 및 블로그 포스트</h3>\n<ul>\n  <li> <a href=\"https://dzone.com/articles/reasons-why-the-constant-interface-pattern-is-disc\">Mohammad Nadeem - 상수 인터페이스 패턴이 권장되지 않는 이유</a> </li>\n  <li> Joshua Bloch - Effective Java, ISBN 9780134686097 </li>\n</ul>"
  },
  {
    "id": "S2438",
    "key": "java:S2438",
    "name": "\"Thread\" should not be used where a \"Runnable\" argument is expected",
    "type": "code-smell",
    "severity": "major",
    "tags": [
      "multi-threading",
      "pitfall"
    ],
    "why": "<p>The semantics of <code>Thread</code> and <code>Runnable</code> are different, and while it is technically correct to use <code>Thread</code> where\na <code>Runnable</code> is expected, it is a bad practice to do so.</p>\n<p>The crux of the issue is that <code>Thread</code> is a larger concept than <code>Runnable</code>. A <code>Runnable</code> represents a task. A\n<code>Thread</code> represents a task and its execution management (ie: how it should behave when started, stopped, resumed, …​). It is both a task\nand a lifecycle management.</p>\n<h3>Noncompliant code example</h3>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\npublic static void main(String[] args) {\n\tThread runnable = new Thread() {\n\t\t@Override\n\t\tpublic void run() { /* ... */ }\n\t};\n\tnew Thread(runnable).start();  // Noncompliant\n}\n</pre>\n<h3>Compliant solution</h3>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\npublic static void main(String[] args) {\n\tRunnable runnable = new Runnable() {\n\t\t@Override\n\t\tpublic void run() { /* ... */ }\n\t};\n\tnew Thread(runnable).start();\n}\n</pre>",
    "howToFix": "",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "Runnable 인수가 필요한 곳에 Thread를 사용하면 안 됩니다",
    "why_ko": "<p><code>Thread</code>와 <code>Runnable</code>의 의미론은 다르며, <code>Runnable</code>이 필요한 곳에 <code>Thread</code>를 사용하는 것이 기술적으로는 올바르지만 나쁜 관행입니다.</p>\n<p>문제의 핵심은 <code>Thread</code>가 <code>Runnable</code>보다 더 큰 개념이라는 것입니다. <code>Runnable</code>은 작업을 나타냅니다. <code>Thread</code>는 작업과 실행 관리(즉, 시작, 중지, 재개 시 어떻게 동작해야 하는지 등)를 나타냅니다. 작업이면서 동시에 라이프사이클 관리입니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\npublic static void main(String[] args) {\n\tThread runnable = new Thread() {\n\t\t@Override\n\t\tpublic void run() { /* ... */ }\n\t};\n\tnew Thread(runnable).start();  // 규칙 위반\n}\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\npublic static void main(String[] args) {\n\tRunnable runnable = new Runnable() {\n\t\t@Override\n\t\tpublic void run() { /* ... */ }\n\t};\n\tnew Thread(runnable).start();\n}\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": ""
  },
  {
    "id": "S2068",
    "key": "java:S2068",
    "name": "Hard-coded passwords are security-sensitive",
    "type": "security-hotspot",
    "severity": "blocker",
    "tags": [
      "cwe",
      "cert"
    ],
    "why": "<p>Because it is easy to extract strings from an application source code or binary, passwords should not be hard-coded. This is particularly true for\napplications that are distributed or that are open-source.</p>\n<p>In the past, it has led to the following vulnerabilities:</p>\n<ul>\n  <li> <a href=\"https://www.cve.org/CVERecord?id=CVE-2019-13466\">CVE-2019-13466</a> </li>\n  <li> <a href=\"https://www.cve.org/CVERecord?id=CVE-2018-15389\">CVE-2018-15389</a> </li>\n</ul>\n<p>Passwords should be stored outside of the code in a configuration file, a database, or a password management service.</p>\n<p>This rule flags instances of hard-coded passwords used in database and LDAP connections. It looks for hard-coded passwords in connection strings,\nand for variable names that match any of the patterns from the provided list.</p>\n",
    "howToFix": "<h2>Recommended Secure Coding Practices</h2>\n<ul>\n  <li> Store the credentials in a configuration file that is not pushed to the code repository. </li>\n  <li> Store the credentials in a database. </li>\n  <li> Use your cloud provider's service for managing secrets. </li>\n  <li> If a password has been disclosed through the source code: change it. </li>\n</ul>\n<h2>Compliant Solution</h2>\n<pre>\nString username = getEncryptedUser();\nString password = getEncryptedPassword();\nConnection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/test?\" +\n                  \"user=\" + username + \"&amp;password=\" + password);\n</pre>\n<h2>See</h2>\n<ul>\n  <li> OWASP - <a href=\"https://owasp.org/Top10/A07_2021-Identification_and_Authentication_Failures/\">Top 10 2021 Category A7 - Identification and\n  Authentication Failures</a> </li>\n  <li> OWASP - <a href=\"https://owasp.org/www-project-top-ten/2017/A2_2017-Broken_Authentication\">Top 10 2017 Category A2 - Broken Authentication</a>\n  </li>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/798\">CWE-798 - Use of Hard-coded Credentials</a> </li>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/259\">CWE-259 - Use of Hard-coded Password</a> </li>\n  <li> <a href=\"https://wiki.sei.cmu.edu/confluence/x/OjdGBQ\">CERT, MSC03-J.</a> - Never hard code sensitive information </li>\n  <li> Derived from FindSecBugs rule <a href=\"https://h3xstream.github.io/find-sec-bugs/bugs.htm#HARD_CODE_PASSWORD\">Hard Coded Password</a> </li>\n</ul>",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "하드코딩된 비밀번호는 보안에 민감합니다",
    "why_ko": "<p>애플리케이션 소스 코드나 바이너리에서 문자열을 추출하기 쉽기 때문에 비밀번호는 하드코딩하면 안 됩니다. 이것은 배포되거나 오픈 소스인 애플리케이션에 특히 해당됩니다.</p>\n<p>과거에 다음과 같은 취약점으로 이어졌습니다:</p>\n<ul>\n  <li> <a href=\"https://www.cve.org/CVERecord?id=CVE-2019-13466\">CVE-2019-13466</a> </li>\n  <li> <a href=\"https://www.cve.org/CVERecord?id=CVE-2018-15389\">CVE-2018-15389</a> </li>\n</ul>\n<p>비밀번호는 구성 파일, 데이터베이스 또는 비밀번호 관리 서비스에서 코드 외부에 저장해야 합니다.</p>\n<p>이 규칙은 데이터베이스 및 LDAP 연결에 사용되는 하드코딩된 비밀번호의 인스턴스를 표시합니다. 연결 문자열에서 하드코딩된 비밀번호를 찾고 제공된 목록의 패턴과 일치하는 변수 이름을 찾습니다.</p>\n",
    "howToFix_ko": "<h2>권장 보안 코딩 방법</h2>\n<ul>\n  <li> 코드 저장소에 푸시되지 않는 구성 파일에 자격 증명을 저장하세요. </li>\n  <li> 데이터베이스에 자격 증명을 저장하세요. </li>\n  <li> 비밀 관리를 위해 클라우드 공급자의 서비스를 사용하세요. </li>\n  <li> 소스 코드를 통해 비밀번호가 노출된 경우: 변경하세요. </li>\n</ul>\n<h2>규칙을 준수하는 해결책</h2>\n<pre>\nString username = getEncryptedUser();\nString password = getEncryptedPassword();\nConnection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/test?\" +\n                  \"user=\" + username + \"&amp;password=\" + password);\n</pre>\n<h2>참고</h2>\n<ul>\n  <li> OWASP - <a href=\"https://owasp.org/Top10/A07_2021-Identification_and_Authentication_Failures/\">Top 10 2021 Category A7 - Identification and Authentication Failures</a> </li>\n  <li> OWASP - <a href=\"https://owasp.org/www-project-top-ten/2017/A2_2017-Broken_Authentication\">Top 10 2017 Category A2 - Broken Authentication</a> </li>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/798\">CWE-798 - Use of Hard-coded Credentials</a> </li>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/259\">CWE-259 - Use of Hard-coded Password</a> </li>\n  <li> <a href=\"https://wiki.sei.cmu.edu/confluence/x/OjdGBQ\">CERT, MSC03-J.</a> - Never hard code sensitive information </li>\n  <li> FindSecBugs 규칙에서 파생됨 <a href=\"https://h3xstream.github.io/find-sec-bugs/bugs.htm#HARD_CODE_PASSWORD\">Hard Coded Password</a> </li>\n</ul>",
    "moreInfo_ko": ""
  },
  {
    "id": "S5876",
    "key": "java:S5876",
    "name": "A new session should be created during user authentication",
    "type": "vulnerability",
    "severity": "critical",
    "tags": [
      "cwe",
      "spring"
    ],
    "why": "<p>Session fixation attacks take advantage of the way web applications manage session identifiers. Here's how a session fixation attack typically\nworks:</p>\n<ul>\n  <li> When a user visits a website or logs in, a session is created for them. </li>\n  <li> This session is assigned a unique session identifier, stored in a cookie, in local storage, or through URL parameters. </li>\n  <li> In a session fixation attack, an attacker tricks a user into using a predetermined session identifier controlled by the attacker. For example,\n  the attacker sends the victim an email containing a link with this predetermined session identifier. </li>\n  <li> When the victim clicks on the link, the web application does not create a new session identifier but uses this identifier known to the\n  attacker. </li>\n  <li> At this point, the attacker can hijack and impersonate the victim's session. </li>\n</ul>\n<h3>What is the potential impact?</h3>\n<p>Session fixation attacks pose a significant security risk to web applications and their users. By exploiting this vulnerability, attackers can gain\nunauthorized access to user sessions, potentially leading to various malicious activities. Some of the most relevant scenarios are the following:</p>\n<h4>Impersonation</h4>\n<p>Once an attacker successfully fixes a session identifier, they can impersonate the victim and gain access to their account without providing valid\ncredentials. This can result in unauthorized actions, such as modifying personal information, making unauthorized transactions, or even performing\nmalicious activities on behalf of the victim. An attacker can also manipulate the victim into performing actions they wouldn't normally do, such as\nrevealing sensitive information or conducting financial transactions on the attacker's behalf.</p>\n<h4>Data Breach</h4>\n<p>If an attacker gains access to a user's session, they may also gain access to sensitive data associated with that session. This can include\npersonal information, financial details, or any other confidential data that the user has access to within the application. The compromised data can\nbe used for identity theft, financial fraud, or other malicious purposes.</p>\n<h4>Privilege Escalation</h4>\n<p>In some cases, session fixation attacks can be used to escalate privileges within a web application. By fixing a session identifier with higher\nprivileges, an attacker can bypass access controls and gain administrative or privileged access to the application. This can lead to unauthorized\nmodifications, data manipulation, or even complete compromise of the application and its underlying systems.</p>",
    "howToFix": "<p>In a Spring Security's context, session fixation protection is enabled by default but can be disabled with <code>sessionFixation().none()</code>\nmethod. Session fixation protection can also be enabled explicitly with <code>migrateSession()</code> but is superfluous in most cases.</p>\n<h4>Noncompliant code example</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\n@Override\nprotected void configure(HttpSecurity http) throws Exception {\n   http.sessionManagement()\n     .sessionFixation().none(); // Noncompliant: the existing session will continue\n}\n</pre>\n<h4>Compliant solution</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\n@Override\nprotected void configure(HttpSecurity http) throws Exception {\n  http.sessionManagement()\n     .sessionFixation().migrateSession();\n}\n</pre>\n<h3>How does this work?</h3>\n<p>The protection works by ensuring that the session identifier, which is used to identify and track a user's session, is changed or regenerated\nduring the authentication process.</p>\n<p>Here's how session fixation protection typically works:</p>\n<ol>\n  <li> When a user visits a website or logs in, a session is created for them. This session is assigned a unique session identifier, which is stored\n  in a cookie or passed through URL parameters. </li>\n  <li> In a session fixation attack, an attacker tricks a user into using a predetermined session identifier controlled by the attacker. This allows\n  the attacker to potentially gain unauthorized access to the user's session. </li>\n  <li> To protect against session fixation attacks, session fixation protection mechanisms come into play during the authentication process. When a\n  user successfully authenticates, this mechanism generates a new session identifier for the user's session. </li>\n  <li> The old session identifier, which may have been manipulated by the attacker, is invalidated and no longer associated with the user's session.\n  This ensures that any attempts by the attacker to use the fixed session identifier are rendered ineffective. </li>\n  <li> The user is then assigned the new session identifier, which is used for subsequent requests and session tracking. This new session identifier\n  is typically stored in a new session cookie or passed through URL parameters. </li>\n</ol>\n<p>By regenerating the session identifier upon authentication, session fixation protection helps ensure that the user's session is tied to a new,\nsecure identifier that the attacker cannot predict or control. This mitigates the risk of an attacker gaining unauthorized access to the user's\nsession and helps maintain the integrity and security of the application's session management process.</p>\n<p>In Spring, calling <code>migrateSession()</code> explicitly is not necessary in most cases, as it automatically migrates session attributes to a\nnew session upon successful authentication. The <code>migrateSession()</code> method is typically explicitly used when you want to manually trigger\nthe migration of session attributes to a new session outside of the authentication process.</p>",
    "moreInfo": "<h3>Documentation</h3>\n<p><a href=\"https://docs.spring.io/spring-security/reference/servlet/authentication/session-management.html\">Session Fixation Attack\nProtection</a></p>\n<h3>Standards</h3>\n<ul>\n  <li> OWASP - <a href=\"https://owasp.org/Top10/A07_2021-Identification_and_Authentication_Failures/\">Top 10 2021 Category A7 - Identification and\n  Authentication Failures</a> </li>\n  <li> OWASP - <a href=\"https://owasp.org/www-project-top-ten/2017/A2_2017-Broken_Authentication\">Top 10 2017 Category A2 - Broken Authentication</a>\n  </li>\n  <li> <a href=\"https://owasp.org/www-community/attacks/Session_fixation\">OWASP Session Fixation</a> </li>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/384\">CWE-384 - Session Fixation</a> </li>\n  <li> STIG Viewer - <a href=\"https://stigviewer.com/stigs/application_security_and_development/2024-12-06/finding/V-222579\">Application Security and\n  Development: V-222579</a> - Applications must use system-generated session identifiers that protect against session fixation. </li>\n  <li> STIG Viewer - <a href=\"https://stigviewer.com/stigs/application_security_and_development/2024-12-06/finding/V-222582\">Application Security and\n  Development: V-222582</a> - The application must not re-use or recycle session IDs. </li>\n</ul>",
    "status": "READY",
    "name_ko": "사용자 인증 시 새 세션을 생성해야 합니다",
    "why_ko": "<p>세션 고정 공격은 웹 애플리케이션이 세션 식별자를 관리하는 방식을 악용합니다. 세션 고정 공격이 일반적으로 작동하는 방식은 다음과 같습니다:</p>\n<ul>\n  <li> 사용자가 웹사이트를 방문하거나 로그인하면 세션이 생성됩니다. </li>\n  <li> 이 세션에는 쿠키, 로컬 스토리지 또는 URL 매개변수를 통해 저장되는 고유한 세션 식별자가 할당됩니다. </li>\n  <li> 세션 고정 공격에서 공격자는 사용자가 공격자가 제어하는 미리 정해진 세션 식별자를 사용하도록 속입니다. 예를 들어, 공격자는 이 미리 정해진 세션 식별자가 포함된 링크가 있는 이메일을 피해자에게 보냅니다. </li>\n  <li> 피해자가 링크를 클릭하면 웹 애플리케이션은 새 세션 식별자를 생성하지 않고 공격자에게 알려진 이 식별자를 사용합니다. </li>\n  <li> 이 시점에서 공격자는 피해자의 세션을 가로채고 사칭할 수 있습니다. </li>\n</ul>\n<h3>잠재적 영향은 무엇인가요?</h3>\n<p>세션 고정 공격은 웹 애플리케이션과 사용자에게 중대한 보안 위험을 초래합니다. 이 취약점을 악용하면 공격자는 사용자 세션에 무단으로 액세스하여 다양한 악의적인 활동을 할 수 있습니다. 가장 관련성 높은 시나리오는 다음과 같습니다:</p>\n<h4>사칭</h4>\n<p>공격자가 세션 식별자를 성공적으로 고정하면 피해자를 사칭하고 유효한 자격 증명을 제공하지 않고도 계정에 액세스할 수 있습니다. 이로 인해 개인 정보 수정, 무단 거래 또는 피해자를 대신한 악의적인 활동 수행과 같은 무단 행위가 발생할 수 있습니다.</p>\n<h4>데이터 유출</h4>\n<p>공격자가 사용자 세션에 액세스하면 해당 세션과 관련된 민감한 데이터에도 액세스할 수 있습니다. 여기에는 개인 정보, 금융 세부 정보 또는 사용자가 애플리케이션 내에서 액세스할 수 있는 기타 기밀 데이터가 포함될 수 있습니다.</p>\n<h4>권한 상승</h4>\n<p>경우에 따라 세션 고정 공격을 사용하여 웹 애플리케이션 내에서 권한을 상승시킬 수 있습니다. 더 높은 권한을 가진 세션 식별자를 고정함으로써 공격자는 액세스 제어를 우회하고 애플리케이션에 대한 관리자 또는 권한 있는 액세스를 얻을 수 있습니다.</p>",
    "howToFix_ko": "<p>Spring Security 컨텍스트에서 세션 고정 보호는 기본적으로 활성화되어 있지만 <code>sessionFixation().none()</code> 메서드로 비활성화할 수 있습니다. 세션 고정 보호는 <code>migrateSession()</code>으로 명시적으로 활성화할 수도 있지만 대부분의 경우 불필요합니다.</p>\n<h4>규칙을 준수하지 않는 코드 예시</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\n@Override\nprotected void configure(HttpSecurity http) throws Exception {\n   http.sessionManagement()\n     .sessionFixation().none(); // 규칙 위반: 기존 세션이 계속됩니다\n}\n</pre>\n<h4>규칙을 준수하는 해결책</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\n@Override\nprotected void configure(HttpSecurity http) throws Exception {\n  http.sessionManagement()\n     .sessionFixation().migrateSession();\n}\n</pre>\n<h3>어떻게 작동하나요?</h3>\n<p>보호는 사용자 세션을 식별하고 추적하는 데 사용되는 세션 식별자가 인증 프로세스 중에 변경되거나 재생성되도록 하여 작동합니다.</p>\n<p>세션 식별자 재생성을 통해 세션 고정 보호는 사용자 세션이 공격자가 예측하거나 제어할 수 없는 새롭고 안전한 식별자에 연결되도록 합니다. 이는 공격자가 사용자 세션에 무단으로 액세스할 위험을 완화하고 애플리케이션의 세션 관리 프로세스의 무결성과 보안을 유지하는 데 도움이 됩니다.</p>\n<p>Spring에서 <code>migrateSession()</code>을 명시적으로 호출하는 것은 대부분의 경우 필요하지 않습니다. 성공적인 인증 시 자동으로 세션 속성을 새 세션으로 마이그레이션하기 때문입니다.</p>",
    "moreInfo_ko": "<h3>문서</h3>\n<p><a href=\"https://docs.spring.io/spring-security/reference/servlet/authentication/session-management.html\">세션 고정 공격 보호</a></p>\n<h3>표준</h3>\n<ul>\n  <li> OWASP - <a href=\"https://owasp.org/Top10/A07_2021-Identification_and_Authentication_Failures/\">Top 10 2021 카테고리 A7 - 식별 및 인증 실패</a> </li>\n  <li> OWASP - <a href=\"https://owasp.org/www-project-top-ten/2017/A2_2017-Broken_Authentication\">Top 10 2017 카테고리 A2 - 취약한 인증</a> </li>\n  <li> <a href=\"https://owasp.org/www-community/attacks/Session_fixation\">OWASP 세션 고정</a> </li>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/384\">CWE-384 - 세션 고정</a> </li>\n</ul>"
  },
  {
    "id": "S2063",
    "key": "java:S2063",
    "name": "Comparators should be \"Serializable\"",
    "type": "code-smell",
    "severity": "critical",
    "tags": [
      "serialization",
      "pitfall"
    ],
    "why": "<p>A non-serializable <code>Comparator</code> can prevent an otherwise-<code>Serializable</code> ordered collection from being serializable. Since the\noverhead to make a <code>Comparator</code> serializable is usually low, doing so can be considered good defensive programming.</p>\n<h3>Noncompliant code example</h3>\n<pre>\npublic class FruitComparator implements Comparator&lt;Fruit&gt; {  // Noncompliant\n  int compare(Fruit f1, Fruit f2) {...}\n  boolean equals(Object obj) {...}\n}\n</pre>\n<h3>Compliant solution</h3>\n<pre>\npublic class FruitComparator implements Comparator&lt;Fruit&gt;, Serializable {\n  private static final long serialVersionUID = 1;\n\n  int compare(Fruit f1, Fruit f2) {...}\n  boolean equals(Object obj) {...}\n}\n</pre>",
    "howToFix": "",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "Comparator는 \"Serializable\"이어야 합니다",
    "why_ko": "<p>직렬화 불가능한 <code>Comparator</code>는 그렇지 않으면 <code>Serializable</code>인 정렬된 컬렉션을 직렬화할 수 없게 만들 수 있습니다. <code>Comparator</code>를 직렬화 가능하게 만드는 오버헤드는 일반적으로 낮으므로 그렇게 하는 것은 좋은 방어적 프로그래밍으로 간주될 수 있습니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\npublic class FruitComparator implements Comparator&lt;Fruit&gt; {  // 규칙 위반\n  int compare(Fruit f1, Fruit f2) {...}\n  boolean equals(Object obj) {...}\n}\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre>\npublic class FruitComparator implements Comparator&lt;Fruit&gt;, Serializable {\n  private static final long serialVersionUID = 1;\n\n  int compare(Fruit f1, Fruit f2) {...}\n  boolean equals(Object obj) {...}\n}\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": ""
  },
  {
    "id": "S6889",
    "key": "java:S6889",
    "name": "Proper Sensor Resource Management",
    "type": "code-smell",
    "severity": "major",
    "tags": [
      "leak",
      "android",
      "sustainability"
    ],
    "why": "<p>Optimizing resource usage and preventing unnecessary battery drain are critical considerations in Android development. Failing to release sensor\nresources when they are no longer needed can lead to prolonged device activity, negatively impacting battery life. Common Android sensors, such as\ncameras, GPS, and microphones, provide a method to release resources after they are not in use anymore.</p>\n<p>This rule identifies situations where a sensor is not released after being utilized, helping developers maintain efficient and battery-friendly\napplications.</p>\n<ul>\n  <li> Missing call to <code>release()</code> method:\n    <ul>\n      <li> <code>android.os.PowerManager.WakeLock</code> </li>\n      <li> <code>android.net.wifi.WifiManager$MulticastLock</code> </li>\n      <li> <code>android.hardware.Camera</code> </li>\n      <li> <code>android.media.MediaPlayer</code> </li>\n      <li> <code>android.media.MediaRecorder</code> </li>\n      <li> <code>android.media.SoundPool</code> </li>\n      <li> <code>android.media.audiofx.Visualizer</code> </li>\n      <li> <code>android.hardware.display.VirtualDisplay</code> </li>\n    </ul>  </li>\n  <li> Missing call to <code>close()</code> method\n    <ul>\n      <li> <code>android.hardware.camera2.CameraDevice</code> </li>\n    </ul>  </li>\n  <li> Missing call to <code>removeUpdates()</code> method:\n    <ul>\n      <li> <code>android.location.LocationManager</code> </li>\n    </ul>  </li>\n  <li> Missing call to <code>unregisterListener()</code> method:\n    <ul>\n      <li> <code>android.hardware.SensorManager</code> </li>\n    </ul>  </li>\n</ul>",
    "howToFix": "<p>Ensure that resources are released when they are no longer needed. This can be done by calling the appropriate release method, such as\n<code>release()</code>, <code>removeUpdates()</code>, <code>unregisterListener()</code>, or <code>stop()</code>.</p>\n\n<ul>\n  <li> <code>android.os.PowerManager.WakeLock</code> </li>\n</ul>\n<h4>Noncompliant code example</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\npublic void method() {\n  PowerManager powerManager = (PowerManager) getSystemService(POWER_SERVICE);\n  PowerManager.WakeLock wakeLock = powerManager.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, \"My Wake Lock\");\n  wakeLock.acquire(); // Noncompliant\n  // do some work...\n}\n</pre>\n<h4>Compliant solution</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\npublic void method() {\n  PowerManager powerManager = (PowerManager) getSystemService(POWER_SERVICE);\n  PowerManager.WakeLock wakeLock = powerManager.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, \"My Wake Lock\");\n  wakeLock.acquire(); // Compliant\n  // do some work...\n  wakeLock.release();\n}\n</pre>\n<ul>\n  <li> <code>android.media.MediaPlayer</code> </li>\n</ul>\n<h4>Noncompliant code example</h4>\n<pre data-diff-id=\"2\" data-diff-type=\"noncompliant\">\npublic void method() {\n  MediaPlayer mediaPlayer = MediaPlayer.create(context, R.raw.sound_file_1);\n  mediaPlayer.start(); // Noncompliant\n  // do some work...\n}\n</pre>\n<h4>Compliant solution</h4>\n<pre data-diff-id=\"2\" data-diff-type=\"compliant\">\npublic void onCreate() {\n  MediaPlayer mediaPlayer = MediaPlayer.create(context, R.raw.sound_file_1);\n  mediaPlayer.start(); // Compliant\n  // do some work...\n  wakeLock.release();\n}\n</pre>\n<ul>\n  <li> <code>android.hardware.SensorManager</code> </li>\n</ul>\n<h4>Noncompliant code example</h4>\n<pre data-diff-id=\"3\" data-diff-type=\"noncompliant\">\npublic void method() {\n  SensorManager sensorManager = getSystemService(SENSOR_SERVICE);\n  Sensor accelerometer = sensorManager.getDefaultSensor(Sensor.TYPE_ACCELEROMETER);\n  sensorManager.registerListener(this, accelerometer, SensorManager.SENSOR_DELAY_NORMAL); // Noncompliant\n  // do some work...\n}\n</pre>\n<h4>Compliant solution</h4>\n<pre data-diff-id=\"3\" data-diff-type=\"compliant\">\npublic void method() {\n  SensorManager sensorManager = getSystemService(SENSOR_SERVICE);\n  Sensor accelerometer = sensorManager.getDefaultSensor(Sensor.TYPE_ACCELEROMETER);\n  sensorManager.registerListener(this, accelerometer, SensorManager.SENSOR_DELAY_NORMAL); // Compliant\n  // do some work...\n  sensorManager.unregisterListener(this);\n}\n</pre>",
    "moreInfo": "<h3>Documentation</h3>\n<ul>\n  <li> <a href=\"https://developer.android.com/reference/android/location/LocationManager\">Android - LocationManager</a> </li>\n  <li> <a href=\"https://developer.android.com/reference/android/os/PowerManager.WakeLock\">Android - PowerManager.WakeLock</a> </li>\n  <li> <a href=\"https://developer.android.com/reference/android/net/wifi/WifiManager.MulticastLock\">Android - WifiManager.MulticastLock</a> </li>\n  <li> <a href=\"https://developer.android.com/reference/android/media/projection/MediaProjection\">Android - MediaProjection</a> </li>\n  <li> <a href=\"https://developer.android.com/reference/android/media/MediaPlayer\">Android - MediaPlayer</a> </li>\n  <li> <a href=\"https://developer.android.com/reference/android/media/MediaRecorder\">Android - MediaRecorder</a> </li>\n  <li> <a href=\"https://developer.android.com/reference/android/media/SoundPool\">Android - SoundPool</a> </li>\n  <li> <a href=\"https://developer.android.com/reference/android/media/audiofx/Visualizer\">Android - Visualizer</a> </li>\n  <li> <a href=\"https://developer.android.com/reference/android/hardware/SensorManager\">Android - SensorManager</a> </li>\n  <li> <a href=\"https://developer.android.com/develop/background-work/background-tasks/scheduling/wakelock\">Android - Keep the device awake</a> </li>\n  <li> <a href=\"https://developer.android.com/media/platform/mediaplayer\">Android - MediaPlayer Overview</a> </li>\n  <li> <a href=\"https://developer.android.com/develop/sensors-and-location/sensors/sensors_overview\">Android - Sensors Overview</a> </li>\n</ul>",
    "status": "READY",
    "name_ko": "적절한 Sensor 리소스 관리",
    "why_ko": "<p>리소스 사용 최적화와 불필요한 배터리 소모 방지는 Android 개발에서 중요한 고려 사항입니다. 더 이상 필요하지 않은 센서 리소스를 해제하지 않으면 장치 활동이 연장되어 배터리 수명에 부정적인 영향을 미칠 수 있습니다. 카메라, GPS, 마이크와 같은 일반적인 Android 센서는 더 이상 사용하지 않을 때 리소스를 해제하는 메서드를 제공합니다.</p>\n<p>이 규칙은 센서를 사용한 후 해제하지 않는 상황을 식별하여 개발자가 효율적이고 배터리 친화적인 애플리케이션을 유지할 수 있도록 도와줍니다.</p>\n<ul>\n  <li> <code>release()</code> 메서드 호출 누락:\n    <ul>\n      <li> <code>android.os.PowerManager.WakeLock</code> </li>\n      <li> <code>android.net.wifi.WifiManager$MulticastLock</code> </li>\n      <li> <code>android.hardware.Camera</code> </li>\n      <li> <code>android.media.MediaPlayer</code> </li>\n      <li> <code>android.media.MediaRecorder</code> </li>\n      <li> <code>android.media.SoundPool</code> </li>\n      <li> <code>android.media.audiofx.Visualizer</code> </li>\n      <li> <code>android.hardware.display.VirtualDisplay</code> </li>\n    </ul>  </li>\n  <li> <code>close()</code> 메서드 호출 누락\n    <ul>\n      <li> <code>android.hardware.camera2.CameraDevice</code> </li>\n    </ul>  </li>\n  <li> <code>removeUpdates()</code> 메서드 호출 누락:\n    <ul>\n      <li> <code>android.location.LocationManager</code> </li>\n    </ul>  </li>\n  <li> <code>unregisterListener()</code> 메서드 호출 누락:\n    <ul>\n      <li> <code>android.hardware.SensorManager</code> </li>\n    </ul>  </li>\n</ul>",
    "howToFix_ko": "<p>더 이상 필요하지 않을 때 리소스가 해제되도록 하세요. 이는 <code>release()</code>, <code>removeUpdates()</code>, <code>unregisterListener()</code> 또는 <code>stop()</code>과 같은 적절한 해제 메서드를 호출하여 수행할 수 있습니다.</p>\n\n<ul>\n  <li> <code>android.os.PowerManager.WakeLock</code> </li>\n</ul>\n<h4>규칙을 준수하지 않는 코드 예시</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\npublic void method() {\n  PowerManager powerManager = (PowerManager) getSystemService(POWER_SERVICE);\n  PowerManager.WakeLock wakeLock = powerManager.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, \"My Wake Lock\");\n  wakeLock.acquire(); // 규칙 위반\n  // 작업 수행...\n}\n</pre>\n<h4>규칙을 준수하는 해결책</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\npublic void method() {\n  PowerManager powerManager = (PowerManager) getSystemService(POWER_SERVICE);\n  PowerManager.WakeLock wakeLock = powerManager.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, \"My Wake Lock\");\n  wakeLock.acquire(); // 규칙 준수\n  // 작업 수행...\n  wakeLock.release();\n}\n</pre>\n<ul>\n  <li> <code>android.media.MediaPlayer</code> </li>\n</ul>\n<h4>규칙을 준수하지 않는 코드 예시</h4>\n<pre data-diff-id=\"2\" data-diff-type=\"noncompliant\">\npublic void method() {\n  MediaPlayer mediaPlayer = MediaPlayer.create(context, R.raw.sound_file_1);\n  mediaPlayer.start(); // 규칙 위반\n  // 작업 수행...\n}\n</pre>\n<h4>규칙을 준수하는 해결책</h4>\n<pre data-diff-id=\"2\" data-diff-type=\"compliant\">\npublic void onCreate() {\n  MediaPlayer mediaPlayer = MediaPlayer.create(context, R.raw.sound_file_1);\n  mediaPlayer.start(); // 규칙 준수\n  // 작업 수행...\n  wakeLock.release();\n}\n</pre>\n<ul>\n  <li> <code>android.hardware.SensorManager</code> </li>\n</ul>\n<h4>규칙을 준수하지 않는 코드 예시</h4>\n<pre data-diff-id=\"3\" data-diff-type=\"noncompliant\">\npublic void method() {\n  SensorManager sensorManager = getSystemService(SENSOR_SERVICE);\n  Sensor accelerometer = sensorManager.getDefaultSensor(Sensor.TYPE_ACCELEROMETER);\n  sensorManager.registerListener(this, accelerometer, SensorManager.SENSOR_DELAY_NORMAL); // 규칙 위반\n  // 작업 수행...\n}\n</pre>\n<h4>규칙을 준수하는 해결책</h4>\n<pre data-diff-id=\"3\" data-diff-type=\"compliant\">\npublic void method() {\n  SensorManager sensorManager = getSystemService(SENSOR_SERVICE);\n  Sensor accelerometer = sensorManager.getDefaultSensor(Sensor.TYPE_ACCELEROMETER);\n  sensorManager.registerListener(this, accelerometer, SensorManager.SENSOR_DELAY_NORMAL); // 규칙 준수\n  // 작업 수행...\n  sensorManager.unregisterListener(this);\n}\n</pre>",
    "moreInfo_ko": "<h3>문서</h3>\n<ul>\n  <li> <a href=\"https://developer.android.com/reference/android/location/LocationManager\">Android - LocationManager</a> </li>\n  <li> <a href=\"https://developer.android.com/reference/android/os/PowerManager.WakeLock\">Android - PowerManager.WakeLock</a> </li>\n  <li> <a href=\"https://developer.android.com/reference/android/net/wifi/WifiManager.MulticastLock\">Android - WifiManager.MulticastLock</a> </li>\n  <li> <a href=\"https://developer.android.com/reference/android/media/projection/MediaProjection\">Android - MediaProjection</a> </li>\n  <li> <a href=\"https://developer.android.com/reference/android/media/MediaPlayer\">Android - MediaPlayer</a> </li>\n  <li> <a href=\"https://developer.android.com/reference/android/media/MediaRecorder\">Android - MediaRecorder</a> </li>\n  <li> <a href=\"https://developer.android.com/reference/android/media/SoundPool\">Android - SoundPool</a> </li>\n  <li> <a href=\"https://developer.android.com/reference/android/media/audiofx/Visualizer\">Android - Visualizer</a> </li>\n  <li> <a href=\"https://developer.android.com/reference/android/hardware/SensorManager\">Android - SensorManager</a> </li>\n  <li> <a href=\"https://developer.android.com/develop/background-work/background-tasks/scheduling/wakelock\">Android - 장치 깨우기 유지</a> </li>\n  <li> <a href=\"https://developer.android.com/media/platform/mediaplayer\">Android - MediaPlayer 개요</a> </li>\n  <li> <a href=\"https://developer.android.com/develop/sensors-and-location/sensors/sensors_overview\">Android - 센서 개요</a> </li>\n</ul>"
  },
  {
    "id": "S6923",
    "key": "java:S6923",
    "name": "Motion Sensor should not use gyroscope",
    "type": "code-smell",
    "severity": "major",
    "tags": [
      "android",
      "sustainability"
    ],
    "why": "<p>The battery life is a major concern for mobile devices and choosing the right Sensor is very important to reduce the power usage and extend the\nbattery life.</p>\n<p>It is recommended, for reducing the power usage, to use <code>TYPE_GEOMAGNETIC_ROTATION_VECTOR</code> for <em>background tasks</em>,\n<em>long-running tasks</em> and other tasks not requiring accurate motion detection.</p>\n<p>The rule reports an issue when <code>android.hardware.SensorManager#getDefaultSensor</code> uses <code>TYPE_ROTATION_VECTOR</code> instead of\n<code>TYPE_GEOMAGNETIC_ROTATION_VECTOR</code>.</p>",
    "howToFix": "<p>Replace <code>TYPE_ROTATION_VECTOR</code> with <code>TYPE_GEOMAGNETIC_ROTATION_VECTOR</code> when retrieving the Motion Sensor.</p>\n\n<h4>Noncompliant code example</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\npublic class BackGroundActivity extends Activity {\n\n    private Sensor motionSensor;\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        SensorManager sensorManager = (SensorManager) getSystemService(Context.SENSOR_SERVICE);\n        motionSensor = sensorManager.getDefaultSensor(Sensor.TYPE_ROTATION_VECTOR); // Noncompliant\n        // ..\n    }\n    //..\n}\n</pre>\n<h4>Compliant solution</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\npublic class BackGroundActivity extends Activity {\n\n    private Sensor motionSensor;\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        SensorManager sensorManager = (SensorManager) getSystemService(Context.SENSOR_SERVICE);\n        motionSensor = sensorManager.getDefaultSensor(Sensor.TYPE_GEOMAGNETIC_ROTATION_VECTOR); // Compliant\n        // ..\n    }\n    //..\n}\n</pre>",
    "moreInfo": "<h3>Documentation</h3>\n<ul>\n  <li> <a href=\"https://source.android.com/docs/core/interaction/sensors/power-use\">Android - Low Power Sensors</a> </li>\n  <li> <a href=\"https://developer.android.com/develop/sensors-and-location/sensors/sensors_motion\">Android - Motion Sensors</a> </li>\n</ul>",
    "status": "READY",
    "name_ko": "Motion Sensor는 자이로스코프를 사용하면 안 됩니다",
    "why_ko": "<p>배터리 수명은 모바일 기기의 주요 관심사이며 전력 사용량을 줄이고 배터리 수명을 연장하려면 올바른 센서를 선택하는 것이 매우 중요합니다.</p>\n<p>전력 사용량을 줄이려면 <em>백그라운드 작업</em>, <em>장기 실행 작업</em> 및 정확한 모션 감지가 필요하지 않은 기타 작업에 <code>TYPE_GEOMAGNETIC_ROTATION_VECTOR</code>를 사용하는 것이 좋습니다.</p>\n<p>이 규칙은 <code>android.hardware.SensorManager#getDefaultSensor</code>가 <code>TYPE_GEOMAGNETIC_ROTATION_VECTOR</code> 대신 <code>TYPE_ROTATION_VECTOR</code>를 사용할 때 문제를 보고합니다.</p>",
    "howToFix_ko": "<p>Motion Sensor를 검색할 때 <code>TYPE_ROTATION_VECTOR</code>를 <code>TYPE_GEOMAGNETIC_ROTATION_VECTOR</code>로 교체하세요.</p>\n\n<h4>규칙을 준수하지 않는 코드 예시</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\npublic class BackGroundActivity extends Activity {\n\n    private Sensor motionSensor;\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        SensorManager sensorManager = (SensorManager) getSystemService(Context.SENSOR_SERVICE);\n        motionSensor = sensorManager.getDefaultSensor(Sensor.TYPE_ROTATION_VECTOR); // 규칙 위반\n        // ..\n    }\n    //..\n}\n</pre>\n<h4>규칙을 준수하는 해결책</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\npublic class BackGroundActivity extends Activity {\n\n    private Sensor motionSensor;\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        SensorManager sensorManager = (SensorManager) getSystemService(Context.SENSOR_SERVICE);\n        motionSensor = sensorManager.getDefaultSensor(Sensor.TYPE_GEOMAGNETIC_ROTATION_VECTOR); // 규칙 준수\n        // ..\n    }\n    //..\n}\n</pre>",
    "moreInfo_ko": "<h3>문서</h3>\n<ul>\n  <li> <a href=\"https://source.android.com/docs/core/interaction/sensors/power-use\">Android - 저전력 센서</a> </li>\n  <li> <a href=\"https://developer.android.com/develop/sensors-and-location/sensors/sensors_motion\">Android - Motion 센서</a> </li>\n</ul>"
  },
  {
    "id": "S5122",
    "key": "java:S5122",
    "name": "Having a permissive Cross-Origin Resource Sharing policy is security-sensitive",
    "type": "security-hotspot",
    "severity": "minor",
    "tags": [
      "spring",
      "cwe"
    ],
    "why": "<p>Having a permissive Cross-Origin Resource Sharing policy is security-sensitive. It has led in the past to the following vulnerabilities:</p>\n<ul>\n  <li> <a href=\"https://www.cve.org/CVERecord?id=CVE-2018-0269\">CVE-2018-0269</a> </li>\n  <li> <a href=\"https://www.cve.org/CVERecord?id=CVE-2017-14460\">CVE-2017-14460</a> </li>\n</ul>\n<p><a href=\"https://developer.mozilla.org/en-US/docs/Web/Security/Same-origin_policy\">Same origin policy</a> in browsers prevents, by default and for\nsecurity-reasons, a javascript frontend to perform a cross-origin HTTP request to a resource that has a different origin (domain, protocol, or port)\nfrom its own. The requested target can append additional HTTP headers in response, called <a\nhref=\"https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS\">CORS</a>, that act like directives for the browser and change the access control policy\n/ relax the same origin policy.</p>\n",
    "howToFix": "<h2>Recommended Secure Coding Practices</h2>\n<ul>\n  <li> The <code>Access-Control-Allow-Origin</code> header should be set only for a trusted origin and for specific resources. </li>\n  <li> Allow only selected, trusted domains in the <code>Access-Control-Allow-Origin</code> header. Prefer whitelisting domains over blacklisting or\n  allowing any domain (do not use * wildcard nor blindly return the <code>Origin</code> header content without any checks). </li>\n</ul>\n<h2>Compliant Solution</h2>\n<p>Java Servlet framework:</p>\n<pre>\n@Override\nprotected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n    resp.setHeader(\"Content-Type\", \"text/plain; charset=utf-8\");\n    resp.setHeader(\"Access-Control-Allow-Origin\", \"trustedwebsite.com\"); // Compliant\n    resp.setHeader(\"Access-Control-Allow-Credentials\", \"true\");\n    resp.setHeader(\"Access-Control-Allow-Methods\", \"GET\");\n    resp.getWriter().write(\"response\");\n}\n</pre>\n<p>Spring MVC framework:</p>\n<ul>\n  <li> <a\n  href=\"https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/web/bind/annotation/CrossOrigin.html\">CrossOrigin</a>\n  </li>\n</ul>\n<pre>\n@CrossOrigin(\"trustedwebsite.com\") // Compliant\n@RequestMapping(\"\")\npublic class TestController {\n    public String home(ModelMap model) {\n        model.addAttribute(\"message\", \"ok \");\n        return \"view\";\n    }\n}\n</pre>\n<ul>\n  <li> <a\n  href=\"https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/web/cors/CorsConfiguration.html\">cors.CorsConfiguration</a> </li>\n</ul>\n<pre>\nCorsConfiguration config = new CorsConfiguration();\nconfig.addAllowedOrigin(\"http://domain2.com\"); // Compliant\n</pre>\n<ul>\n  <li> <a\n  href=\"https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/web/servlet/config/annotation/CorsRegistration.html\">servlet.config.annotation.CorsConfiguration</a> </li>\n</ul>\n<pre>\nclass Safe implements WebMvcConfigurer {\n  @Override\n  public void addCorsMappings(CorsRegistry registry) {\n    registry.addMapping(\"/**\")\n      .allowedOrigins(\"safe.com\"); // Compliant\n  }\n}\n</pre>\n<p>User-controlled origin validated with an allow-list:</p>\n<pre>\npublic ResponseEntity&lt;String&gt; userControlledOrigin(@RequestHeader(\"Origin\") String origin) {\n  HttpHeaders responseHeaders = new HttpHeaders();\n  if (trustedOrigins.contains(origin)) {\n    responseHeaders.add(\"Access-Control-Allow-Origin\", origin);\n  }\n\n  return new ResponseEntity&lt;&gt;(\"content\", responseHeaders, HttpStatus.CREATED);\n}\n</pre>\n<h2>See</h2>\n<ul>\n  <li> OWASP - <a href=\"https://owasp.org/Top10/A05_2021-Security_Misconfiguration/\">Top 10 2021 Category A5 - Security Misconfiguration</a> </li>\n  <li> OWASP - <a href=\"https://owasp.org/Top10/A07_2021-Identification_and_Authentication_Failures/\">Top 10 2021 Category A7 - Identification and\n  Authentication Failures</a> </li>\n  <li> <a href=\"https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS\">developer.mozilla.org</a> - CORS </li>\n  <li> <a href=\"https://developer.mozilla.org/en-US/docs/Web/Security/Same-origin_policy\">developer.mozilla.org</a> - Same origin policy </li>\n  <li> OWASP - <a href=\"https://owasp.org/www-project-top-ten/2017/A6_2017-Security_Misconfiguration\">Top 10 2017 Category A6 - Security\n  Misconfiguration</a> </li>\n  <li> <a href=\"https://cheatsheetseries.owasp.org/cheatsheets/HTML5_Security_Cheat_Sheet.html#cross-origin-resource-sharing\">OWASP HTML5 Security\n  Cheat Sheet</a> - Cross Origin Resource Sharing </li>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/346\">CWE-346 - Origin Validation Error</a> </li>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/942\">CWE-942 - Overly Permissive Cross-domain Whitelist</a> </li>\n</ul>",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "허용적인 CORS 정책은 보안에 민감합니다",
    "why_ko": "<p>허용적인 Cross-Origin Resource Sharing 정책은 보안에 민감합니다. 이는 과거에 다음과 같은 취약점으로 이어졌습니다:</p>\n<ul>\n  <li> <a href=\"https://www.cve.org/CVERecord?id=CVE-2018-0269\">CVE-2018-0269</a> </li>\n  <li> <a href=\"https://www.cve.org/CVERecord?id=CVE-2017-14460\">CVE-2017-14460</a> </li>\n</ul>\n<p>브라우저의 <a href=\"https://developer.mozilla.org/en-US/docs/Web/Security/Same-origin_policy\">동일 출처 정책</a>은 기본적으로 보안상의 이유로 자바스크립트 프론트엔드가 자체 출처(도메인, 프로토콜 또는 포트)와 다른 출처를 가진 리소스에 교차 출처 HTTP 요청을 수행하는 것을 방지합니다. 요청된 대상은 응답에 <a href=\"https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS\">CORS</a>라고 불리는 추가 HTTP 헤더를 추가할 수 있으며, 이는 브라우저에 대한 지시문 역할을 하고 접근 제어 정책을 변경하거나 동일 출처 정책을 완화합니다.</p>\n",
    "howToFix_ko": "<h2>권장 보안 코딩 방법</h2>\n<ul>\n  <li> <code>Access-Control-Allow-Origin</code> 헤더는 신뢰할 수 있는 출처와 특정 리소스에 대해서만 설정해야 합니다. </li>\n  <li> <code>Access-Control-Allow-Origin</code> 헤더에는 선택된 신뢰할 수 있는 도메인만 허용하세요. 블랙리스트나 모든 도메인을 허용하는 것보다 화이트리스트 도메인을 선호하세요(* 와일드카드를 사용하거나 검사 없이 <code>Origin</code> 헤더 내용을 맹목적으로 반환하지 마세요). </li>\n</ul>\n<h2>규칙을 준수하는 해결책</h2>\n<p>Java Servlet 프레임워크:</p>\n<pre>\n@Override\nprotected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n    resp.setHeader(\"Content-Type\", \"text/plain; charset=utf-8\");\n    resp.setHeader(\"Access-Control-Allow-Origin\", \"trustedwebsite.com\"); // 규칙 준수\n    resp.setHeader(\"Access-Control-Allow-Credentials\", \"true\");\n    resp.setHeader(\"Access-Control-Allow-Methods\", \"GET\");\n    resp.getWriter().write(\"response\");\n}\n</pre>\n<p>Spring MVC 프레임워크:</p>\n<ul>\n  <li> <a href=\"https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/web/bind/annotation/CrossOrigin.html\">CrossOrigin</a> </li>\n</ul>\n<pre>\n@CrossOrigin(\"trustedwebsite.com\") // 규칙 준수\n@RequestMapping(\"\")\npublic class TestController {\n    public String home(ModelMap model) {\n        model.addAttribute(\"message\", \"ok \");\n        return \"view\";\n    }\n}\n</pre>\n<ul>\n  <li> <a href=\"https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/web/cors/CorsConfiguration.html\">cors.CorsConfiguration</a> </li>\n</ul>\n<pre>\nCorsConfiguration config = new CorsConfiguration();\nconfig.addAllowedOrigin(\"http://domain2.com\"); // 규칙 준수\n</pre>\n<ul>\n  <li> <a href=\"https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/web/servlet/config/annotation/CorsRegistration.html\">servlet.config.annotation.CorsConfiguration</a> </li>\n</ul>\n<pre>\nclass Safe implements WebMvcConfigurer {\n  @Override\n  public void addCorsMappings(CorsRegistry registry) {\n    registry.addMapping(\"/**\")\n      .allowedOrigins(\"safe.com\"); // 규칙 준수\n  }\n}\n</pre>\n<p>허용 목록으로 검증된 사용자 제어 출처:</p>\n<pre>\npublic ResponseEntity&lt;String&gt; userControlledOrigin(@RequestHeader(\"Origin\") String origin) {\n  HttpHeaders responseHeaders = new HttpHeaders();\n  if (trustedOrigins.contains(origin)) {\n    responseHeaders.add(\"Access-Control-Allow-Origin\", origin);\n  }\n\n  return new ResponseEntity&lt;&gt;(\"content\", responseHeaders, HttpStatus.CREATED);\n}\n</pre>\n<h2>참고</h2>\n<ul>\n  <li> OWASP - <a href=\"https://owasp.org/Top10/A05_2021-Security_Misconfiguration/\">상위 10가지 2021 카테고리 A5 - 보안 구성 오류</a> </li>\n  <li> OWASP - <a href=\"https://owasp.org/Top10/A07_2021-Identification_and_Authentication_Failures/\">상위 10가지 2021 카테고리 A7 - 식별 및 인증 실패</a> </li>\n  <li> <a href=\"https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS\">developer.mozilla.org</a> - CORS </li>\n  <li> <a href=\"https://developer.mozilla.org/en-US/docs/Web/Security/Same-origin_policy\">developer.mozilla.org</a> - 동일 출처 정책 </li>\n  <li> OWASP - <a href=\"https://owasp.org/www-project-top-ten/2017/A6_2017-Security_Misconfiguration\">상위 10가지 2017 카테고리 A6 - 보안 구성 오류</a> </li>\n  <li> <a href=\"https://cheatsheetseries.owasp.org/cheatsheets/HTML5_Security_Cheat_Sheet.html#cross-origin-resource-sharing\">OWASP HTML5 보안 치트 시트</a> - Cross Origin Resource Sharing </li>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/346\">CWE-346 - 출처 검증 오류</a> </li>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/942\">CWE-942 - 과도하게 허용적인 교차 도메인 화이트리스트</a> </li>\n</ul>",
    "moreInfo_ko": ""
  },
  {
    "id": "S1862",
    "key": "java:S1862",
    "name": "Related \"if/else if\" statements should not have the same condition",
    "type": "bug",
    "severity": "major",
    "tags": [
      "unused",
      "cert",
      "pitfall"
    ],
    "why": "<p>A chain of <code>if</code>/<code>else if</code> statements is evaluated from top to bottom. At most, only one branch will be executed: the first\none with a condition that evaluates to <code>true</code>.</p>\n<p>Therefore, duplicating a condition automatically leads to dead code. Usually, this is due to a copy/paste error. At best, it's simply dead code and\nat worst, it's a bug that is likely to induce further bugs as the code is maintained, and obviously it could lead to unexpected behavior.</p>\n<h3>Noncompliant code example</h3>\n<pre>\nif (param == 1)\n  openWindow();\nelse if (param == 2)\n  closeWindow();\nelse if (param == 1)  // Noncompliant\n  moveWindowToTheBackground();\n}\n</pre>\n<h3>Compliant solution</h3>\n<pre>\nif (param == 1)\n  openWindow();\nelse if (param == 2)\n  closeWindow();\nelse if (param == 3)\n  moveWindowToTheBackground();\n}\n</pre>",
    "howToFix": "",
    "moreInfo": "<ul>\n  <li> <a href=\"https://wiki.sei.cmu.edu/confluence/x/5dUxBQ\">CERT, MSC12-C.</a> - Detect and remove code that has no effect or is never executed\n  </li>\n</ul>",
    "status": "READY",
    "name_ko": "관련된 \"if/else if\" 문에 동일한 조건이 있으면 안 됩니다",
    "why_ko": "<p><code>if</code>/<code>else if</code> 문의 체인은 위에서 아래로 평가됩니다. 최대 하나의 분기만 실행됩니다: <code>true</code>로 평가되는 조건을 가진 첫 번째 분기입니다.</p>\n<p>따라서 조건을 중복하면 자동으로 데드 코드가 됩니다. 일반적으로 이것은 복사/붙여넣기 오류로 인한 것입니다. 최선의 경우 단순히 데드 코드이고, 최악의 경우 코드가 유지보수될 때 추가 버그를 유발할 가능성이 있는 버그이며, 명백히 예기치 않은 동작으로 이어질 수 있습니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\nif (param == 1)\n  openWindow();\nelse if (param == 2)\n  closeWindow();\nelse if (param == 1)  // 규칙 위반\n  moveWindowToTheBackground();\n}\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre>\nif (param == 1)\n  openWindow();\nelse if (param == 2)\n  closeWindow();\nelse if (param == 3)\n  moveWindowToTheBackground();\n}\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": "<ul>\n  <li> <a href=\"https://wiki.sei.cmu.edu/confluence/x/5dUxBQ\">CERT, MSC12-C.</a> - 효과가 없거나 실행되지 않는 코드를 감지하고 제거하세요 </li>\n</ul>"
  },
  {
    "id": "S1161",
    "key": "java:S1161",
    "name": "\"@Override\" should be used on overriding and implementing methods",
    "type": "code-smell",
    "severity": "major",
    "tags": [
      "bad-practice"
    ],
    "why": "<p>While not mandatory, using the <code>@Override</code> annotation on compliant methods improves readability by making it explicit that methods are\noverridden.</p>\n<p>A compliant method either overrides a parent method or implements an interface or abstract method.</p>\n<h3>Noncompliant code example</h3>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\nclass ParentClass {\n  public boolean doSomething(){/*...*/}\n}\nclass FirstChildClass extends ParentClass {\n  public boolean doSomething(){/*...*/}  // Noncompliant\n}\n</pre>\n<h3>Compliant solution</h3>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\nclass ParentClass {\n  public boolean doSomething(){/*...*/}\n}\nclass FirstChildClass extends ParentClass {\n  @Override\n  public boolean doSomething(){/*...*/}  // Compliant\n}\n</pre>\n<h3>Exceptions</h3>\n<p>This rule does not raise issues when overriding methods from <code>Object</code> (eg: <code>equals()</code>, <code>hashCode()</code>,\n<code>toString()</code>, …​).</p>",
    "howToFix": "",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "오버라이딩 및 구현 메서드에 \"@Override\"를 사용해야 합니다",
    "why_ko": "<p>필수는 아니지만 규칙을 준수하는 메서드에 <code>@Override</code> 어노테이션을 사용하면 메서드가 오버라이드되었음을 명시적으로 표시하여 가독성이 향상됩니다.</p>\n<p>규칙을 준수하는 메서드는 부모 메서드를 오버라이드하거나 인터페이스 또는 추상 메서드를 구현합니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\nclass ParentClass {\n  public boolean doSomething(){/*...*/}\n}\nclass FirstChildClass extends ParentClass {\n  public boolean doSomething(){/*...*/}  // 규칙 위반\n}\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\nclass ParentClass {\n  public boolean doSomething(){/*...*/}\n}\nclass FirstChildClass extends ParentClass {\n  @Override\n  public boolean doSomething(){/*...*/}  // 규칙 준수\n}\n</pre>\n<h3>예외</h3>\n<p>이 규칙은 <code>Object</code>의 메서드를 오버라이드할 때(예: <code>equals()</code>, <code>hashCode()</code>, <code>toString()</code> 등) 이슈를 발생시키지 않습니다.</p>",
    "howToFix_ko": "",
    "moreInfo_ko": ""
  },
  {
    "id": "S864",
    "key": "java:S864",
    "name": "Limited dependence should be placed on operator precedence",
    "type": "code-smell",
    "severity": "major",
    "tags": [
      "cwe",
      "cert"
    ],
    "why": "<p>The rules of operator precedence are complicated and can lead to errors. For this reason, parentheses should be used for clarification in complex\nstatements. However, this does not mean that parentheses should be gratuitously added around every operation.</p>\n<p>This rule raises issues when <code>&amp;&amp;</code> and <code>||</code> are used in combination, when assignment and equality or relational\noperators are used together in a condition, and for other operator combinations according to the following table:</p>\n<table>\n  <colgroup>\n    <col style=\"width: 16.6666%;\">\n    <col style=\"width: 16.6666%;\">\n    <col style=\"width: 16.6666%;\">\n    <col style=\"width: 16.6666%;\">\n    <col style=\"width: 16.6666%;\">\n    <col style=\"width: 16.667%;\">\n  </colgroup>\n  <thead>\n    <tr>\n      <th></th>\n      <th><code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>%</code></th>\n      <th><code>&lt;&lt;</code>, <code>&gt;&gt;</code>, <code>&gt;&gt;&gt;</code></th>\n      <th><code>&amp;</code></th>\n      <th><code>^</code></th>\n      <th><code>|</code></th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td><p><code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>%</code></p></td>\n      <td></td>\n      <td><p>x</p></td>\n      <td><p>x</p></td>\n      <td><p>x</p></td>\n      <td><p>x</p></td>\n    </tr>\n    <tr>\n      <td><p><code>&lt;&lt;</code>, <code>&gt;&gt;</code>, <code>&gt;&gt;&gt;</code></p></td>\n      <td><p>x</p></td>\n      <td></td>\n      <td><p>x</p></td>\n      <td><p>x</p></td>\n      <td><p>x</p></td>\n    </tr>\n    <tr>\n      <td><p><code>&amp;</code></p></td>\n      <td><p>x</p></td>\n      <td><p>x</p></td>\n      <td></td>\n      <td><p>x</p></td>\n      <td><p>x</p></td>\n    </tr>\n    <tr>\n      <td><p><code>^</code></p></td>\n      <td><p>x</p></td>\n      <td><p>x</p></td>\n      <td><p>x</p></td>\n      <td></td>\n      <td><p>x</p></td>\n    </tr>\n    <tr>\n      <td><p><code>|</code></p></td>\n      <td><p>x</p></td>\n      <td><p>x</p></td>\n      <td><p>x</p></td>\n      <td><p>x</p></td>\n      <td></td>\n    </tr>\n  </tbody>\n</table>\n<p>This rule also raises an issue when the \"true\" or \"false\" expression of a ternary operator is not trivial and not wrapped inside parentheses.</p>\n<h3>Noncompliant code example</h3>\n<pre>\nx = a + b - c;\nx = a + 1 &lt;&lt; b;  // Noncompliant\ny = a == b ? a * 2 : a + b;  // Noncompliant\n\nif ( a &gt; b || c &lt; d || a == d) {...}\nif ( a &gt; b &amp;&amp; c &lt; d || a == b) {...}  // Noncompliant\nif (a = f(b,c) == 1) { ... } // Noncompliant; == evaluated first\n</pre>\n<h3>Compliant solution</h3>\n<pre>\nx = a + b - c;\nx = (a + 1) &lt;&lt; b;\ny = a == b ? (a * 2) : (a + b);\n\nif ( a &gt; b || c &lt; d || a == d) {...}\nif ( (a &gt; b &amp;&amp; c &lt; d) || a == b) {...}\nif ( (a = f(b,c)) == 1) { ... }\n</pre>",
    "howToFix": "",
    "moreInfo": "<ul>\n  <li> <a href=\"https://wiki.sei.cmu.edu/confluence/x/YdYxBQ\">CERT, EXP00-C.</a> - Use parentheses for precedence of operation </li>\n  <li> <a href=\"https://wiki.sei.cmu.edu/confluence/x/ZzZGBQ\">CERT, EXP53-J.</a> - Use parentheses for precedence of operation </li>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/783\">CWE-783 - Operator Precedence Logic Error</a> </li>\n</ul>",
    "status": "READY",
    "name_ko": "연산자 우선순위에 대한 의존은 제한해야 합니다",
    "why_ko": "<p>연산자 우선순위 규칙은 복잡하고 오류를 유발할 수 있습니다. 이러한 이유로 복잡한 문에서는 명확성을 위해 괄호를 사용해야 합니다. 그러나 이것이 모든 연산 주위에 괄호를 무분별하게 추가해야 한다는 의미는 아닙니다.</p>\n<p>이 규칙은 <code>&amp;&amp;</code>와 <code>||</code>가 조합되어 사용될 때, 조건에서 대입과 동등 또는 관계 연산자가 함께 사용될 때, 그리고 다음 표에 따른 기타 연산자 조합에 대해 이슈를 발생시킵니다:</p>\n<table>\n  <colgroup>\n    <col style=\"width: 16.6666%;\">\n    <col style=\"width: 16.6666%;\">\n    <col style=\"width: 16.6666%;\">\n    <col style=\"width: 16.6666%;\">\n    <col style=\"width: 16.6666%;\">\n    <col style=\"width: 16.667%;\">\n  </colgroup>\n  <thead>\n    <tr>\n      <th></th>\n      <th><code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>%</code></th>\n      <th><code>&lt;&lt;</code>, <code>&gt;&gt;</code>, <code>&gt;&gt;&gt;</code></th>\n      <th><code>&amp;</code></th>\n      <th><code>^</code></th>\n      <th><code>|</code></th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td><p><code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>%</code></p></td>\n      <td></td>\n      <td><p>x</p></td>\n      <td><p>x</p></td>\n      <td><p>x</p></td>\n      <td><p>x</p></td>\n    </tr>\n    <tr>\n      <td><p><code>&lt;&lt;</code>, <code>&gt;&gt;</code>, <code>&gt;&gt;&gt;</code></p></td>\n      <td><p>x</p></td>\n      <td></td>\n      <td><p>x</p></td>\n      <td><p>x</p></td>\n      <td><p>x</p></td>\n    </tr>\n    <tr>\n      <td><p><code>&amp;</code></p></td>\n      <td><p>x</p></td>\n      <td><p>x</p></td>\n      <td></td>\n      <td><p>x</p></td>\n      <td><p>x</p></td>\n    </tr>\n    <tr>\n      <td><p><code>^</code></p></td>\n      <td><p>x</p></td>\n      <td><p>x</p></td>\n      <td><p>x</p></td>\n      <td></td>\n      <td><p>x</p></td>\n    </tr>\n    <tr>\n      <td><p><code>|</code></p></td>\n      <td><p>x</p></td>\n      <td><p>x</p></td>\n      <td><p>x</p></td>\n      <td><p>x</p></td>\n      <td></td>\n    </tr>\n  </tbody>\n</table>\n<p>이 규칙은 또한 삼항 연산자의 \"true\" 또는 \"false\" 표현식이 간단하지 않고 괄호로 감싸지 않았을 때도 이슈를 발생시킵니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\nx = a + b - c;\nx = a + 1 &lt;&lt; b;  // 규칙 위반\ny = a == b ? a * 2 : a + b;  // 규칙 위반\n\nif ( a &gt; b || c &lt; d || a == d) {...}\nif ( a &gt; b &amp;&amp; c &lt; d || a == b) {...}  // 규칙 위반\nif (a = f(b,c) == 1) { ... } // 규칙 위반; ==가 먼저 평가됨\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre>\nx = a + b - c;\nx = (a + 1) &lt;&lt; b;\ny = a == b ? (a * 2) : (a + b);\n\nif ( a &gt; b || c &lt; d || a == d) {...}\nif ( (a &gt; b &amp;&amp; c &lt; d) || a == b) {...}\nif ( (a = f(b,c)) == 1) { ... }\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": "<ul>\n  <li> <a href=\"https://wiki.sei.cmu.edu/confluence/x/YdYxBQ\">CERT, EXP00-C.</a> - 연산 우선순위를 위해 괄호를 사용하세요 </li>\n  <li> <a href=\"https://wiki.sei.cmu.edu/confluence/x/ZzZGBQ\">CERT, EXP53-J.</a> - 연산 우선순위를 위해 괄호를 사용하세요 </li>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/783\">CWE-783 - 연산자 우선순위 논리 오류</a> </li>\n</ul>"
  },
  {
    "id": "S3330",
    "key": "java:S3330",
    "name": "Creating cookies without the \"HttpOnly\" flag is security-sensitive",
    "type": "security-hotspot",
    "severity": "minor",
    "tags": [
      "cwe",
      "privacy"
    ],
    "why": "<p>When a cookie is configured with the <code>HttpOnly</code> attribute set to <em>true</em>, the browser guaranties that no client-side script will\nbe able to read it. In most cases, when a cookie is created, the default value of <code>HttpOnly</code> is <em>false</em> and it's up to the developer\nto decide whether or not the content of the cookie can be read by the client-side script. As a majority of Cross-Site Scripting (XSS) attacks target\nthe theft of session-cookies, the <code>HttpOnly</code> attribute can help to reduce their impact as it won't be possible to exploit the XSS\nvulnerability to steal session-cookies.</p>\n",
    "howToFix": "<h2>Recommended Secure Coding Practices</h2>\n<ul>\n  <li> By default the <code>HttpOnly</code> flag should be set to <em>true</em> for most of the cookies and it's mandatory for session /\n  sensitive-security cookies. </li>\n</ul>\n<h2>Compliant Solution</h2>\n<pre>\nCookie c = new Cookie(COOKIENAME, sensitivedata);\nc.setHttpOnly(true); // Compliant: this sensitive cookie is protected against theft (HttpOnly=true)\n</pre>\n<h2>See</h2>\n<ul>\n  <li> OWASP - <a href=\"https://owasp.org/Top10/A05_2021-Security_Misconfiguration/\">Top 10 2021 Category A5 - Security Misconfiguration</a> </li>\n  <li> <a href=\"https://owasp.org/www-community/HttpOnly\">OWASP HttpOnly</a> </li>\n  <li> OWASP - <a href=\"https://owasp.org/www-project-top-ten/2017/A7_2017-Cross-Site_Scripting_(XSS)\">Top 10 2017 Category A7 - Cross-Site Scripting\n  (XSS)</a> </li>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/1004\">CWE-1004 - Sensitive Cookie Without 'HttpOnly' Flag</a> </li>\n  <li> Derived from FindSecBugs rule <a href=\"https://find-sec-bugs.github.io/bugs.htm#HTTPONLY_COOKIE\">HTTPONLY_COOKIE</a> </li>\n  <li> STIG Viewer - <a href=\"https://stigviewer.com/stigs/application_security_and_development/2024-12-06/finding/V-222575\">Application Security and\n  Development: V-222575</a> - The application must set the HTTPOnly flag on session cookies. </li>\n</ul>",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "HttpOnly 플래그 없이 쿠키를 생성하는 것은 보안에 민감합니다",
    "why_ko": "<p>쿠키가 <code>HttpOnly</code> 속성을 <em>true</em>로 설정하여 구성되면, 브라우저는 클라이언트 측 스크립트가 쿠키를 읽을 수 없도록 보장합니다. 대부분의 경우 쿠키가 생성될 때 <code>HttpOnly</code>의 기본값은 <em>false</em>이며, 쿠키 내용을 클라이언트 측 스크립트가 읽을 수 있는지 여부는 개발자가 결정합니다. 대부분의 Cross-Site Scripting(XSS) 공격이 세션 쿠키 탈취를 목표로 하므로, <code>HttpOnly</code> 속성은 XSS 취약점을 악용하여 세션 쿠키를 훔치는 것이 불가능하게 되어 영향을 줄이는 데 도움이 될 수 있습니다.</p>\n",
    "howToFix_ko": "<h2>권장되는 보안 코딩 관행</h2>\n<ul>\n  <li> 기본적으로 <code>HttpOnly</code> 플래그는 대부분의 쿠키에 대해 <em>true</em>로 설정되어야 하며, 세션/보안에 민감한 쿠키에는 필수입니다. </li>\n</ul>\n<h2>규칙을 준수하는 해결책</h2>\n<pre>\nCookie c = new Cookie(COOKIENAME, sensitivedata);\nc.setHttpOnly(true); // 규칙 준수: 이 민감한 쿠키는 탈취로부터 보호됩니다 (HttpOnly=true)\n</pre>\n<h2>참고</h2>\n<ul>\n  <li> OWASP - <a href=\"https://owasp.org/Top10/A05_2021-Security_Misconfiguration/\">Top 10 2021 카테고리 A5 - 보안 설정 오류</a> </li>\n  <li> <a href=\"https://owasp.org/www-community/HttpOnly\">OWASP HttpOnly</a> </li>\n  <li> OWASP - <a href=\"https://owasp.org/www-project-top-ten/2017/A7_2017-Cross-Site_Scripting_(XSS)\">Top 10 2017 카테고리 A7 - Cross-Site Scripting (XSS)</a> </li>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/1004\">CWE-1004 - 'HttpOnly' 플래그가 없는 민감한 쿠키</a> </li>\n  <li> FindSecBugs 규칙에서 파생됨 <a href=\"https://find-sec-bugs.github.io/bugs.htm#HTTPONLY_COOKIE\">HTTPONLY_COOKIE</a> </li>\n  <li> STIG Viewer - <a href=\"https://stigviewer.com/stigs/application_security_and_development/2024-12-06/finding/V-222575\">Application Security and Development: V-222575</a> - 애플리케이션은 세션 쿠키에 HTTPOnly 플래그를 설정해야 합니다. </li>\n</ul>",
    "moreInfo_ko": ""
  },
  {
    "id": "S6831",
    "key": "java:S6831",
    "name": "\"@Qualifier\" should not be used on \"@Bean\" methods",
    "type": "bug",
    "severity": "major",
    "tags": [
      "spring"
    ],
    "why": "<p>In Spring Framework, the <code>@Qualifier</code> annotation is typically used to disambiguate between multiple beans of the same type when\nauto-wiring dependencies. It is not necessary to use <code>@Qualifier</code> when defining a bean using the <code>@Bean</code> annotation because the\nbean's name can be explicitly specified using the <code>name</code> attribute or derived from the method name. Using <code>@Qualifier</code> on\n<code>@Bean</code> methods can lead to confusion and redundancy. Beans should be named appropriately using either the <code>name</code> attribute of\nthe <code>@Bean</code> annotation or the method name itself.</p>\n<h3>Noncompliant code example</h3>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\n@Configuration\npublic class MyConfiguration {\n  @Bean\n  @Qualifier(\"myService\")\n  public MyService myService() {\n    // ...\n    return new MyService();\n  }\n\n  @Bean\n  @Qualifier(\"betterService\")\n  public MyService aBetterService() {\n    // ...\n    return new MyService();\n  }\n\n  @Bean\n  @Qualifier(\"evenBetterService\")\n  public MyService anEvenBetterService() {\n    // ...\n    return new MyService();\n  }\n\n  @Bean\n  @Qualifier(\"differentService\")\n  public MyBean aDifferentService() {\n    // ...\n    return new MyBean();\n  }\n}\n</pre>\n<h3>Compliant solution</h3>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\n@Configuration\npublic class MyConfiguration {\n  @Bean\n  public MyService myService() {\n    // ...\n    return new MyService();\n  }\n\n  @Bean(name=\"betterService\")\n  public MyService aBetterService() {\n    // ...\n    return new MyService();\n  }\n\n  @Bean(name=\"evenBetterService\")\n  public MyService anEvenBetterService() {\n    // ...\n    return new MyService();\n  }\n\n  @Bean(name=\"differentService\")\n  public MyBean aDifferentService() {\n    // ...\n    return new MyBean();\n  }\n}\n</pre>",
    "howToFix": "",
    "moreInfo": "<h3>Documentation</h3>\n<ul>\n  <li> <a href=\"https://docs.spring.io/spring-framework/reference/core/beans/java/bean-annotation.html\">Spring Framework - Using the @Bean\n  Annotation</a> </li>\n  <li> <a href=\"https://docs.spring.io/spring-framework/reference/core/beans/annotation-config/autowired-qualifiers.html\">Spring Framework - Using\n  @Qualifier</a> </li>\n</ul>\n<h3>Articles &amp; blog posts</h3>\n<ul>\n  <li> <a href=\"https://www.baeldung.com/spring-qualifier-annotation\">Baeldung - Spring @Qualifier Annotation</a> </li>\n  <li> <a href=\"https://www.baeldung.com/spring-bean-annotations\">Baeldung - Spring Bean Annotations</a> </li>\n</ul>",
    "status": "READY",
    "name_ko": "\"@Qualifier\"는 \"@Bean\" 메서드에 사용하면 안 됩니다",
    "why_ko": "<p>Spring Framework에서 <code>@Qualifier</code> 어노테이션은 일반적으로 의존성을 자동 연결할 때 동일한 타입의 여러 빈 사이를 구분하는 데 사용됩니다. <code>@Bean</code> 어노테이션을 사용하여 빈을 정의할 때는 빈의 이름을 <code>name</code> 속성을 사용하여 명시적으로 지정하거나 메서드 이름에서 파생할 수 있으므로 <code>@Qualifier</code>를 사용할 필요가 없습니다. <code>@Bean</code> 메서드에 <code>@Qualifier</code>를 사용하면 혼란과 중복이 발생할 수 있습니다. 빈은 <code>@Bean</code> 어노테이션의 <code>name</code> 속성이나 메서드 이름 자체를 사용하여 적절하게 명명해야 합니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\n@Configuration\npublic class MyConfiguration {\n  @Bean\n  @Qualifier(\"myService\")\n  public MyService myService() {\n    // ...\n    return new MyService();\n  }\n\n  @Bean\n  @Qualifier(\"betterService\")\n  public MyService aBetterService() {\n    // ...\n    return new MyService();\n  }\n\n  @Bean\n  @Qualifier(\"evenBetterService\")\n  public MyService anEvenBetterService() {\n    // ...\n    return new MyService();\n  }\n\n  @Bean\n  @Qualifier(\"differentService\")\n  public MyBean aDifferentService() {\n    // ...\n    return new MyBean();\n  }\n}\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\n@Configuration\npublic class MyConfiguration {\n  @Bean\n  public MyService myService() {\n    // ...\n    return new MyService();\n  }\n\n  @Bean(name=\"betterService\")\n  public MyService aBetterService() {\n    // ...\n    return new MyService();\n  }\n\n  @Bean(name=\"evenBetterService\")\n  public MyService anEvenBetterService() {\n    // ...\n    return new MyService();\n  }\n\n  @Bean(name=\"differentService\")\n  public MyBean aDifferentService() {\n    // ...\n    return new MyBean();\n  }\n}\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": "<h3>문서</h3>\n<ul>\n  <li> <a href=\"https://docs.spring.io/spring-framework/reference/core/beans/java/bean-annotation.html\">Spring Framework - @Bean 어노테이션 사용하기</a> </li>\n  <li> <a href=\"https://docs.spring.io/spring-framework/reference/core/beans/annotation-config/autowired-qualifiers.html\">Spring Framework - @Qualifier 사용하기</a> </li>\n</ul>\n<h3>기사 및 블로그 게시물</h3>\n<ul>\n  <li> <a href=\"https://www.baeldung.com/spring-qualifier-annotation\">Baeldung - Spring @Qualifier 어노테이션</a> </li>\n  <li> <a href=\"https://www.baeldung.com/spring-bean-annotations\">Baeldung - Spring Bean 어노테이션</a> </li>\n</ul>"
  },
  {
    "id": "S1874",
    "key": "java:S1874",
    "name": "\"@Deprecated\" code should not be used",
    "type": "code-smell",
    "severity": "minor",
    "tags": [
      "cwe",
      "obsolete",
      "cert"
    ],
    "why": "<p>Code is sometimes annotated as deprecated by developers maintaining libraries or APIs to indicate that the method, class, or other programming\nelement is no longer recommended for use. This is typically due to the introduction of a newer or more effective alternative. For example, when a\nbetter solution has been identified, or when the existing code presents potential errors or security risks.</p>\n<p>Deprecation is a good practice because it helps to phase out obsolete code in a controlled manner, without breaking existing software that may\nstill depend on it. It is a way to warn other developers not to use the deprecated element in new code, and to replace it in existing code when\npossible.</p>\n<p>Deprecated classes, interfaces, and their members should not be used, inherited or extended because they will eventually be removed. The\ndeprecation period allows you to make a smooth transition away from the aging, soon-to-be-retired technology.</p>\n<p>Check the documentation or the deprecation message to understand why the code was deprecated and what the recommended alternative is.</p>\n<pre>\n/**\n * @deprecated  As of release 1.3, replaced by {@link #Foo}\n */\n@Deprecated\npublic class Fum { ... }\n\npublic class Foo {\n  /**\n   * @deprecated  As of release 1.7, replaced by {@link #newMethod()}\n   */\n  @Deprecated\n  public void oldMethod() { ... }\n\n  public void newMethod() { ... }\n}\n\npublic class Bar extends Foo {\n  public void oldMethod() { ... } // Noncompliant; don't override a deprecated method\n}\n\npublic class Baz extends Fum {  // Noncompliant; Fum is deprecated\n  public void myMethod() {\n    Foo foo = new Foo();\n    foo.oldMethod();  // Noncompliant; oldMethod method is deprecated\n  }\n}\n</pre>",
    "howToFix": "",
    "moreInfo": "<h3>Documentation</h3>\n<ul>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/477\">CWE-477 - Use of Obsolete Functions</a> </li>\n</ul>",
    "status": "READY",
    "name_ko": "\"@Deprecated\" 코드를 사용하면 안 됩니다",
    "why_ko": "<p>코드는 때때로 라이브러리나 API를 유지보수하는 개발자에 의해 메서드, 클래스 또는 기타 프로그래밍 요소가 더 이상 사용을 권장하지 않음을 나타내기 위해 deprecated로 어노테이션됩니다. 이것은 일반적으로 더 새롭거나 더 효과적인 대안의 도입으로 인한 것입니다. 예를 들어, 더 나은 해결책이 확인되었거나 기존 코드가 잠재적인 오류나 보안 위험을 나타내는 경우입니다.</p>\n<p>Deprecation은 기존 소프트웨어를 손상시키지 않고 제어된 방식으로 오래된 코드를 단계적으로 제거하는 데 도움이 되므로 좋은 관행입니다. 이것은 다른 개발자들에게 새 코드에서 deprecated 요소를 사용하지 않고 가능할 때 기존 코드에서 교체하도록 경고하는 방법입니다.</p>\n<p>Deprecated 클래스, 인터페이스 및 해당 멤버는 결국 제거될 것이므로 사용, 상속 또는 확장하면 안 됩니다. deprecation 기간은 노후화되고 곧 폐기될 기술에서 원활하게 전환할 수 있도록 합니다.</p>\n<p>코드가 왜 deprecated되었고 권장되는 대안이 무엇인지 이해하려면 문서나 deprecation 메시지를 확인하세요.</p>\n<pre>\n/**\n * @deprecated  릴리스 1.3부터 {@link #Foo}로 대체됨\n */\n@Deprecated\npublic class Fum { ... }\n\npublic class Foo {\n  /**\n   * @deprecated  릴리스 1.7부터 {@link #newMethod()}로 대체됨\n   */\n  @Deprecated\n  public void oldMethod() { ... }\n\n  public void newMethod() { ... }\n}\n\npublic class Bar extends Foo {\n  public void oldMethod() { ... } // 규칙 위반; deprecated 메서드를 오버라이드하지 마세요\n}\n\npublic class Baz extends Fum {  // 규칙 위반; Fum은 deprecated됨\n  public void myMethod() {\n    Foo foo = new Foo();\n    foo.oldMethod();  // 규칙 위반; oldMethod 메서드는 deprecated됨\n  }\n}\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": "<h3>문서</h3>\n<ul>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/477\">CWE-477 - 오래된 함수 사용</a> </li>\n</ul>"
  },
  {
    "id": "S2167",
    "key": "java:S2167",
    "name": "\"compareTo\" should not return \"Integer.MIN_VALUE\"",
    "type": "bug",
    "severity": "minor",
    "tags": [],
    "why": "<p>The <code>Comparable.compareTo</code> method returns a negative integer, zero, or a positive integer to indicate whether the object is less than,\nequal to, or greater than the parameter. The sign of the return value or whether it is zero is what matters, not its magnitude.</p>\n<p>Returning a positive or negative constant value other than the basic ones (-1, 0, or 1) provides no additional information to the caller. Moreover,\nit could potentially confuse code readers who are trying to understand its purpose.</p>",
    "howToFix": "<p>Replace any positive constant return value with 1. Replace any negative constant return value with -1.</p>\n\n<h4>Noncompliant code example</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\npublic int compareTo(Name name) {\n  if (condition) {\n    return Integer.MIN_VALUE; // Noncompliant\n  }\n}\n</pre>\n<h4>Compliant solution</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\npublic int compareTo(Name name) {\n  if (condition) {\n    return -1; // Compliant\n  }\n}\n</pre>\n<h4>Noncompliant code example</h4>\n<pre data-diff-id=\"2\" data-diff-type=\"noncompliant\">\npublic int compareTo(Name name) {\n  if (condition) {\n    return 42; // Noncompliant\n  }\n}\n</pre>\n<h4>Compliant solution</h4>\n<pre data-diff-id=\"2\" data-diff-type=\"compliant\">\npublic int compareTo(Name name) {\n  if (condition) {\n    return 1; // Compliant\n  }\n}\n</pre>\n<h4>Noncompliant code example</h4>\n<p>It is compliant to return other values than -1, 0 or 1 if they are not constants.</p>\n<pre data-diff-id=\"3\" data-diff-type=\"noncompliant\">\npublic int compareTo(Name name) {\n  if (condition) {\n    return 42; // Noncompliant\n  }\n}\n</pre>\n<h4>Compliant solution</h4>\n<pre data-diff-id=\"3\" data-diff-type=\"compliant\">\npublic int compareTo(Name name) {\n  if (condition) {\n    return hashCode() - name.hashCode(); // Compliant, not a constant\n  }\n}\n</pre>",
    "moreInfo": "<h3>Documentation</h3>\n<ul>\n  <li> <a href=\"https://docs.oracle.com/javase/8/docs/api/java/lang/Comparable.html#compareTo-T-\">Java SE 8 API Specification:\n  Comparable.compareTo</a> </li>\n  <li> <a href=\"https://docs.oracle.com/javase/8/docs/api/java/lang/Integer.html#MIN_VALUE\">Java SE 8 API Specification: Integer.MIN_VALUE</a> </li>\n</ul>",
    "status": "READY",
    "name_ko": "\"compareTo\"는 \"Integer.MIN_VALUE\"를 반환하면 안 됩니다",
    "why_ko": "<p><code>Comparable.compareTo</code> 메서드는 객체가 파라미터보다 작은지, 같은지, 큰지를 나타내기 위해 음의 정수, 0 또는 양의 정수를 반환합니다. 중요한 것은 반환 값의 부호 또는 0인지 여부이지, 그 크기가 아닙니다.</p>\n<p>기본 값(-1, 0, 또는 1) 이외의 양수 또는 음수 상수 값을 반환하는 것은 호출자에게 추가 정보를 제공하지 않습니다. 더욱이, 그 목적을 이해하려는 코드 독자를 혼란스럽게 할 수 있습니다.</p>",
    "howToFix_ko": "<p>양수 상수 반환 값은 1로 교체하세요. 음수 상수 반환 값은 -1로 교체하세요.</p>\n\n<h4>규칙을 준수하지 않는 코드 예시</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\npublic int compareTo(Name name) {\n  if (condition) {\n    return Integer.MIN_VALUE; // 규칙 위반\n  }\n}\n</pre>\n<h4>규칙을 준수하는 해결책</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\npublic int compareTo(Name name) {\n  if (condition) {\n    return -1; // 규칙 준수\n  }\n}\n</pre>\n<h4>규칙을 준수하지 않는 코드 예시</h4>\n<pre data-diff-id=\"2\" data-diff-type=\"noncompliant\">\npublic int compareTo(Name name) {\n  if (condition) {\n    return 42; // 규칙 위반\n  }\n}\n</pre>\n<h4>규칙을 준수하는 해결책</h4>\n<pre data-diff-id=\"2\" data-diff-type=\"compliant\">\npublic int compareTo(Name name) {\n  if (condition) {\n    return 1; // 규칙 준수\n  }\n}\n</pre>\n<h4>규칙을 준수하지 않는 코드 예시</h4>\n<p>상수가 아닌 경우 -1, 0, 1 이외의 값을 반환해도 규칙을 준수합니다.</p>\n<pre data-diff-id=\"3\" data-diff-type=\"noncompliant\">\npublic int compareTo(Name name) {\n  if (condition) {\n    return 42; // 규칙 위반\n  }\n}\n</pre>\n<h4>규칙을 준수하는 해결책</h4>\n<pre data-diff-id=\"3\" data-diff-type=\"compliant\">\npublic int compareTo(Name name) {\n  if (condition) {\n    return hashCode() - name.hashCode(); // 규칙 준수, 상수가 아님\n  }\n}\n</pre>",
    "moreInfo_ko": "<h3>문서</h3>\n<ul>\n  <li> <a href=\"https://docs.oracle.com/javase/8/docs/api/java/lang/Comparable.html#compareTo-T-\">Java SE 8 API Specification: Comparable.compareTo</a> </li>\n  <li> <a href=\"https://docs.oracle.com/javase/8/docs/api/java/lang/Integer.html#MIN_VALUE\">Java SE 8 API Specification: Integer.MIN_VALUE</a> </li>\n</ul>"
  },
  {
    "id": "S2864",
    "key": "java:S2864",
    "name": "\"entrySet()\" should be iterated when both the key and value are needed",
    "type": "code-smell",
    "severity": "major",
    "tags": [
      "performance"
    ],
    "why": "<p><code>Map</code> is an object that maps keys to values. A map cannot contain duplicate keys, which means each key can map to at most one value.</p>\n<p>When both the key and the value are needed, it is more efficient to iterate the <code>entrySet()</code>, which will give access to both instead of\niterating over the <code>keySet()</code> and then getting the value.</p>\n<p>If the <code>entrySet()</code> method is not iterated when both the key and value are needed, it can lead to unnecessary lookups. This is because\neach lookup requires two operations: one to retrieve the key and another to retrieve the value. By iterating the <code>entrySet()</code> method, the\nkey-value pair can be retrieved in a single operation, which can improve performance.</p>\n<h3>Noncompliant code example</h3>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\npublic void doSomethingWithMap(Map&lt;String,Object&gt; map) {\n  for (String key : map.keySet()) {  // Noncompliant; for each key the value is retrieved\n    Object value = map.get(key);\n    // ...\n  }\n}\n</pre>\n<h3>Compliant solution</h3>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\npublic void doSomethingWithMap(Map&lt;String,Object&gt; map) {\n  for (Map.Entry&lt;String,Object&gt; entry : map.entrySet()) {\n    String key = entry.getKey();\n    Object value = entry.getValue();\n    // ...\n  }\n}\n</pre>",
    "howToFix": "",
    "moreInfo": "<h3>Documentation</h3>\n<ul>\n  <li> <a href=\"https://docs.oracle.com/en/java/javase/20/docs/api/java.base/java/util/Map.html\">Oracle SE 20 - Map</a> </li>\n</ul>\n<h3>Articles &amp; blog posts</h3>\n<ul>\n  <li> <a href=\"https://www.baeldung.com/java-map-entries-methods\">Baeldung - Java Map methods</a> </li>\n</ul>\n<h3>Benchmarks</h3>\n<table>\n  <colgroup>\n    <col style=\"width: 20%;\">\n    <col style=\"width: 20%;\">\n    <col style=\"width: 20%;\">\n    <col style=\"width: 20%;\">\n    <col style=\"width: 20%;\">\n  </colgroup>\n  <thead>\n    <tr>\n      <th>Method</th>\n      <th>size</th>\n      <th>Runtime</th>\n      <th>Average time</th>\n      <th>Error margin</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td><p>usingEntrySet</p></td>\n      <td><p>10</p></td>\n      <td><p>Temurin 21</p></td>\n      <td><p>27.48 ns/op</p></td>\n      <td><p>±6.22 ns/op</p></td>\n    </tr>\n    <tr>\n      <td><p>usingEntrySet</p></td>\n      <td><p>1000</p></td>\n      <td><p>Temurin 21</p></td>\n      <td><p>2480.26 ns/op</p></td>\n      <td><p>±899.05 ns/op</p></td>\n    </tr>\n    <tr>\n      <td><p>usingEntrySet</p></td>\n      <td><p>10000</p></td>\n      <td><p>Temurin 21</p></td>\n      <td><p>22745.78 ns/op</p></td>\n      <td><p>±10505.46 ns/op</p></td>\n    </tr>\n    <tr>\n      <td><p>usingKeySet</p></td>\n      <td><p>10</p></td>\n      <td><p>Temurin 21</p></td>\n      <td><p>49.70 ns/op</p></td>\n      <td><p>±3.78 ns/op</p></td>\n    </tr>\n    <tr>\n      <td><p>usingKeySet</p></td>\n      <td><p>1000</p></td>\n      <td><p>Temurin 21</p></td>\n      <td><p>5061.54 ns/op</p></td>\n      <td><p>±2056.60 ns/op</p></td>\n    </tr>\n    <tr>\n      <td><p>usingKeySet</p></td>\n      <td><p>10000</p></td>\n      <td><p>Temurin 21</p></td>\n      <td><p>46689.04 ns/op</p></td>\n      <td><p>±14509.97 ns/op</p></td>\n    </tr>\n  </tbody>\n</table>\n<p><strong>Benchmarking code</strong></p>\n<p>The results were generated by running the following snippet with <a href=\"https://github.com/openjdk/jmh\">JMH</a>.</p>\n<pre>\n@BenchmarkMode({Mode.AverageTime})\n@OutputTimeUnit(TimeUnit.NANOSECONDS)\n@State(Scope.Benchmark)\npublic class S2864 {\n  @Param({\"10\", \"1000\", \"10000\"})\n  int size;\n\n  Map&lt;Integer,Integer&gt; map;\n\n  @Setup(Level.Trial)\n  public void setup() {\n    Random random = new Random();\n    map = new HashMap&lt;&gt;();\n    for (int i = 0; i &lt; size; i++) {\n      map.put(i, random.nextInt());\n    }\n  }\n\n  @Benchmark\n  public int usingKeySet() {\n    int sumKeysValues = 0;\n    for (Integer key : map.keySet()) {\n      sumKeysValues += key + map.get(key);\n    }\n    return sumKeysValues;\n  }\n\n  @Benchmark\n  public int usingEntrySet() {\n    int sumKeysValues = 0;\n    for (Map.Entry&lt;Integer, Integer&gt; entry : map.entrySet()) {\n      sumKeysValues += entry.getKey() + entry.getValue();\n    }\n    return sumKeysValues;\n  }\n}\n</pre>",
    "status": "READY",
    "name_ko": "키와 값이 모두 필요할 때는 entrySet()을 순회해야 합니다",
    "why_ko": "<p><code>Map</code>은 키를 값에 매핑하는 객체입니다. 맵은 중복 키를 포함할 수 없으므로 각 키는 최대 하나의 값에만 매핑될 수 있습니다.</p>\n<p>키와 값이 모두 필요할 때는 <code>keySet()</code>을 순회한 후 값을 가져오는 대신 <code>entrySet()</code>을 순회하는 것이 더 효율적이며, 이를 통해 둘 다 액세스할 수 있습니다.</p>\n<p>키와 값이 모두 필요할 때 <code>entrySet()</code> 메서드를 순회하지 않으면 불필요한 조회가 발생할 수 있습니다. 이는 각 조회에 키를 검색하는 작업과 값을 검색하는 작업 두 가지가 필요하기 때문입니다. <code>entrySet()</code> 메서드를 순회하면 키-값 쌍을 단일 작업으로 검색할 수 있어 성능이 향상될 수 있습니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\npublic void doSomethingWithMap(Map&lt;String,Object&gt; map) {\n  for (String key : map.keySet()) {  // 규칙 위반; 각 키에 대해 값을 검색합니다\n    Object value = map.get(key);\n    // ...\n  }\n}\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\npublic void doSomethingWithMap(Map&lt;String,Object&gt; map) {\n  for (Map.Entry&lt;String,Object&gt; entry : map.entrySet()) {\n    String key = entry.getKey();\n    Object value = entry.getValue();\n    // ...\n  }\n}\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": "<h3>문서</h3>\n<ul>\n  <li> <a href=\"https://docs.oracle.com/en/java/javase/20/docs/api/java.base/java/util/Map.html\">Oracle SE 20 - Map</a> </li>\n</ul>\n<h3>관련 문서 및 블로그 게시물</h3>\n<ul>\n  <li> <a href=\"https://www.baeldung.com/java-map-entries-methods\">Baeldung - Java Map methods</a> </li>\n</ul>\n<h3>벤치마크</h3>\n<table>\n  <colgroup>\n    <col style=\"width: 20%;\">\n    <col style=\"width: 20%;\">\n    <col style=\"width: 20%;\">\n    <col style=\"width: 20%;\">\n    <col style=\"width: 20%;\">\n  </colgroup>\n  <thead>\n    <tr>\n      <th>메서드</th>\n      <th>크기</th>\n      <th>런타임</th>\n      <th>평균 시간</th>\n      <th>오차 범위</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td><p>usingEntrySet</p></td>\n      <td><p>10</p></td>\n      <td><p>Temurin 21</p></td>\n      <td><p>27.48 ns/op</p></td>\n      <td><p>±6.22 ns/op</p></td>\n    </tr>\n    <tr>\n      <td><p>usingEntrySet</p></td>\n      <td><p>1000</p></td>\n      <td><p>Temurin 21</p></td>\n      <td><p>2480.26 ns/op</p></td>\n      <td><p>±899.05 ns/op</p></td>\n    </tr>\n    <tr>\n      <td><p>usingEntrySet</p></td>\n      <td><p>10000</p></td>\n      <td><p>Temurin 21</p></td>\n      <td><p>22745.78 ns/op</p></td>\n      <td><p>±10505.46 ns/op</p></td>\n    </tr>\n    <tr>\n      <td><p>usingKeySet</p></td>\n      <td><p>10</p></td>\n      <td><p>Temurin 21</p></td>\n      <td><p>49.70 ns/op</p></td>\n      <td><p>±3.78 ns/op</p></td>\n    </tr>\n    <tr>\n      <td><p>usingKeySet</p></td>\n      <td><p>1000</p></td>\n      <td><p>Temurin 21</p></td>\n      <td><p>5061.54 ns/op</p></td>\n      <td><p>±2056.60 ns/op</p></td>\n    </tr>\n    <tr>\n      <td><p>usingKeySet</p></td>\n      <td><p>10000</p></td>\n      <td><p>Temurin 21</p></td>\n      <td><p>46689.04 ns/op</p></td>\n      <td><p>±14509.97 ns/op</p></td>\n    </tr>\n  </tbody>\n</table>\n<p><strong>벤치마킹 코드</strong></p>\n<p>결과는 <a href=\"https://github.com/openjdk/jmh\">JMH</a>로 다음 스니펫을 실행하여 생성되었습니다.</p>\n<pre>\n@BenchmarkMode({Mode.AverageTime})\n@OutputTimeUnit(TimeUnit.NANOSECONDS)\n@State(Scope.Benchmark)\npublic class S2864 {\n  @Param({\"10\", \"1000\", \"10000\"})\n  int size;\n\n  Map&lt;Integer,Integer&gt; map;\n\n  @Setup(Level.Trial)\n  public void setup() {\n    Random random = new Random();\n    map = new HashMap&lt;&gt;();\n    for (int i = 0; i &lt; size; i++) {\n      map.put(i, random.nextInt());\n    }\n  }\n\n  @Benchmark\n  public int usingKeySet() {\n    int sumKeysValues = 0;\n    for (Integer key : map.keySet()) {\n      sumKeysValues += key + map.get(key);\n    }\n    return sumKeysValues;\n  }\n\n  @Benchmark\n  public int usingEntrySet() {\n    int sumKeysValues = 0;\n    for (Map.Entry&lt;Integer, Integer&gt; entry : map.entrySet()) {\n      sumKeysValues += entry.getKey() + entry.getValue();\n    }\n    return sumKeysValues;\n  }\n}\n</pre>"
  },
  {
    "id": "S3776",
    "key": "java:S3776",
    "name": "Cognitive Complexity of methods should not be too high",
    "type": "code-smell",
    "severity": "critical",
    "tags": [
      "brain-overload"
    ],
    "why": "<p>Cognitive Complexity is a measure of how hard it is to understand the control flow of a unit of code. Code with high cognitive complexity is hard\nto read, understand, test, and modify.</p>\n<p>As a rule of thumb, high cognitive complexity is a sign that the code should be refactored into smaller, easier-to-manage pieces.</p>\n<h3>Which syntax in code does impact cognitive complexity score?</h3>\n<p>Here are the core concepts:</p>\n<ul>\n  <li> <strong>Cognitive complexity is incremented each time the code breaks the normal linear reading flow.</strong><br> This concerns, for example,\n  loop structures, conditionals, catches, switches, jumps to labels, and conditions mixing multiple operators. </li>\n  <li> <strong>Each nesting level increases complexity.</strong><br> During code reading, the deeper you go through nested layers, the harder it\n  becomes to keep the context in mind. </li>\n  <li> <strong>Method calls are free</strong><br> A well-picked method name is a summary of multiple lines of code. A reader can first explore a\n  high-level view of what the code is performing then go deeper and deeper by looking at called functions content.<br> <em>Note:</em> This does not\n  apply to recursive calls, those will increment cognitive score. </li>\n</ul>\n<p>The method of computation is fully detailed in the pdf linked in the resources.</p>\n<h3>Exceptions</h3>\n<p><code>equals</code> and <code>hashCode</code> methods are ignored because they might be automatically generated and might end up being difficult to\nunderstand, especially in the presence of many fields.</p>",
    "howToFix": "<p>Reducing cognitive complexity can be challenging.<br> Here are a few suggestions:</p>\n<ul>\n  <li> <strong>Extract complex conditions in a new function.</strong><br> Mixed operators in condition will increase complexity. Extracting the\n  condition in a new function with an appropriate name will reduce cognitive load. </li>\n  <li> <strong>Break down large functions.</strong><br> Large functions can be hard to understand and maintain. If a function is doing too many\n  things, consider breaking it down into smaller, more manageable functions. Each function should have a single responsibility. </li>\n  <li> <strong>Avoid deep nesting by returning early.</strong><br> To avoid the nesting of conditions, process exceptional cases first and return\n  early. </li>\n</ul>\n\n<p><strong>Extraction of a complex condition in a new function.</strong></p>\n<h4>Noncompliant code example</h4>\n<p>The code is using a complex condition and has a cognitive cost of 3.</p>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\ndouble calculateFinalPrice(User user, Cart cart) {\n  double total = calculateTotal(cart);\n  if (user.hasMembership()                            // +1 (if)\n    &amp;&amp; user.ordersCount() &gt; 10                        // +1 (more than one condition)\n    &amp;&amp; user.isAccountActive()\n    &amp;&amp; !user.hasDiscount()\n    || user.ordersCount() == 1) {                    // +1 (change of operator in condition)\n    total = applyDiscount(user, total);\n  }\n  return total;\n}\n</pre>\n<h4>Compliant solution</h4>\n<p>Even if the cognitive complexity of the whole program did not change, it is easier for a reader to understand the code of the\n<code>calculateFinalPrice</code> function, which now only has a cognitive cost of 1.</p>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\ndouble calculateFinalPrice(User user, Cart cart) {\n  double total = calculateTotal(cart);\n  if (isEligibleForDiscount(user)) {                  // +1 (if)\n    total = applyDiscount(user, total);\n  }\n  return total;\n}\n\nboolean isEligibleForDiscount(User user) {\n  return user.hasMembership()\n    &amp;&amp; user.ordersCount() &gt; 10                        // +1 (more than one condition)\n    &amp;&amp; user.isAccountActive()\n    &amp;&amp; !user.hasDiscount()\n    || user.ordersCount() == 1;                       // +1 (change of operator in condition)\n}\n</pre>\n<p><strong>Break down large functions.</strong></p>\n<h4>Noncompliant code example</h4>\n<p>For example, consider a function that calculates the total price of a shopping cart, including sales tax and shipping.<br> <em>Note:</em> The code\nis simplified here, to illustrate the purpose. Please imagine there is more happening in the <code>for</code> loops.</p>\n<pre data-diff-id=\"2\" data-diff-type=\"noncompliant\">\ndouble calculateTotal(Cart cart) {\n  double total = 0;\n  for (Item item : cart.items()) {       // +1 (for)\n    total += item.price;\n  }\n\n  // calculateSalesTax\n  for (Item item : cart.items()) {       // +1 (for)\n    total += 0.2 * item.price;\n  }\n\n  //calculateShipping\n  total += 5 * cart.items().size();\n\n  return total;\n}\n</pre>\n<p>This function could be refactored into smaller functions: The complexity is spread over multiple functions and the complex\n<code>calculateTotal</code> has now a complexity score of zero.</p>\n<h4>Compliant solution</h4>\n<pre data-diff-id=\"2\" data-diff-type=\"compliant\">\ndouble calculateTotal(Cart cart) {\n  double total = 0;\n  total = calculateSubtotal(cart, total);\n  total += calculateSalesTax(cart, total);\n  total += calculateShipping(cart, total);\n\n  return total;\n}\n\ndouble calculateShipping(Cart cart, double total) {\n  total += 5 * cart.items().size();\n  return total;\n}\n\ndouble calculateSalesTax(Cart cart, double total) {\n  for (Item item : cart.items()) {       // +1 (for)\n    total += 0.2 * item.price;\n  }\n  return total;\n}\n\ndouble calculateSubtotal(Cart cart, double total) {\n  for (Item item : cart.items()) {       // +1 (for)\n    total += item.price;\n  }\n  return total;\n}\n</pre>\n<p><strong>Avoid deep nesting by returning early.</strong></p>\n<h4>Noncompliant code example</h4>\n<p>The below code has a cognitive complexity of 6.</p>\n<pre data-diff-id=\"3\" data-diff-type=\"noncompliant\">\ndouble calculateDiscount(double price, User user) {\n  if (isEligibleForDiscount(user)) {      // +1 ( if )\n    if (user.hasMembership()) {           // +2 ( nested if )\n      return price * 0.9;\n    } else if (user.ordersCount() == 1) { // +1 ( else )\n      return price * 0.95;\n    } else {                              // +1 ( else )\n      return price;\n    }\n  } else {                                // +1 ( else )\n    return price;\n  }\n}\n</pre>\n<h4>Compliant solution</h4>\n<p>Checking for the edge case first flattens the <code>if</code> statements and reduces the cognitive complexity to 3.</p>\n<pre data-diff-id=\"3\" data-diff-type=\"compliant\">\ndouble calculateDiscount(double price, User user) {\n  if (!isEligibleForDiscount(user)) {     // +1 ( if )\n    return price;\n  }\n  if (user.hasMembership()) {             // +1\n    return price * 0.9;\n  }\n  if (user.ordersCount() == 1) {          // +1 ( if )\n    return price * 0.95;\n  }\n  return price;\n}\n</pre>\n<h3>Pitfalls</h3>\n<p>As this code is complex, ensure that you have unit tests that cover the code before refactoring.</p>",
    "moreInfo": "<h3>Documentation</h3>\n<ul>\n  <li> Sonar - <a href=\"https://www.sonarsource.com/docs/CognitiveComplexity.pdf\">Cognitive Complexity</a> </li>\n</ul>\n<h3>Articles &amp; blog posts</h3>\n<ul>\n  <li> Sonar Blog - <a href=\"https://www.sonarsource.com/blog/5-clean-code-tips-for-reducing-cognitive-complexity/\">5 Clean Code Tips for Reducing\n  Cognitive Complexity</a> </li>\n</ul>",
    "status": "READY",
    "name_ko": "메서드의 Cognitive Complexity가 너무 높으면 안 됩니다",
    "why_ko": "<p>Cognitive Complexity는 코드 단위의 제어 흐름을 이해하기 어려운 정도를 측정한 것입니다. Cognitive complexity가 높은 코드는 읽기, 이해하기, 테스트하기, 수정하기 어렵습니다.</p>\n<p>경험상 높은 cognitive complexity는 코드를 더 작고 관리하기 쉬운 조각으로 리팩토링해야 한다는 신호입니다.</p>\n<h3>코드의 어떤 구문이 cognitive complexity 점수에 영향을 미치나요?</h3>\n<p>핵심 개념은 다음과 같습니다:</p>\n<ul>\n  <li> <strong>코드가 정상적인 선형 읽기 흐름을 깨뜨릴 때마다 cognitive complexity가 증가합니다.</strong><br> 예를 들어 루프 구조, 조건문, catch, switch, 레이블로의 점프, 여러 연산자를 혼합한 조건 등이 해당됩니다. </li>\n  <li> <strong>각 중첩 수준은 복잡도를 증가시킵니다.</strong><br> 코드를 읽는 동안 중첩된 레이어를 깊이 들어갈수록 컨텍스트를 기억하기가 더 어려워집니다. </li>\n  <li> <strong>메서드 호출은 무료입니다</strong><br> 잘 선택된 메서드 이름은 여러 줄의 코드에 대한 요약입니다. 독자는 먼저 코드가 수행하는 것에 대한 높은 수준의 보기를 탐색한 다음 호출된 함수 내용을 보면서 점점 더 깊이 들어갈 수 있습니다.<br> <em>참고:</em> 이는 재귀 호출에는 적용되지 않으며, 재귀 호출은 cognitive 점수를 증가시킵니다. </li>\n</ul>\n<p>계산 방법은 리소스에 연결된 pdf에 자세히 설명되어 있습니다.</p>\n<h3>예외</h3>\n<p><code>equals</code> 및 <code>hashCode</code> 메서드는 자동으로 생성될 수 있고 특히 많은 필드가 있을 때 이해하기 어려울 수 있으므로 무시됩니다.</p>",
    "howToFix_ko": "<p>Cognitive complexity를 줄이는 것은 어려울 수 있습니다.<br> 다음은 몇 가지 제안입니다:</p>\n<ul>\n  <li> <strong>복잡한 조건을 새 함수로 추출합니다.</strong><br> 조건에서 혼합된 연산자는 복잡도를 증가시킵니다. 적절한 이름을 가진 새 함수로 조건을 추출하면 cognitive 부하가 줄어듭니다. </li>\n  <li> <strong>큰 함수를 분해합니다.</strong><br> 큰 함수는 이해하고 유지 관리하기 어려울 수 있습니다. 함수가 너무 많은 일을 하고 있다면 더 작고 관리하기 쉬운 함수로 분해하는 것을 고려하세요. 각 함수는 단일 책임을 가져야 합니다. </li>\n  <li> <strong>조기 반환으로 깊은 중첩을 피합니다.</strong><br> 조건의 중첩을 피하려면 예외적인 경우를 먼저 처리하고 조기에 반환하세요. </li>\n</ul>\n\n<p><strong>복잡한 조건을 새 함수로 추출.</strong></p>\n<h4>규칙을 준수하지 않는 코드 예시</h4>\n<p>코드가 복잡한 조건을 사용하고 있으며 cognitive 비용이 3입니다.</p>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\ndouble calculateFinalPrice(User user, Cart cart) {\n  double total = calculateTotal(cart);\n  if (user.hasMembership()                            // +1 (if)\n    &amp;&amp; user.ordersCount() &gt; 10                        // +1 (둘 이상의 조건)\n    &amp;&amp; user.isAccountActive()\n    &amp;&amp; !user.hasDiscount()\n    || user.ordersCount() == 1) {                    // +1 (조건에서 연산자 변경)\n    total = applyDiscount(user, total);\n  }\n  return total;\n}\n</pre>\n<h4>규칙을 준수하는 해결책</h4>\n<p>전체 프로그램의 cognitive complexity가 변경되지 않았더라도, 이제 cognitive 비용이 1만 있는 <code>calculateFinalPrice</code> 함수의 코드를 독자가 이해하기가 더 쉽습니다.</p>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\ndouble calculateFinalPrice(User user, Cart cart) {\n  double total = calculateTotal(cart);\n  if (isEligibleForDiscount(user)) {                  // +1 (if)\n    total = applyDiscount(user, total);\n  }\n  return total;\n}\n\nboolean isEligibleForDiscount(User user) {\n  return user.hasMembership()\n    &amp;&amp; user.ordersCount() &gt; 10                        // +1 (둘 이상의 조건)\n    &amp;&amp; user.isAccountActive()\n    &amp;&amp; !user.hasDiscount()\n    || user.ordersCount() == 1;                       // +1 (조건에서 연산자 변경)\n}\n</pre>\n<p><strong>큰 함수 분해.</strong></p>\n<h4>규칙을 준수하지 않는 코드 예시</h4>\n<p>예를 들어, 판매세와 배송을 포함하여 장바구니의 총 가격을 계산하는 함수를 고려하세요.<br> <em>참고:</em> 여기서 코드는 목적을 설명하기 위해 단순화되었습니다. <code>for</code> 루프에서 더 많은 일이 일어난다고 상상해 주세요.</p>\n<pre data-diff-id=\"2\" data-diff-type=\"noncompliant\">\ndouble calculateTotal(Cart cart) {\n  double total = 0;\n  for (Item item : cart.items()) {       // +1 (for)\n    total += item.price;\n  }\n\n  // calculateSalesTax\n  for (Item item : cart.items()) {       // +1 (for)\n    total += 0.2 * item.price;\n  }\n\n  //calculateShipping\n  total += 5 * cart.items().size();\n\n  return total;\n}\n</pre>\n<p>이 함수는 더 작은 함수로 리팩토링될 수 있습니다: 복잡도가 여러 함수에 분산되고 복잡한 <code>calculateTotal</code>은 이제 복잡도 점수가 0입니다.</p>\n<h4>규칙을 준수하는 해결책</h4>\n<pre data-diff-id=\"2\" data-diff-type=\"compliant\">\ndouble calculateTotal(Cart cart) {\n  double total = 0;\n  total = calculateSubtotal(cart, total);\n  total += calculateSalesTax(cart, total);\n  total += calculateShipping(cart, total);\n\n  return total;\n}\n\ndouble calculateShipping(Cart cart, double total) {\n  total += 5 * cart.items().size();\n  return total;\n}\n\ndouble calculateSalesTax(Cart cart, double total) {\n  for (Item item : cart.items()) {       // +1 (for)\n    total += 0.2 * item.price;\n  }\n  return total;\n}\n\ndouble calculateSubtotal(Cart cart, double total) {\n  for (Item item : cart.items()) {       // +1 (for)\n    total += item.price;\n  }\n  return total;\n}\n</pre>\n<p><strong>조기 반환으로 깊은 중첩 피하기.</strong></p>\n<h4>규칙을 준수하지 않는 코드 예시</h4>\n<p>아래 코드는 cognitive complexity가 6입니다.</p>\n<pre data-diff-id=\"3\" data-diff-type=\"noncompliant\">\ndouble calculateDiscount(double price, User user) {\n  if (isEligibleForDiscount(user)) {      // +1 ( if )\n    if (user.hasMembership()) {           // +2 ( 중첩 if )\n      return price * 0.9;\n    } else if (user.ordersCount() == 1) { // +1 ( else )\n      return price * 0.95;\n    } else {                              // +1 ( else )\n      return price;\n    }\n  } else {                                // +1 ( else )\n    return price;\n  }\n}\n</pre>\n<h4>규칙을 준수하는 해결책</h4>\n<p>엣지 케이스를 먼저 확인하면 <code>if</code> 문이 평평해지고 cognitive complexity가 3으로 줄어듭니다.</p>\n<pre data-diff-id=\"3\" data-diff-type=\"compliant\">\ndouble calculateDiscount(double price, User user) {\n  if (!isEligibleForDiscount(user)) {     // +1 ( if )\n    return price;\n  }\n  if (user.hasMembership()) {             // +1\n    return price * 0.9;\n  }\n  if (user.ordersCount() == 1) {          // +1 ( if )\n    return price * 0.95;\n  }\n  return price;\n}\n</pre>\n<h3>주의사항</h3>\n<p>이 코드가 복잡하므로 리팩토링하기 전에 코드를 커버하는 단위 테스트가 있는지 확인하세요.</p>",
    "moreInfo_ko": "<h3>문서</h3>\n<ul>\n  <li> Sonar - <a href=\"https://www.sonarsource.com/docs/CognitiveComplexity.pdf\">Cognitive Complexity</a> </li>\n</ul>\n<h3>기사 및 블로그 포스트</h3>\n<ul>\n  <li> Sonar Blog - <a href=\"https://www.sonarsource.com/blog/5-clean-code-tips-for-reducing-cognitive-complexity/\">5 Clean Code Tips for Reducing\n  Cognitive Complexity</a> </li>\n</ul>"
  },
  {
    "id": "S2188",
    "key": "java:S2188",
    "name": "JUnit test cases should call super methods",
    "type": "code-smell",
    "severity": "blocker",
    "tags": [
      "junit",
      "tests"
    ],
    "why": "<p>Overriding a parent class method prevents that method from being called unless an explicit <code>super</code> call is made in the overriding\nmethod. In some cases, not calling the parent method is fine. However, <code>setUp</code> and <code>tearDown</code> provide some shared logic that is\ncalled before all test cases. This logic may change over the lifetime of your codebase. To make sure that your test cases are set up and cleaned up\nconsistently, your overriding implementations of <code>setUp</code> and <code>tearDown</code> should call the parent implementations explicitly.</p>",
    "howToFix": "<p>Add an explicit call to <code>super.setUp()</code> and <code>super.tearDown()</code> in the overriding methods.</p>\n\n<h4>Noncompliant code example</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\npublic class MyClassTest extends MyAbstractTestCase {\n\n  private MyClass myClass;\n\n  @Override\n  protected void setUp() throws Exception {  // Noncompliant\n    myClass = new MyClass();\n  }\n}\n</pre>\n<h4>Compliant solution</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\npublic class MyClassTest extends MyAbstractTestCase {\n\n  private MyClass myClass;\n\n  @Override\n  protected void setUp() throws Exception {\n    super.setUp();\n    myClass = new MyClass();\n  }\n}\n</pre>",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "JUnit 테스트 케이스는 super 메서드를 호출해야 합니다",
    "why_ko": "<p>부모 클래스 메서드를 오버라이드하면 오버라이드하는 메서드에서 명시적인 <code>super</code> 호출이 이루어지지 않는 한 해당 메서드가 호출되지 않습니다. 어떤 경우에는 부모 메서드를 호출하지 않는 것이 괜찮습니다. 그러나 <code>setUp</code>과 <code>tearDown</code>은 모든 테스트 케이스 전에 호출되는 일부 공유 로직을 제공합니다. 이 로직은 코드베이스의 수명 동안 변경될 수 있습니다. 테스트 케이스가 일관되게 설정되고 정리되도록 하려면 <code>setUp</code>과 <code>tearDown</code>의 오버라이드 구현이 부모 구현을 명시적으로 호출해야 합니다.</p>",
    "howToFix_ko": "<p>오버라이드하는 메서드에 <code>super.setUp()</code>과 <code>super.tearDown()</code>에 대한 명시적인 호출을 추가하세요.</p>\n\n<h4>규칙을 준수하지 않는 코드 예시</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\npublic class MyClassTest extends MyAbstractTestCase {\n\n  private MyClass myClass;\n\n  @Override\n  protected void setUp() throws Exception {  // 규칙 위반\n    myClass = new MyClass();\n  }\n}\n</pre>\n<h4>규칙을 준수하는 해결책</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\npublic class MyClassTest extends MyAbstractTestCase {\n\n  private MyClass myClass;\n\n  @Override\n  protected void setUp() throws Exception {\n    super.setUp();\n    myClass = new MyClass();\n  }\n}\n</pre>",
    "moreInfo_ko": ""
  },
  {
    "id": "S1989",
    "key": "java:S1989",
    "name": "Exceptions should not be thrown from servlet methods",
    "type": "vulnerability",
    "severity": "minor",
    "tags": [
      "cwe",
      "error-handling",
      "cert"
    ],
    "why": "<p>Servlets are components in Java web development, responsible for processing HTTP requests and generating responses. In this context, exceptions are\nused to handle and manage unexpected errors or exceptional conditions that may occur during the execution of a servlet.</p>\n<p>Catching exceptions within the servlet allows us to convert them into meaningful, user-friendly messages. Otherwise, failing to catch exceptions\nwill propagate them to the servlet container, where the default error-handling mechanism may impact the overall security and stability of the\nserver.</p>\n<p>Possible security problems are:</p>\n<ol>\n  <li> <strong>Vulnerability to denial-of-service attacks:</strong> Not caught exceptions can leave the servlet container in an unstable state, which\n  can exhaust the available resources and make the system unavailable in the worst cases. </li>\n  <li> <strong>Exposure of sensitive information:</strong> Exceptions handled by the servlet container, by default, expose detailed error messages or\n  debugging information to the user, which may contain sensitive data such as stack traces, database connection, or system configuration. </li>\n</ol>\n<p>Unfortunately, servlet method signatures do not force developers to handle <code>IOException</code> and <code>ServletException</code>:</p>\n<pre>\npublic void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {\n}\n</pre>\n<p>To prevent this risk, this rule enforces all exceptions to be caught within the \"do*\" methods of servlet classes.</p>",
    "howToFix": "<p>Surround all method calls that may throw an exception with a <code>try/catch</code> block.</p>\n\n<p>In the following example, the <code>getByName</code> method may throw an <code>UnknownHostException</code>.</p>\n<h4>Noncompliant code example</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\npublic void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {\n  InetAddress addr = InetAddress.getByName(request.getRemoteAddr()); // Noncompliant\n  //...\n}\n</pre>\n<h4>Compliant solution</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\npublic void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {\n  try {\n    InetAddress addr = InetAddress.getByName(request.getRemoteAddr());\n    //...\n  }\n  catch (UnknownHostException ex) {  // Compliant\n    //...\n  }\n}\n</pre>",
    "moreInfo": "<h3>Articles &amp; blog posts</h3>\n<ul>\n  <li> OWASP - <a href=\"https://owasp.org/www-project-top-ten/2017/A3_2017-Sensitive_Data_Exposure\">Top 10 2017 Category A3 - Sensitive Data\n  Exposure</a> </li>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/600\">CWE-600 - Uncaught Exception in Servlet</a> </li>\n  <li> <a href=\"https://wiki.sei.cmu.edu/confluence/x/-zZGBQ\">CERT, ERR01-J.</a> - Do not allow exceptions to expose sensitive information </li>\n</ul>",
    "status": "READY",
    "name_ko": "Servlet 메서드에서 Exception을 던지면 안 됩니다",
    "why_ko": "<p>Servlet은 Java 웹 개발에서 HTTP 요청을 처리하고 응답을 생성하는 컴포넌트입니다. 이 맥락에서 예외는 servlet 실행 중 발생할 수 있는 예기치 않은 오류나 예외적 상황을 처리하고 관리하는 데 사용됩니다.</p>\n<p>servlet 내에서 예외를 잡으면 의미 있고 사용자 친화적인 메시지로 변환할 수 있습니다. 그렇지 않으면 예외를 잡지 못하면 servlet 컨테이너로 전파되어 기본 오류 처리 메커니즘이 서버의 전반적인 보안과 안정성에 영향을 미칠 수 있습니다.</p>\n<p>가능한 보안 문제:</p>\n<ol>\n  <li> <strong>서비스 거부 공격에 대한 취약성:</strong> 잡히지 않은 예외는 servlet 컨테이너를 불안정한 상태로 남겨둘 수 있으며, 이는 사용 가능한 리소스를 고갈시키고 최악의 경우 시스템을 사용할 수 없게 만들 수 있습니다. </li>\n  <li> <strong>민감한 정보 노출:</strong> servlet 컨테이너가 처리하는 예외는 기본적으로 스택 트레이스, 데이터베이스 연결 또는 시스템 구성과 같은 민감한 데이터를 포함할 수 있는 상세한 오류 메시지나 디버깅 정보를 사용자에게 노출합니다. </li>\n</ol>\n<p>안타깝게도 servlet 메서드 시그니처는 개발자가 <code>IOException</code>과 <code>ServletException</code>을 처리하도록 강제하지 않습니다:</p>\n<pre>\npublic void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {\n}\n</pre>\n<p>이 위험을 방지하기 위해 이 규칙은 servlet 클래스의 \"do*\" 메서드 내에서 모든 예외를 잡도록 강제합니다.</p>",
    "howToFix_ko": "<p>예외를 던질 수 있는 모든 메서드 호출을 <code>try/catch</code> 블록으로 감싸세요.</p>\n\n<p>다음 예제에서 <code>getByName</code> 메서드는 <code>UnknownHostException</code>을 던질 수 있습니다.</p>\n<h4>규칙을 준수하지 않는 코드 예시</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\npublic void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {\n  InetAddress addr = InetAddress.getByName(request.getRemoteAddr()); // 규칙 위반\n  //...\n}\n</pre>\n<h4>규칙을 준수하는 해결책</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\npublic void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {\n  try {\n    InetAddress addr = InetAddress.getByName(request.getRemoteAddr());\n    //...\n  }\n  catch (UnknownHostException ex) {  // 규칙 준수\n    //...\n  }\n}\n</pre>",
    "moreInfo_ko": "<h3>관련 문서 및 블로그 게시물</h3>\n<ul>\n  <li> OWASP - <a href=\"https://owasp.org/www-project-top-ten/2017/A3_2017-Sensitive_Data_Exposure\">Top 10 2017 카테고리 A3 - 민감한 데이터 노출</a> </li>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/600\">CWE-600 - Servlet에서 잡히지 않은 예외</a> </li>\n  <li> <a href=\"https://wiki.sei.cmu.edu/confluence/x/-zZGBQ\">CERT, ERR01-J.</a> - 예외가 민감한 정보를 노출하도록 허용하지 마세요 </li>\n</ul>"
  },
  {
    "id": "S4288",
    "key": "java:S4288",
    "name": "Spring components should use constructor injection",
    "type": "code-smell",
    "severity": "major",
    "tags": [
      "spring",
      "design"
    ],
    "why": "<p>Spring <code>@Controller</code>, <code>@Service</code>, and <code>@Repository</code> classes are singletons by default, meaning only one instance\nof the class is ever instantiated in the application. Typically such a class might have a few <code>static</code> members, such as a logger, but all\nnon-static members should be managed by Spring and supplied via constructor injection rather than by field injection.</p>\n<p>This rule raise an issue when any non-<code>static</code> member of a Spring component has an injection annotation.</p>\n<h3>Noncompliant code example</h3>\n<pre>\n@Controller\npublic class HelloWorld {\n\n  @Autowired\n  private String name = null; // Noncompliant\n\n}\n</pre>\n<h3>Compliant solution</h3>\n<p>As of Spring 4.3</p>\n<pre>\n@Controller\npublic class HelloWorld {\n\n  private String name = null;\n\n  HelloWorld(String name) {\n    this.name = name;\n  }\n}\n</pre>\n<p>Before Spring 4.3</p>\n<pre>\n@Controller\npublic class HelloWorld {\n\n  private String name = null;\n\n  @Autowired\n  HelloWorld(String name) {\n    this.name = name;\n  }\n}\n</pre>",
    "howToFix": "",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "Spring 컴포넌트는 생성자 주입을 사용해야 합니다",
    "why_ko": "<p>Spring <code>@Controller</code>, <code>@Service</code>, <code>@Repository</code> 클래스는 기본적으로 싱글톤입니다. 즉, 애플리케이션에서 클래스의 인스턴스가 하나만 인스턴스화됩니다. 일반적으로 이러한 클래스에는 로거와 같은 몇 가지 <code>static</code> 멤버가 있을 수 있지만, 모든 비정적 멤버는 필드 주입이 아닌 생성자 주입을 통해 Spring에서 관리하고 제공해야 합니다.</p>\n<p>이 규칙은 Spring 컴포넌트의 비<code>static</code> 멤버에 주입 어노테이션이 있을 때 문제를 제기합니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\n@Controller\npublic class HelloWorld {\n\n  @Autowired\n  private String name = null; // 규칙 위반\n\n}\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<p>Spring 4.3 이상</p>\n<pre>\n@Controller\npublic class HelloWorld {\n\n  private String name = null;\n\n  HelloWorld(String name) {\n    this.name = name;\n  }\n}\n</pre>\n<p>Spring 4.3 이전</p>\n<pre>\n@Controller\npublic class HelloWorld {\n\n  private String name = null;\n\n  @Autowired\n  HelloWorld(String name) {\n    this.name = name;\n  }\n}\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": ""
  },
  {
    "id": "S5860",
    "key": "java:S5860",
    "name": "Names of regular expressions named groups should be used",
    "type": "code-smell",
    "severity": "major",
    "tags": [
      "regex"
    ],
    "why": "<p>Why use named groups only to never use any of them later on in the code?</p>\n<p>This rule raises issues every time named groups are:</p>\n<ul>\n  <li> defined but never called anywhere in the code through their name; </li>\n  <li> defined but called elsewhere in the code by their number instead; </li>\n  <li> referenced while not defined. </li>\n</ul>\n<h3>Noncompliant code example</h3>\n<pre>\nString date = \"01/02\";\n\nPattern datePattern = Pattern.compile(\"(?&lt;month&gt;[0-9]{2})/(?&lt;year&gt;[0-9]{2})\");\nMatcher dateMatcher = datePattern.matcher(date);\n\nif (dateMatcher.matches()) {\n  checkValidity(dateMatcher.group(1), dateMatcher.group(2));  // Noncompliant - numbers instead of names of groups are used\n  checkValidity(dateMatcher.group(\"day\")); // Noncompliant - there is no group called \"day\"\n}\n\n// ...\n\nString score = \"14:1\";\n\nPattern scorePattern = Pattern.compile(\"(?&lt;player1&gt;[0-9]+):(?&lt;player2&gt;[0-9]+)\"); // Noncompliant - named groups are never used\nMatcher scoreMatcher = scorePattern.matcher(score);\n\nif (scoreMatcher.matches()) {\n  checkScore(score);\n}\n</pre>\n<h3>Compliant solution</h3>\n<pre>\nString date = \"01/02\";\n\nPattern datePattern = Pattern.compile(\"(?&lt;month&gt;[0-9]{2})/(?&lt;year&gt;[0-9]{2})\");\nMatcher dateMatcher = datePattern.matcher(date);\n\nif (dateMatcher.matches()) {\n  checkValidity(dateMatcher.group(\"month\"), dateMatcher.group(\"year\"));\n}\n\n// ...\n\nString score = \"14:1\";\n\nPattern scorePattern = Pattern.compile(\"(?&lt;player1&gt;[0-9]+):(?&lt;player2&gt;[0-9]+)\");\nMatcher scoreMatcher = scorePattern.matcher(score);\n\nif (scoreMatcher.matches()) {\n  checkScore(scoreMatcher.group(\"player1\"));\n  checkScore(scoreMatcher.group(\"player2\"));\n}\n</pre>\n<p>Or, using dedicated variables instead of group names:</p>\n<pre>\nString score = \"14:1\";\n\nString player = \"([0-9]+)\";\nString gameScore = player + \":\" + player;\n\nPattern scorePattern = Pattern.compile(gameScore);\nMatcher scoreMatcher = scorePattern.matcher(score);\n\nif (scoreMatcher.matches()) {\n  checkScore(score);\n}\n</pre>",
    "howToFix": "",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "정규식의 명명된 그룹 이름이 사용되어야 합니다",
    "why_ko": "<p>명명된 그룹을 정의하고 나중에 코드에서 전혀 사용하지 않는 이유가 무엇일까요?</p>\n<p>이 규칙은 다음과 같은 경우에 문제를 제기합니다:</p>\n<ul>\n  <li> 정의되었지만 코드 어디에서도 이름으로 호출되지 않는 경우; </li>\n  <li> 정의되었지만 코드 다른 곳에서 이름 대신 번호로 호출되는 경우; </li>\n  <li> 정의되지 않은 상태에서 참조되는 경우. </li>\n</ul>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\nString date = \"01/02\";\n\nPattern datePattern = Pattern.compile(\"(?&lt;month&gt;[0-9]{2})/(?&lt;year&gt;[0-9]{2})\");\nMatcher dateMatcher = datePattern.matcher(date);\n\nif (dateMatcher.matches()) {\n  checkValidity(dateMatcher.group(1), dateMatcher.group(2));  // 규칙 위반 - 그룹 이름 대신 번호 사용\n  checkValidity(dateMatcher.group(\"day\")); // 규칙 위반 - \"day\"라는 그룹이 없음\n}\n\n// ...\n\nString score = \"14:1\";\n\nPattern scorePattern = Pattern.compile(\"(?&lt;player1&gt;[0-9]+):(?&lt;player2&gt;[0-9]+)\"); // 규칙 위반 - 명명된 그룹이 사용되지 않음\nMatcher scoreMatcher = scorePattern.matcher(score);\n\nif (scoreMatcher.matches()) {\n  checkScore(score);\n}\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre>\nString date = \"01/02\";\n\nPattern datePattern = Pattern.compile(\"(?&lt;month&gt;[0-9]{2})/(?&lt;year&gt;[0-9]{2})\");\nMatcher dateMatcher = datePattern.matcher(date);\n\nif (dateMatcher.matches()) {\n  checkValidity(dateMatcher.group(\"month\"), dateMatcher.group(\"year\"));\n}\n\n// ...\n\nString score = \"14:1\";\n\nPattern scorePattern = Pattern.compile(\"(?&lt;player1&gt;[0-9]+):(?&lt;player2&gt;[0-9]+)\");\nMatcher scoreMatcher = scorePattern.matcher(score);\n\nif (scoreMatcher.matches()) {\n  checkScore(scoreMatcher.group(\"player1\"));\n  checkScore(scoreMatcher.group(\"player2\"));\n}\n</pre>\n<p>또는 그룹 이름 대신 전용 변수를 사용:</p>\n<pre>\nString score = \"14:1\";\n\nString player = \"([0-9]+)\";\nString gameScore = player + \":\" + player;\n\nPattern scorePattern = Pattern.compile(gameScore);\nMatcher scoreMatcher = scorePattern.matcher(score);\n\nif (scoreMatcher.matches()) {\n  checkScore(score);\n}\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": ""
  },
  {
    "id": "S1120",
    "key": "java:S1120",
    "name": "Source code should be indented consistently",
    "type": "code-smell",
    "severity": "minor",
    "tags": [
      "convention"
    ],
    "why": "<p>Consistent indentation is a simple and effective way to improve the code's readability. It reduces the differences that are committed to source\ncontrol systems, making code reviews easier.</p>\n<p>This rule raises an issue when the indentation does not match the configured value. Only the first line of a badly indented section is\nreported.</p>\n<p>The rule behaves consistently when the indentation settings of the IDE use <em>spaces</em> instead of <em>tabs</em>. Using <em>tabs</em> can lead\nto inconsistent indentation because the width of a <em>tab</em> can be configured differently in different environments.</p>\n<h3>What is the potential impact?</h3>\n<p>The readability is decreased. It becomes more tedious to review and modify the code.</p>",
    "howToFix": "<p>Change the indentation so that the text starts at the expected column. The expected column should be the configured indent size multiplied by the\nlevel at which the code block is nested.</p>\n\n<h4>Noncompliant code example</h4>\n<p>With an indent size of 2:</p>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\nclass Foo {\n  public int a;\n   public int b;   // Noncompliant, expected to start at column 4\n\n...\n\n  public void doSomething() {\n    if(something) {\n          doSomethingElse();  // Noncompliant, expected to start at column 6\n  }   // Noncompliant, expected to start at column 4\n  }\n}\n</pre>\n<h4>Compliant solution</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\nclass Foo {\n  public int a;\n  public int b;\n\n...\n\n  public void doSomething() {\n    if(something) {\n      doSomethingElse();\n    }\n  }\n}\n</pre>\n<h3>Going the extra mile</h3>\n<p>You can adopt a tool or configure your IDE to take care of code formatting automatically.</p>",
    "moreInfo": "<h3>External coding guidelines</h3>\n<ul>\n  <li> <a href=\"https://google.github.io/styleguide/javaguide.html\">Google Java Style Guide</a> </li>\n</ul>",
    "status": "READY",
    "name_ko": "소스 코드는 일관되게 들여쓰기해야 합니다",
    "why_ko": "<p>일관된 들여쓰기는 코드의 가독성을 향상시키는 간단하고 효과적인 방법입니다. 소스 컨트롤 시스템에 커밋되는 차이점을 줄여 코드 리뷰를 더 쉽게 만듭니다.</p>\n<p>이 규칙은 들여쓰기가 설정된 값과 일치하지 않을 때 이슈를 제기합니다. 잘못 들여쓰기된 섹션의 첫 번째 줄만 보고됩니다.</p>\n<p>IDE의 들여쓰기 설정이 <em>탭</em> 대신 <em>공백</em>을 사용할 때 규칙이 일관되게 동작합니다. <em>탭</em>을 사용하면 다른 환경에서 <em>탭</em>의 너비가 다르게 설정될 수 있으므로 일관되지 않은 들여쓰기가 발생할 수 있습니다.</p>\n<h3>잠재적 영향은 무엇인가요?</h3>\n<p>가독성이 감소합니다. 코드를 검토하고 수정하기가 더 지루해집니다.</p>",
    "howToFix_ko": "<p>텍스트가 예상 열에서 시작하도록 들여쓰기를 변경하세요. 예상 열은 설정된 들여쓰기 크기에 코드 블록이 중첩된 수준을 곱한 값이어야 합니다.</p>\n\n<h4>규칙을 준수하지 않는 코드 예시</h4>\n<p>들여쓰기 크기가 2인 경우:</p>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\nclass Foo {\n  public int a;\n   public int b;   // 규칙 위반, 열 4에서 시작해야 함\n\n...\n\n  public void doSomething() {\n    if(something) {\n          doSomethingElse();  // 규칙 위반, 열 6에서 시작해야 함\n  }   // 규칙 위반, 열 4에서 시작해야 함\n  }\n}\n</pre>\n<h4>규칙을 준수하는 해결책</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\nclass Foo {\n  public int a;\n  public int b;\n\n...\n\n  public void doSomething() {\n    if(something) {\n      doSomethingElse();\n    }\n  }\n}\n</pre>\n<h3>한 걸음 더 나아가기</h3>\n<p>코드 서식을 자동으로 처리하도록 도구를 채택하거나 IDE를 구성할 수 있습니다.</p>",
    "moreInfo_ko": "<h3>외부 코딩 가이드라인</h3>\n<ul>\n  <li> <a href=\"https://google.github.io/styleguide/javaguide.html\">Google Java Style Guide</a> </li>\n</ul>"
  },
  {
    "id": "S1065",
    "key": "java:S1065",
    "name": "Unused labels should be removed",
    "type": "code-smell",
    "severity": "major",
    "tags": [
      "cert",
      "unused"
    ],
    "why": "<p>If a label is declared but not used in the program, it can be considered as dead code and should therefore be removed.</p>\n<p>This will improve maintainability as developers will not wonder what this label is used for.</p>\n<h3>Noncompliant code example</h3>\n<pre>\nvoid foo() {\n  outer: //label is not used.\n  for(int i = 0; i&lt;10; i++) {\n    break;\n  }\n}\n</pre>\n<h3>Compliant solution</h3>\n<pre>\nvoid foo() {\n  for(int i = 0; i&lt;10; i++) {\n    break;\n  }\n}\n</pre>",
    "howToFix": "",
    "moreInfo": "<ul>\n  <li> <a href=\"https://wiki.sei.cmu.edu/confluence/x/5dUxBQ\">CERT, MSC12-C.</a> - Detect and remove code that has no effect or is never executed\n  </li>\n</ul>",
    "status": "READY",
    "name_ko": "사용되지 않는 label은 제거해야 합니다",
    "why_ko": "<p>label이 선언되었지만 프로그램에서 사용되지 않으면 죽은 코드로 간주할 수 있으므로 제거해야 합니다.</p>\n<p>이렇게 하면 개발자들이 이 label이 무엇에 사용되는지 궁금해하지 않아도 되므로 유지보수성이 향상됩니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\nvoid foo() {\n  outer: //label이 사용되지 않음.\n  for(int i = 0; i&lt;10; i++) {\n    break;\n  }\n}\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre>\nvoid foo() {\n  for(int i = 0; i&lt;10; i++) {\n    break;\n  }\n}\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": "<ul>\n  <li> <a href=\"https://wiki.sei.cmu.edu/confluence/x/5dUxBQ\">CERT, MSC12-C.</a> - 효과가 없거나 실행되지 않는 코드를 탐지하고 제거하기\n  </li>\n</ul>"
  },
  {
    "id": "S126",
    "key": "java:S126",
    "name": "\"if ... else if\" constructs should end with \"else\" clauses",
    "type": "code-smell",
    "severity": "critical",
    "tags": [
      "cert"
    ],
    "why": "<p>This rule applies whenever an <code>if</code> statement is followed by one or more <code>else if</code> statements; the final <code>else if</code>\nshould be followed by an <code>else</code> statement.</p>\n<p>The requirement for a final <code>else</code> statement is defensive programming.</p>\n<p>The <code>else</code> statement should either take appropriate action or contain a suitable comment as to why no action is taken. This is\nconsistent with the requirement to have a final <code>default</code> clause in a <code>switch</code> statement.</p>\n<h3>Noncompliant code example</h3>\n<pre>\nif (x == 0) {\n  doSomething();\n} else if (x == 1) {\n  doSomethingElse();\n}\n</pre>\n<h3>Compliant solution</h3>\n<pre>\nif (x == 0) {\n  doSomething();\n} else if (x == 1) {\n  doSomethingElse();\n} else {\n  throw new IllegalStateException();\n}\n</pre>",
    "howToFix": "",
    "moreInfo": "<ul>\n  <li> <a href=\"https://wiki.sei.cmu.edu/confluence/x/RtYxBQ\">CERT, MSC01-C.</a> - Strive for logical completeness </li>\n  <li> <a href=\"https://wiki.sei.cmu.edu/confluence/x/jzZGBQ\">CERT, MSC57-J.</a> - Strive for logical completeness </li>\n</ul>",
    "status": "READY",
    "name_ko": "\"if ... else if\" 구문은 \"else\" 절로 끝나야 합니다",
    "why_ko": "<p>이 규칙은 <code>if</code> 문 뒤에 하나 이상의 <code>else if</code> 문이 오는 경우에 적용됩니다. 마지막 <code>else if</code> 뒤에는 <code>else</code> 문이 와야 합니다.</p>\n<p>마지막 <code>else</code> 문에 대한 요구 사항은 방어적 프로그래밍입니다.</p>\n<p><code>else</code> 문은 적절한 조치를 취하거나 조치를 취하지 않는 이유에 대한 적절한 주석을 포함해야 합니다. 이는 <code>switch</code> 문에 마지막 <code>default</code> 절을 두어야 하는 요구 사항과 일치합니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\nif (x == 0) {\n  doSomething();\n} else if (x == 1) {\n  doSomethingElse();\n}\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre>\nif (x == 0) {\n  doSomething();\n} else if (x == 1) {\n  doSomethingElse();\n} else {\n  throw new IllegalStateException();\n}\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": "<ul>\n  <li> <a href=\"https://wiki.sei.cmu.edu/confluence/x/RtYxBQ\">CERT, MSC01-C.</a> - 논리적 완전성을 위해 노력하세요 </li>\n  <li> <a href=\"https://wiki.sei.cmu.edu/confluence/x/jzZGBQ\">CERT, MSC57-J.</a> - 논리적 완전성을 위해 노력하세요 </li>\n</ul>"
  },
  {
    "id": "S2130",
    "key": "java:S2130",
    "name": "Parsing should be used to convert \"Strings\" to primitives",
    "type": "code-smell",
    "severity": "minor",
    "tags": [
      "performance"
    ],
    "why": "<p>Rather than creating a boxed primitive from a <code>String</code> to extract the primitive value, use the relevant <code>parse</code> method\ninstead. Using <code>parse</code> makes the code more efficient and the intent of the developer clearer.</p>\n<h3>Noncompliant code example</h3>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\nString myNum = \"42.0\";\nfloat myFloat = new Float(myNum);  // Noncompliant\nfloat myFloatValue = (new Float(myNum)).floatValue();  // Noncompliant\nint myInteger = Integer.valueOf(myNum); // Noncompliant\nint myIntegerValue = Integer.valueOf(myNum).intValue(); // Noncompliant\n</pre>\n<h3>Compliant solution</h3>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\nString myNum = \"42.0\";\nfloat f = Float.parseFloat(myNum);\nint myInteger = Integer.parseInt(myNum);\n</pre>",
    "howToFix": "",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "String을 primitive로 변환할 때는 파싱을 사용해야 합니다",
    "why_ko": "<p>primitive 값을 추출하기 위해 <code>String</code>에서 박싱된 primitive를 생성하는 대신 관련 <code>parse</code> 메서드를 사용하세요. <code>parse</code>를 사용하면 코드가 더 효율적이고 개발자의 의도가 더 명확해집니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\nString myNum = \"42.0\";\nfloat myFloat = new Float(myNum);  // 규칙 위반\nfloat myFloatValue = (new Float(myNum)).floatValue();  // 규칙 위반\nint myInteger = Integer.valueOf(myNum); // 규칙 위반\nint myIntegerValue = Integer.valueOf(myNum).intValue(); // 규칙 위반\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\nString myNum = \"42.0\";\nfloat f = Float.parseFloat(myNum);\nint myInteger = Integer.parseInt(myNum);\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": ""
  },
  {
    "id": "S1659",
    "key": "java:S1659",
    "name": "Multiple variables should not be declared on the same line",
    "type": "code-smell",
    "severity": "minor",
    "tags": [
      "convention",
      "cert"
    ],
    "why": "<p>Declaring multiple variables on one line is difficult to read.</p>\n<h3>Noncompliant code example</h3>\n<pre>\nclass MyClass {\n\n  private int a, b;\n\n  public void method(){\n    int c; int d;\n  }\n}\n</pre>\n<h3>Compliant solution</h3>\n<pre>\nclass MyClass {\n\n  private int a;\n  private int b;\n\n  public void method(){\n    int c;\n    int d;\n  }\n}\n</pre>",
    "howToFix": "",
    "moreInfo": "<ul>\n  <li> <a href=\"https://wiki.sei.cmu.edu/confluence/x/YTZGBQ\">CERT, DCL52-J.</a> - Do not declare more than one variable per declaration </li>\n  <li> <a href=\"https://wiki.sei.cmu.edu/confluence/x/EtcxBQ\">CERT, DCL04-C.</a> - Do not declare more than one variable per declaration </li>\n</ul>",
    "status": "READY",
    "name_ko": "같은 줄에 여러 변수를 선언하면 안 됩니다",
    "why_ko": "<p>한 줄에 여러 변수를 선언하면 읽기 어렵습니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\nclass MyClass {\n\n  private int a, b;\n\n  public void method(){\n    int c; int d;\n  }\n}\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre>\nclass MyClass {\n\n  private int a;\n  private int b;\n\n  public void method(){\n    int c;\n    int d;\n  }\n}\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": "<ul>\n  <li> <a href=\"https://wiki.sei.cmu.edu/confluence/x/YTZGBQ\">CERT, DCL52-J.</a> - 선언당 두 개 이상의 변수를 선언하지 마세요 </li>\n  <li> <a href=\"https://wiki.sei.cmu.edu/confluence/x/EtcxBQ\">CERT, DCL04-C.</a> - 선언당 두 개 이상의 변수를 선언하지 마세요 </li>\n</ul>"
  },
  {
    "id": "S1858",
    "key": "java:S1858",
    "name": "\"toString()\" should never be called on a String object",
    "type": "code-smell",
    "severity": "minor",
    "tags": [
      "finding",
      "clumsy"
    ],
    "why": "<p>Invoking a method designed to return a string representation of an object which is already a string is a waste of keystrokes. This redundant\nconstruction may be optimized by the compiler, but will be confusing in the meantime.</p>\n<h3>Noncompliant code example</h3>\n<pre>\nString message = \"hello world\";\nSystem.out.println(message.toString()); // Noncompliant;\n</pre>\n<h3>Compliant solution</h3>\n<pre>\nString message = \"hello world\";\nSystem.out.println(message);\n</pre>",
    "howToFix": "",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "String 객체에서 \"toString()\"을 호출하면 안 됩니다",
    "why_ko": "<p>이미 문자열인 객체의 문자열 표현을 반환하도록 설계된 메서드를 호출하는 것은 키 입력 낭비입니다. 이 중복 구성은 컴파일러에 의해 최적화될 수 있지만, 그동안 혼란을 줄 것입니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\nString message = \"hello world\";\nSystem.out.println(message.toString()); // 규칙 위반;\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre>\nString message = \"hello world\";\nSystem.out.println(message);\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": ""
  },
  {
    "id": "S4973",
    "key": "java:S4973",
    "name": "Strings and Boxed types should be compared using \"equals()\"",
    "type": "bug",
    "severity": "major",
    "tags": [
      "cwe",
      "cert"
    ],
    "why": "<p>It's almost always a mistake to compare two instances of <code>java.lang.String</code> or boxed types like <code>java.lang.Integer</code> using\nreference equality <code>==</code> or <code>!=</code>, because it is not comparing actual value but locations in memory.</p>\n<h3>Noncompliant code example</h3>\n<pre>\nString firstName = getFirstName(); // String overrides equals\nString lastName = getLastName();\n\nif (firstName == lastName) { ... }; // Non-compliant; false even if the strings have the same value\n</pre>\n<h3>Compliant solution</h3>\n<pre>\nString firstName = getFirstName();\nString lastName = getLastName();\n\nif (firstName != null &amp;&amp; firstName.equals(lastName)) { ... };\n</pre>",
    "howToFix": "",
    "moreInfo": "<ul>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/595\">CWE-595 - Comparison of Object References Instead of Object Contents</a> </li>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/597\">CWE-597 - Use of Wrong Operator in String Comparison</a> </li>\n  <li> <a href=\"https://wiki.sei.cmu.edu/confluence/x/UjdGBQ\">CERT, EXP03-J.</a> - Do not use the equality operators when comparing values of boxed\n  primitives </li>\n  <li> <a href=\"https://wiki.sei.cmu.edu/confluence/x/yDdGBQ\">CERT, EXP50-J.</a> - Do not confuse abstract object equality with reference equality\n  </li>\n</ul>",
    "status": "READY",
    "name_ko": "String과 박싱된 타입은 equals()로 비교해야 합니다",
    "why_ko": "<p><code>java.lang.String</code> 또는 <code>java.lang.Integer</code>와 같은 박싱된 타입의 두 인스턴스를 참조 동등성 <code>==</code> 또는 <code>!=</code>로 비교하는 것은 거의 항상 실수입니다. 이는 실제 값이 아닌 메모리 위치를 비교하기 때문입니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\nString firstName = getFirstName(); // String은 equals를 오버라이드함\nString lastName = getLastName();\n\nif (firstName == lastName) { ... }; // 규칙 위반; 문자열이 같은 값을 가지더라도 false\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre>\nString firstName = getFirstName();\nString lastName = getLastName();\n\nif (firstName != null &amp;&amp; firstName.equals(lastName)) { ... };\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": "<ul>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/595\">CWE-595 - 객체 내용 대신 객체 참조 비교</a> </li>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/597\">CWE-597 - 문자열 비교에서 잘못된 연산자 사용</a> </li>\n  <li> <a href=\"https://wiki.sei.cmu.edu/confluence/x/UjdGBQ\">CERT, EXP03-J.</a> - 박싱된 기본 타입의 값을 비교할 때 동등 연산자를 사용하지 마세요 </li>\n  <li> <a href=\"https://wiki.sei.cmu.edu/confluence/x/yDdGBQ\">CERT, EXP50-J.</a> - 추상 객체 동등성과 참조 동등성을 혼동하지 마세요 </li>\n</ul>"
  },
  {
    "id": "S7467",
    "key": "java:S7467",
    "name": "Unused exception parameter should use the unnamed variable pattern",
    "type": "code-smell",
    "severity": "minor",
    "tags": [
      "java22"
    ],
    "why": "<p>Good exception management is key to keeping a consistent application state in the face of errors and unexpected behaviors. However, in some cases,\nthe information carried by the exception is not as important as the exception bubbling up itself. In such cases, developers may want to explicitly\nindicate that they have no use for the exception parameter. Java 22 introduces the unnamed variable pattern <code>_</code> which allows developers to\nfree the catch clause from an unnecessary exception parameter name.</p>",
    "howToFix": "<p>Replace exception parameter name with unnamed variable pattern <code>_</code>.</p>\n\n<h4>Noncompliant code example</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\nList&lt;String&gt; elements = // ...\nint value = 0;\ntry {\n  var elem = elements.get(idx);\n  value = Integer.parseInt(elem);\n} catch (NumberFormatException nfe) { // Noncompliant\n  System.err.println(\"Wrong number format\");\n} catch (IndexOutOfBoundsException ioob) {  // Noncompliant\n  System.err.println(\"No such element\");\n}\n</pre>\n<h4>Compliant solution</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\nList&lt;String&gt; elements = // ...\nint value = 0;\ntry {\n  var elem = elements.get(idx);\n  value = Integer.parseInt(elem);\n} catch (NumberFormatException _) {\n  System.err.println(\"Wrong number format\");\n} catch (IndexOutOfBoundsException _) {\n  System.err.println(\"No such element\");\n}\n</pre>",
    "moreInfo": "<h3>Documentation</h3>\n<ul>\n  <li> OpenJDK - <a href=\"https://openjdk.org/jeps/456\">JEP 456: Unnamed Variables &amp; Patterns</a> </li>\n</ul>",
    "status": "READY",
    "name_ko": "사용되지 않는 exception 매개변수는 이름 없는 변수 패턴을 사용해야 합니다",
    "why_ko": "<p>좋은 예외 관리는 오류와 예상치 못한 동작에 직면했을 때 일관된 애플리케이션 상태를 유지하는 데 핵심입니다. 그러나 일부 경우에는 예외가 전달하는 정보보다 예외 자체가 전파되는 것이 더 중요합니다. 이러한 경우 개발자는 예외 매개변수를 사용하지 않겠다는 것을 명시적으로 나타내고 싶을 수 있습니다. Java 22에서는 개발자가 불필요한 예외 매개변수 이름으로부터 catch 절을 해방할 수 있는 이름 없는 변수 패턴 <code>_</code>를 도입했습니다.</p>",
    "howToFix_ko": "<p>예외 매개변수 이름을 이름 없는 변수 패턴 <code>_</code>로 교체하세요.</p>\n\n<h4>규칙을 준수하지 않는 코드 예시</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\nList&lt;String&gt; elements = // ...\nint value = 0;\ntry {\n  var elem = elements.get(idx);\n  value = Integer.parseInt(elem);\n} catch (NumberFormatException nfe) { // 규칙 위반\n  System.err.println(\"Wrong number format\");\n} catch (IndexOutOfBoundsException ioob) {  // 규칙 위반\n  System.err.println(\"No such element\");\n}\n</pre>\n<h4>규칙을 준수하는 해결책</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\nList&lt;String&gt; elements = // ...\nint value = 0;\ntry {\n  var elem = elements.get(idx);\n  value = Integer.parseInt(elem);\n} catch (NumberFormatException _) {\n  System.err.println(\"Wrong number format\");\n} catch (IndexOutOfBoundsException _) {\n  System.err.println(\"No such element\");\n}\n</pre>",
    "moreInfo_ko": "<h3>문서</h3>\n<ul>\n  <li> OpenJDK - <a href=\"https://openjdk.org/jeps/456\">JEP 456: 이름 없는 변수 및 패턴</a> </li>\n</ul>"
  },
  {
    "id": "S2235",
    "key": "java:S2235",
    "name": "\"IllegalMonitorStateException\" should not be caught",
    "type": "code-smell",
    "severity": "critical",
    "tags": [
      "error-handling",
      "multi-threading"
    ],
    "why": "<p>The <code>IllegalMonitorStateException</code> is an exception that occurs when a thread tries to perform an operation on an object's monitor that\nit does not own. This exception is typically thrown when a method like <code>wait()</code>, <code>notify()</code>, or <code>notifyAll()</code> is\ncalled outside a synchronized block or method.</p>\n<p><code>IllegalMonitorStateException</code> is specifically designed to be an unchecked exception to point out a programming mistake. This exception\nserves as a reminder for developers to rectify their code by correctly acquiring and releasing locks using synchronized blocks or methods. It also\nemphasizes the importance of calling monitor-related methods on the appropriate objects to ensure proper synchronization.</p>\n<p>Catching and handling this exception can mask underlying synchronization issues and lead to unpredictable behavior.</p>\n<h3>Noncompliant code example</h3>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\npublic void doSomething() {\n  try {\n    anObject.notify();\n  } catch(IllegalMonitorStateException e) { // Noncompliant\n  }\n}\n</pre>\n<h3>Compliant solution</h3>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\npublic void doSomething() {\n  synchronized(anObject) {\n    anObject.notify();\n  }\n}\n</pre>",
    "howToFix": "",
    "moreInfo": "<ul>\n  <li> <a href=\"https://docs.oracle.com/en/java/javase/20/docs/api/java.base/java/lang/IllegalMonitorStateException.html\">Oracle Java SE -\n  IllegalMonitorStateException</a> </li>\n</ul>",
    "status": "READY",
    "name_ko": "\"IllegalMonitorStateException\"을 catch하면 안 됩니다",
    "why_ko": "<p><code>IllegalMonitorStateException</code>은 스레드가 소유하지 않은 객체의 모니터에 대해 작업을 수행하려고 할 때 발생하는 예외입니다. 이 예외는 일반적으로 <code>wait()</code>, <code>notify()</code> 또는 <code>notifyAll()</code>과 같은 메서드가 synchronized 블록이나 메서드 외부에서 호출될 때 던져집니다.</p>\n<p><code>IllegalMonitorStateException</code>은 프로그래밍 실수를 지적하기 위해 특별히 설계된 unchecked 예외입니다. 이 예외는 개발자가 synchronized 블록이나 메서드를 사용하여 잠금을 올바르게 획득하고 해제하여 코드를 수정하도록 상기시키는 역할을 합니다. 또한 적절한 동기화를 보장하기 위해 적절한 객체에서 모니터 관련 메서드를 호출하는 것의 중요성을 강조합니다.</p>\n<p>이 예외를 catch하고 처리하면 근본적인 동기화 문제를 숨기고 예측할 수 없는 동작으로 이어질 수 있습니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\npublic void doSomething() {\n  try {\n    anObject.notify();\n  } catch(IllegalMonitorStateException e) { // 규칙 위반\n  }\n}\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\npublic void doSomething() {\n  synchronized(anObject) {\n    anObject.notify();\n  }\n}\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": "<ul>\n  <li> <a href=\"https://docs.oracle.com/en/java/javase/20/docs/api/java.base/java/lang/IllegalMonitorStateException.html\">Oracle Java SE - IllegalMonitorStateException</a> </li>\n</ul>"
  },
  {
    "id": "S2059",
    "key": "java:S2059",
    "name": "\"Serializable\" inner classes of \"Serializable\" classes should be static",
    "type": "code-smell",
    "severity": "minor",
    "tags": [
      "serialization",
      "cert",
      "pitfall"
    ],
    "why": "<p>Serializing a non-<code>static</code> inner class will result in an attempt at serializing the outer class as well. If the outer class is actually\nserializable, then the serialization will succeed but possibly write out far more data than was intended.</p>\n<p>Making the inner class <code>static</code> (i.e. \"nested\") avoids this problem, therefore inner classes should be <code>static</code> if possible.\nHowever, you should be aware that there are semantic differences between an inner class and a nested one:</p>\n<ul>\n  <li> an inner class can only be instantiated within the context of an instance of the outer class. </li>\n  <li> a nested (<code>static</code>) class can be instantiated independently of the outer class. </li>\n</ul>\n<h3>Noncompliant code example</h3>\n<pre>\npublic class Raspberry implements Serializable {\n  // ...\n\n  public class Drupelet implements Serializable {  // Noncompliant; output may be too large\n    // ...\n  }\n}\n</pre>\n<h3>Compliant solution</h3>\n<pre>\npublic class Raspberry implements Serializable {\n  // ...\n\n  public static class Drupelet implements Serializable {\n    // ...\n  }\n}\n</pre>",
    "howToFix": "",
    "moreInfo": "<ul>\n  <li> <a href=\"https://wiki.sei.cmu.edu/confluence/x/ZTdGBQ\">CERT, SER05-J.</a> - Do not serialize instances of inner classes </li>\n</ul>",
    "status": "READY",
    "name_ko": "\"Serializable\" 클래스의 \"Serializable\" 내부 클래스는 static이어야 합니다",
    "why_ko": "<p>비-<code>static</code> 내부 클래스를 직렬화하면 외부 클래스도 직렬화하려는 시도가 발생합니다. 외부 클래스가 실제로 직렬화 가능하다면 직렬화는 성공하지만 의도한 것보다 훨씬 많은 데이터를 출력할 수 있습니다.</p>\n<p>내부 클래스를 <code>static</code>(즉, \"중첩\")으로 만들면 이 문제를 피할 수 있으므로 가능하면 내부 클래스는 <code>static</code>이어야 합니다. 그러나 내부 클래스와 중첩 클래스 사이에는 의미적 차이가 있음을 알아야 합니다:</p>\n<ul>\n  <li> 내부 클래스는 외부 클래스의 인스턴스 컨텍스트 내에서만 인스턴스화할 수 있습니다. </li>\n  <li> 중첩(<code>static</code>) 클래스는 외부 클래스와 독립적으로 인스턴스화할 수 있습니다. </li>\n</ul>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\npublic class Raspberry implements Serializable {\n  // ...\n\n  public class Drupelet implements Serializable {  // 규칙 위반; 출력이 너무 클 수 있음\n    // ...\n  }\n}\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre>\npublic class Raspberry implements Serializable {\n  // ...\n\n  public static class Drupelet implements Serializable {\n    // ...\n  }\n}\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": "<ul>\n  <li> <a href=\"https://wiki.sei.cmu.edu/confluence/x/ZTdGBQ\">CERT, SER05-J.</a> - Do not serialize instances of inner classes </li>\n</ul>"
  },
  {
    "id": "S3824",
    "key": "java:S3824",
    "name": "\"Map.get\" and value test should be replaced with single method call",
    "type": "code-smell",
    "severity": "major",
    "tags": [
      "symbolic-execution",
      "java8"
    ],
    "why": "<p>It's a common pattern to test the result of a <code>java.util.Map.get()</code> against <code>null</code> or calling\n<code>java.util.Map.containsKey()</code> before proceeding with adding or changing the value in the map. However the <code>java.util.Map</code> API\noffers a significantly better alternative in the form of the <code>computeIfPresent()</code> and <code>computeIfAbsent()</code> methods. Using these\ninstead leads to cleaner and more readable code.</p>\n<p><strong>Note</strong> that this rule is automatically disabled when the project's <code>sonar.java.source</code> is not 8.</p>\n<h3>Noncompliant code example</h3>\n<pre>\nV value = map.get(key);\nif (value == null) {  // Noncompliant\n  value = V.createFor(key);\n  if (value != null) {\n    map.put(key, value);\n  }\n}\nif (!map.containsKey(key)) {  // Noncompliant\n  value = V.createFor(key);\n  if (value != null) {\n    map.put(key, value);\n  }\n}\nreturn value;\n</pre>\n<h3>Compliant solution</h3>\n<pre>\nreturn map.computeIfAbsent(key, k -&gt; V.createFor(k));\n</pre>\n<h3>Exceptions</h3>\n<p>This rule will not raise an issue when trying to add <code>null</code> to a map, because <code>computeIfAbsent</code> will not add the entry if the\nvalue returned by the function is <code>null</code>.</p>",
    "howToFix": "",
    "moreInfo": "<h3>Related rules</h3>\n<ul>\n  <li> <a href='/coding_rules#rule_key=java%3AS6104'>S6104</a> - Map \"computeIfAbsent()\" and \"computeIfPresent()\" should not be used to add \"null\" values. </li>\n</ul>",
    "status": "READY",
    "name_ko": "Map.get과 값 테스트는 단일 메서드 호출로 대체해야 합니다",
    "why_ko": "<p>맵에서 값을 추가하거나 변경하기 전에 <code>java.util.Map.get()</code>의 결과를 <code>null</code>과 비교하거나 <code>java.util.Map.containsKey()</code>를 호출하는 것은 일반적인 패턴입니다. 그러나 <code>java.util.Map</code> API는 <code>computeIfPresent()</code> 및 <code>computeIfAbsent()</code> 메서드 형태로 훨씬 더 나은 대안을 제공합니다. 이것을 대신 사용하면 더 깔끔하고 읽기 쉬운 코드가 됩니다.</p>\n<p><strong>참고</strong>: 이 규칙은 프로젝트의 <code>sonar.java.source</code>가 8이 아닐 때 자동으로 비활성화됩니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\nV value = map.get(key);\nif (value == null) {  // 규칙 위반\n  value = V.createFor(key);\n  if (value != null) {\n    map.put(key, value);\n  }\n}\nif (!map.containsKey(key)) {  // 규칙 위반\n  value = V.createFor(key);\n  if (value != null) {\n    map.put(key, value);\n  }\n}\nreturn value;\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre>\nreturn map.computeIfAbsent(key, k -&gt; V.createFor(k));\n</pre>\n<h3>예외</h3>\n<p><code>computeIfAbsent</code>는 함수가 반환하는 값이 <code>null</code>이면 항목을 추가하지 않으므로, 맵에 <code>null</code>을 추가하려고 할 때 이 규칙은 문제를 제기하지 않습니다.</p>",
    "howToFix_ko": "",
    "moreInfo_ko": "<h3>관련 규칙</h3>\n<ul>\n  <li> <a href='/coding_rules#rule_key=java%3AS6104'>S6104</a> - Map \"computeIfAbsent()\"와 \"computeIfPresent()\"를 사용하여 \"null\" 값을 추가하면 안 됩니다. </li>\n</ul>"
  },
  {
    "id": "S3577",
    "key": "java:S3577",
    "name": "Test classes should comply with a naming convention",
    "type": "code-smell",
    "severity": "minor",
    "tags": [
      "convention",
      "tests"
    ],
    "why": "<p>Shared naming conventions allow teams to collaborate efficiently. This rule raises an issue when a test class name does not match the provided\nregular expression.</p>\n<h3>Noncompliant code example</h3>\n<p>With the default value: <code>^((Test|IT)[a-zA-Z0-9_]+|[A-Z][a-zA-Z0-9_]*(Test|Tests|TestCase|IT|ITCase))$</code></p>\n<pre>\nclass Foo {  // Noncompliant\n  @Test\n  void check() {  }\n}\n\nclass Bar {  // Noncompliant\n  @Nested\n  class PositiveCase {\n    @Test\n    void check() {  }\n  }\n}\n</pre>\n<h3>Compliant solution</h3>\n<pre>\nclass FooTest {\n  @Test\n  void check() {  }\n}\n\nclass BarIT {\n  @Nested\n  class PositiveCase {\n    @Test\n    void check() {  }\n  }\n}\n</pre>",
    "howToFix": "",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "테스트 클래스는 명명 규칙을 준수해야 합니다",
    "why_ko": "<p>공유된 명명 규칙을 통해 팀이 효율적으로 협업할 수 있습니다. 이 규칙은 테스트 클래스 이름이 제공된 정규 표현식과 일치하지 않을 때 문제를 제기합니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<p>기본값: <code>^((Test|IT)[a-zA-Z0-9_]+|[A-Z][a-zA-Z0-9_]*(Test|Tests|TestCase|IT|ITCase))$</code></p>\n<pre>\nclass Foo {  // 규칙 위반\n  @Test\n  void check() {  }\n}\n\nclass Bar {  // 규칙 위반\n  @Nested\n  class PositiveCase {\n    @Test\n    void check() {  }\n  }\n}\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre>\nclass FooTest {\n  @Test\n  void check() {  }\n}\n\nclass BarIT {\n  @Nested\n  class PositiveCase {\n    @Test\n    void check() {  }\n  }\n}\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": ""
  },
  {
    "id": "S4174",
    "key": "java:S4174",
    "name": "Local constants should follow naming conventions for constants",
    "type": "code-smell",
    "severity": "minor",
    "tags": [
      "convention"
    ],
    "why": "<p>Shared coding conventions allow teams to collaborate efficiently. This rule checks that all local, <code>final</code>, initialized, primitive\nvariables, have names that match a provided regular expression.</p>\n<h3>Noncompliant code example</h3>\n<p>With the default regular expression <code>^[A-Z][A-Z0-9]*(_[A-Z0-9]+)*$</code>:</p>\n<pre>\npublic void doSomething() {\n  final int local = 42;\n  ...\n}\n</pre>\n<h3>Compliant solution</h3>\n<pre>\npublic void doSomething() {\n  final int LOCAL = 42;\n  ...\n}\n</pre>",
    "howToFix": "",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "지역 상수는 상수 명명 규칙을 따라야 합니다",
    "why_ko": "<p>공유 코딩 규칙을 통해 팀이 효율적으로 협업할 수 있습니다. 이 규칙은 모든 지역 <code>final</code> 초기화된 기본 변수가 제공된 정규식과 일치하는 이름을 가지는지 확인합니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<p>기본 정규식 <code>^[A-Z][A-Z0-9]*(_[A-Z0-9]+)*$</code>를 사용한 경우:</p>\n<pre>\npublic void doSomething() {\n  final int local = 42;\n  ...\n}\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre>\npublic void doSomething() {\n  final int LOCAL = 42;\n  ...\n}\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": ""
  },
  {
    "id": "S4524",
    "key": "java:S4524",
    "name": "\"default\" clauses should be last",
    "type": "code-smell",
    "severity": "critical",
    "tags": [],
    "why": "<p><code>switch</code> can contain a <code>default</code> clause for various reasons: to handle unexpected values, to show that all the cases were\nproperly considered, etc.</p>\n<p>For readability purposes, to help a developer quickly spot the default behavior of a <code>switch</code> statement, it is recommended to put the\n<code>default</code> clause at the end of the <code>switch</code> statement.</p>\n<p>This rule raises an issue if the <code>default</code> clause is not the last one of the <code>switch</code>'s cases.</p>\n<pre>\nswitch (param) {\n  case 0:\n    doSomething();\n    break;\n  default: // Noncompliant: default clause should be the last one\n    error();\n    break;\n  case 1:\n    doSomethingElse();\n    break;\n}\n</pre>",
    "howToFix": "",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "\"default\" 절은 마지막에 위치해야 합니다",
    "why_ko": "<p><code>switch</code>는 예상치 못한 값을 처리하거나, 모든 경우가 적절하게 고려되었음을 보여주는 등 다양한 이유로 <code>default</code> 절을 포함할 수 있습니다.</p>\n<p>가독성을 위해 개발자가 <code>switch</code> 문의 기본 동작을 빠르게 파악할 수 있도록 <code>default</code> 절을 <code>switch</code> 문의 끝에 배치하는 것이 권장됩니다.</p>\n<p>이 규칙은 <code>default</code> 절이 <code>switch</code> case들 중 마지막이 아닌 경우 문제를 제기합니다.</p>\n<pre>\nswitch (param) {\n  case 0:\n    doSomething();\n    break;\n  default: // 규칙 위반: default 절은 마지막에 있어야 함\n    error();\n    break;\n  case 1:\n    doSomethingElse();\n    break;\n}\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": ""
  },
  {
    "id": "S2274",
    "key": "java:S2274",
    "name": "\"Object.wait(...)\" and \"Condition.await(...)\" should be called inside a \"while\" loop",
    "type": "code-smell",
    "severity": "critical",
    "tags": [
      "multi-threading",
      "cert"
    ],
    "why": "<p>In a multithreaded environment, the <code>Object.wait(…​)</code>, as well as <code>Condition.await(…​)</code> and similar methods are used to pause\nthe execution of a thread until the thread is awakened. A thread is typically awakened when it is notified, signaled, or interrupted, usually because\nof an event in another thread requiring some subsequent action by the waiting thread.</p>\n<p>However, a thread may be awakened despite the desired condition not being met or the desired event not having happened. This is referred to as\n\"spurious wakeups\" and may be caused by underlying platform semantics. In other words, a thread may be awakened due to reasons that have nothing to do\nwith the business logic. Hence, the assumption that the desired condition is met or the desired event occurred after a thread is awakened does not\nalways hold.</p>\n<p>According to the documentation of the Java <code>Condition</code> interface [1]:</p>\n<blockquote>\n  <p>When waiting upon a <code>Condition</code>, a \"spurious wakeup\" is permitted to occur, in general, as a concession to the underlying platform\n  semantics. This has little practical impact on most application programs as a Condition should always be waited upon in a loop, testing the state\n  predicate that is being waited for. An implementation is free to remove the possibility of spurious wakeups but it is recommended that applications\n  programmers always assume that they can occur and so always wait in a loop.</p>\n</blockquote>\n<p>The same advice is also found for the <code>Object.wait(…​)</code> method [2]:</p>\n<blockquote>\n  <p>[…​] waits should always occur in loops, like this one:</p>\n  <pre>\nsynchronized (obj) {\n  while (&lt;condition does not hold&gt;){\n    obj.wait(timeout);\n  }\n   ... // Perform action appropriate to condition\n}\n</pre>\n</blockquote>",
    "howToFix": "<p>Make sure that the desired condition is actually true after being awakened. This can be accomplished by calling the <code>wait</code> or\n<code>await</code> methods inside a loop that checks said condition.</p>\n\n<h4>Noncompliant code example</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\nsynchronized (obj) {\n  if (!suitableCondition()){\n    obj.wait(timeout); // Noncompliant, the thread can be awakened even though the condition is still false\n  }\n   ... // Perform some logic that is appropriate for when the condition is true\n}\n</pre>\n<h4>Compliant solution</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\nsynchronized (obj) {\n  while (!suitableCondition()){\n    obj.wait(timeout); // Compliant, the condition is checked in a loop, so the action below will only occur if the condition is true\n  }\n   ... // Perform some logic that is appropriate for when the condition is true\n}\n</pre>",
    "moreInfo": "<ol>\n  <li> <a href=\"https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/concurrent/locks/Condition.html\">Java SE 17 &amp; JDK 17</a> -\n  Condition </li>\n  <li> <a href=\"https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html#wait--\">Java Platform SE 8</a> - Object#wait </li>\n  <li> <a href=\"https://wiki.sei.cmu.edu/confluence/x/EzdGBQ\">CERT THI03-J.</a> - Always invoke wait() and await() methods inside a loop </li>\n</ol>",
    "status": "READY",
    "name_ko": "\"Object.wait(...)\"와 \"Condition.await(...)\"는 \"while\" 루프 안에서 호출해야 합니다",
    "why_ko": "<p>멀티스레드 환경에서 <code>Object.wait(…​)</code>, <code>Condition.await(…​)</code> 및 유사한 메서드는 스레드가 깨어날 때까지 스레드 실행을 일시 중지하는 데 사용됩니다. 스레드는 일반적으로 다른 스레드에서 대기 중인 스레드의 후속 작업이 필요한 이벤트로 인해 통지, 신호 또는 인터럽트될 때 깨어납니다.</p>\n<p>그러나 원하는 조건이 충족되지 않거나 원하는 이벤트가 발생하지 않았음에도 불구하고 스레드가 깨어날 수 있습니다. 이를 \"가짜 깨움(spurious wakeups)\"이라고 하며 기본 플랫폼 의미론에 의해 발생할 수 있습니다. 즉, 스레드는 비즈니스 로직과 관련이 없는 이유로 깨어날 수 있습니다. 따라서 스레드가 깨어난 후 원하는 조건이 충족되었거나 원하는 이벤트가 발생했다는 가정이 항상 유효하지는 않습니다.</p>\n<p>Java <code>Condition</code> 인터페이스 문서에 따르면 [1]:</p>\n<blockquote>\n  <p><code>Condition</code>을 기다릴 때 일반적으로 기본 플랫폼 의미론에 대한 양보로 \"가짜 깨움\"이 발생할 수 있습니다. Condition은 항상 루프에서 대기하면서 기다리는 상태 조건을 테스트해야 하므로 대부분의 애플리케이션 프로그램에는 실질적인 영향이 거의 없습니다. 구현은 가짜 깨움의 가능성을 제거할 수 있지만 애플리케이션 프로그래머는 항상 가짜 깨움이 발생할 수 있다고 가정하고 항상 루프에서 대기하는 것이 좋습니다.</p>\n</blockquote>\n<p><code>Object.wait(…​)</code> 메서드에 대해서도 동일한 조언이 있습니다 [2]:</p>\n<blockquote>\n  <p>[…​] 대기는 항상 다음과 같이 루프에서 발생해야 합니다:</p>\n  <pre>\nsynchronized (obj) {\n  while (&lt;조건이 충족되지 않음&gt;){\n    obj.wait(timeout);\n  }\n   ... // 조건에 적합한 작업 수행\n}\n</pre>\n</blockquote>",
    "howToFix_ko": "<p>깨어난 후 원하는 조건이 실제로 참인지 확인하세요. 이는 해당 조건을 확인하는 루프 내에서 <code>wait</code> 또는 <code>await</code> 메서드를 호출하여 수행할 수 있습니다.</p>\n\n<h4>규칙을 준수하지 않는 코드 예시</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\nsynchronized (obj) {\n  if (!suitableCondition()){\n    obj.wait(timeout); // 규칙 위반, 조건이 여전히 거짓임에도 스레드가 깨어날 수 있음\n  }\n   ... // 조건이 참일 때 적합한 로직 수행\n}\n</pre>\n<h4>규칙을 준수하는 해결책</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\nsynchronized (obj) {\n  while (!suitableCondition()){\n    obj.wait(timeout); // 규칙 준수, 조건이 루프에서 확인되므로 아래 작업은 조건이 참일 때만 발생함\n  }\n   ... // 조건이 참일 때 적합한 로직 수행\n}\n</pre>",
    "moreInfo_ko": "<ol>\n  <li> <a href=\"https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/concurrent/locks/Condition.html\">Java SE 17 &amp; JDK 17</a> - Condition </li>\n  <li> <a href=\"https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html#wait--\">Java Platform SE 8</a> - Object#wait </li>\n  <li> <a href=\"https://wiki.sei.cmu.edu/confluence/x/EzdGBQ\">CERT THI03-J.</a> - 항상 wait()와 await() 메서드를 루프 안에서 호출하세요 </li>\n</ol>"
  },
  {
    "id": "S2761",
    "key": "java:S2761",
    "name": "Unary prefix operators should not be repeated",
    "type": "bug",
    "severity": "major",
    "tags": [],
    "why": "<p>The repetition of a unary operator is usually a typo. The second operator invalidates the first one in most cases:</p>\n<pre>\nint i = 1;\n\nint j = - - -i;  // Noncompliant: equivalent to \"-i\"\nint k = ~~~i;    // Noncompliant: equivalent to \"~i\"\nint m = + +i;    // Noncompliant: equivalent to \"i\"\n\nboolean b = false;\nboolean c = !!!b;   // Noncompliant\n</pre>\n<p>On the other hand, while repeating the increment and decrement operators is technically correct, it obfuscates the meaning:</p>\n<pre>\nint i = 1;\nint j = ++ ++i;  // Noncompliant\nint k = i-- --; // Noncompliant\n</pre>\n<p>Using <code>+=</code> or <code>-=</code> improves readability:</p>\n<pre>\nint i = 1;\ni += 2;\nint j = i;\nint k = i;\ni -=2;\n</pre>\n<p>This rule raises an issue for repetitions of <code>!</code>, <code>~</code>, <code>-</code>, <code>+</code>, prefix increments <code>++</code> and\nprefix decrements <code>--</code>.</p>\n<h3>Exceptions</h3>\n<p>Overflow handling for GWT compilation using <code>~~</code> is ignored.</p>",
    "howToFix": "",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "단항 전위 연산자를 반복하면 안 됩니다",
    "why_ko": "<p>단항 연산자의 반복은 보통 오타입니다. 대부분의 경우 두 번째 연산자가 첫 번째 연산자를 무효화합니다:</p>\n<pre>\nint i = 1;\n\nint j = - - -i;  // 규칙 위반: \"-i\"와 동일\nint k = ~~~i;    // 규칙 위반: \"~i\"와 동일\nint m = + +i;    // 규칙 위반: \"i\"와 동일\n\nboolean b = false;\nboolean c = !!!b;   // 규칙 위반\n</pre>\n<p>반면에, 증가 및 감소 연산자를 반복하는 것은 기술적으로는 올바르지만 의미를 모호하게 합니다:</p>\n<pre>\nint i = 1;\nint j = ++ ++i;  // 규칙 위반\nint k = i-- --; // 규칙 위반\n</pre>\n<p><code>+=</code> 또는 <code>-=</code>를 사용하면 가독성이 향상됩니다:</p>\n<pre>\nint i = 1;\ni += 2;\nint j = i;\nint k = i;\ni -=2;\n</pre>\n<p>이 규칙은 <code>!</code>, <code>~</code>, <code>-</code>, <code>+</code>, 전위 증가 <code>++</code> 및 전위 감소 <code>--</code>의 반복에 대해 문제를 제기합니다.</p>\n<h3>예외</h3>\n<p><code>~~</code>를 사용한 GWT 컴파일의 오버플로 처리는 무시됩니다.</p>",
    "howToFix_ko": "",
    "moreInfo_ko": ""
  },
  {
    "id": "S1264",
    "key": "java:S1264",
    "name": "A \"while\" loop should be used instead of a \"for\" loop",
    "type": "code-smell",
    "severity": "minor",
    "tags": [
      "clumsy"
    ],
    "why": "<p>A <code>for</code> loop is a type of loop construct that allows a block of code to be executed repeatedly for a fixed number of times. The\n<code>for</code> loop is typically used when the number of iterations is known in advance and consists of three parts:</p>\n<ul>\n  <li> The initialization statement is executed once at the beginning of the loop. It is used to initialize the loop counter or any other variables\n  that may be used in the loop. </li>\n  <li> The loop condition is evaluated at the beginning of each iteration, and if it is <code>true</code>, the code inside the loop is executed. </li>\n  <li> The update statement is executed at the end of each iteration and is used to update the loop counter or any other variables that may be used in\n  the loop. </li>\n</ul>\n<pre>\nfor (initialization; termination; increment) { /*...*/ }\n</pre>\n<p>All three statements are optional. However, when the initialization and update statements are not used, it can be unclear to the reader what the\nloop counter is and how it is being updated. This can make the code harder to understand and maintain.</p>",
    "howToFix": "<h4>Noncompliant code example</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\nfor (;condition;) { /*...*/ } // Noncompliant; only the condition is specified\n</pre>\n<p>When only the condition expression is defined in a <code>for</code> loop, a <code>while</code> loop should be used instead to increase readability.\nA <code>while</code> loop consists of a single loop condition and allows a block of code to be executed repeatedly as long as the specified condition\nis true.</p>\n<h4>Compliant solution</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\nwhile (condition) { /*...*/ }\n</pre>",
    "moreInfo": "<ul>\n  <li> <a href=\"https://docs.oracle.com/javase/tutorial/java/nutsandbolts/for.html\">Java SE - The for Statement</a> </li>\n</ul>",
    "status": "READY",
    "name_ko": "\"for\" 루프 대신 \"while\" 루프를 사용해야 합니다",
    "why_ko": "<p><code>for</code> 루프는 코드 블록을 고정된 횟수만큼 반복적으로 실행할 수 있게 해주는 루프 구조입니다. <code>for</code> 루프는 일반적으로 반복 횟수가 미리 알려져 있을 때 사용되며 세 부분으로 구성됩니다:</p>\n<ul>\n  <li> 초기화 문은 루프 시작 시 한 번 실행됩니다. 루프 카운터나 루프에서 사용될 수 있는 다른 변수들을 초기화하는 데 사용됩니다. </li>\n  <li> 루프 조건은 각 반복 시작 시 평가되며, <code>true</code>이면 루프 내부의 코드가 실행됩니다. </li>\n  <li> 업데이트 문은 각 반복 끝에 실행되며 루프 카운터나 루프에서 사용될 수 있는 다른 변수들을 업데이트하는 데 사용됩니다. </li>\n</ul>\n<pre>\nfor (초기화; 종료조건; 증가) { /*...*/ }\n</pre>\n<p>세 문장 모두 선택 사항입니다. 그러나 초기화와 업데이트 문이 사용되지 않으면 독자에게 루프 카운터가 무엇이고 어떻게 업데이트되는지 불명확할 수 있습니다. 이로 인해 코드를 이해하고 유지 관리하기 어려워질 수 있습니다.</p>",
    "howToFix_ko": "<h4>규칙을 준수하지 않는 코드 예시</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\nfor (;condition;) { /*...*/ } // 규칙 위반; 조건만 지정됨\n</pre>\n<p><code>for</code> 루프에서 조건 표현식만 정의된 경우, 가독성을 높이기 위해 <code>while</code> 루프를 대신 사용해야 합니다. <code>while</code> 루프는 단일 루프 조건으로 구성되며 지정된 조건이 true인 한 코드 블록을 반복적으로 실행할 수 있게 합니다.</p>\n<h4>규칙을 준수하는 해결책</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\nwhile (condition) { /*...*/ }\n</pre>",
    "moreInfo_ko": "<ul>\n  <li> <a href=\"https://docs.oracle.com/javase/tutorial/java/nutsandbolts/for.html\">Java SE - for 문</a> </li>\n</ul>"
  },
  {
    "id": "S6539",
    "key": "java:S6539",
    "name": "Classes should not depend on an excessive number of classes (aka Monster Class)",
    "type": "code-smell",
    "severity": "info",
    "tags": [
      "design"
    ],
    "why": "<p>Monster Classes become monolithic entities, with numerous responsibilities and functionalities packed into a single class. This is problematic\nbecause it violates the Single Responsibility Principle, which states that a class should have only one reason to change.</p>\n<p>When a class has too many responsibilities and functionalities, it becomes difficult to maintain. Changes to one part of the class can\nunintentionally affect other parts, leading to bugs. Additionally, it can be difficult to test the class, as there may be many different interactions\nbetween different parts of the class that need to be considered.</p>",
    "howToFix": "<p>There is no magical recipe. Monster Classes should be refactored and broken into smaller, more focused classes, each one with a single\nresponsibility. When a class has only one responsibility, it is easier to reason about its behavior and to make changes to it without affecting other\nparts of the code.</p>\n\n<h4>Noncompliant code example</h4>\n<p>With a threshold of 5:</p>\n<pre>\nclass Foo { // class Foo depends on too many classes: T1, T2, T3, T4, T5, T6 and T7\n  T1 t1;\n  T2 t2;\n  T3 t3;\n\n  public T4 compute(T5 a, T6 b) {\n    T7 result = a.getResult(b);\n    return (T4) result;\n  }\n}\n</pre>\n<h4>Compliant solution</h4>\n<pre>\npublic class Bar {\n    T8 a8;\n    T9 a9;\n}\n</pre>",
    "moreInfo": "<h3>Articles &amp; blog posts</h3>\n<ul>\n  <li> <a href=\"https://blog.cleancoder.com/uncle-bob/2014/05/08/SingleReponsibilityPrinciple.html\">Single Responsibility Principle (aka SRP)</a>\n  </li>\n  <li> <a href=\"https://en.wikipedia.org/wiki/SOLID\">SOLID</a> </li>\n</ul>",
    "status": "BETA",
    "name_ko": "클래스는 과도한 수의 클래스에 의존하면 안 됩니다 (Monster Class)",
    "why_ko": "<p>Monster 클래스는 하나의 클래스에 수많은 책임과 기능이 담긴 단일체 엔티티가 됩니다. 이것은 클래스가 변경해야 하는 이유가 하나만 있어야 한다고 명시하는 단일 책임 원칙을 위반하기 때문에 문제가 됩니다.</p>\n<p>클래스에 너무 많은 책임과 기능이 있으면 유지 관리가 어려워집니다. 클래스의 한 부분에 대한 변경이 의도치 않게 다른 부분에 영향을 미쳐 버그가 발생할 수 있습니다. 또한 고려해야 할 클래스의 여러 부분 간의 다양한 상호 작용이 있을 수 있으므로 클래스를 테스트하기 어려울 수 있습니다.</p>",
    "howToFix_ko": "<p>마법 같은 레시피는 없습니다. Monster 클래스는 리팩토링하여 각각 단일 책임을 가진 더 작고 집중된 클래스로 분리해야 합니다. 클래스에 하나의 책임만 있으면 동작에 대해 추론하기 쉽고 코드의 다른 부분에 영향을 주지 않고 변경하기가 더 쉽습니다.</p>\n\n<h4>규칙을 준수하지 않는 코드 예시</h4>\n<p>임계값이 5인 경우:</p>\n<pre>\nclass Foo { // Foo 클래스는 너무 많은 클래스에 의존합니다: T1, T2, T3, T4, T5, T6, T7\n  T1 t1;\n  T2 t2;\n  T3 t3;\n\n  public T4 compute(T5 a, T6 b) {\n    T7 result = a.getResult(b);\n    return (T4) result;\n  }\n}\n</pre>\n<h4>규칙을 준수하는 해결책</h4>\n<pre>\npublic class Bar {\n    T8 a8;\n    T9 a9;\n}\n</pre>",
    "moreInfo_ko": "<h3>기사 및 블로그 게시물</h3>\n<ul>\n  <li> <a href=\"https://blog.cleancoder.com/uncle-bob/2014/05/08/SingleReponsibilityPrinciple.html\">단일 책임 원칙 (SRP)</a> </li>\n  <li> <a href=\"https://en.wikipedia.org/wiki/SOLID\">SOLID</a> </li>\n</ul>"
  },
  {
    "id": "S6885",
    "key": "java:S6885",
    "name": "Use built-in \"Math.clamp\" methods",
    "type": "code-smell",
    "severity": "major",
    "tags": [
      "java21"
    ],
    "why": "<p>In Java 21 the <code>java.lang.Math</code> class was updated with the static method <code>Math.clamp</code>, to clamp a numerical value between a\nmin and a max value.</p>\n<p>Using this built-in method is now the preferred way to restrict to a given interval, as it is more readable and less error-prone.</p>",
    "howToFix": "<p>Replace your clamp method implementation with the <code>Math.clamp</code> method.</p>\n\n<h4>Noncompliant code example</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\nint clampedValue = value &gt; max ? max : value &lt; min ? min : value; // Noncompliant; Replace with \"Math.clamp\"\n</pre>\n<pre data-diff-id=\"2\" data-diff-type=\"noncompliant\">\nint clampedValue = Math.max(min, Math.min(max, value)); // Noncompliant; Replace with \"Math.clamp\"\n</pre>\n<h4>Compliant solution</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\nint clampedValue = Math.clamp(value, min, max);\n</pre>\n<pre data-diff-id=\"2\" data-diff-type=\"compliant\">\nint clampedValue = Math.clamp(value, min, max);\n</pre>",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "내장 \"Math.clamp\" 메서드를 사용하세요",
    "why_ko": "<p>Java 21에서 <code>java.lang.Math</code> 클래스가 숫자 값을 최소값과 최대값 사이로 제한하는 정적 메서드 <code>Math.clamp</code>로 업데이트되었습니다.</p>\n<p>이 내장 메서드를 사용하는 것이 이제 주어진 구간으로 제한하는 선호되는 방법입니다. 더 읽기 쉽고 오류가 발생하기 어렵기 때문입니다.</p>",
    "howToFix_ko": "<p>클램프 메서드 구현을 <code>Math.clamp</code> 메서드로 교체하세요.</p>\n\n<h4>규칙을 준수하지 않는 코드 예시</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\nint clampedValue = value &gt; max ? max : value &lt; min ? min : value; // 규칙 위반; \"Math.clamp\"로 교체하세요\n</pre>\n<pre data-diff-id=\"2\" data-diff-type=\"noncompliant\">\nint clampedValue = Math.max(min, Math.min(max, value)); // 규칙 위반; \"Math.clamp\"로 교체하세요\n</pre>\n<h4>규칙을 준수하는 해결책</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\nint clampedValue = Math.clamp(value, min, max);\n</pre>\n<pre data-diff-id=\"2\" data-diff-type=\"compliant\">\nint clampedValue = Math.clamp(value, min, max);\n</pre>",
    "moreInfo_ko": ""
  },
  {
    "id": "S1213",
    "key": "java:S1213",
    "name": "The members of an interface or class declaration should appear in a pre-defined order",
    "type": "code-smell",
    "severity": "minor",
    "tags": [
      "convention"
    ],
    "why": "<p>According to the Java Code Conventions as defined by Oracle, the members of a class or interface declaration should appear in the following order\nin the source files:</p>\n<ul>\n  <li> Class variables </li>\n  <li> Instance variables </li>\n  <li> Constructors </li>\n  <li> Methods </li>\n</ul>\n<h3>Noncompliant code example</h3>\n<pre>\npublic class Foo{\n   private int field = 0;\n   public boolean isTrue() {...}\n   public Foo() {...}                         // Noncompliant, constructor defined after methods\n   public static final int OPEN = 4;  //Noncompliant, variable defined after constructors and methods\n}\n</pre>\n<h3>Compliant solution</h3>\n<pre>\npublic class Foo{\n   public static final int OPEN = 4;\n   private int field = 0;\n   public Foo() {...}\n   public boolean isTrue() {...}\n}\n</pre>",
    "howToFix": "",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "인터페이스나 클래스 선언의 멤버는 사전 정의된 순서로 나타나야 합니다",
    "why_ko": "<p>Oracle이 정의한 Java 코드 규약에 따르면 클래스나 인터페이스 선언의 멤버는 소스 파일에서 다음 순서로 나타나야 합니다:</p>\n<ul>\n  <li> 클래스 변수 </li>\n  <li> 인스턴스 변수 </li>\n  <li> 생성자 </li>\n  <li> 메서드 </li>\n</ul>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\npublic class Foo{\n   private int field = 0;\n   public boolean isTrue() {...}\n   public Foo() {...}                         // 규칙 위반, 메서드 뒤에 생성자가 정의됨\n   public static final int OPEN = 4;  // 규칙 위반, 생성자와 메서드 뒤에 변수가 정의됨\n}\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre>\npublic class Foo{\n   public static final int OPEN = 4;\n   private int field = 0;\n   public Foo() {...}\n   public boolean isTrue() {...}\n}\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": ""
  },
  {
    "id": "S4011",
    "key": "java:S4011",
    "name": "Track uses of disallowed constructors",
    "type": "code-smell",
    "severity": "major",
    "tags": [],
    "why": "<p>This rule allows banning usage of certain constructors.</p>\n<h3>Noncompliant code example</h3>\n<p>Given parameters:</p>\n<ul>\n  <li> className: java.util.Date </li>\n  <li> argumentTypes: java.lang.String </li>\n</ul>\n<pre>\nDate birthday;\nbirthday = new Date(\"Sat Sep 27 05:42:21 EDT 1986\");  // Noncompliant\nbirthday = new Date(528176541000L); // Compliant\n</pre>",
    "howToFix": "",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "허용되지 않는 생성자 사용을 추적해야 합니다",
    "why_ko": "<p>이 규칙은 특정 생성자의 사용을 금지할 수 있게 합니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<p>주어진 매개변수:</p>\n<ul>\n  <li> className: java.util.Date </li>\n  <li> argumentTypes: java.lang.String </li>\n</ul>\n<pre>\nDate birthday;\nbirthday = new Date(\"Sat Sep 27 05:42:21 EDT 1986\");  // 규칙 위반\nbirthday = new Date(528176541000L); // 규칙 준수\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": ""
  },
  {
    "id": "S1643",
    "key": "java:S1643",
    "name": "Strings should not be concatenated using '+' in a loop",
    "type": "code-smell",
    "severity": "minor",
    "tags": [
      "performance"
    ],
    "why": "<p>Strings are immutable objects, so concatenation doesn't simply add the new String to the end of the existing string. Instead, in each loop\niteration, the first String is converted to an intermediate object type, the second string is appended, and then the intermediate object is converted\nback to a String. Further, performance of these intermediate operations degrades as the String gets longer. Therefore, the use of StringBuilder is\npreferred.</p>\n<h3>Noncompliant code example</h3>\n<pre>\nString str = \"\";\nfor (int i = 0; i &lt; arrayOfStrings.length ; ++i) {\n  str = str + arrayOfStrings[i];\n}\n</pre>\n<h3>Compliant solution</h3>\n<pre>\nStringBuilder bld = new StringBuilder();\n  for (int i = 0; i &lt; arrayOfStrings.length; ++i) {\n    bld.append(arrayOfStrings[i]);\n  }\n  String str = bld.toString();\n</pre>",
    "howToFix": "",
    "moreInfo": "<h3>Benchmarks</h3>\n<table>\n  <colgroup>\n    <col style=\"width: 20%;\">\n    <col style=\"width: 20%;\">\n    <col style=\"width: 20%;\">\n    <col style=\"width: 20%;\">\n    <col style=\"width: 20%;\">\n  </colgroup>\n  <thead>\n    <tr>\n      <th>Method</th>\n      <th>size</th>\n      <th>Runtime</th>\n      <th>Average time</th>\n      <th>Error margin</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td><p>plus</p></td>\n      <td><p>100</p></td>\n      <td><p>Temurin 21</p></td>\n      <td><p>4.19 µs/op</p></td>\n      <td><p>±0.34 µs/op</p></td>\n    </tr>\n    <tr>\n      <td><p>plus</p></td>\n      <td><p>1000</p></td>\n      <td><p>Temurin 21</p></td>\n      <td><p>377.08 µs/op</p></td>\n      <td><p>±17.36 µs/op</p></td>\n    </tr>\n    <tr>\n      <td><p>plus</p></td>\n      <td><p>10000</p></td>\n      <td><p>Temurin 21</p></td>\n      <td><p>40221.49 µs/op</p></td>\n      <td><p>±1342.76 µs/op</p></td>\n    </tr>\n    <tr>\n      <td><p>plus</p></td>\n      <td><p>100000</p></td>\n      <td><p>Temurin 21</p></td>\n      <td><p>5286840.53 µs/op</p></td>\n      <td><p>±185796.75 µs/op</p></td>\n    </tr>\n    <tr>\n      <td><p>stringBuilder</p></td>\n      <td><p>100</p></td>\n      <td><p>Temurin 21</p></td>\n      <td><p>0.97 µs/op</p></td>\n      <td><p>±0.03 µs/op</p></td>\n    </tr>\n    <tr>\n      <td><p>stringBuilder</p></td>\n      <td><p>1000</p></td>\n      <td><p>Temurin 21</p></td>\n      <td><p>10.25 µs/op</p></td>\n      <td><p>±1.64 µs/op</p></td>\n    </tr>\n    <tr>\n      <td><p>stringBuilder</p></td>\n      <td><p>10000</p></td>\n      <td><p>Temurin 21</p></td>\n      <td><p>93.27 µs/op</p></td>\n      <td><p>±16.05 µs/op</p></td>\n    </tr>\n    <tr>\n      <td><p>stringBuilder</p></td>\n      <td><p>100000</p></td>\n      <td><p>Temurin 21</p></td>\n      <td><p>1019.91 µs/op</p></td>\n      <td><p>±69.58 µs/op</p></td>\n    </tr>\n  </tbody>\n</table>\n<p><strong>Benchmarking code</strong></p>\n<p>The results were generated by running the following snippet with <a href=\"https://github.com/openjdk/jmh\">JMH</a>.</p>\n<pre>\n@Param({\"100\", \"1000\", \"10000\", \"100000\"})\nint size;\nprivate String word = \"append\";\n\n@Benchmark\npublic String plus() {\n  String str = \"\";\n  for (int i = 0; i &lt; size; i++) {\n    str = str + word;\n  }\n  return str;\n}\n\n@Benchmark\npublic String stringBuilder() {\n  StringBuilder builder = new StringBuilder();\n  for (int i = 0; i &lt; size; i++) {\n    builder.append(word);\n  }\n  return builder.toString();\n}\n</pre>",
    "status": "READY",
    "name_ko": "루프 내에서 '+' 연산자로 문자열을 연결하면 안 됩니다",
    "why_ko": "<p>문자열은 불변 객체이므로 연결 연산은 단순히 기존 문자열 끝에 새 문자열을 추가하지 않습니다. 대신 각 루프 반복에서 첫 번째 문자열이 중간 객체 타입으로 변환되고 두 번째 문자열이 추가된 다음 중간 객체가 다시 문자열로 변환됩니다. 또한 이러한 중간 연산의 성능은 문자열이 길어질수록 저하됩니다. 따라서 StringBuilder 사용이 선호됩니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\nString str = \"\";\nfor (int i = 0; i &lt; arrayOfStrings.length ; ++i) {\n  str = str + arrayOfStrings[i];\n}\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre>\nStringBuilder bld = new StringBuilder();\n  for (int i = 0; i &lt; arrayOfStrings.length; ++i) {\n    bld.append(arrayOfStrings[i]);\n  }\n  String str = bld.toString();\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": "<h3>벤치마크</h3>\n<table>\n  <colgroup>\n    <col style=\"width: 20%;\">\n    <col style=\"width: 20%;\">\n    <col style=\"width: 20%;\">\n    <col style=\"width: 20%;\">\n    <col style=\"width: 20%;\">\n  </colgroup>\n  <thead>\n    <tr>\n      <th>메서드</th>\n      <th>크기</th>\n      <th>런타임</th>\n      <th>평균 시간</th>\n      <th>오차 범위</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td><p>plus</p></td>\n      <td><p>100</p></td>\n      <td><p>Temurin 21</p></td>\n      <td><p>4.19 µs/op</p></td>\n      <td><p>±0.34 µs/op</p></td>\n    </tr>\n    <tr>\n      <td><p>plus</p></td>\n      <td><p>1000</p></td>\n      <td><p>Temurin 21</p></td>\n      <td><p>377.08 µs/op</p></td>\n      <td><p>±17.36 µs/op</p></td>\n    </tr>\n    <tr>\n      <td><p>plus</p></td>\n      <td><p>10000</p></td>\n      <td><p>Temurin 21</p></td>\n      <td><p>40221.49 µs/op</p></td>\n      <td><p>±1342.76 µs/op</p></td>\n    </tr>\n    <tr>\n      <td><p>plus</p></td>\n      <td><p>100000</p></td>\n      <td><p>Temurin 21</p></td>\n      <td><p>5286840.53 µs/op</p></td>\n      <td><p>±185796.75 µs/op</p></td>\n    </tr>\n    <tr>\n      <td><p>stringBuilder</p></td>\n      <td><p>100</p></td>\n      <td><p>Temurin 21</p></td>\n      <td><p>0.97 µs/op</p></td>\n      <td><p>±0.03 µs/op</p></td>\n    </tr>\n    <tr>\n      <td><p>stringBuilder</p></td>\n      <td><p>1000</p></td>\n      <td><p>Temurin 21</p></td>\n      <td><p>10.25 µs/op</p></td>\n      <td><p>±1.64 µs/op</p></td>\n    </tr>\n    <tr>\n      <td><p>stringBuilder</p></td>\n      <td><p>10000</p></td>\n      <td><p>Temurin 21</p></td>\n      <td><p>93.27 µs/op</p></td>\n      <td><p>±16.05 µs/op</p></td>\n    </tr>\n    <tr>\n      <td><p>stringBuilder</p></td>\n      <td><p>100000</p></td>\n      <td><p>Temurin 21</p></td>\n      <td><p>1019.91 µs/op</p></td>\n      <td><p>±69.58 µs/op</p></td>\n    </tr>\n  </tbody>\n</table>\n<p><strong>벤치마킹 코드</strong></p>\n<p>결과는 <a href=\"https://github.com/openjdk/jmh\">JMH</a>를 사용하여 다음 스니펫을 실행하여 생성되었습니다.</p>\n<pre>\n@Param({\"100\", \"1000\", \"10000\", \"100000\"})\nint size;\nprivate String word = \"append\";\n\n@Benchmark\npublic String plus() {\n  String str = \"\";\n  for (int i = 0; i &lt; size; i++) {\n    str = str + word;\n  }\n  return str;\n}\n\n@Benchmark\npublic String stringBuilder() {\n  StringBuilder builder = new StringBuilder();\n  for (int i = 0; i &lt; size; i++) {\n    builder.append(word);\n  }\n  return builder.toString();\n}\n</pre>"
  },
  {
    "id": "S3042",
    "key": "java:S3042",
    "name": "\"writeObject\" should not be the only \"synchronized\" code in a class",
    "type": "code-smell",
    "severity": "major",
    "tags": [
      "confusing"
    ],
    "why": "<p>Synchronization is a mechanism used when multithreading in Java to ensure that only one thread executes a given block of code at a time. This is\ndone to avoid bugs that can occur when multiple threads share a given state and try to manipulate simultaneously.</p>\n<p>Object serialization is not thread-safe by default. In a multithreaded environment, one option is to mark <code>writeObject</code> with\n<code>synchronized</code> to improve thread safety. It is highly suspicious, however, if <code>writeObject</code> is the only\n<code>synchronized</code> method in a class. It may indicate that serialization is not required, as multithreading is not used. Alternatively, it\ncould also suggest that other methods in the same class have been forgotten to be made thread-safe.</p>",
    "howToFix": "<p>Consider whether this class is used in a multithreaded context. If it is, ask yourself whether other methods in this class should also be marked as\n<code>synchronized</code>. Otherwise, remove the <code>synchronized</code> modifier from this method.</p>\n\n<h4>Noncompliant code example</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\npublic class RubberBall implements Serializable {\n\n  private Color color;\n  private int diameter;\n\n  public RubberBall(Color color, int diameter) {\n    // ...\n  }\n\n  public void bounce(float angle, float velocity) {\n    // ...\n  }\n\n  private synchronized void writeObject(ObjectOutputStream stream) throws IOException { // Noncompliant, \"writeObject\" is the only synchronized method in this class\n    // ...\n  }\n}\n</pre>\n<h4>Compliant solution</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\npublic class RubberBall implements Serializable {\n\n  private Color color;\n  private int diameter;\n\n  public RubberBall(Color color, int diameter) {\n    // ...\n  }\n\n  public void bounce(float angle, float velocity) {\n    // ...\n  }\n\n  private void writeObject(ObjectOutputStream stream) throws IOException { // Compliant, no methods in this class are synchronized\n    // ...\n  }\n}\n</pre>",
    "moreInfo": "<ul>\n  <li> <a href=\"https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/io/Serializable.html\">Java SE 17 &amp; JDK 17 - Serializable\n  Javadoc</a> </li>\n  <li> <a href=\"https://docs.oracle.com/javase/tutorial/essential/concurrency/syncmeth.html\">The Java™ Tutorials - Synchronized Methods</a> </li>\n</ul>",
    "status": "READY",
    "name_ko": "\"writeObject\"가 클래스에서 유일한 \"synchronized\" 코드가 되어서는 안 됩니다",
    "why_ko": "<p>동기화는 Java에서 멀티스레딩할 때 한 번에 하나의 스레드만 주어진 코드 블록을 실행하도록 보장하는 메커니즘입니다. 이는 여러 스레드가 주어진 상태를 공유하고 동시에 조작하려 할 때 발생할 수 있는 버그를 방지하기 위해 수행됩니다.</p>\n<p>객체 직렬화는 기본적으로 스레드 안전하지 않습니다. 멀티스레드 환경에서 스레드 안전성을 향상시키기 위한 한 가지 옵션은 <code>writeObject</code>를 <code>synchronized</code>로 표시하는 것입니다. 그러나 <code>writeObject</code>가 클래스에서 유일한 <code>synchronized</code> 메서드라면 매우 의심스럽습니다. 이는 멀티스레딩이 사용되지 않아 직렬화가 필요하지 않음을 나타낼 수 있습니다. 또는 동일한 클래스의 다른 메서드를 스레드 안전하게 만드는 것을 잊었다는 것을 암시할 수도 있습니다.</p>",
    "howToFix_ko": "<p>이 클래스가 멀티스레드 컨텍스트에서 사용되는지 고려하세요. 그렇다면 이 클래스의 다른 메서드도 <code>synchronized</code>로 표시해야 하는지 자문해 보세요. 그렇지 않으면 이 메서드에서 <code>synchronized</code> 수정자를 제거하세요.</p>\n\n<h4>규칙을 준수하지 않는 코드 예시</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\npublic class RubberBall implements Serializable {\n\n  private Color color;\n  private int diameter;\n\n  public RubberBall(Color color, int diameter) {\n    // ...\n  }\n\n  public void bounce(float angle, float velocity) {\n    // ...\n  }\n\n  private synchronized void writeObject(ObjectOutputStream stream) throws IOException { // 규칙 위반, \"writeObject\"는 이 클래스에서 유일한 synchronized 메서드입니다\n    // ...\n  }\n}\n</pre>\n<h4>규칙을 준수하는 해결책</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\npublic class RubberBall implements Serializable {\n\n  private Color color;\n  private int diameter;\n\n  public RubberBall(Color color, int diameter) {\n    // ...\n  }\n\n  public void bounce(float angle, float velocity) {\n    // ...\n  }\n\n  private void writeObject(ObjectOutputStream stream) throws IOException { // 규칙 준수, 이 클래스에는 synchronized 메서드가 없습니다\n    // ...\n  }\n}\n</pre>",
    "moreInfo_ko": "<ul>\n  <li> <a href=\"https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/io/Serializable.html\">Java SE 17 &amp; JDK 17 - Serializable Javadoc</a> </li>\n  <li> <a href=\"https://docs.oracle.com/javase/tutorial/essential/concurrency/syncmeth.html\">The Java™ Tutorials - Synchronized 메서드</a> </li>\n</ul>"
  },
  {
    "id": "S2203",
    "key": "java:S2203",
    "name": "\"collect\" should be used with \"Streams\" instead of \"list::add\"",
    "type": "code-smell",
    "severity": "minor",
    "tags": [
      "java8"
    ],
    "why": "<p>While you can use either <code>forEach(list::add)</code> or <code>collect</code> with a <code>Stream</code>, <code>collect</code> is by far the\nbetter choice because it's automatically thread-safe and parallellizable.</p>\n<h3>Noncompliant code example</h3>\n<pre>\nList&lt;String&gt; bookNames = new ArrayList&lt;&gt;();\nbooks.stream().filter(book -&gt; book.getIsbn().startsWith(\"0\"))\n                .map(Book::getTitle)\n                .forEach(bookNames::add);  // Noncompliant\n</pre>\n<h3>Compliant solution</h3>\n<pre>\nList&lt;String&gt; bookNames = books.stream().filter(book -&gt; book.getIsbn().startsWith(\"0\"))\n                .map(Book::getTitle)\n                .collect(Collectors.toList());\n</pre>",
    "howToFix": "",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "\"Streams\"에서는 \"list::add\" 대신 \"collect\"를 사용해야 합니다",
    "why_ko": "<p><code>Stream</code>에서 <code>forEach(list::add)</code>나 <code>collect</code>를 둘 다 사용할 수 있지만, <code>collect</code>가 자동으로 스레드 안전하고 병렬화 가능하기 때문에 훨씬 더 나은 선택입니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\nList&lt;String&gt; bookNames = new ArrayList&lt;&gt;();\nbooks.stream().filter(book -&gt; book.getIsbn().startsWith(\"0\"))\n                .map(Book::getTitle)\n                .forEach(bookNames::add);  // 규칙 위반\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre>\nList&lt;String&gt; bookNames = books.stream().filter(book -&gt; book.getIsbn().startsWith(\"0\"))\n                .map(Book::getTitle)\n                .collect(Collectors.toList());\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": ""
  },
  {
    "id": "S1751",
    "key": "java:S1751",
    "name": "Loops with at most one iteration should be refactored",
    "type": "bug",
    "severity": "major",
    "tags": [
      "bad-practice",
      "confusing"
    ],
    "why": "<p>A loop with at most one iteration is equivalent to an <code>if</code> statement. This can confuse developers and make the code less readable since\nloops are not meant to replace <code>if</code> statements.</p>\n<p>If the intention was to conditionally execute the block only once, an <code>if</code> statement should be used instead. Otherwise, the loop should\nbe fixed so the loop block can be executed multiple times.</p>\n<p>A loop statement with at most one iteration can happen when a statement that unconditionally transfers control, such as a jump or throw statement,\nis misplaced inside the loop block.</p>\n<p>This rule arises when the following statements are misplaced:</p>\n<ul>\n  <li> <code>break</code> </li>\n  <li> <code>return</code> </li>\n  <li> <code>throw</code> </li>\n</ul>",
    "howToFix": "<h4>Noncompliant code example</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\nint i = 0;\nwhile(i &lt; 10) { // Noncompliant; loop only executes once\n  System.out.println(\"i is \" + i);\n  i++;\n  break;\n}\n</pre>\n<pre data-diff-id=\"2\" data-diff-type=\"noncompliant\">\nfor (int i = 0; i &lt; 10; i++) { // Noncompliant; loop only executes once\n  if (i == x) {\n    break;\n  } else {\n    System.out.println(\"i is \" + i);\n    return;\n  }\n}\n</pre>\n<h4>Compliant solution</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\nint i = 0;\nwhile (i &lt; 10) {\n  System.out.println(\"i is \" + i);\n  i++;\n}\n</pre>\n<pre data-diff-id=\"2\" data-diff-type=\"compliant\">\nfor (int i = 0; i &lt; 10; i++) {\n  if (i == x) {\n    break;\n  } else {\n    System.out.println(\"i is \" + i);\n  }\n}\n</pre>",
    "moreInfo": "<h3>Documentation</h3>\n<ul>\n  <li> <a href=\"https://docs.oracle.com/javase/tutorial/java/nutsandbolts/for.html\">Oracle - The for Statement</a> </li>\n</ul>",
    "status": "READY",
    "name_ko": "최대 한 번만 반복하는 루프는 리팩토링해야 합니다",
    "why_ko": "<p>최대 한 번만 반복하는 루프는 <code>if</code> 문과 동일합니다. 루프는 <code>if</code> 문을 대체하기 위한 것이 아니므로 개발자를 혼란스럽게 하고 코드 가독성을 떨어뜨릴 수 있습니다.</p>\n<p>블록을 조건부로 한 번만 실행하려는 의도였다면 대신 <code>if</code> 문을 사용해야 합니다. 그렇지 않으면 루프 블록이 여러 번 실행될 수 있도록 루프를 수정해야 합니다.</p>\n<p>최대 한 번만 반복하는 루프 문은 점프나 throw 문과 같이 무조건적으로 제어를 전달하는 문이 루프 블록 내부에 잘못 배치되었을 때 발생할 수 있습니다.</p>\n<p>이 규칙은 다음 문이 잘못 배치되었을 때 발생합니다:</p>\n<ul>\n  <li> <code>break</code> </li>\n  <li> <code>return</code> </li>\n  <li> <code>throw</code> </li>\n</ul>",
    "howToFix_ko": "<h4>규칙을 준수하지 않는 코드 예시</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\nint i = 0;\nwhile(i &lt; 10) { // 규칙 위반; 루프가 한 번만 실행됨\n  System.out.println(\"i is \" + i);\n  i++;\n  break;\n}\n</pre>\n<pre data-diff-id=\"2\" data-diff-type=\"noncompliant\">\nfor (int i = 0; i &lt; 10; i++) { // 규칙 위반; 루프가 한 번만 실행됨\n  if (i == x) {\n    break;\n  } else {\n    System.out.println(\"i is \" + i);\n    return;\n  }\n}\n</pre>\n<h4>규칙을 준수하는 해결책</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\nint i = 0;\nwhile (i &lt; 10) {\n  System.out.println(\"i is \" + i);\n  i++;\n}\n</pre>\n<pre data-diff-id=\"2\" data-diff-type=\"compliant\">\nfor (int i = 0; i &lt; 10; i++) {\n  if (i == x) {\n    break;\n  } else {\n    System.out.println(\"i is \" + i);\n  }\n}\n</pre>",
    "moreInfo_ko": "<h3>문서</h3>\n<ul>\n  <li> <a href=\"https://docs.oracle.com/javase/tutorial/java/nutsandbolts/for.html\">Oracle - for 문</a> </li>\n</ul>"
  },
  {
    "id": "S1301",
    "key": "java:S1301",
    "name": "\"switch\" statements should have at least 3 \"case\" clauses",
    "type": "code-smell",
    "severity": "minor",
    "tags": [
      "bad-practice"
    ],
    "why": "<p><code>switch</code> statements are useful when there are many different cases depending on the value of the same expression.</p>\n<p>For just one or two cases, however, the code will be more readable with <code>if</code> statements.</p>\n<h3>Noncompliant code example</h3>\n<pre>\nswitch (variable) {\n  case 0:\n    doSomething();\n    break;\n  default:\n    doSomethingElse();\n    break;\n}\n</pre>\n<h3>Compliant solution</h3>\n<pre>\nif (variable == 0) {\n  doSomething();\n} else {\n  doSomethingElse();\n}\n</pre>",
    "howToFix": "",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "\"switch\" 문에는 최소 3개의 \"case\" 절이 있어야 합니다",
    "why_ko": "<p><code>switch</code> 문은 동일한 표현식의 값에 따라 여러 다른 경우가 있을 때 유용합니다.</p>\n<p>그러나 하나 또는 두 개의 경우만 있을 때는 <code>if</code> 문을 사용하는 것이 코드를 더 읽기 쉽게 만듭니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\nswitch (variable) {\n  case 0:\n    doSomething();\n    break;\n  default:\n    doSomethingElse();\n    break;\n}\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre>\nif (variable == 0) {\n  doSomething();\n} else {\n  doSomethingElse();\n}\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": ""
  },
  {
    "id": "S1244",
    "key": "java:S1244",
    "name": "Floating point numbers should not be tested for equality",
    "type": "bug",
    "severity": "major",
    "tags": [],
    "why": "<p>Floating point math is imprecise because of the challenges of storing such values in a binary representation. Even worse, floating point math is\nnot associative; push a <code>float</code> or a <code>double</code> through a series of simple mathematical operations and the answer will be\ndifferent based on the order of those operation because of the rounding that takes place at each step.</p>\n<p>Even simple floating point assignments are not simple:</p>\n<pre>\nfloat f = 0.1; // 0.100000001490116119384765625\ndouble d = 0.1; // 0.1000000000000000055511151231257827021181583404541015625\n</pre>\n<p>(Results will vary based on compiler and compiler settings);</p>\n<p>Therefore, the use of the equality (<code>==</code>) and inequality (<code>!=</code>) operators on <code>float</code> or <code>double</code> values\nis almost always an error. Instead the best course is to avoid floating point comparisons altogether. When that is not possible, you should consider\nusing one of Java's float-handling <code>Numbers</code> such as <code>BigDecimal</code> which can properly handle floating point comparisons. A third\noption is to look not for equality but for whether the value is close enough. I.e. compare the absolute value of the difference between the stored\nvalue and the expected value against a margin of acceptable error. Note that this does not cover all cases (<code>NaN</code> and <code>Infinity</code>\nfor instance).</p>\n<p>This rule checks for the use of direct and indirect equality/inequailty tests on floats and doubles.</p>\n<h3>Noncompliant code example</h3>\n<pre>\nfloat myNumber = 3.146;\nif ( myNumber == 3.146f ) { //Noncompliant. Because of floating point imprecision, this will be false\n  // ...\n}\nif ( myNumber != 3.146f ) { //Noncompliant. Because of floating point imprecision, this will be true\n  // ...\n}\n\nif (myNumber &lt; 4 || myNumber &gt; 4) { // Noncompliant; indirect inequality test\n  // ...\n}\n\nfloat zeroFloat = 0.0f;\nif (zeroFloat == 0) {  // Noncompliant. Computations may end up with a value close but not equal to zero.\n}\n</pre>\n<h3>Exceptions</h3>\n<p>Since <code>NaN</code> is not equal to itself, the specific case of testing a floating point value against itself is a valid test for\n<code>NaN</code> and is therefore ignored. Though using <code>Double.isNaN</code> method should be preferred instead, as intent is more explicit.</p>\n<pre>\nfloat f;\ndouble d;\nif(f != f) { // Compliant; test for NaN value\n  System.out.println(\"f is NaN\");\n} else if (f != d) { // Noncompliant\n  // ...\n}\n</pre>",
    "howToFix": "",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "부동 소수점 숫자는 동등성 테스트를 하면 안 됩니다",
    "why_ko": "<p>부동 소수점 연산은 이진 표현으로 이러한 값을 저장하는 것이 어렵기 때문에 부정확합니다. 더 나쁜 것은 부동 소수점 연산은 결합 법칙이 적용되지 않습니다. <code>float</code>이나 <code>double</code>을 일련의 간단한 수학적 연산을 통해 처리하면 각 단계에서 발생하는 반올림 때문에 연산 순서에 따라 결과가 달라집니다.</p>\n<p>간단한 부동 소수점 할당조차 간단하지 않습니다:</p>\n<pre>\nfloat f = 0.1; // 0.100000001490116119384765625\ndouble d = 0.1; // 0.1000000000000000055511151231257827021181583404541015625\n</pre>\n<p>(결과는 컴파일러와 컴파일러 설정에 따라 달라집니다);</p>\n<p>따라서 <code>float</code>이나 <code>double</code> 값에 대한 동등(<code>==</code>) 및 부등(<code>!=</code>) 연산자의 사용은 거의 항상 오류입니다. 대신 부동 소수점 비교를 완전히 피하는 것이 최선입니다. 그것이 불가능할 때는 부동 소수점 비교를 적절히 처리할 수 있는 <code>BigDecimal</code>과 같은 Java의 부동 소수점 처리 <code>Numbers</code> 중 하나를 사용하는 것을 고려해야 합니다. 세 번째 옵션은 동등성이 아니라 값이 충분히 가까운지 확인하는 것입니다. 즉, 저장된 값과 예상 값 사이의 차이의 절대값을 허용 가능한 오차 범위와 비교합니다. 이것이 모든 경우를 다루지는 않습니다(예: <code>NaN</code>과 <code>Infinity</code>).</p>\n<p>이 규칙은 float와 double에 대한 직접 및 간접 동등/부등 테스트의 사용을 검사합니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\nfloat myNumber = 3.146;\nif ( myNumber == 3.146f ) { // 규칙 위반. 부동 소수점 부정확성 때문에 이것은 false가 됩니다\n  // ...\n}\nif ( myNumber != 3.146f ) { // 규칙 위반. 부동 소수점 부정확성 때문에 이것은 true가 됩니다\n  // ...\n}\n\nif (myNumber &lt; 4 || myNumber &gt; 4) { // 규칙 위반; 간접 부등 테스트\n  // ...\n}\n\nfloat zeroFloat = 0.0f;\nif (zeroFloat == 0) {  // 규칙 위반. 계산 결과가 0에 가깝지만 0과 같지 않은 값이 될 수 있습니다.\n}\n</pre>\n<h3>예외</h3>\n<p><code>NaN</code>은 자기 자신과 같지 않으므로, 부동 소수점 값을 자기 자신과 비교하는 특정 경우는 <code>NaN</code>에 대한 유효한 테스트이므로 무시됩니다. 그러나 의도가 더 명시적이므로 <code>Double.isNaN</code> 메서드를 사용하는 것이 선호되어야 합니다.</p>\n<pre>\nfloat f;\ndouble d;\nif(f != f) { // 규칙 준수; NaN 값 테스트\n  System.out.println(\"f is NaN\");\n} else if (f != d) { // 규칙 위반\n  // ...\n}\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": ""
  },
  {
    "id": "S2254",
    "key": "java:S2254",
    "name": "\"HttpServletRequest.getRequestedSessionId()\" should not be used",
    "type": "vulnerability",
    "severity": "critical",
    "tags": [
      "cwe"
    ],
    "why": "<p>According to the API documentation of the <code>HttpServletRequest.getRequestedSessionId()</code> method:</p>\n<blockquote>\n  <p>Returns the session ID specified by the client. This may not be the same as the ID of the current valid session for this request. If the client\n  did not specify a session ID, this method returns null.</p>\n</blockquote>\n<p>The session ID it returns is either transmitted through a cookie or a URL parameter. This allows an end user to manually update the value of this\nsession ID in an HTTP request.</p>\n<p>Due to the ability of the end-user to manually change the value, the session ID in the request should only be used by a servlet container (e.g.\nTomcat or Jetty) to see if the value matches the ID of an existing session. If it does not, the user should be considered unauthenticated.</p>\n<h3>What is the potential impact?</h3>\n<p>Using a client-supplied session ID to manage sessions on the server side can potentially have an impact on the security of the application.</p>\n<h4>Impersonation (through session fixation)</h4>\n<p>If an attacker succeeds in fixing a user's session to a session identifier that they know, then they can impersonate this victim and gain access to\ntheir account without providing valid credentials. This can result in unauthorized actions, such as modifying personal information, making\nunauthorized transactions, or even performing malicious activities on behalf of the victim. An attacker can also manipulate the victim into performing\nactions they wouldn't normally do, such as revealing sensitive information or conducting financial transactions on the attacker's behalf.</p>",
    "howToFix": "<p>In both examples, a session ID is used to check whether a user's session is still active. In the noncompliant example, the session ID supplied by\nthe user is used. In the compliant example, the session ID defined by the server is used instead.</p>\n<h4>Noncompliant code example</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\nif (isActiveSession(request.getRequestedSessionId())) { // Noncompliant\n    // ...\n}\n</pre>\n<h4>Compliant solution</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\nif (isActiveSession(request.getSession().getId())) {\n    // ...\n}\n</pre>\n<h3>How does this work?</h3>\n<p>The noncompliant example uses <code>HttpServletRequest.getRequestedSessionId()</code> to retrieve a session ID. This ID is then used to verify if\nthe given session is still active. As this value is given by a user, this value is not guaranteed to be a valid ID.</p>\n<p>The compliant example instead uses the server's session ID to verify if the session is active. Additionally, <code>getSession()</code> will create\na new session if the user's request does not contain a valid ID.</p>",
    "moreInfo": "<h3>Documentation</h3>\n<ul>\n  <li> Jakarta EE Documentation - <a\n  href=\"https://jakarta.ee/specifications/platform/10/apidocs/jakarta/servlet/http/httpservletrequest#getRequestedSessionId--\"><code>HttpServletRequest</code> - <code>getRequestedSessionId</code></a> </li>\n</ul>\n<h3>Standards</h3>\n<ul>\n  <li> OWASP - <a href=\"https://owasp.org/Top10/A04_2021-Insecure_Design/\">Top 10 2021 Category A4 - Insecure Design</a> </li>\n  <li> OWASP - <a href=\"https://owasp.org/www-project-top-ten/2017/A2_2017-Broken_Authentication\">Top 10 2017 Category A2 - Broken Authentication</a>\n  </li>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/807\">CWE-807 - Reliance on Untrusted Inputs in a Security Decision</a> </li>\n  <li> STIG Viewer - <a href=\"https://stigviewer.com/stigs/application_security_and_development/2024-12-06/finding/V-222582\">Application Security and\n  Development: V-222582</a> - The application must not re-use or recycle session IDs. </li>\n</ul>",
    "status": "READY",
    "name_ko": "HttpServletRequest.getRequestedSessionId()를 사용하면 안 됩니다",
    "why_ko": "<p><code>HttpServletRequest.getRequestedSessionId()</code> 메서드의 API 문서에 따르면:</p>\n<blockquote>\n  <p>클라이언트가 지정한 세션 ID를 반환합니다. 이것은 이 요청에 대한 현재 유효한 세션의 ID와 동일하지 않을 수 있습니다. 클라이언트가 세션 ID를 지정하지 않은 경우 이 메서드는 null을 반환합니다.</p>\n</blockquote>\n<p>반환되는 세션 ID는 쿠키 또는 URL 매개변수를 통해 전송됩니다. 이를 통해 최종 사용자가 HTTP 요청에서 이 세션 ID의 값을 수동으로 업데이트할 수 있습니다.</p>\n<p>최종 사용자가 값을 수동으로 변경할 수 있기 때문에 요청의 세션 ID는 서블릿 컨테이너(예: Tomcat 또는 Jetty)에서만 사용하여 값이 기존 세션의 ID와 일치하는지 확인해야 합니다. 일치하지 않으면 사용자를 인증되지 않은 것으로 간주해야 합니다.</p>\n<h3>잠재적 영향은 무엇입니까?</h3>\n<p>서버 측에서 세션을 관리하기 위해 클라이언트가 제공한 세션 ID를 사용하면 애플리케이션의 보안에 잠재적으로 영향을 미칠 수 있습니다.</p>\n<h4>사칭(세션 고정을 통해)</h4>\n<p>공격자가 사용자의 세션을 자신이 알고 있는 세션 식별자로 고정하는 데 성공하면 유효한 자격 증명을 제공하지 않고도 이 피해자를 사칭하고 계정에 접근할 수 있습니다. 이로 인해 개인 정보 수정, 무단 거래 또는 피해자를 대신한 악의적인 활동 수행과 같은 무단 작업이 발생할 수 있습니다. 공격자는 또한 피해자가 민감한 정보를 공개하거나 공격자를 대신하여 금융 거래를 수행하는 것과 같이 평소에는 하지 않을 작업을 수행하도록 조작할 수 있습니다.</p>",
    "howToFix_ko": "<p>두 예시 모두에서 세션 ID는 사용자의 세션이 여전히 활성 상태인지 확인하는 데 사용됩니다. 규칙을 준수하지 않는 예시에서는 사용자가 제공한 세션 ID가 사용됩니다. 규칙을 준수하는 예시에서는 대신 서버가 정의한 세션 ID가 사용됩니다.</p>\n<h4>규칙을 준수하지 않는 코드 예시</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\nif (isActiveSession(request.getRequestedSessionId())) { // 규칙 위반\n    // ...\n}\n</pre>\n<h4>규칙을 준수하는 해결책</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\nif (isActiveSession(request.getSession().getId())) {\n    // ...\n}\n</pre>\n<h3>어떻게 작동합니까?</h3>\n<p>규칙을 준수하지 않는 예시는 <code>HttpServletRequest.getRequestedSessionId()</code>를 사용하여 세션 ID를 검색합니다. 이 ID는 주어진 세션이 여전히 활성 상태인지 확인하는 데 사용됩니다. 이 값은 사용자가 제공하므로 이 값이 유효한 ID라고 보장할 수 없습니다.</p>\n<p>규칙을 준수하는 예시는 대신 서버의 세션 ID를 사용하여 세션이 활성 상태인지 확인합니다. 또한 <code>getSession()</code>은 사용자의 요청에 유효한 ID가 포함되지 않은 경우 새 세션을 생성합니다.</p>",
    "moreInfo_ko": "<h3>문서</h3>\n<ul>\n  <li> Jakarta EE Documentation - <a\n  href=\"https://jakarta.ee/specifications/platform/10/apidocs/jakarta/servlet/http/httpservletrequest#getRequestedSessionId--\"><code>HttpServletRequest</code> - <code>getRequestedSessionId</code></a> </li>\n</ul>\n<h3>표준</h3>\n<ul>\n  <li> OWASP - <a href=\"https://owasp.org/Top10/A04_2021-Insecure_Design/\">Top 10 2021 카테고리 A4 - 안전하지 않은 설계</a> </li>\n  <li> OWASP - <a href=\"https://owasp.org/www-project-top-ten/2017/A2_2017-Broken_Authentication\">Top 10 2017 카테고리 A2 - 취약한 인증</a> </li>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/807\">CWE-807 - 보안 결정에서 신뢰할 수 없는 입력에 의존</a> </li>\n  <li> STIG Viewer - <a href=\"https://stigviewer.com/stigs/application_security_and_development/2024-12-06/finding/V-222582\">Application Security and Development: V-222582</a> - 애플리케이션은 세션 ID를 재사용하거나 재활용해서는 안 됩니다. </li>\n</ul>"
  },
  {
    "id": "S6217",
    "key": "java:S6217",
    "name": "Permitted types of a sealed class should be omitted if they are declared in the same file",
    "type": "code-smell",
    "severity": "minor",
    "tags": [
      "java17"
    ],
    "why": "<p><code>sealed</code> classes were introduced in Java 17. This feature is very useful if there is a need to define a strict hierarchy and restrict\nthe possibility of extending classes. In order to mention all the allowed subclasses, there is a keyword <code>permits</code>, which should be\nfollowed by subclasses' names.</p>\n<p>This notation is quite useful if subclasses of a given <code>sealed</code> class can be found in different files, packages, or even modules. In\ncase when all subclasses are declared in the same file there is no need to mention the explicitly and <code>permits</code> part of a declaration can\nbe omitted.</p>\n<p>This rule reports an issue if all subclasses of a <code>sealed</code> class are declared in the same file as their superclass.</p>\n<h3>Noncompliant code example</h3>\n<pre>\nsealed class A permits B, C, D, E {} // Noncompliant\nfinal class B extends A {}\nfinal class C extends A {}\nfinal class D extends A {}\nfinal class E extends A {}\n</pre>\n<h3>Compliant solution</h3>\n<pre>\nsealed class A {} // Compliant\nfinal class B extends A {}\nfinal class C extends A {}\nfinal class D extends A {}\nfinal class E extends A {}\n</pre>",
    "howToFix": "",
    "moreInfo": "<ul>\n  <li> <a href=\"https://docs.oracle.com/javase/specs/jls/se17/html/jls-8.html#jls-8.1.1.2\">Sealed Classes specification</a> </li>\n</ul>",
    "status": "READY",
    "name_ko": "Sealed 클래스의 허용 타입이 같은 파일에 선언된 경우 생략해야 합니다",
    "why_ko": "<p>Java 17에서 <code>sealed</code> 클래스가 도입되었습니다. 이 기능은 엄격한 계층 구조를 정의하고 클래스 확장 가능성을 제한해야 할 때 매우 유용합니다. 허용된 모든 서브클래스를 언급하기 위해 <code>permits</code> 키워드가 있으며, 그 뒤에 서브클래스 이름이 와야 합니다.</p>\n<p>이 표기법은 주어진 <code>sealed</code> 클래스의 서브클래스가 다른 파일, 패키지 또는 모듈에서 찾을 수 있을 때 상당히 유용합니다. 모든 서브클래스가 같은 파일에 선언된 경우 명시적으로 언급할 필요가 없으며 선언의 <code>permits</code> 부분을 생략할 수 있습니다.</p>\n<p>이 규칙은 <code>sealed</code> 클래스의 모든 서브클래스가 상위 클래스와 같은 파일에 선언된 경우 문제를 보고합니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\nsealed class A permits B, C, D, E {} // 규칙 위반\nfinal class B extends A {}\nfinal class C extends A {}\nfinal class D extends A {}\nfinal class E extends A {}\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre>\nsealed class A {} // 규칙 준수\nfinal class B extends A {}\nfinal class C extends A {}\nfinal class D extends A {}\nfinal class E extends A {}\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": "<ul>\n  <li> <a href=\"https://docs.oracle.com/javase/specs/jls/se17/html/jls-8.html#jls-8.1.1.2\">Sealed 클래스 명세</a> </li>\n</ul>"
  },
  {
    "id": "S1182",
    "key": "java:S1182",
    "name": "Classes that override \"clone\" should be \"Cloneable\" and call \"super.clone()\"",
    "type": "code-smell",
    "severity": "minor",
    "tags": [
      "cwe",
      "convention",
      "cert"
    ],
    "why": "<p><code>Cloneable</code> is the marker <code>Interface</code> that indicates that <code>clone()</code> may be called on an object. Overriding\n<code>clone()</code> without implementing <code>Cloneable</code> can be helpful if you want to control how subclasses clone themselves, but otherwise,\nit's probably a mistake.</p>\n<p>The usual convention for <code>Object.clone()</code> according to Oracle's Javadoc is:</p>\n<ol>\n  <li> <code>x.clone() != x</code> </li>\n  <li> <code>x.clone().getClass() == x.getClass()</code> </li>\n  <li> <code>x.clone().equals(x)</code> </li>\n</ol>\n<p>Obtaining the object that will be returned by calling <code>super.clone()</code> helps to satisfy those invariants:</p>\n<ol>\n  <li> <code>super.clone()</code> returns a new object instance </li>\n  <li> <code>super.clone()</code> returns an object of the same type as the one <code>clone()</code> was called on </li>\n  <li> <code>Object.clone()</code> performs a shallow copy of the object's state. </li>\n</ol>",
    "howToFix": "<p>Ensure that the <code>clone()</code> method calls <code>super.clone()</code> and implement <code>Cloneable</code> in the class or remove the clone\nmethod.</p>\n\n<h4>Noncompliant code example</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\nclass BaseClass {  // Noncompliant - should implement Cloneable\n  @Override\n  public Object clone() throws CloneNotSupportedException {    // Noncompliant - should return the super.clone() instance\n    return new BaseClass();\n  }\n}\n\nclass DerivedClass extends BaseClass implements Cloneable {\n  /* Does not override clone() */\n\n  public void sayHello() {\n    System.out.println(\"Hello, world!\");\n  }\n}\n\nclass Application {\n  public static void main(String[] args) throws Exception {\n    DerivedClass instance = new DerivedClass();\n    ((DerivedClass) instance.clone()).sayHello();              // Throws a ClassCastException because invariant #2 is violated\n  }\n}\n</pre>\n<h4>Compliant solution</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\nclass BaseClass implements Cloneable {\n  @Override\n  public Object clone() throws CloneNotSupportedException {    // Compliant\n    return super.clone();\n  }\n}\n\nclass DerivedClass extends BaseClass implements Cloneable {\n  /* Does not override clone() */\n\n  public void sayHello() {\n    System.out.println(\"Hello, world!\");\n  }\n}\n\nclass Application {\n  public static void main(String[] args) throws Exception {\n    DerivedClass instance = new DerivedClass();\n    ((DerivedClass) instance.clone()).sayHello();              // Displays \"Hello, world!\" as expected. Invariant #2 is satisfied\n  }\n}\n</pre>",
    "moreInfo": "<ul>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/580\">CWE-580 - clone() Method Without super.clone()</a> </li>\n  <li> <a href=\"https://wiki.sei.cmu.edu/confluence/x/FjZGBQ\">CERT, MET53-J.</a> - Ensure that the clone() method calls super.clone() </li>\n</ul>",
    "status": "READY",
    "name_ko": "\"clone\"을 오버라이드하는 클래스는 \"Cloneable\"을 구현하고 \"super.clone()\"을 호출해야 합니다",
    "why_ko": "<p><code>Cloneable</code>은 객체에서 <code>clone()</code>을 호출할 수 있음을 나타내는 마커 <code>Interface</code>입니다. <code>Cloneable</code>을 구현하지 않고 <code>clone()</code>을 오버라이드하는 것은 서브클래스가 스스로 복제하는 방법을 제어하려는 경우 유용할 수 있지만, 그렇지 않으면 아마도 실수일 것입니다.</p>\n<p>Oracle의 Javadoc에 따른 <code>Object.clone()</code>의 일반적인 규약은 다음과 같습니다:</p>\n<ol>\n  <li> <code>x.clone() != x</code> </li>\n  <li> <code>x.clone().getClass() == x.getClass()</code> </li>\n  <li> <code>x.clone().equals(x)</code> </li>\n</ol>\n<p><code>super.clone()</code>을 호출하여 반환될 객체를 얻으면 이러한 불변식을 충족하는 데 도움이 됩니다:</p>\n<ol>\n  <li> <code>super.clone()</code>은 새 객체 인스턴스를 반환합니다 </li>\n  <li> <code>super.clone()</code>은 <code>clone()</code>이 호출된 것과 동일한 타입의 객체를 반환합니다 </li>\n  <li> <code>Object.clone()</code>은 객체 상태의 얕은 복사를 수행합니다 </li>\n</ol>",
    "howToFix_ko": "<p><code>clone()</code> 메서드가 <code>super.clone()</code>을 호출하고 클래스에서 <code>Cloneable</code>을 구현하도록 하거나 clone 메서드를 제거하세요.</p>\n\n<h4>규칙을 준수하지 않는 코드 예시</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\nclass BaseClass {  // 규칙 위반 - Cloneable을 구현해야 함\n  @Override\n  public Object clone() throws CloneNotSupportedException {    // 규칙 위반 - super.clone() 인스턴스를 반환해야 함\n    return new BaseClass();\n  }\n}\n\nclass DerivedClass extends BaseClass implements Cloneable {\n  /* clone()을 오버라이드하지 않음 */\n\n  public void sayHello() {\n    System.out.println(\"Hello, world!\");\n  }\n}\n\nclass Application {\n  public static void main(String[] args) throws Exception {\n    DerivedClass instance = new DerivedClass();\n    ((DerivedClass) instance.clone()).sayHello();              // 불변식 #2가 위반되어 ClassCastException이 발생함\n  }\n}\n</pre>\n<h4>규칙을 준수하는 해결책</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\nclass BaseClass implements Cloneable {\n  @Override\n  public Object clone() throws CloneNotSupportedException {    // 규칙 준수\n    return super.clone();\n  }\n}\n\nclass DerivedClass extends BaseClass implements Cloneable {\n  /* clone()을 오버라이드하지 않음 */\n\n  public void sayHello() {\n    System.out.println(\"Hello, world!\");\n  }\n}\n\nclass Application {\n  public static void main(String[] args) throws Exception {\n    DerivedClass instance = new DerivedClass();\n    ((DerivedClass) instance.clone()).sayHello();              // 예상대로 \"Hello, world!\"를 출력함. 불변식 #2가 충족됨\n  }\n}\n</pre>",
    "moreInfo_ko": "<ul>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/580\">CWE-580 - super.clone() 없는 clone() 메서드</a> </li>\n  <li> <a href=\"https://wiki.sei.cmu.edu/confluence/x/FjZGBQ\">CERT, MET53-J.</a> - clone() 메서드가 super.clone()을 호출하도록 하세요 </li>\n</ul>"
  },
  {
    "id": "S1317",
    "key": "java:S1317",
    "name": "\"StringBuilder\" and \"StringBuffer\" should not be instantiated with a character",
    "type": "bug",
    "severity": "major",
    "tags": [
      "pitfall"
    ],
    "why": "<p>When a developer uses the <code>StringBuilder</code> or <code>StringBuffer</code> constructor with a single character as an argument, the likely\nintention is to create an instance with the character as the initial string value.</p>\n<p>However, this is not what happens because of the absence of a dedicated <code>StringBuilder(char)</code> or <code>StringBuffer(char)</code>\nconstructor. Instead, <code>StringBuilder(int)</code> or <code>StringBuffer(int)</code> is invoked, which results in an instance with the provided\n<code>int</code> value as the initial capacity of the <code>StringBuilder</code> or <code>StringBuffer</code>.</p>\n<p>The reason behind this behavior lies in the automatic widening of <code>char</code> expressions to <code>int</code> when required. Consequently,\nthe UTF-16 code point value of the character (for example, <code>65</code> for the character <code>'A'</code>) is interpreted as an <code>int</code>\nto specify the initial capacity.</p>",
    "howToFix": "<p>If the argument is a <code>char</code> literal, use a string literal instead:</p>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\nStringBuffer foo = new StringBuffer('x'); // Noncompliant, replace with String\n</pre>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\nStringBuffer foo = new StringBuffer(\"x\"); // Compliant\n</pre>\n<p>If the argument is it is a non-literal <code>char</code> expression, convert it to <code>String</code> using the <code>String.valueOf()</code>\nmethod:</p>\n<pre data-diff-id=\"2\" data-diff-type=\"noncompliant\">\nStringBuffer foo(char firstChar) {\n  return new StringBuffer(firstChar);                 // Noncompliant\n}\n</pre>\n<pre data-diff-id=\"2\" data-diff-type=\"compliant\">\nStringBuffer foo(char firstChar) {\n  return new StringBuffer(String.valueOf(firstChar)); // Compliant\n}\n</pre>",
    "moreInfo": "<h3>Documentation</h3>\n<ul>\n  <li> <a href=\"https://docs.oracle.com/javase/specs/jls/se10/html/jls-5.html#jls-5.1.2\">Oracle - Java Language Specification, section 5.1.2. Widening\n  Primitive Conversion</a> </li>\n</ul>\n<h3>Articles &amp; blog posts</h3>\n<ul>\n  <li> <a href=\"https://www.w3schools.com/java/java_type_casting.asp\">W3schools - Java Type Casting</a> </li>\n</ul>",
    "status": "READY",
    "name_ko": "\"StringBuilder\"와 \"StringBuffer\"는 문자로 인스턴스화하면 안 됩니다",
    "why_ko": "<p>개발자가 단일 문자를 인수로 <code>StringBuilder</code> 또는 <code>StringBuffer</code> 생성자를 사용할 때, 의도는 해당 문자를 초기 문자열 값으로 하는 인스턴스를 생성하는 것일 가능성이 높습니다.</p>\n<p>그러나 전용 <code>StringBuilder(char)</code> 또는 <code>StringBuffer(char)</code> 생성자가 없기 때문에 이것이 실제로 일어나는 일이 아닙니다. 대신 <code>StringBuilder(int)</code> 또는 <code>StringBuffer(int)</code>가 호출되어 제공된 <code>int</code> 값이 <code>StringBuilder</code> 또는 <code>StringBuffer</code>의 초기 용량으로 설정된 인스턴스가 생성됩니다.</p>\n<p>이 동작의 이유는 필요할 때 <code>char</code> 표현식이 자동으로 <code>int</code>로 확장되기 때문입니다. 결과적으로 문자의 UTF-16 코드 포인트 값(예: 문자 <code>'A'</code>의 경우 <code>65</code>)이 초기 용량을 지정하는 <code>int</code>로 해석됩니다.</p>",
    "howToFix_ko": "<p>인수가 <code>char</code> 리터럴인 경우 대신 문자열 리터럴을 사용하세요:</p>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\nStringBuffer foo = new StringBuffer('x'); // 규칙 위반, String으로 교체하세요\n</pre>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\nStringBuffer foo = new StringBuffer(\"x\"); // 규칙 준수\n</pre>\n<p>인수가 리터럴이 아닌 <code>char</code> 표현식인 경우 <code>String.valueOf()</code> 메서드를 사용하여 <code>String</code>으로 변환하세요:</p>\n<pre data-diff-id=\"2\" data-diff-type=\"noncompliant\">\nStringBuffer foo(char firstChar) {\n  return new StringBuffer(firstChar);                 // 규칙 위반\n}\n</pre>\n<pre data-diff-id=\"2\" data-diff-type=\"compliant\">\nStringBuffer foo(char firstChar) {\n  return new StringBuffer(String.valueOf(firstChar)); // 규칙 준수\n}\n</pre>",
    "moreInfo_ko": "<h3>문서</h3>\n<ul>\n  <li> <a href=\"https://docs.oracle.com/javase/specs/jls/se10/html/jls-5.html#jls-5.1.2\">Oracle - Java 언어 명세, 섹션 5.1.2. 기본 타입 확장 변환</a> </li>\n</ul>\n<h3>관련 글 및 블로그 포스트</h3>\n<ul>\n  <li> <a href=\"https://www.w3schools.com/java/java_type_casting.asp\">W3schools - Java 타입 캐스팅</a> </li>\n</ul>"
  },
  {
    "id": "S2184",
    "key": "java:S2184",
    "name": "Math operands should be cast before assignment",
    "type": "bug",
    "severity": "minor",
    "tags": [
      "cwe",
      "overflow",
      "cert"
    ],
    "why": "<p>When arithmetic is performed on integers, the result will always be an integer. You can assign that result to a <code>long</code>,\n<code>double</code>, or <code>float</code> with automatic type conversion, but having started as an <code>int</code> or <code>long</code>, the result\nwill likely not be what you expect.</p>\n<p>For instance, if the result of <code>int</code> division is assigned to a floating-point variable, precision will have been lost before the\nassignment. Likewise, if the result of multiplication is assigned to a <code>long</code>, it may have already overflowed before the assignment.</p>\n<p>In either case, the result will not be what was expected. Instead, at least one operand should be cast or promoted to the final type before the\noperation takes place.</p>\n<h3>Noncompliant code example</h3>\n<pre>\nfloat twoThirds = 2/3; // Noncompliant; int division. Yields 0.0\nlong millisInYear = 1_000*3_600*24*365; // Noncompliant; int multiplication. Yields 1471228928\nlong bigNum = Integer.MAX_VALUE + 2; // Noncompliant. Yields -2147483647\nlong bigNegNum =  Integer.MIN_VALUE-1; //Noncompliant, gives a positive result instead of a negative one.\nDate myDate = new Date(seconds * 1_000); //Noncompliant, won't produce the expected result if seconds &gt; 2_147_483\n...\npublic long compute(int factor){\n  return factor * 10_000;  //Noncompliant, won't produce the expected result if factor &gt; 214_748\n}\n\npublic float compute2(long factor){\n  return factor / 123;  //Noncompliant, will be rounded to closest long integer\n}\n</pre>\n<h3>Compliant solution</h3>\n<pre>\nfloat twoThirds = 2f/3; // 2 promoted to float. Yields 0.6666667\nlong millisInYear = 1_000L*3_600*24*365; // 1000 promoted to long. Yields 31_536_000_000\nlong bigNum = Integer.MAX_VALUE + 2L; // 2 promoted to long. Yields 2_147_483_649\nlong bigNegNum =  Integer.MIN_VALUE-1L; // Yields -2_147_483_649\nDate myDate = new Date(seconds * 1_000L);\n...\npublic long compute(int factor){\n  return factor * 10_000L;\n}\n\npublic float compute2(long factor){\n  return factor / 123f;\n}\n</pre>\n<p>or</p>\n<pre>\nfloat twoThirds = (float)2/3; // 2 cast to float\nlong millisInYear = (long)1_000*3_600*24*365; // 1_000 cast to long\nlong bigNum = (long)Integer.MAX_VALUE + 2;\nlong bigNegNum =  (long)Integer.MIN_VALUE-1;\nDate myDate = new Date((long)seconds * 1_000);\n...\npublic long compute(long factor){\n  return factor * 10_000;\n}\n\npublic float compute2(float factor){\n  return factor / 123;\n}\n</pre>",
    "howToFix": "",
    "moreInfo": "<h3>Standards</h3>\n<ul>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/190\">CWE-190 - Integer Overflow or Wraparound</a> </li>\n  <li> <a href=\"https://wiki.sei.cmu.edu/confluence/x/AjdGBQ\">CERT, NUM50-J.</a> - Convert integers to floating point for floating-point operations\n  </li>\n  <li> <a href=\"https://wiki.sei.cmu.edu/confluence/x/I9cxBQ\">CERT, INT18-C.</a> - Evaluate integer expressions in a larger size before comparing or\n  assigning to that size </li>\n  <li> STIG Viewer - <a href=\"https://stigviewer.com/stigs/application_security_and_development/2024-12-06/finding/V-222612\">Application Security and\n  Development: V-222612</a> - The application must not be vulnerable to overflow attacks. </li>\n</ul>",
    "status": "READY",
    "name_ko": "수학 연산자는 할당 전에 형변환해야 합니다",
    "why_ko": "<p>정수에 대해 산술 연산을 수행하면 결과는 항상 정수가 됩니다. 자동 타입 변환을 통해 해당 결과를 <code>long</code>, <code>double</code> 또는 <code>float</code>에 할당할 수 있지만, <code>int</code> 또는 <code>long</code>으로 시작했기 때문에 결과가 예상한 것과 다를 가능성이 높습니다.</p>\n<p>예를 들어, <code>int</code> 나눗셈의 결과가 부동 소수점 변수에 할당되면 할당 전에 정밀도가 손실되었을 것입니다. 마찬가지로 곱셈의 결과가 <code>long</code>에 할당되면 할당 전에 이미 오버플로가 발생했을 수 있습니다.</p>\n<p>어느 경우든 결과는 예상한 것과 다를 것입니다. 대신 연산이 수행되기 전에 적어도 하나의 피연산자를 최종 타입으로 캐스팅하거나 프로모션해야 합니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\nfloat twoThirds = 2/3; // 규칙 위반; int 나눗셈. 0.0을 산출\nlong millisInYear = 1_000*3_600*24*365; // 규칙 위반; int 곱셈. 1471228928을 산출\nlong bigNum = Integer.MAX_VALUE + 2; // 규칙 위반. -2147483647을 산출\nlong bigNegNum =  Integer.MIN_VALUE-1; // 규칙 위반, 음수 대신 양수 결과를 제공\nDate myDate = new Date(seconds * 1_000); // 규칙 위반, seconds &gt; 2_147_483이면 예상 결과를 생성하지 않음\n...\npublic long compute(int factor){\n  return factor * 10_000;  // 규칙 위반, factor &gt; 214_748이면 예상 결과를 생성하지 않음\n}\n\npublic float compute2(long factor){\n  return factor / 123;  // 규칙 위반, 가장 가까운 long 정수로 반올림됨\n}\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre>\nfloat twoThirds = 2f/3; // 2가 float로 프로모션. 0.6666667을 산출\nlong millisInYear = 1_000L*3_600*24*365; // 1000이 long으로 프로모션. 31_536_000_000을 산출\nlong bigNum = Integer.MAX_VALUE + 2L; // 2가 long으로 프로모션. 2_147_483_649를 산출\nlong bigNegNum =  Integer.MIN_VALUE-1L; // -2_147_483_649를 산출\nDate myDate = new Date(seconds * 1_000L);\n...\npublic long compute(int factor){\n  return factor * 10_000L;\n}\n\npublic float compute2(long factor){\n  return factor / 123f;\n}\n</pre>\n<p>또는</p>\n<pre>\nfloat twoThirds = (float)2/3; // 2가 float로 캐스팅\nlong millisInYear = (long)1_000*3_600*24*365; // 1_000이 long으로 캐스팅\nlong bigNum = (long)Integer.MAX_VALUE + 2;\nlong bigNegNum =  (long)Integer.MIN_VALUE-1;\nDate myDate = new Date((long)seconds * 1_000);\n...\npublic long compute(long factor){\n  return factor * 10_000;\n}\n\npublic float compute2(float factor){\n  return factor / 123;\n}\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": "<h3>표준</h3>\n<ul>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/190\">CWE-190 - Integer Overflow or Wraparound</a> </li>\n  <li> <a href=\"https://wiki.sei.cmu.edu/confluence/x/AjdGBQ\">CERT, NUM50-J.</a> - 부동 소수점 연산을 위해 정수를 부동 소수점으로 변환하세요 </li>\n  <li> <a href=\"https://wiki.sei.cmu.edu/confluence/x/I9cxBQ\">CERT, INT18-C.</a> - 해당 크기로 비교하거나 할당하기 전에 더 큰 크기에서 정수 표현식을 평가하세요 </li>\n  <li> STIG Viewer - <a href=\"https://stigviewer.com/stigs/application_security_and_development/2024-12-06/finding/V-222612\">Application Security and Development: V-222612</a> - 애플리케이션은 오버플로 공격에 취약하면 안 됩니다. </li>\n</ul>"
  },
  {
    "id": "S1602",
    "key": "java:S1602",
    "name": "Lambdas containing only one statement should not nest this statement in a block",
    "type": "code-smell",
    "severity": "minor",
    "tags": [
      "java8"
    ],
    "why": "<p>The right-hand side of a lambda expression can be written in two ways:</p>\n<ol>\n  <li> Expression notation: the right-hand side is as an expression, such as in <code>(a, b) → a + b</code> </li>\n  <li> Block notation: the right-hand side is a conventional function body with a code block and an optional return statement, such as in <code>(a, b)\n  → {return a + b;}</code> </li>\n</ol>\n<p>By convention, expression notation is preferred over block notation. Block notation must be used when the function implementation requires more\nthan one statement. However, when the code block consists of only one statement (which may or may not be a <code>return</code> statement), it can be\nrewritten using expression notation.</p>\n<p>This convention exists because expression notation has a cleaner, more concise, functional programming style and is regarded as more readable.</p>",
    "howToFix": "<ul>\n  <li> If the code block consists only of a <code>return</code> statement, replace the code block with the argument expression from the\n  <code>return</code> statement. </li>\n  <li> If the code block consists of a single statement that is not a <code>return</code> statement, replace the code block with that statement. </li>\n</ul>\n\n<h4>Noncompliant code example</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\n(a, b) -&gt; { return a + b; } // Noncompliant, replace code block with expression\n</pre>\n<h4>Compliant solution</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\n(a, b) -&gt; a + b             // Compliant\n</pre>\n<h4>Noncompliant code example</h4>\n<pre data-diff-id=\"2\" data-diff-type=\"noncompliant\">\nx -&gt; {System.out.println(x+1);} // Noncompliant, replace code block with statement\n</pre>\n<h4>Compliant solution</h4>\n<pre data-diff-id=\"2\" data-diff-type=\"compliant\">\nx -&gt; System.out.println(x+1)    // Compliant\n</pre>",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "하나의 문만 포함하는 Lambda는 블록으로 감싸면 안 됩니다",
    "why_ko": "<p>람다 표현식의 오른쪽은 두 가지 방식으로 작성할 수 있습니다:</p>\n<ol>\n  <li> 표현식 표기법: 오른쪽이 <code>(a, b) → a + b</code>와 같은 표현식입니다 </li>\n  <li> 블록 표기법: 오른쪽이 <code>(a, b) → {return a + b;}</code>와 같이 코드 블록과 선택적 return 문이 있는 일반적인 함수 본문입니다 </li>\n</ol>\n<p>관례적으로 표현식 표기법이 블록 표기법보다 선호됩니다. 블록 표기법은 함수 구현에 둘 이상의 문이 필요할 때 사용해야 합니다. 그러나 코드 블록이 하나의 문(<code>return</code> 문일 수도 있고 아닐 수도 있음)으로만 구성된 경우 표현식 표기법을 사용하여 다시 작성할 수 있습니다.</p>\n<p>이 관례가 존재하는 이유는 표현식 표기법이 더 깔끔하고 간결한 함수형 프로그래밍 스타일을 가지며 더 읽기 쉽다고 간주되기 때문입니다.</p>",
    "howToFix_ko": "<ul>\n  <li> 코드 블록이 <code>return</code> 문으로만 구성된 경우 코드 블록을 <code>return</code> 문의 인자 표현식으로 대체하세요. </li>\n  <li> 코드 블록이 <code>return</code> 문이 아닌 단일 문으로 구성된 경우 코드 블록을 해당 문으로 대체하세요. </li>\n</ul>\n\n<h4>규칙을 준수하지 않는 코드 예시</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\n(a, b) -&gt; { return a + b; } // 규칙 위반, 코드 블록을 표현식으로 대체하세요\n</pre>\n<h4>규칙을 준수하는 해결책</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\n(a, b) -&gt; a + b             // 규칙 준수\n</pre>\n<h4>규칙을 준수하지 않는 코드 예시</h4>\n<pre data-diff-id=\"2\" data-diff-type=\"noncompliant\">\nx -&gt; {System.out.println(x+1);} // 규칙 위반, 코드 블록을 문으로 대체하세요\n</pre>\n<h4>규칙을 준수하는 해결책</h4>\n<pre data-diff-id=\"2\" data-diff-type=\"compliant\">\nx -&gt; System.out.println(x+1)    // 규칙 준수\n</pre>",
    "moreInfo_ko": ""
  },
  {
    "id": "S2757",
    "key": "java:S2757",
    "name": "Non-existent operators like \"=+\" should not be used",
    "type": "bug",
    "severity": "major",
    "tags": [],
    "why": "<p>Using operator pairs (<code>=+</code>, <code>=-</code>, or <code>=!</code>) that look like reversed single operators (<code>+=</code>,\n<code>-=</code> or <code>!=</code>) is confusing. They compile and run but do not produce the same result as their mirrored counterpart.</p>\n<pre>\nint target = -5;\nint num = 3;\n\ntarget =- num;  // Noncompliant: target = -3. Is that the intended behavior?\ntarget =+ num; // Noncompliant: target = 3\n</pre>\n<p>This rule raises an issue when <code>=+</code>, <code>=-</code>, or <code>=!</code> are used without any space between the operators and when there\nis at least one whitespace after.</p>\n<p>Replace the operators with a single one if that is the intention</p>\n<pre>\nint target = -5;\nint num = 3;\n\ntarget -= num;  // target = -8\n</pre>\n<p>Or fix the spacing to avoid confusion</p>\n<pre>\nint target = -5;\nint num = 3;\n\ntarget = -num;  // target = -3\n</pre>",
    "howToFix": "",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "\"=+\"와 같은 존재하지 않는 연산자를 사용하면 안 됩니다",
    "why_ko": "<p>뒤집힌 단일 연산자(<code>+=</code>, <code>-=</code> 또는 <code>!=</code>)처럼 보이는 연산자 쌍(<code>=+</code>, <code>=-</code> 또는 <code>=!</code>)을 사용하면 혼란스럽습니다. 이들은 컴파일되고 실행되지만 원래 연산자와 동일한 결과를 생성하지 않습니다.</p>\n<pre>\nint target = -5;\nint num = 3;\n\ntarget =- num;  // 규칙 위반: target = -3. 이것이 의도된 동작인가요?\ntarget =+ num; // 규칙 위반: target = 3\n</pre>\n<p>이 규칙은 <code>=+</code>, <code>=-</code> 또는 <code>=!</code>가 연산자 사이에 공백 없이 사용되고 뒤에 최소 하나의 공백이 있을 때 문제를 제기합니다.</p>\n<p>의도한 것이라면 연산자를 단일 연산자로 교체하세요</p>\n<pre>\nint target = -5;\nint num = 3;\n\ntarget -= num;  // target = -8\n</pre>\n<p>또는 혼란을 피하기 위해 공백을 수정하세요</p>\n<pre>\nint target = -5;\nint num = 3;\n\ntarget = -num;  // target = -3\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": ""
  },
  {
    "id": "S3516",
    "key": "java:S3516",
    "name": "Methods returns should not be invariant",
    "type": "code-smell",
    "severity": "blocker",
    "tags": [
      "symbolic-execution"
    ],
    "why": "<p>When a method is designed to return an invariant value, it may be poor design, but it shouldn't adversely affect the outcome of your program.\nHowever, when it happens on all paths through the logic, it is surely a bug.</p>\n<p>This rule raises an issue when a method contains several <code>return</code> statements that all return the same value.</p>\n<h3>Noncompliant code example</h3>\n<pre>\nint foo(int a) {\n  int b = 12;\n  if (a == 1) {\n    return b;\n  }\n  return b;  // Noncompliant\n}\n</pre>",
    "howToFix": "",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "메서드 반환값이 불변이면 안 됩니다",
    "why_ko": "<p>메서드가 불변 값을 반환하도록 설계된 경우 잘못된 설계일 수 있지만, 프로그램의 결과에 부정적인 영향을 미치지는 않아야 합니다. 그러나 로직의 모든 경로에서 발생하는 경우 이는 분명히 버그입니다.</p>\n<p>이 규칙은 메서드에 모두 같은 값을 반환하는 여러 <code>return</code> 문이 포함된 경우 문제를 제기합니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\nint foo(int a) {\n  int b = 12;\n  if (a == 1) {\n    return b;\n  }\n  return b;  // 규칙 위반\n}\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": ""
  },
  {
    "id": "S1481",
    "key": "java:S1481",
    "name": "Unused local variables should be removed",
    "type": "code-smell",
    "severity": "minor",
    "tags": [
      "unused",
      "java22"
    ],
    "why": "<p>An unused local variable is a variable that has been declared but is not used anywhere in the block of code where it is defined. It is dead code,\ncontributing to unnecessary complexity and leading to confusion when reading the code. Therefore, it should be removed from your code to maintain\nclarity and efficiency.</p>\n<h3>What is the potential impact?</h3>\n<p>Having unused local variables in your code can lead to several issues:</p>\n<ul>\n  <li> <strong>Decreased Readability</strong>: Unused variables can make your code more difficult to read. They add extra lines and complexity, which\n  can distract from the main logic of the code. </li>\n  <li> <strong>Misunderstanding</strong>: When other developers read your code, they may wonder why a variable is declared but not used. This can lead\n  to confusion and misinterpretation of the code's intent. </li>\n  <li> <strong>Potential for Bugs</strong>: If a variable is declared but not used, it might indicate a bug or incomplete code. For example, if you\n  declared a variable intending to use it in a calculation, but then forgot to do so, your program might not work as expected. </li>\n  <li> <strong>Maintenance Issues</strong>: Unused variables can make code maintenance more difficult. If a programmer sees an unused variable, they\n  might think it is a mistake and try to 'fix' the code, potentially introducing new bugs. </li>\n  <li> <strong>Memory Usage</strong>: Although modern compilers are smart enough to ignore unused variables, not all compilers do this. In such cases,\n  unused variables take up memory space, leading to inefficient use of resources. </li>\n</ul>\n<p>In summary, unused local variables can make your code less readable, more confusing, and harder to maintain, and they can potentially lead to bugs\nor inefficient memory use. Therefore, it is best to remove them.</p>",
    "howToFix": "<p>The fix for this issue is straightforward. Once you ensure the unused variable is not part of an incomplete implementation, you just need to remove\nit.</p>\n<p>Java 22 introduces the unnamed variable pattern <code>_</code>. When a variable declared within a pattern match, an enhanced for loop, or a try\nwith resource is unused, you should replace its name with the unnamed variable pattern to clearly indicate the intent not to use the variable.</p>\n\n<h4>Noncompliant code example</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\npublic int numberOfMinutes(int hours) {\n  int seconds = 0;   // Noncompliant: \"seconds\" is unused\n  return hours * 60;\n}\n</pre>\n<pre data-diff-id=\"2\" data-diff-type=\"noncompliant\">\npublic String name(Person p) {\n  return switch (p) {\n    case User(String name, int age) -&gt; name; // Noncompliant: \"age\" is unused replace it with the unnamed variable pattern (starting from Java 22)\n    default -&gt; throw new IllegalArgumentException();\n  };\n}\n</pre>\n<pre data-diff-id=\"3\" data-diff-type=\"noncompliant\">\npublic String type(Person p) {\n  return switch (p) {\n    case User user -&gt; \"user\"; // Noncompliant:  \"user\" is unused replace it with the unnamed variable pattern (starting from Java 22)\n    default -&gt; throw new IllegalArgumentException();\n  };\n}\n</pre>\n<pre data-diff-id=\"4\" data-diff-type=\"noncompliant\">\npublic int age(Person p) {\n  if (p instanceof User(String name, int age)) { // Noncompliant:  \"name\" is unused replace it with the unnamed variable pattern (starting from Java 22)\n    return age;\n  }\n}\n</pre>\n<pre data-diff-id=\"5\" data-diff-type=\"noncompliant\">\npublic static int count(int[] elements) {\n  int count = 0;\n  for (var el : elements) { // Noncompliant:  \"el\" is unused replace it with the unnamed variable pattern (starting from Java 22)\n    count++;\n  }\n  return count;\n}\n</pre>\n<pre data-diff-id=\"6\" data-diff-type=\"noncompliant\">\npublic void foo() {\n  try (var file = Files.createTempFile(directory, \"temp\", \".txt\")) { // Noncompliant:  \"file\" is unused replace it with the unnamed variable pattern (starting from Java 22)\n    System.out.println(\"file created\");\n  }\n}\n</pre>\n<h4>Compliant solution</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\npublic int numberOfMinutes(int hours) {\n  return hours * 60;\n}\n</pre>\n<pre data-diff-id=\"2\" data-diff-type=\"compliant\">\npublic String name(Person p) {\n  return switch (p) {\n    case User(String name, _) -&gt; name; // Compliant\n    default -&gt; throw new IllegalArgumentException();\n  };\n}\n</pre>\n<pre data-diff-id=\"3\" data-diff-type=\"compliant\">\npublic String type(Person p) {\n  return switch (p) {\n    case User _ -&gt; \"user\"; // Compliant\n    default -&gt; throw new IllegalArgumentException();\n  };\n}\n</pre>\n<pre data-diff-id=\"4\" data-diff-type=\"compliant\">\npublic int age(Person p) {\n  if (p instanceof User(String _, int age)) { // Compliant\n    return age;\n  }\n}\n</pre>\n<pre data-diff-id=\"5\" data-diff-type=\"compliant\">\npublic static int count(int[] elements) {\n  int count = 0;\n  for (var _ : elements) { // Compliant\n    count++;\n  }\n  return count;\n}\n</pre>\n<pre data-diff-id=\"6\" data-diff-type=\"compliant\">\npublic void foo() {\n  try (var _ = Files.createTempFile(directory, \"temp\", \".txt\")) { // Compliant\n    System.out.println(\"file created\");\n  }\n}\n</pre>",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "사용되지 않는 지역 변수는 제거해야 합니다",
    "why_ko": "<p>사용되지 않는 지역 변수는 선언되었지만 정의된 코드 블록 내 어디에서도 사용되지 않는 변수입니다. 이는 죽은 코드로, 불필요한 복잡성을 유발하고 코드를 읽을 때 혼란을 초래합니다. 따라서 명확성과 효율성을 유지하기 위해 코드에서 제거해야 합니다.</p>\n<h3>잠재적인 영향은 무엇인가요?</h3>\n<p>코드에 사용되지 않는 지역 변수가 있으면 여러 문제가 발생할 수 있습니다:</p>\n<ul>\n  <li> <strong>가독성 저하</strong>: 사용되지 않는 변수는 코드를 읽기 더 어렵게 만들 수 있습니다. 추가 라인과 복잡성이 추가되어 코드의 주요 로직에서 주의를 분산시킬 수 있습니다. </li>\n  <li> <strong>오해</strong>: 다른 개발자가 코드를 읽을 때 변수가 선언되었지만 사용되지 않는 이유에 대해 궁금해할 수 있습니다. 이는 코드 의도의 혼란과 잘못된 해석으로 이어질 수 있습니다. </li>\n  <li> <strong>버그 가능성</strong>: 변수가 선언되었지만 사용되지 않는다면 버그나 불완전한 코드를 나타낼 수 있습니다. 예를 들어 계산에 사용하려고 변수를 선언했지만 잊어버린 경우 프로그램이 예상대로 작동하지 않을 수 있습니다. </li>\n  <li> <strong>유지보수 문제</strong>: 사용되지 않는 변수는 코드 유지보수를 더 어렵게 만들 수 있습니다. 프로그래머가 사용되지 않는 변수를 보면 실수라고 생각하고 코드를 '수정'하려고 하여 잠재적으로 새로운 버그를 도입할 수 있습니다. </li>\n  <li> <strong>메모리 사용</strong>: 현대 컴파일러는 사용되지 않는 변수를 무시할 만큼 똑똑하지만 모든 컴파일러가 그렇지는 않습니다. 이러한 경우 사용되지 않는 변수는 메모리 공간을 차지하여 리소스를 비효율적으로 사용하게 됩니다. </li>\n</ul>\n<p>요약하면 사용되지 않는 지역 변수는 코드를 덜 읽기 쉽고, 더 혼란스럽고, 유지보수하기 어렵게 만들 수 있으며, 잠재적으로 버그나 비효율적인 메모리 사용으로 이어질 수 있습니다. 따라서 제거하는 것이 가장 좋습니다.</p>",
    "howToFix_ko": "<p>이 문제의 수정은 간단합니다. 사용되지 않는 변수가 불완전한 구현의 일부가 아닌지 확인한 후 제거하면 됩니다.</p>\n<p>Java 22에서는 이름 없는 변수 패턴 <code>_</code>가 도입되었습니다. 패턴 매치, 향상된 for 루프 또는 try-with-resources 내에서 선언된 변수가 사용되지 않는 경우, 변수를 사용하지 않겠다는 의도를 명확하게 나타내기 위해 이름을 이름 없는 변수 패턴으로 대체해야 합니다.</p>\n\n<h4>규칙을 준수하지 않는 코드 예시</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\npublic int numberOfMinutes(int hours) {\n  int seconds = 0;   // 규칙 위반: \"seconds\"가 사용되지 않음\n  return hours * 60;\n}\n</pre>\n<pre data-diff-id=\"2\" data-diff-type=\"noncompliant\">\npublic String name(Person p) {\n  return switch (p) {\n    case User(String name, int age) -&gt; name; // 규칙 위반: \"age\"가 사용되지 않음, 이름 없는 변수 패턴으로 대체하세요 (Java 22부터)\n    default -&gt; throw new IllegalArgumentException();\n  };\n}\n</pre>\n<pre data-diff-id=\"3\" data-diff-type=\"noncompliant\">\npublic String type(Person p) {\n  return switch (p) {\n    case User user -&gt; \"user\"; // 규칙 위반: \"user\"가 사용되지 않음, 이름 없는 변수 패턴으로 대체하세요 (Java 22부터)\n    default -&gt; throw new IllegalArgumentException();\n  };\n}\n</pre>\n<pre data-diff-id=\"4\" data-diff-type=\"noncompliant\">\npublic int age(Person p) {\n  if (p instanceof User(String name, int age)) { // 규칙 위반: \"name\"이 사용되지 않음, 이름 없는 변수 패턴으로 대체하세요 (Java 22부터)\n    return age;\n  }\n}\n</pre>\n<pre data-diff-id=\"5\" data-diff-type=\"noncompliant\">\npublic static int count(int[] elements) {\n  int count = 0;\n  for (var el : elements) { // 규칙 위반: \"el\"이 사용되지 않음, 이름 없는 변수 패턴으로 대체하세요 (Java 22부터)\n    count++;\n  }\n  return count;\n}\n</pre>\n<pre data-diff-id=\"6\" data-diff-type=\"noncompliant\">\npublic void foo() {\n  try (var file = Files.createTempFile(directory, \"temp\", \".txt\")) { // 규칙 위반: \"file\"이 사용되지 않음, 이름 없는 변수 패턴으로 대체하세요 (Java 22부터)\n    System.out.println(\"file created\");\n  }\n}\n</pre>\n<h4>규칙을 준수하는 해결책</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\npublic int numberOfMinutes(int hours) {\n  return hours * 60;\n}\n</pre>\n<pre data-diff-id=\"2\" data-diff-type=\"compliant\">\npublic String name(Person p) {\n  return switch (p) {\n    case User(String name, _) -&gt; name; // 규칙 준수\n    default -&gt; throw new IllegalArgumentException();\n  };\n}\n</pre>\n<pre data-diff-id=\"3\" data-diff-type=\"compliant\">\npublic String type(Person p) {\n  return switch (p) {\n    case User _ -&gt; \"user\"; // 규칙 준수\n    default -&gt; throw new IllegalArgumentException();\n  };\n}\n</pre>\n<pre data-diff-id=\"4\" data-diff-type=\"compliant\">\npublic int age(Person p) {\n  if (p instanceof User(String _, int age)) { // 규칙 준수\n    return age;\n  }\n}\n</pre>\n<pre data-diff-id=\"5\" data-diff-type=\"compliant\">\npublic static int count(int[] elements) {\n  int count = 0;\n  for (var _ : elements) { // 규칙 준수\n    count++;\n  }\n  return count;\n}\n</pre>\n<pre data-diff-id=\"6\" data-diff-type=\"compliant\">\npublic void foo() {\n  try (var _ = Files.createTempFile(directory, \"temp\", \".txt\")) { // 규칙 준수\n    System.out.println(\"file created\");\n  }\n}\n</pre>",
    "moreInfo_ko": ""
  },
  {
    "id": "S1194",
    "key": "java:S1194",
    "name": "\"java.lang.Error\" should not be extended",
    "type": "code-smell",
    "severity": "major",
    "tags": [
      "error-handling"
    ],
    "why": "<p><code>java.lang.Error</code> and its subclasses represent abnormal conditions, such as <code>OutOfMemoryError</code>, which should only be\nencountered by the Java Virtual Machine.</p>\n<h3>Noncompliant code example</h3>\n<pre>\npublic class MyException extends Error { /* ... */ }       // Noncompliant\n</pre>\n<h3>Compliant solution</h3>\n<pre>\npublic class MyException extends Exception { /* ... */ }   // Compliant\n</pre>",
    "howToFix": "",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "\"java.lang.Error\"를 확장하면 안 됩니다",
    "why_ko": "<p><code>java.lang.Error</code>와 그 서브클래스는 <code>OutOfMemoryError</code>와 같이 Java Virtual Machine에서만 발생해야 하는 비정상적인 상태를 나타냅니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\npublic class MyException extends Error { /* ... */ }       // 규칙 위반\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre>\npublic class MyException extends Exception { /* ... */ }   // 규칙 준수\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": ""
  },
  {
    "id": "S6201",
    "key": "java:S6201",
    "name": "Pattern Matching for \"instanceof\" operator should be used instead of simple \"instanceof\" + cast",
    "type": "code-smell",
    "severity": "minor",
    "tags": [
      "java16"
    ],
    "why": "<p>In Java 16, the feature \"Pattern matching for instanceof\" is finalized and can&nbsp;be used in production. Previously developers needed to do 3\noperations in order to do this: check the variable type, cast it and assign the casted value to the new variable. This approach is quite verbose and\ncan be replaced with pattern matching for&nbsp;<code>instanceof</code>, doing these 3 actions (check, cast and assign) in one expression.</p>\n<p>This rule raises an issue when an <code>instanceof</code> check followed by a cast and an assignment could be replaced by pattern matching.</p>\n<h3>Noncompliant code example</h3>\n<pre>\nint f(Object o) {\n  if (o instanceof String) {&nbsp; // Noncompliant\n    String string = (String) o;\n    return string.length();\n  }\n  return 0;\n}\n</pre>\n<h3>Compliant solution</h3>\n<pre>\nint f(Object o) {\n&nbsp; if (o instanceof String string) {&nbsp; // Compliant\n&nbsp; &nbsp; return string.length();\n&nbsp; }\n&nbsp; return 0;\n}\n</pre>",
    "howToFix": "",
    "moreInfo": "<ul>\n  <li> <a href=\"https://openjdk.java.net/jeps/394\">JEP 394: Pattern Matching for instanceof</a> &nbsp; </li>\n</ul>",
    "status": "READY",
    "name_ko": "단순 \"instanceof\" + 캐스트 대신 \"instanceof\" 연산자용 패턴 매칭을 사용해야 합니다",
    "why_ko": "<p>Java 16에서 \"instanceof 패턴 매칭\" 기능이 완성되어 프로덕션에서 사용할 수 있습니다. 이전에는 개발자가 이를 위해 3가지 작업을 수행해야 했습니다: 변수 타입 확인, 캐스트, 캐스트된 값을 새 변수에 할당. 이 접근 방식은 상당히 장황하며 <code>instanceof</code> 패턴 매칭으로 대체할 수 있어 이 3가지 작업(확인, 캐스트, 할당)을 하나의 표현식으로 수행합니다.</p>\n<p>이 규칙은 <code>instanceof</code> 확인 후 캐스트와 할당이 패턴 매칭으로 대체될 수 있을 때 문제를 보고합니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\nint f(Object o) {\n  if (o instanceof String) {&nbsp; // 규칙 위반\n    String string = (String) o;\n    return string.length();\n  }\n  return 0;\n}\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre>\nint f(Object o) {\n&nbsp; if (o instanceof String string) {&nbsp; // 규칙 준수\n&nbsp; &nbsp; return string.length();\n&nbsp; }\n&nbsp; return 0;\n}\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": "<ul>\n  <li> <a href=\"https://openjdk.java.net/jeps/394\">JEP 394: instanceof 패턴 매칭</a> </li>\n</ul>"
  },
  {
    "id": "S2612",
    "key": "java:S2612",
    "name": "Setting loose POSIX file permissions is security-sensitive",
    "type": "security-hotspot",
    "severity": "major",
    "tags": [
      "cwe",
      "cert"
    ],
    "why": "<p>In Unix file system permissions, the \"<code>others</code>\" category refers to all users except the owner of the file system resource and the\nmembers of the group assigned to this resource.</p>\n<p>Granting permissions to this category can lead to unintended access to files or directories that could allow attackers to obtain sensitive\ninformation, disrupt services or elevate privileges.</p>\n",
    "howToFix": "<h2>Recommended Secure Coding Practices</h2>\n<p>The most restrictive possible permissions should be assigned to files and directories.</p>\n<h2>Compliant Solution</h2>\n<p>On operating systems that implement POSIX standard. This will throw a <code>UnsupportedOperationException</code> on Windows.</p>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\n    public void setPermissions(String filePath) throws IOException {\n        Set&lt;PosixFilePermission&gt; perms = new HashSet&lt;PosixFilePermission&gt;();\n        // user permission\n        perms.add(PosixFilePermission.OWNER_READ);\n        perms.add(PosixFilePermission.OWNER_WRITE);\n        perms.add(PosixFilePermission.OWNER_EXECUTE);\n        // group permissions\n        perms.add(PosixFilePermission.GROUP_READ);\n        perms.add(PosixFilePermission.GROUP_EXECUTE);\n        // others permissions removed\n        perms.remove(PosixFilePermission.OTHERS_READ);\n        perms.remove(PosixFilePermission.OTHERS_WRITE);\n        perms.remove(PosixFilePermission.OTHERS_EXECUTE);\n\n        Files.setPosixFilePermissions(Paths.get(filePath), perms);\n    }\n</pre>\n<pre data-diff-id=\"2\" data-diff-type=\"compliant\">\n    public void setOthersPermissionsHardCoded(String filePath ) {\n        Files.setPosixFilePermissions(Paths.get(filePath), PosixFilePermissions.fromString(\"rwxrwx---\"));\n    }\n</pre>\n<h2>See</h2>\n<ul>\n  <li> OWASP - <a href=\"https://owasp.org/Top10/A01_2021-Broken_Access_Control/\">Top 10 2021 Category A1 - Broken Access Control</a> </li>\n  <li> OWASP - <a href=\"https://owasp.org/Top10/A04_2021-Insecure_Design/\">Top 10 2021 Category A4 - Insecure Design</a> </li>\n  <li> OWASP - <a href=\"https://owasp.org/www-project-top-ten/2017/A5_2017-Broken_Access_Control\">Top 10 2017 Category A5 - Broken Access Control</a>\n  </li>\n  <li> <a\n  href=\"https://owasp.org/www-project-web-security-testing-guide/latest/4-Web_Application_Security_Testing/02-Configuration_and_Deployment_Management_Testing/09-Test_File_Permission\">OWASP File Permission</a> </li>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/732\">CWE-732 - Incorrect Permission Assignment for Critical Resource</a> </li>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/266\">CWE-266 - Incorrect Privilege Assignment</a> </li>\n  <li> <a href=\"https://wiki.sei.cmu.edu/confluence/display/java/FIO01-J.+Create+files+with+appropriate+access+permissions\">CERT, FIO01-J.</a> -\n  Create files with appropriate access permissions </li>\n  <li> <a href=\"https://wiki.sei.cmu.edu/confluence/display/c/FIO06-C.+Create+files+with+appropriate+access+permissions\">CERT, FIO06-C.</a> - Create\n  files with appropriate access permissions </li>\n  <li> STIG Viewer - <a href=\"https://stigviewer.com/stigs/application_security_and_development/2024-12-06/finding/V-222430\">Application Security and\n  Development: V-222430</a> - The application must execute without excessive account permissions. </li>\n</ul>",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "느슨한 POSIX 파일 권한 설정은 보안에 민감합니다",
    "why_ko": "<p>Unix 파일 시스템 권한에서 \"<code>others</code>\" 카테고리는 파일 시스템 리소스의 소유자와 이 리소스에 할당된 그룹의 구성원을 제외한 모든 사용자를 의미합니다.</p>\n<p>이 카테고리에 권한을 부여하면 공격자가 민감한 정보를 얻거나, 서비스를 중단시키거나, 권한을 상승시킬 수 있는 파일이나 디렉토리에 의도하지 않은 접근이 발생할 수 있습니다.</p>\n",
    "howToFix_ko": "<h2>권장 보안 코딩 관행</h2>\n<p>파일과 디렉토리에는 가능한 가장 제한적인 권한을 할당해야 합니다.</p>\n<h2>규칙을 준수하는 해결책</h2>\n<p>POSIX 표준을 구현하는 운영 체제에서. Windows에서는 <code>UnsupportedOperationException</code>이 발생합니다.</p>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\n    public void setPermissions(String filePath) throws IOException {\n        Set&lt;PosixFilePermission&gt; perms = new HashSet&lt;PosixFilePermission&gt;();\n        // 사용자 권한\n        perms.add(PosixFilePermission.OWNER_READ);\n        perms.add(PosixFilePermission.OWNER_WRITE);\n        perms.add(PosixFilePermission.OWNER_EXECUTE);\n        // 그룹 권한\n        perms.add(PosixFilePermission.GROUP_READ);\n        perms.add(PosixFilePermission.GROUP_EXECUTE);\n        // 다른 사용자 권한 제거\n        perms.remove(PosixFilePermission.OTHERS_READ);\n        perms.remove(PosixFilePermission.OTHERS_WRITE);\n        perms.remove(PosixFilePermission.OTHERS_EXECUTE);\n\n        Files.setPosixFilePermissions(Paths.get(filePath), perms);\n    }\n</pre>\n<pre data-diff-id=\"2\" data-diff-type=\"compliant\">\n    public void setOthersPermissionsHardCoded(String filePath ) {\n        Files.setPosixFilePermissions(Paths.get(filePath), PosixFilePermissions.fromString(\"rwxrwx---\"));\n    }\n</pre>\n<h2>참고</h2>\n<ul>\n  <li> OWASP - <a href=\"https://owasp.org/Top10/A01_2021-Broken_Access_Control/\">Top 10 2021 Category A1 - 취약한 접근 제어</a> </li>\n  <li> OWASP - <a href=\"https://owasp.org/Top10/A04_2021-Insecure_Design/\">Top 10 2021 Category A4 - 안전하지 않은 설계</a> </li>\n  <li> OWASP - <a href=\"https://owasp.org/www-project-top-ten/2017/A5_2017-Broken_Access_Control\">Top 10 2017 Category A5 - 취약한 접근 제어</a>\n  </li>\n  <li> <a\n  href=\"https://owasp.org/www-project-web-security-testing-guide/latest/4-Web_Application_Security_Testing/02-Configuration_and_Deployment_Management_Testing/09-Test_File_Permission\">OWASP 파일 권한</a> </li>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/732\">CWE-732 - 중요 리소스에 대한 잘못된 권한 할당</a> </li>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/266\">CWE-266 - 잘못된 권한 할당</a> </li>\n  <li> <a href=\"https://wiki.sei.cmu.edu/confluence/display/java/FIO01-J.+Create+files+with+appropriate+access+permissions\">CERT, FIO01-J.</a> -\n  적절한 접근 권한으로 파일 생성 </li>\n  <li> <a href=\"https://wiki.sei.cmu.edu/confluence/display/c/FIO06-C.+Create+files+with+appropriate+access+permissions\">CERT, FIO06-C.</a> - 적절한 접근 권한으로 파일 생성 </li>\n  <li> STIG Viewer - <a href=\"https://stigviewer.com/stigs/application_security_and_development/2024-12-06/finding/V-222430\">Application Security and\n  Development: V-222430</a> - 애플리케이션은 과도한 계정 권한 없이 실행해야 합니다. </li>\n</ul>",
    "moreInfo_ko": ""
  },
  {
    "id": "S2096",
    "key": "java:S2096",
    "name": "\"main\" should not \"throw\" anything",
    "type": "code-smell",
    "severity": "blocker",
    "tags": [
      "error-handling"
    ],
    "why": "<p>There's no reason for a <code>main</code> method to <code>throw</code> anything. After all, what's going to catch it?</p>\n<p>Instead, the method should itself gracefully handle any exceptions that may bubble up to it, attach as much contextual information as possible, and\nperform whatever logging or user communication is necessary, and <code>exit</code> with a non-zero (i.e. non-success) exit code if necessary.</p>\n<h3>Noncompliant code example</h3>\n<pre>\npublic static void main(String args[]) throws Exception { // Noncompliant\n  doSomething();\n}\n</pre>\n<h3>Compliant solution</h3>\n<pre>\npublic static void main(String args[]) {\n try {\n    doSomething();\n  } catch (Throwable t) {\n    log.error(t);\n    System.exit(1);  // Default exit code, 0, indicates success. Non-zero value means failure.\n  }\n}\n</pre>",
    "howToFix": "",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "\"main\"은 아무것도 \"throw\"하면 안 됩니다",
    "why_ko": "<p><code>main</code> 메서드가 무언가를 <code>throw</code>할 이유가 없습니다. 결국 무엇이 그것을 잡겠습니까?</p>\n<p>대신 메서드는 발생할 수 있는 모든 예외를 자체적으로 우아하게 처리하고, 가능한 많은 컨텍스트 정보를 첨부하고, 필요한 로깅이나 사용자 통신을 수행하고, 필요한 경우 0이 아닌(즉, 비성공) 종료 코드로 <code>exit</code>해야 합니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\npublic static void main(String args[]) throws Exception { // 규칙 위반\n  doSomething();\n}\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre>\npublic static void main(String args[]) {\n try {\n    doSomething();\n  } catch (Throwable t) {\n    log.error(t);\n    System.exit(1);  // 기본 종료 코드 0은 성공을 나타냅니다. 0이 아닌 값은 실패를 의미합니다.\n  }\n}\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": ""
  },
  {
    "id": "S1710",
    "key": "java:S1710",
    "name": "Annotation repetitions should not be wrapped",
    "type": "code-smell",
    "severity": "minor",
    "tags": [
      "java8"
    ],
    "why": "<p>Before Java 8, a container annotation was required as wrapper to use multiple instances of the same annotation. As of Java 8, this is no longer\nnecessary. Instead, these annotations should be used directly without a wrapper, resulting in cleaner and more readable code.</p>\n<p>This rule is automatically disabled when the project's <code>sonar.java.source</code> is lower than <code>8</code> as repeating annotations were\nintroduced in Java 8.</p>\n\n<h4>Noncompliant code example</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\n@SomeAnnotations({  // Noncompliant, wrapper annotations are not necessary in Java 8+\n  @SomeAnnotation(..a..),\n  @SomeAnnotation(..b..),\n  @SomeAnnotation(..c..),\n})\npublic class SomeClass {\n  ...\n}\n</pre>\n<h4>Compliant solution</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\n@SomeAnnotation(..a..)\n@SomeAnnotation(..b..)\n@SomeAnnotation(..c..)\npublic class SomeClass {\n  ...\n}\n</pre>",
    "howToFix": "",
    "moreInfo": "<h3>Documentation</h3>\n<ul>\n  <li> <a href=\"https://docs.oracle.com/javase/tutorial/java/annotations/repeating.html\">Repeating Annotations - The Java™ Tutorials</a> </li>\n</ul>",
    "status": "READY",
    "name_ko": "반복되는 어노테이션을 래핑하면 안 됩니다",
    "why_ko": "<p>Java 8 이전에는 동일한 어노테이션의 여러 인스턴스를 사용하려면 컨테이너 어노테이션이 래퍼로 필요했습니다. Java 8부터는 이것이 더 이상 필요하지 않습니다. 대신 이러한 어노테이션은 래퍼 없이 직접 사용해야 하며, 이로 인해 더 깔끔하고 읽기 쉬운 코드가 됩니다.</p>\n<p>반복 어노테이션은 Java 8에서 도입되었으므로 프로젝트의 <code>sonar.java.source</code>가 <code>8</code>보다 낮으면 이 규칙은 자동으로 비활성화됩니다.</p>\n\n<h4>규칙을 준수하지 않는 코드 예시</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\n@SomeAnnotations({  // 규칙 위반, Java 8+에서는 래퍼 어노테이션이 필요하지 않음\n  @SomeAnnotation(..a..),\n  @SomeAnnotation(..b..),\n  @SomeAnnotation(..c..),\n})\npublic class SomeClass {\n  ...\n}\n</pre>\n<h4>규칙을 준수하는 해결책</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\n@SomeAnnotation(..a..)\n@SomeAnnotation(..b..)\n@SomeAnnotation(..c..)\npublic class SomeClass {\n  ...\n}\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": "<h3>문서</h3>\n<ul>\n  <li> <a href=\"https://docs.oracle.com/javase/tutorial/java/annotations/repeating.html\">반복 어노테이션 - The Java™ Tutorials</a> </li>\n</ul>"
  },
  {
    "id": "S4512",
    "key": "java:S4512",
    "name": "Setting JavaBean properties is security-sensitive",
    "type": "security-hotspot",
    "severity": "critical",
    "tags": [
      "cwe",
      "cert"
    ],
    "why": "<p>Setting JavaBean properties is security sensitive. Doing it with untrusted values has led in the past to the following vulnerability:</p>\n<ul>\n  <li> <a href=\"https://www.cve.org/CVERecord?id=CVE-2014-0114\">CVE-2014-0114</a> </li>\n</ul>\n<p>JavaBeans can have their properties or nested properties set by population functions. An attacker can leverage this feature to push into the\nJavaBean malicious data that can compromise the software integrity. A typical attack will try to manipulate the ClassLoader and finally execute\nmalicious code.</p>\n<p>This rule raises an issue when:</p>\n<ul>\n  <li> BeanUtils.populate(…​) or BeanUtilsBean.populate(…​) from <a href=\"http://commons.apache.org/proper/commons-beanutils/\">Apache Commons\n  BeanUtils</a> are called </li>\n  <li> BeanUtils.setProperty(…​) or BeanUtilsBean.setProperty(…​) from <a href=\"http://commons.apache.org/proper/commons-beanutils/\">Apache Commons\n  BeanUtils</a> are called </li>\n  <li> org.springframework.beans.BeanWrapper.setPropertyValue(…​) or org.springframework.beans.BeanWrapper.setPropertyValues(…​) from Spring is called\n  </li>\n</ul>\n",
    "howToFix": "<h2>Recommended Secure Coding Practices</h2>\n<p>Sanitize all values used as JavaBean properties.</p>\n<p>Don't set any sensitive properties. Keep full control over which properties are set. If the property names are provided by an unstrusted source,\nfilter them with a whitelist.</p>\n<h2>See</h2>\n<ul>\n  <li> OWASP - <a href=\"https://owasp.org/Top10/A03_2021-Injection/\">Top 10 2021 Category A3 - Injection</a> </li>\n  <li> OWASP - <a href=\"https://owasp.org/Top10/A08_2021-Software_and_Data_Integrity_Failures/\">Top 10 2021 Category A8 - Software and Data Integrity\n  Failures</a> </li>\n  <li> OWASP - <a href=\"https://owasp.org/www-project-top-ten/2017/A1_2017-Injection\">Top 10 2017 Category A1 - Injection</a> </li>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/915\">CWE-915 - Improperly Controlled Modification of Dynamically-Determined Object\n  Attributes</a> </li>\n  <li> <a href=\"https://wiki.sei.cmu.edu/confluence/x/hDdGBQ\">CERT, MSC61-J.</a> - Do not use insecure or weak cryptographic algorithms </li>\n  <li> Derived from FindSecBugs rule <a href=\"https://find-sec-bugs.github.io/bugs.htm#BEAN_PROPERTY_INJECTION\">BEAN_PROPERTY_INJECTION</a> </li>\n</ul>",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "JavaBean 속성 설정은 보안에 민감합니다",
    "why_ko": "<p>JavaBean 속성 설정은 보안에 민감합니다. 신뢰할 수 없는 값으로 이를 수행하면 과거에 다음과 같은 취약점이 발생했습니다:</p>\n<ul>\n  <li> <a href=\"https://www.cve.org/CVERecord?id=CVE-2014-0114\">CVE-2014-0114</a> </li>\n</ul>\n<p>JavaBeans는 population 함수를 통해 속성이나 중첩 속성을 설정할 수 있습니다. 공격자는 이 기능을 활용하여 소프트웨어 무결성을 손상시킬 수 있는 악성 데이터를 JavaBean에 주입할 수 있습니다. 일반적인 공격은 ClassLoader를 조작하여 최종적으로 악성 코드를 실행하려고 시도합니다.</p>\n<p>이 규칙은 다음과 같은 경우에 문제를 제기합니다:</p>\n<ul>\n  <li> <a href=\"http://commons.apache.org/proper/commons-beanutils/\">Apache Commons BeanUtils</a>의 BeanUtils.populate(…​) 또는 BeanUtilsBean.populate(…​)가 호출될 때 </li>\n  <li> <a href=\"http://commons.apache.org/proper/commons-beanutils/\">Apache Commons BeanUtils</a>의 BeanUtils.setProperty(…​) 또는 BeanUtilsBean.setProperty(…​)가 호출될 때 </li>\n  <li> Spring의 org.springframework.beans.BeanWrapper.setPropertyValue(…​) 또는 org.springframework.beans.BeanWrapper.setPropertyValues(…​)가 호출될 때 </li>\n</ul>\n",
    "howToFix_ko": "<h2>권장 보안 코딩 방법</h2>\n<p>JavaBean 속성으로 사용되는 모든 값을 검증하세요.</p>\n<p>민감한 속성을 설정하지 마세요. 어떤 속성이 설정되는지 완전히 제어하세요. 속성 이름이 신뢰할 수 없는 소스에서 제공되는 경우 화이트리스트로 필터링하세요.</p>\n<h2>참고</h2>\n<ul>\n  <li> OWASP - <a href=\"https://owasp.org/Top10/A03_2021-Injection/\">Top 10 2021 Category A3 - Injection</a> </li>\n  <li> OWASP - <a href=\"https://owasp.org/Top10/A08_2021-Software_and_Data_Integrity_Failures/\">Top 10 2021 Category A8 - Software and Data Integrity Failures</a> </li>\n  <li> OWASP - <a href=\"https://owasp.org/www-project-top-ten/2017/A1_2017-Injection\">Top 10 2017 Category A1 - Injection</a> </li>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/915\">CWE-915 - Improperly Controlled Modification of Dynamically-Determined Object Attributes</a> </li>\n  <li> <a href=\"https://wiki.sei.cmu.edu/confluence/x/hDdGBQ\">CERT, MSC61-J.</a> - Do not use insecure or weak cryptographic algorithms </li>\n  <li> FindSecBugs 규칙에서 파생됨 <a href=\"https://find-sec-bugs.github.io/bugs.htm#BEAN_PROPERTY_INJECTION\">BEAN_PROPERTY_INJECTION</a> </li>\n</ul>",
    "moreInfo_ko": ""
  },
  {
    "id": "S6485",
    "key": "java:S6485",
    "name": "Hash-based collections with known capacity should be initialized with the proper related static method.",
    "type": "code-smell",
    "severity": "major",
    "tags": [
      "performance"
    ],
    "why": "<p>When creating an instance of HashMap or HashSet, the developer can pick a constructor with known capacity. However, the requested capacity is not\nfully allocated by default. Indeed, when the collection reaches the load factor of the collection (default: 0.75), the collection is resized on the\nfly, leading to unexpected performance issues.</p>",
    "howToFix": "<p>As of Java 19, hash-based collections provide a static method that allocates the requested capacity at construction time.</p>\n\n<h4>Noncompliant code example</h4>\n<pre>\nprivate static final int KNOWN_CAPACITY = 1_000_000;\n\npublic static Map&lt;String, Integer&gt; buildAMap() {\n    return new HashMap&lt;&gt;(KNOWN_CAPACITY); // Noncompliant\n}\n\npublic static Set&lt;String&gt; buildASet() {\n    return new HashSet&lt;&gt;(KNOWN_CAPACITY); // Noncompliant\n}\n</pre>\n<h4>Compliant solution</h4>\n<pre>\nprivate static final int KNOWN_CAPACITY = 1_000_000;\n\npublic static Map&lt;String, Integer&gt; buildABetterMap() {\n    return HashMap.newHashMap(KNOWN_CAPACITY);\n}\n\npublic static Set&lt;String&gt; buildABetterSet() {\n    return HashSet.newHashSet(KNOWN_CAPACITY);\n}\n\npublic static Set&lt;String&gt; buildABetterSet(float customLoadFactor) {\n    return new HashSet&lt;&gt;(KNOWN_CAPACITY, customLoadFactor);\n}\n</pre>",
    "moreInfo": "<h3>Documentation</h3>\n<ul>\n  <li> <a\n  href=\"https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/util/HashMap.html#newHashMap(int\">https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/util/HashMap.html#newHashMap(int</a>) </li>\n  <li> <a\n  href=\"https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/util/HashSet.html#newHashSet(int\">https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/util/HashSet.html#newHashSet(int</a>) </li>\n  <li> <a\n  href=\"https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/util/LinkedHashMap.html#newLinkedHashMap(int\">https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/util/LinkedHashMap.html#newLinkedHashMap(int</a>) </li>\n  <li> <a\n  href=\"https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/util/LinkedHashSet.html#newLinkedHashSet(int\">https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/util/LinkedHashSet.html#newLinkedHashSet(int</a>) </li>\n  <li> <a\n  href=\"https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/util/WeakHashMap.html#newWeakHashMap(int\">https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/util/WeakHashMap.html#newWeakHashMap(int</a>) </li>\n</ul>\n<p>Message:<br> Replace this call to the constructor with the better suited static method.</p>\n<p>Highlighting:<br> The infringing constructor call.</p>",
    "status": "READY",
    "name_ko": "용량이 알려진 해시 기반 컬렉션은 적절한 정적 메서드로 초기화해야 합니다",
    "why_ko": "<p>HashMap이나 HashSet 인스턴스를 생성할 때 개발자는 알려진 용량을 가진 생성자를 선택할 수 있습니다. 그러나 요청된 용량은 기본적으로 완전히 할당되지 않습니다. 실제로 컬렉션이 로드 팩터(기본값: 0.75)에 도달하면 컬렉션이 즉석에서 크기 조정되어 예상치 못한 성능 문제가 발생합니다.</p>",
    "howToFix_ko": "<p>Java 19부터 해시 기반 컬렉션은 생성 시 요청된 용량을 할당하는 정적 메서드를 제공합니다.</p>\n\n<h4>규칙을 준수하지 않는 코드 예시</h4>\n<pre>\nprivate static final int KNOWN_CAPACITY = 1_000_000;\n\npublic static Map&lt;String, Integer&gt; buildAMap() {\n    return new HashMap&lt;&gt;(KNOWN_CAPACITY); // 규칙 위반\n}\n\npublic static Set&lt;String&gt; buildASet() {\n    return new HashSet&lt;&gt;(KNOWN_CAPACITY); // 규칙 위반\n}\n</pre>\n<h4>규칙을 준수하는 해결책</h4>\n<pre>\nprivate static final int KNOWN_CAPACITY = 1_000_000;\n\npublic static Map&lt;String, Integer&gt; buildABetterMap() {\n    return HashMap.newHashMap(KNOWN_CAPACITY);\n}\n\npublic static Set&lt;String&gt; buildABetterSet() {\n    return HashSet.newHashSet(KNOWN_CAPACITY);\n}\n\npublic static Set&lt;String&gt; buildABetterSet(float customLoadFactor) {\n    return new HashSet&lt;&gt;(KNOWN_CAPACITY, customLoadFactor);\n}\n</pre>",
    "moreInfo_ko": "<h3>문서</h3>\n<ul>\n  <li> <a href=\"https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/util/HashMap.html#newHashMap(int\">https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/util/HashMap.html#newHashMap(int</a>) </li>\n  <li> <a href=\"https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/util/HashSet.html#newHashSet(int\">https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/util/HashSet.html#newHashSet(int</a>) </li>\n  <li> <a href=\"https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/util/LinkedHashMap.html#newLinkedHashMap(int\">https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/util/LinkedHashMap.html#newLinkedHashMap(int</a>) </li>\n  <li> <a href=\"https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/util/LinkedHashSet.html#newLinkedHashSet(int\">https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/util/LinkedHashSet.html#newLinkedHashSet(int</a>) </li>\n  <li> <a href=\"https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/util/WeakHashMap.html#newWeakHashMap(int\">https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/util/WeakHashMap.html#newWeakHashMap(int</a>) </li>\n</ul>\n<p>메시지:<br> 이 생성자 호출을 더 적합한 정적 메서드로 교체하세요.</p>\n<p>강조 표시:<br> 위반하는 생성자 호출.</p>"
  },
  {
    "id": "S2583",
    "key": "java:S2583",
    "name": "Conditionally executed code should be reachable",
    "type": "bug",
    "severity": "major",
    "tags": [
      "cwe",
      "symbolic-execution",
      "cert",
      "unused",
      "suspicious",
      "pitfall"
    ],
    "why": "<p>Conditional expressions which are always <code>true</code> or <code>false</code> can lead to <a\nhref=\"https://en.wikipedia.org/wiki/Unreachable_code\">unreachable code</a>.</p>\n<h3>Noncompliant code example</h3>\n<pre>\na = false;\nif (a) { // Noncompliant\n  doSomething(); // never executed\n}\n\nif (!a || b) { // Noncompliant; \"!a\" is always \"true\", \"b\" is never evaluated\n  doSomething();\n} else {\n  doSomethingElse(); // never executed\n}\n</pre>\n<h3>Exceptions</h3>\n<p>This rule will not raise an issue in either of these cases:</p>\n<ul>\n  <li> When the condition is a single <code>final boolean</code> </li>\n</ul>\n<pre>\nfinal boolean debug = false;\n//...\nif (debug) {\n  // Print something\n}\n</pre>\n<ul>\n  <li> When the condition is literally <code>true</code> or <code>false</code>. </li>\n</ul>\n<pre>\nif (true) {\n  // do something\n}\n</pre>\n<p>In these cases it is obvious the code is as intended.</p>",
    "howToFix": "",
    "moreInfo": "<ul>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/570\">CWE-570 - Expression is Always False</a> </li>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/571\">CWE-571 - Expression is Always True</a> </li>\n  <li> <a href=\"https://wiki.sei.cmu.edu/confluence/x/5dUxBQ\">CERT, MSC12-C.</a> - Detect and remove code that has no effect or is never executed\n  </li>\n</ul>",
    "status": "READY",
    "name_ko": "조건부로 실행되는 코드는 도달 가능해야 합니다",
    "why_ko": "<p>항상 <code>true</code> 또는 <code>false</code>인 조건 표현식은 <a href=\"https://en.wikipedia.org/wiki/Unreachable_code\">도달 불가능한 코드</a>로 이어질 수 있습니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\na = false;\nif (a) { // 규칙 위반\n  doSomething(); // 절대 실행되지 않음\n}\n\nif (!a || b) { // 규칙 위반; \"!a\"는 항상 \"true\"이고, \"b\"는 평가되지 않음\n  doSomething();\n} else {\n  doSomethingElse(); // 절대 실행되지 않음\n}\n</pre>\n<h3>예외 사항</h3>\n<p>이 규칙은 다음 경우에는 이슈를 제기하지 않습니다:</p>\n<ul>\n  <li> 조건이 단일 <code>final boolean</code>인 경우 </li>\n</ul>\n<pre>\nfinal boolean debug = false;\n//...\nif (debug) {\n  // 무언가 출력\n}\n</pre>\n<ul>\n  <li> 조건이 문자 그대로 <code>true</code> 또는 <code>false</code>인 경우. </li>\n</ul>\n<pre>\nif (true) {\n  // 무언가 수행\n}\n</pre>\n<p>이러한 경우 코드가 의도한 대로임이 분명합니다.</p>",
    "howToFix_ko": "",
    "moreInfo_ko": "<ul>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/570\">CWE-570 - 표현식이 항상 False</a> </li>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/571\">CWE-571 - 표현식이 항상 True</a> </li>\n  <li> <a href=\"https://wiki.sei.cmu.edu/confluence/x/5dUxBQ\">CERT, MSC12-C.</a> - 효과가 없거나 절대 실행되지 않는 코드를 감지하고 제거하세요 </li>\n</ul>"
  },
  {
    "id": "S6411",
    "key": "java:S6411",
    "name": "Types used as keys in Maps should implement Comparable",
    "type": "code-smell",
    "severity": "major",
    "tags": [],
    "why": "<p>Maps use hashes of the keys to select a bucket to store data in. Objects that hash to the same value will be added to the same bucket.</p>\n<p>When the hashing function has a poor distribution, buckets can grow to very large sizes. This may negatively affect lookup performance, as, by\ndefault, matching a key within a bucket has linear complexity.</p>\n<p>In addition, as the default hashCode function can be selected at runtime, performance expectations cannot be maintained.</p>\n<p>Implementing Comparable mitigates the performance issue for objects that hash to the same value.</p>\n<h3>Noncompliant code example</h3>\n<pre>\nclass MyKeyType {\n    // ...\n}\n\nclass Program {\n    Map&lt;MyKeyType, MyValueType&gt; data = new HashMap&lt;&gt;(); // Noncompliant\n\n    Map&lt;MyKeyType, MyValueType&gt; buildMap() { // Noncompliant\n        //...\n    }\n}\n</pre>\n<h3>Compliant solution</h3>\n<pre>\nclass MyKeyType implements Comparable&lt;MyKeyType&gt; {\n    // ...\n}\n\nclass MyChildKeyType extends MyKeyType {\n    // ...\n}\n\nclass Program {\n    Map&lt;MyKeyType, MyValueType&gt; data = new HashMap&lt;&gt;();\n    Map&lt;MyChildKeyType, MyValueType&gt; data = new HashMap&lt;&gt;();\n\n    Map&lt;MyKeyType, MyValueType&gt; buildMap() {\n        //...\n    }\n}\n</pre>",
    "howToFix": "",
    "moreInfo": "<ul>\n  <li> <a\n  href=\"https://dzone.com/articles/java-8-hashmaps-keys-and-the-comparable-interface\">https://dzone.com/articles/java-8-hashmaps-keys-and-the-comparable-interface</a> </li>\n  <li> <a\n  href=\"https://github.com/openjdk/jdk/blob/4927ee426aedbeea0f4119bac0a342c6d3576762/src/hotspot/share/runtime/synchronizer.cpp#L760-L798\">https://github.com/openjdk/jdk/blob/4927ee426aedbeea0f4119bac0a342c6d3576762/src/hotspot/share/runtime/synchronizer.cpp#L760-L798</a> </li>\n  <li> <a\n  href=\"https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/Comparable.html\">https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/Comparable.html</a> </li>\n</ul>",
    "status": "READY",
    "name_ko": "Map의 키로 사용되는 타입은 Comparable을 구현해야 합니다",
    "why_ko": "<p>Map은 키의 해시를 사용하여 데이터를 저장할 버킷을 선택합니다. 동일한 값으로 해시되는 객체는 동일한 버킷에 추가됩니다.</p>\n<p>해시 함수의 분포가 좋지 않으면 버킷이 매우 큰 크기로 커질 수 있습니다. 기본적으로 버킷 내에서 키를 매칭하는 것은 선형 복잡도를 가지므로 조회 성능에 부정적인 영향을 미칠 수 있습니다.</p>\n<p>또한 기본 hashCode 함수가 런타임에 선택될 수 있으므로 성능 기대치를 유지할 수 없습니다.</p>\n<p>Comparable을 구현하면 동일한 값으로 해시되는 객체의 성능 문제가 완화됩니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\nclass MyKeyType {\n    // ...\n}\n\nclass Program {\n    Map&lt;MyKeyType, MyValueType&gt; data = new HashMap&lt;&gt;(); // 규칙 위반\n\n    Map&lt;MyKeyType, MyValueType&gt; buildMap() { // 규칙 위반\n        //...\n    }\n}\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre>\nclass MyKeyType implements Comparable&lt;MyKeyType&gt; {\n    // ...\n}\n\nclass MyChildKeyType extends MyKeyType {\n    // ...\n}\n\nclass Program {\n    Map&lt;MyKeyType, MyValueType&gt; data = new HashMap&lt;&gt;();\n    Map&lt;MyChildKeyType, MyValueType&gt; data = new HashMap&lt;&gt;();\n\n    Map&lt;MyKeyType, MyValueType&gt; buildMap() {\n        //...\n    }\n}\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": "<ul>\n  <li> <a href=\"https://dzone.com/articles/java-8-hashmaps-keys-and-the-comparable-interface\">https://dzone.com/articles/java-8-hashmaps-keys-and-the-comparable-interface</a> </li>\n  <li> <a href=\"https://github.com/openjdk/jdk/blob/4927ee426aedbeea0f4119bac0a342c6d3576762/src/hotspot/share/runtime/synchronizer.cpp#L760-L798\">https://github.com/openjdk/jdk/blob/4927ee426aedbeea0f4119bac0a342c6d3576762/src/hotspot/share/runtime/synchronizer.cpp#L760-L798</a> </li>\n  <li> <a href=\"https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/Comparable.html\">https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/Comparable.html</a> </li>\n</ul>"
  },
  {
    "id": "S2147",
    "key": "java:S2147",
    "name": "Catches should be combined",
    "type": "code-smell",
    "severity": "minor",
    "tags": [
      "clumsy"
    ],
    "why": "<p>Since Java 7 it has been possible to catch multiple exceptions at once. Therefore, when multiple <code>catch</code> blocks have the same code, they\nshould be combined for better readability.</p>\n<p><strong>Note</strong> that this rule is automatically disabled when the project's <code>sonar.java.source</code> is lower than <code>7</code>.</p>\n<h3>Noncompliant code example</h3>\n<pre>\ncatch (IOException e) {\n  doCleanup();\n  logger.log(e);\n}\ncatch (SQLException e) {  // Noncompliant\n  doCleanup();\n  logger.log(e);\n}\ncatch (TimeoutException e) {  // Compliant; block contents are different\n  doCleanup();\n  throw e;\n}\n</pre>\n<h3>Compliant solution</h3>\n<pre>\ncatch (IOException|SQLException e) {\n  doCleanup();\n  logger.log(e);\n}\ncatch (TimeoutException e) {\n  doCleanup();\n  throw e;\n}\n</pre>",
    "howToFix": "",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "catch 블록은 결합되어야 합니다",
    "why_ko": "<p>Java 7부터 여러 예외를 한 번에 catch할 수 있습니다. 따라서 여러 <code>catch</code> 블록이 동일한 코드를 가지고 있을 때 가독성을 위해 결합해야 합니다.</p>\n<p><strong>참고</strong>: 이 규칙은 프로젝트의 <code>sonar.java.source</code>가 <code>7</code> 미만일 때 자동으로 비활성화됩니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\ncatch (IOException e) {\n  doCleanup();\n  logger.log(e);\n}\ncatch (SQLException e) {  // 규칙 위반\n  doCleanup();\n  logger.log(e);\n}\ncatch (TimeoutException e) {  // 규칙 준수; 블록 내용이 다름\n  doCleanup();\n  throw e;\n}\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre>\ncatch (IOException|SQLException e) {\n  doCleanup();\n  logger.log(e);\n}\ncatch (TimeoutException e) {\n  doCleanup();\n  throw e;\n}\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": ""
  },
  {
    "id": "S3306",
    "key": "java:S3306",
    "name": "Constructor injection should be used instead of field injection",
    "type": "bug",
    "severity": "major",
    "tags": [
      "spring",
      "design",
      "jee",
      "pitfall"
    ],
    "why": "<p>Field injection seems like a tidy way to get your classes what they need to do their jobs, but it's really a <code>NullPointerException</code>\nwaiting to happen unless all your class constructors are <code>private</code>. That's because any class instances that are constructed by callers,\nrather than instantiated by a Dependency Injection framework compliant with the JSR-330 (Spring, Guice, …​), won't have the ability to perform the\nfield injection.</p>\n<p>Instead <code>@Inject</code> should be moved to the constructor and the fields required as constructor parameters.</p>\n<p>This rule raises an issue when classes with non-<code>private</code> constructors (including the default constructor) use field injection.</p>\n<h3>Noncompliant code example</h3>\n<pre>\nclass MyComponent {  // Anyone can call the default constructor\n\n  @Inject MyCollaborator collaborator;  // Noncompliant\n\n  public void myBusinessMethod() {\n    collaborator.doSomething();  // this will fail in classes new-ed by a caller\n  }\n}\n</pre>\n<h3>Compliant solution</h3>\n<pre>\nclass MyComponent {\n\n  private final MyCollaborator collaborator;\n\n  @Inject\n  public MyComponent(MyCollaborator collaborator) {\n    Assert.notNull(collaborator, \"MyCollaborator must not be null!\");\n    this.collaborator = collaborator;\n  }\n\n  public void myBusinessMethod() {\n    collaborator.doSomething();\n  }\n}\n</pre>",
    "howToFix": "",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "필드 주입 대신 생성자 주입을 사용해야 합니다",
    "why_ko": "<p>필드 주입은 클래스가 작업을 수행하는 데 필요한 것을 얻는 깔끔한 방법처럼 보이지만, 모든 클래스 생성자가 <code>private</code>가 아닌 한 <code>NullPointerException</code>이 발생하기를 기다리는 것과 같습니다. 이는 JSR-330(Spring, Guice, …​)을 준수하는 의존성 주입 프레임워크에 의해 인스턴스화되지 않고 호출자에 의해 생성된 클래스 인스턴스는 필드 주입을 수행할 수 없기 때문입니다.</p>\n<p>대신 <code>@Inject</code>를 생성자로 옮기고 필드를 생성자 매개변수로 요구해야 합니다.</p>\n<p>이 규칙은 non-<code>private</code> 생성자(기본 생성자 포함)를 가진 클래스가 필드 주입을 사용할 때 문제를 제기합니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\nclass MyComponent {  // 누구나 기본 생성자를 호출할 수 있음\n\n  @Inject MyCollaborator collaborator;  // 규칙 위반\n\n  public void myBusinessMethod() {\n    collaborator.doSomething();  // 호출자에 의해 new된 클래스에서는 실패함\n  }\n}\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre>\nclass MyComponent {\n\n  private final MyCollaborator collaborator;\n\n  @Inject\n  public MyComponent(MyCollaborator collaborator) {\n    Assert.notNull(collaborator, \"MyCollaborator must not be null!\");\n    this.collaborator = collaborator;\n  }\n\n  public void myBusinessMethod() {\n    collaborator.doSomething();\n  }\n}\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": ""
  },
  {
    "id": "S6104",
    "key": "java:S6104",
    "name": "Map \"computeIfAbsent()\" and \"computeIfPresent()\" should not be used to add \"null\" values.",
    "type": "bug",
    "severity": "critical",
    "tags": [],
    "why": "<p>Map <a\nhref=\"https://docs.oracle.com/javase/8/docs/api/java/util/Map.html#computeIfAbsent-K-java.util.function.Function-\">computeIfAbsent</a>&nbsp;and <a\nhref=\"https://docs.oracle.com/javase/8/docs/api/java/util/Map.html#computeIfPresent-K-java.util.function.BiFunction-\">computeIfPresent</a> methods are\nconvenient to avoid the cumbersome process to check if a key exists or not, followed by the addition of the entry. However, when the function used to\ncompute the value returns <code>null</code>, the entry <code>key-&gt;null</code> will not be added to the Map. Furthermore, in the case of\n<code>computeIfPresent</code>, if the key is present the entry will be removed. These methods should therefore not be used to conditionally add an\nentry with a null value. The traditional way should be used instead.</p>\n<p>This rule raises an issue when <code>computeIfAbsent</code> or <code>computeIfPresent</code> is used with a lambda always returning null.</p>\n<h3>Noncompliant code example</h3>\n<pre>\nmap.computeIfAbsent(key, k -&gt; null); // Noncompliant, the map will not contain an entry key-&gt;null.\nmap.computeIfPresent(key, (k, oldValue) -&gt; null); // Noncompliant\n</pre>\n<h3>Compliant solution</h3>\n<pre>\nif (!map.containsKey(key)) {\n    map.put(key, null);\n}\nif (map.containsKey(key)) {\n    map.put(key, null);\n}\n</pre>",
    "howToFix": "",
    "moreInfo": "<h3>Related rules</h3>\n<ul>\n  <li> <a href='/coding_rules#rule_key=java%3AS3824'>S3824</a> - \"Map.get\" and value test should be replaced with a single method call </li>\n</ul>",
    "status": "READY",
    "name_ko": "Map의 \"computeIfAbsent()\"와 \"computeIfPresent()\"로 \"null\" 값을 추가하면 안 됩니다",
    "why_ko": "<p>Map의 <a\nhref=\"https://docs.oracle.com/javase/8/docs/api/java/util/Map.html#computeIfAbsent-K-java.util.function.Function-\">computeIfAbsent</a>와 <a\nhref=\"https://docs.oracle.com/javase/8/docs/api/java/util/Map.html#computeIfPresent-K-java.util.function.BiFunction-\">computeIfPresent</a> 메서드는 키가 존재하는지 확인한 후 항목을 추가하는 번거로운 과정을 피하는 데 편리합니다. 그러나 값을 계산하는 함수가 <code>null</code>을 반환하면, <code>key-&gt;null</code> 항목이 Map에 추가되지 않습니다. 또한, <code>computeIfPresent</code>의 경우 키가 존재하면 항목이 제거됩니다. 따라서 이 메서드들은 null 값을 가진 항목을 조건부로 추가하는 데 사용하면 안 됩니다. 대신 전통적인 방법을 사용해야 합니다.</p>\n<p>이 규칙은 <code>computeIfAbsent</code> 또는 <code>computeIfPresent</code>가 항상 null을 반환하는 람다와 함께 사용될 때 문제를 보고합니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\nmap.computeIfAbsent(key, k -&gt; null); // 규칙 위반, map에 key-&gt;null 항목이 포함되지 않음\nmap.computeIfPresent(key, (k, oldValue) -&gt; null); // 규칙 위반\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre>\nif (!map.containsKey(key)) {\n    map.put(key, null);\n}\nif (map.containsKey(key)) {\n    map.put(key, null);\n}\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": "<h3>관련 규칙</h3>\n<ul>\n  <li> <a href='/coding_rules#rule_key=java%3AS3824'>S3824</a> - \"Map.get\"과 값 테스트는 단일 메서드 호출로 대체해야 합니다 </li>\n</ul>"
  },
  {
    "id": "S1157",
    "key": "java:S1157",
    "name": "Case insensitive string comparisons should be made without intermediate upper or lower casing",
    "type": "code-smell",
    "severity": "minor",
    "tags": [
      "performance",
      "clumsy"
    ],
    "why": "<p>Using <code>toLowerCase()</code> or <code>toUpperCase()</code> to make case insensitive comparisons is inefficient because it requires the creation\nof temporary, intermediate <code>String</code> objects.</p>\n<h3>Noncompliant code example</h3>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\nprivate void compareStrings(String foo, String bar){\n    boolean result1 = foo.toUpperCase().equals(bar);               // Noncompliant\n    boolean result2 = foo.equals(bar.toUpperCase());               // Noncompliant\n    boolean result3 = foo.toLowerCase().equals(bar.toLowerCase()); // Noncompliant\n}\n</pre>\n<h3>Compliant solution</h3>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\nprivate void compareStrings(String foo, String bar){\n    boolean result1 = foo.equalsIgnoreCase(bar);                    // Compliant\n}\n</pre>\n<h3>Exceptions</h3>\n<p>No issue will be raised when a locale is specified because the result could be different from <code>equalsIgnoreCase()</code>. (e.g.: using the\nTurkish locale)</p>\n<pre>\nprivate void compareStrings(String foo, String bar, java.util.Locale locale){\n    boolean result1 = foo.toUpperCase(locale).equals(bar);         // Compliant\n}\n</pre>",
    "howToFix": "",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "대소문자 구분 없는 문자열 비교는 중간에 대소문자 변환 없이 수행해야 합니다",
    "why_ko": "<p>대소문자를 구분하지 않는 비교를 위해 <code>toLowerCase()</code> 또는 <code>toUpperCase()</code>를 사용하는 것은 임시 중간 <code>String</code> 객체를 생성해야 하므로 비효율적입니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\nprivate void compareStrings(String foo, String bar){\n    boolean result1 = foo.toUpperCase().equals(bar);               // 규칙 위반\n    boolean result2 = foo.equals(bar.toUpperCase());               // 규칙 위반\n    boolean result3 = foo.toLowerCase().equals(bar.toLowerCase()); // 규칙 위반\n}\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\nprivate void compareStrings(String foo, String bar){\n    boolean result1 = foo.equalsIgnoreCase(bar);                    // 규칙 준수\n}\n</pre>\n<h3>예외 사항</h3>\n<p>로케일이 지정되면 결과가 <code>equalsIgnoreCase()</code>와 다를 수 있으므로 이슈가 제기되지 않습니다. (예: 터키어 로케일 사용 시)</p>\n<pre>\nprivate void compareStrings(String foo, String bar, java.util.Locale locale){\n    boolean result1 = foo.toUpperCase(locale).equals(bar);         // 규칙 준수\n}\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": ""
  },
  {
    "id": "S1854",
    "key": "java:S1854",
    "name": "Unused assignments should be removed",
    "type": "code-smell",
    "severity": "major",
    "tags": [
      "cwe",
      "cert",
      "unused"
    ],
    "why": "<p>Dead stores refer to assignments made to local variables that are subsequently never used or immediately overwritten. Such assignments are\nunnecessary and don't contribute to the functionality or clarity of the code. They may even negatively impact performance. Removing them enhances code\ncleanliness and readability. Even if the unnecessary operations do not do any harm in terms of the program's correctness, they are - at best - a waste\nof computing resources.</p>\n<h3>Exceptions</h3>\n<p>This rule ignores initializations to <code>-1</code>, <code>0</code>, <code>1</code>, <code>null</code>, <code>true</code>, <code>false</code> and\n<code>\"\"</code>.</p>",
    "howToFix": "<p>Remove the unnecessary assignment, then test the code to make sure that the right-hand side of a given assignment had no side effects (e.g. a\nmethod that writes certain data to a file and returns the number of written bytes).</p>\n\n<h4>Noncompliant code example</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\nint foo(int y) {\n  int x = 100; // Noncompliant: dead store\n  x = 150;     // Noncompliant: dead store\n  x = 200;\n  return x + y;\n}\n</pre>\n<h4>Compliant solution</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\nint foo(int y) {\n  int x = 200; // Compliant: no unnecessary assignment\n  return x + y;\n}\n</pre>",
    "moreInfo": "<h3>Standards</h3>\n<ul>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/563\">CWE-563 - Assignment to Variable without Use ('Unused Variable')</a> </li>\n</ul>\n<h3>Related rules</h3>\n<ul>\n  <li> <a href='/coding_rules#rule_key=java%3AS2583'>S2583</a> - Conditionally executed code should be reachable </li>\n  <li> <a href='/coding_rules#rule_key=java%3AS2589'>S2589</a> - Boolean expressions should not be gratuitous </li>\n  <li> <a href='/coding_rules#rule_key=java%3AS3516'>S3516</a> - Methods returns should not be invariant </li>\n  <li> <a href='/coding_rules#rule_key=java%3AS3626'>S3626</a> - Jump statements should not be redundant </li>\n</ul>",
    "status": "READY",
    "name_ko": "사용되지 않는 할당은 제거해야 합니다",
    "why_ko": "<p>데드 스토어는 이후에 사용되지 않거나 즉시 덮어쓰여지는 지역 변수에 대한 할당을 의미합니다. 이러한 할당은 불필요하며 코드의 기능이나 명확성에 기여하지 않습니다. 심지어 성능에 부정적인 영향을 미칠 수도 있습니다. 이를 제거하면 코드의 깔끔함과 가독성이 향상됩니다. 불필요한 작업이 프로그램의 정확성 측면에서 해를 끼치지 않더라도, 최소한 컴퓨팅 리소스 낭비입니다.</p>\n<h3>예외</h3>\n<p>이 규칙은 <code>-1</code>, <code>0</code>, <code>1</code>, <code>null</code>, <code>true</code>, <code>false</code>, <code>\"\"</code>로의 초기화는 무시합니다.</p>",
    "howToFix_ko": "<p>불필요한 할당을 제거한 다음, 주어진 할당의 오른쪽이 부작용이 없었는지 확인하기 위해 코드를 테스트하세요(예: 특정 데이터를 파일에 쓰고 쓴 바이트 수를 반환하는 메서드).</p>\n\n<h4>규칙을 준수하지 않는 코드 예시</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\nint foo(int y) {\n  int x = 100; // 규칙 위반: 데드 스토어\n  x = 150;     // 규칙 위반: 데드 스토어\n  x = 200;\n  return x + y;\n}\n</pre>\n<h4>규칙을 준수하는 해결책</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\nint foo(int y) {\n  int x = 200; // 규칙 준수: 불필요한 할당 없음\n  return x + y;\n}\n</pre>",
    "moreInfo_ko": "<h3>표준</h3>\n<ul>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/563\">CWE-563 - 사용하지 않는 변수에 대한 할당('사용되지 않는 변수')</a> </li>\n</ul>\n<h3>관련 규칙</h3>\n<ul>\n  <li> <a href='/coding_rules#rule_key=java%3AS2583'>S2583</a> - 조건부로 실행되는 코드는 도달 가능해야 합니다 </li>\n  <li> <a href='/coding_rules#rule_key=java%3AS2589'>S2589</a> - 불필요한 부울 표현식을 사용하면 안 됩니다 </li>\n  <li> <a href='/coding_rules#rule_key=java%3AS3516'>S3516</a> - 메서드 반환값은 불변이면 안 됩니다 </li>\n  <li> <a href='/coding_rules#rule_key=java%3AS3626'>S3626</a> - 점프 문은 중복되면 안 됩니다 </li>\n</ul>"
  },
  {
    "id": "S6915",
    "key": "java:S6915",
    "name": "\"String.indexOf\" should be used with correct ranges",
    "type": "bug",
    "severity": "major",
    "tags": [
      "java21"
    ],
    "why": "<p>Java 21 adds new <code>String.indexOf</code> methods that accept ranges (<code>beginIndex</code>, to <code>endIndex</code>) rather than just a\nstart index. A <code>StringIndexOutOfBounds</code> can be thrown when indicating an invalid range, namely when:</p>\n<ul>\n  <li> <code>beginIndex &gt; endIndex</code> (eg: <code>beginIndex</code> and <code>endIndex</code> arguments are mistakenly reversed) </li>\n  <li> <code>beginIndex &lt; 0</code> (eg: because the older <code>String.indexOf(what, fromIndex)</code> accepts negative values) </li>\n</ul>",
    "howToFix": "<ul>\n  <li> Use <code>String.indexOf(what, beginIndex, endIndex)</code> instead of <code>String.indexOf(what, endIndex, beginIndex)</code>. </li>\n  <li> Use <code>String.indexOf(what, 0, endIndex)</code> instead of <code>String.indexOf(what, -1, endIndex)</code>. </li>\n</ul>\n\n<h4>Noncompliant code example</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\nString hello = \"Hello, world!\";\nint index = hello.indexOf('o', 11, 7); // Noncompliant, 11..7 is not a valid range\n</pre>\n<h4>Compliant solution</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\nString hello = \"Hello, world!\";\nint index = hello.indexOf('o', 7, 11); // Compliant\n</pre>\n<h4>Noncompliant code example</h4>\n<pre data-diff-id=\"2\" data-diff-type=\"noncompliant\">\nString hello = \"Hello, world!\";\nint index = hello.indexOf('o', -1, 11); // Noncompliant, because beginIndex is negative\n</pre>\n<h4>Compliant solution</h4>\n<pre data-diff-id=\"2\" data-diff-type=\"compliant\">\nString hello = \"Hello, world!\";\nint index = hello.indexOf('o', 0, 11); // Compliant\n</pre>",
    "moreInfo": "<ul>\n  <li> Java Documentation - <a\n  href=\"https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/String.html#indexOf(int,int,int)\">String.indexOf(int, int, int)</a>\n  </li>\n  <li> Java Documentation - <a\n  href=\"https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/String.html#indexOf(java.lang.String,int,int)\">String.indexOf(java.lang.String,int,int)</a> </li>\n</ul>",
    "status": "READY",
    "name_ko": "String.indexOf는 올바른 범위와 함께 사용해야 합니다",
    "why_ko": "<p>Java 21에서는 시작 인덱스만이 아닌 범위(<code>beginIndex</code>에서 <code>endIndex</code>까지)를 받는 새로운 <code>String.indexOf</code> 메서드가 추가되었습니다. 유효하지 않은 범위를 지정하면 <code>StringIndexOutOfBounds</code>가 발생할 수 있습니다. 특히 다음과 같은 경우:</p>\n<ul>\n  <li> <code>beginIndex &gt; endIndex</code>인 경우 (예: <code>beginIndex</code>와 <code>endIndex</code> 인수가 실수로 뒤바뀐 경우) </li>\n  <li> <code>beginIndex &lt; 0</code>인 경우 (예: 이전 <code>String.indexOf(what, fromIndex)</code>가 음수 값을 허용했기 때문) </li>\n</ul>",
    "howToFix_ko": "<ul>\n  <li> <code>String.indexOf(what, endIndex, beginIndex)</code> 대신 <code>String.indexOf(what, beginIndex, endIndex)</code>를 사용하세요. </li>\n  <li> <code>String.indexOf(what, -1, endIndex)</code> 대신 <code>String.indexOf(what, 0, endIndex)</code>를 사용하세요. </li>\n</ul>\n\n<h4>규칙을 준수하지 않는 코드 예시</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\nString hello = \"Hello, world!\";\nint index = hello.indexOf('o', 11, 7); // 규칙 위반, 11..7은 유효한 범위가 아닙니다\n</pre>\n<h4>규칙을 준수하는 해결책</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\nString hello = \"Hello, world!\";\nint index = hello.indexOf('o', 7, 11); // 규칙 준수\n</pre>\n<h4>규칙을 준수하지 않는 코드 예시</h4>\n<pre data-diff-id=\"2\" data-diff-type=\"noncompliant\">\nString hello = \"Hello, world!\";\nint index = hello.indexOf('o', -1, 11); // 규칙 위반, beginIndex가 음수이기 때문\n</pre>\n<h4>규칙을 준수하는 해결책</h4>\n<pre data-diff-id=\"2\" data-diff-type=\"compliant\">\nString hello = \"Hello, world!\";\nint index = hello.indexOf('o', 0, 11); // 규칙 준수\n</pre>",
    "moreInfo_ko": "<ul>\n  <li> Java 문서 - <a href=\"https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/String.html#indexOf(int,int,int)\">String.indexOf(int, int, int)</a> </li>\n  <li> Java 문서 - <a href=\"https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/String.html#indexOf(java.lang.String,int,int)\">String.indexOf(java.lang.String,int,int)</a> </li>\n</ul>"
  },
  {
    "id": "S2055",
    "key": "java:S2055",
    "name": "The non-serializable super class of a \"Serializable\" class should have a no-argument constructor",
    "type": "bug",
    "severity": "minor",
    "tags": [
      "serialization"
    ],
    "why": "<p>Java serialization is the conversion from objects to byte streams for storage or transmission. And later, java deserialization is the reverse\nconversion, it reconstructs objects from byte streams.</p>\n<p>To make a java class serializable, this class should implement the <code>java.io.Serializable</code> interface directly or through its\ninheritance.</p>\n<pre>\nimport java.io.Serializable;\n\npublic class NonSerializableClass {\n}\n\npublic class SerializableClass implements Serializable {\n}\n\npublic class OtherSerializableClass extends SerializableClass {\n  // is also serializable because it is a subtype of Serializable\n}\n</pre>\n<p>Given a serializable class, it is important to note that not all its superclasses are serializable. Eventually, its superclasses stop implementing\n<code>java.io.Serializable</code>. It could be at the end, once reaching the <code>java.lang.Object</code> class, or before.</p>\n<p>This is important because the serialization/deserialization runs through the class hierarchy of an object to decide which object fields to write or\nread, and applies two different logics:</p>\n<ul>\n  <li> When the class is serializable:\n    <ul>\n      <li> Serialization saves the class reference and the object fields of this class. </li>\n      <li> Deserialization instantiates a new object of this class without using a constructor, and restores the object fields of this class. </li>\n    </ul>  </li>\n  <li> When the class is not serializable:\n    <ul>\n      <li> Serialization only saves the class reference and <strong>ignores</strong> the object fields of this class. </li>\n      <li> Deserialization instantiates a new object of this class using the <strong>no-argument constructor</strong> and does not restore the object\n      fields of this class. </li>\n    </ul>  </li>\n</ul>\n<p>So developers should pay particular attention to the non-serializable classes in the class hierarchy, because the presence of an implicit or\nexplicit <strong>no-argument constructor</strong> is required in those classes.</p>\n<p>This is an example of mandatory no-argument constructors in the hierarchy of <code>SerializableClass</code>:</p>\n<pre>\npublic class NonSerializableClassWithoutConstructor {\n  // after deserialization, \"field1\" will always be set to 42\n  private int field1 = 42;\n\n  // this non-serializable class has an implicit no-argument constructor\n}\n\npublic class NonSerializableClass extends NonSerializableClassWithoutConstructor {\n  // after deserialization, \"field2\" will always be set to 12 by the no-argument constructor\n  private int field2;\n\n  // this non-serializable class has an explicit no-argument constructor\n  public NonSerializableClass() {\n    field2 = 12;\n  }\n\n  public NonSerializableClass(int field2) {\n    this.field2 = field2;\n  }\n}\n\npublic class SerializableClass extends NonSerializableClass implements Serializable {\n  // after deserialization, \"field3\" will have the previously serialized value.\n  private int field3;\n\n  // deserialization does not use declared constructors\n  public SerializableClass(int field3) {\n    super(field3 * 2);\n    this.field3 = field3;\n  }\n}\n</pre>\n<p>Unfortunately, there is no compilation error when a class implements <code>java.io.Serializable</code> and extends a non-serializable superclass\nwithout a no-argument constructor. This is an issue because, at runtime, deserialization will fail to find the required constructor.</p>\n<p>For example, deserialization of an instance of the following <code>SerializableClass</code> class, throws an <code>InvalidClassException: no valid\nconstructor</code>.</p>\n<pre>\npublic class NonSerializableClass {\n  private int field;\n  // this class can not be deserialized because it does not have any implicit or explicit no-argument constructor\n  public NonSerializableClass(int field) {\n    this.field = field;\n  }\n}\n\npublic class SerializableClass extends NonSerializableClass implements Serializable {\n}\n</pre>\n<p>This rule checks in the hierarchy of serializable classes and reports an issue when a non-serializable superclass does not have the required\nno-argument constructor which will produce a runtime error.</p>",
    "howToFix": "<p>There are two solutions to fix the missing <strong>no-argument constructor</strong> issue on non-serializable classes:</p>\n<ul>\n  <li> <code>Solution 1</code> If the fields of a non-serializable class need to be persisted, add the <code>java.io.Serializable</code> interface to\n  the class <code>implements</code> definition. </li>\n  <li> <code>Solution 2</code> Otherwise, add a no-argument constructor and initialize the fields with some valid default values. </li>\n</ul>\n\n<p><strong>Example #1</strong></p>\n<h4>Noncompliant code example</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\n// Noncompliant; this Raspberry's ancestor doesn't have a no-argument constructor\n// this rule raises an issue on the Raspberry class declaration\npublic class Fruit {\n  private Season pickingSeason;\n  public Fruit(Season pickingSeason) {\n    this.pickingSeason = pickingSeason;\n  }\n}\n</pre>\n<pre>\npublic class Raspberry extends Fruit implements Serializable {\n  private static final long serialVersionUID = 1;\n  private String variety;\n  public Raspberry(String variety) {\n    super(Season.SUMMER);\n    this.variety = variety;\n  }\n}\n</pre>\n<h4>Compliant solution</h4>\n<p><code>Solution 1</code></p>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\n// Compliant; this Raspberry's ancestor is serializable\npublic class Fruit implements Serializable {\n  private static final long serialVersionUID = 1;\n  private Season pickingSeason;\n  public Fruit(Season pickingSeason) {\n    this.pickingSeason = pickingSeason;\n  }\n}\n</pre>\n<p><strong>Example #2</strong></p>\n<h4>Noncompliant code example</h4>\n<pre data-diff-id=\"2\" data-diff-type=\"noncompliant\">\npublic class Fruit {\n  // Noncompliant; this Raspberry's ancestor doesn't have a no-argument constructor\n  // this rule raises an issue on the Raspberry class declaration\n  public Fruit(String debugMessage) {\n    LOG.debug(debugMessage);\n  }\n}\n</pre>\n<pre>\npublic class Raspberry extends Fruit implements Serializable {\n  private static final long serialVersionUID = 1;\n  private String variety;\n  public Raspberry(String variety) {\n    super(\"From Raspberry constructor\");\n    this.variety = variety;\n  }\n}\n</pre>\n<h4>Compliant solution</h4>\n<p><code>Solution 2</code></p>\n<pre data-diff-id=\"2\" data-diff-type=\"compliant\">\npublic class Fruit {\n  // Compliant; this Raspberry ancestor has a no-argument constructor\n  public Fruit() {\n    this(\"From serialization\");\n  }\n  public Fruit(String debugMessage) {\n    LOG.debug(debugMessage);\n  }\n}\n</pre>",
    "moreInfo": "<h3>Documentation</h3>\n<ul>\n  <li> <a href=\"https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/io/Serializable.html\">Oracle SDK - java.io.Serializable</a> </li>\n</ul>",
    "status": "READY",
    "name_ko": "\"Serializable\" 클래스의 직렬화 불가능한 상위 클래스는 인자 없는 생성자를 가져야 합니다",
    "why_ko": "<p>Java 직렬화는 저장 또는 전송을 위해 객체를 바이트 스트림으로 변환하는 것입니다. 그리고 나중에 Java 역직렬화는 역변환으로 바이트 스트림에서 객체를 재구성합니다.</p>\n<p>Java 클래스를 직렬화 가능하게 만들려면 이 클래스가 직접 또는 상속을 통해 <code>java.io.Serializable</code> 인터페이스를 구현해야 합니다.</p>\n<pre>\nimport java.io.Serializable;\n\npublic class NonSerializableClass {\n}\n\npublic class SerializableClass implements Serializable {\n}\n\npublic class OtherSerializableClass extends SerializableClass {\n  // Serializable의 하위 타입이므로 역시 직렬화 가능합니다\n}\n</pre>\n<p>직렬화 가능한 클래스가 주어지면 모든 상위 클래스가 직렬화 가능한 것은 아니라는 점에 유의해야 합니다. 결국 상위 클래스는 <code>java.io.Serializable</code> 구현을 중단합니다. 이는 <code>java.lang.Object</code> 클래스에 도달할 때 끝나거나 그 전에 끝날 수 있습니다.</p>\n<p>이것이 중요한 이유는 직렬화/역직렬화가 객체의 클래스 계층 구조를 통해 실행되어 어떤 객체 필드를 쓰거나 읽을지 결정하고 두 가지 다른 로직을 적용하기 때문입니다:</p>\n<ul>\n  <li> 클래스가 직렬화 가능한 경우:\n    <ul>\n      <li> 직렬화는 클래스 참조와 이 클래스의 객체 필드를 저장합니다. </li>\n      <li> 역직렬화는 생성자를 사용하지 않고 이 클래스의 새 객체를 인스턴스화하고 이 클래스의 객체 필드를 복원합니다. </li>\n    </ul>  </li>\n  <li> 클래스가 직렬화 가능하지 않은 경우:\n    <ul>\n      <li> 직렬화는 클래스 참조만 저장하고 이 클래스의 객체 필드를 <strong>무시</strong>합니다. </li>\n      <li> 역직렬화는 <strong>인자 없는 생성자</strong>를 사용하여 이 클래스의 새 객체를 인스턴스화하고 이 클래스의 객체 필드를 복원하지 않습니다. </li>\n    </ul>  </li>\n</ul>\n<p>따라서 개발자는 클래스 계층 구조에서 직렬화 불가능한 클래스에 특별히 주의해야 합니다. 해당 클래스에서 암시적 또는 명시적 <strong>인자 없는 생성자</strong>의 존재가 필요하기 때문입니다.</p>\n<p>다음은 <code>SerializableClass</code> 계층 구조에서 필수 인자 없는 생성자의 예입니다:</p>\n<pre>\npublic class NonSerializableClassWithoutConstructor {\n  // 역직렬화 후 \"field1\"은 항상 42로 설정됩니다\n  private int field1 = 42;\n\n  // 이 직렬화 불가능한 클래스는 암시적 인자 없는 생성자를 가집니다\n}\n\npublic class NonSerializableClass extends NonSerializableClassWithoutConstructor {\n  // 역직렬화 후 \"field2\"는 항상 인자 없는 생성자에 의해 12로 설정됩니다\n  private int field2;\n\n  // 이 직렬화 불가능한 클래스는 명시적 인자 없는 생성자를 가집니다\n  public NonSerializableClass() {\n    field2 = 12;\n  }\n\n  public NonSerializableClass(int field2) {\n    this.field2 = field2;\n  }\n}\n\npublic class SerializableClass extends NonSerializableClass implements Serializable {\n  // 역직렬화 후 \"field3\"은 이전에 직렬화된 값을 갖습니다.\n  private int field3;\n\n  // 역직렬화는 선언된 생성자를 사용하지 않습니다\n  public SerializableClass(int field3) {\n    super(field3 * 2);\n    this.field3 = field3;\n  }\n}\n</pre>\n<p>안타깝게도 클래스가 <code>java.io.Serializable</code>을 구현하고 인자 없는 생성자가 없는 직렬화 불가능한 상위 클래스를 확장할 때 컴파일 오류가 발생하지 않습니다. 이것은 런타임에 역직렬화가 필요한 생성자를 찾지 못하기 때문에 문제가 됩니다.</p>\n<p>예를 들어 다음 <code>SerializableClass</code> 클래스의 인스턴스를 역직렬화하면 <code>InvalidClassException: no valid constructor</code>가 발생합니다.</p>\n<pre>\npublic class NonSerializableClass {\n  private int field;\n  // 이 클래스는 암시적 또는 명시적 인자 없는 생성자가 없으므로 역직렬화할 수 없습니다\n  public NonSerializableClass(int field) {\n    this.field = field;\n  }\n}\n\npublic class SerializableClass extends NonSerializableClass implements Serializable {\n}\n</pre>\n<p>이 규칙은 직렬화 가능한 클래스의 계층 구조를 확인하고 직렬화 불가능한 상위 클래스에 필요한 인자 없는 생성자가 없어 런타임 오류가 발생할 때 문제를 보고합니다.</p>",
    "howToFix_ko": "<p>직렬화 불가능한 클래스에서 누락된 <strong>인자 없는 생성자</strong> 문제를 수정하는 두 가지 솔루션이 있습니다:</p>\n<ul>\n  <li> <code>솔루션 1</code> 직렬화 불가능한 클래스의 필드가 영속화되어야 하는 경우 클래스 <code>implements</code> 정의에 <code>java.io.Serializable</code> 인터페이스를 추가합니다. </li>\n  <li> <code>솔루션 2</code> 그렇지 않으면 인자 없는 생성자를 추가하고 유효한 기본값으로 필드를 초기화합니다. </li>\n</ul>\n\n<p><strong>예시 #1</strong></p>\n<h4>규칙을 준수하지 않는 코드 예시</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\n// 규칙 위반; 이 Raspberry의 조상에 인자 없는 생성자가 없습니다\n// 이 규칙은 Raspberry 클래스 선언에서 문제를 제기합니다\npublic class Fruit {\n  private Season pickingSeason;\n  public Fruit(Season pickingSeason) {\n    this.pickingSeason = pickingSeason;\n  }\n}\n</pre>\n<pre>\npublic class Raspberry extends Fruit implements Serializable {\n  private static final long serialVersionUID = 1;\n  private String variety;\n  public Raspberry(String variety) {\n    super(Season.SUMMER);\n    this.variety = variety;\n  }\n}\n</pre>\n<h4>규칙을 준수하는 해결책</h4>\n<p><code>솔루션 1</code></p>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\n// 규칙 준수; 이 Raspberry의 조상이 직렬화 가능합니다\npublic class Fruit implements Serializable {\n  private static final long serialVersionUID = 1;\n  private Season pickingSeason;\n  public Fruit(Season pickingSeason) {\n    this.pickingSeason = pickingSeason;\n  }\n}\n</pre>\n<p><strong>예시 #2</strong></p>\n<h4>규칙을 준수하지 않는 코드 예시</h4>\n<pre data-diff-id=\"2\" data-diff-type=\"noncompliant\">\npublic class Fruit {\n  // 규칙 위반; 이 Raspberry의 조상에 인자 없는 생성자가 없습니다\n  // 이 규칙은 Raspberry 클래스 선언에서 문제를 제기합니다\n  public Fruit(String debugMessage) {\n    LOG.debug(debugMessage);\n  }\n}\n</pre>\n<pre>\npublic class Raspberry extends Fruit implements Serializable {\n  private static final long serialVersionUID = 1;\n  private String variety;\n  public Raspberry(String variety) {\n    super(\"From Raspberry constructor\");\n    this.variety = variety;\n  }\n}\n</pre>\n<h4>규칙을 준수하는 해결책</h4>\n<p><code>솔루션 2</code></p>\n<pre data-diff-id=\"2\" data-diff-type=\"compliant\">\npublic class Fruit {\n  // 규칙 준수; 이 Raspberry 조상에 인자 없는 생성자가 있습니다\n  public Fruit() {\n    this(\"From serialization\");\n  }\n  public Fruit(String debugMessage) {\n    LOG.debug(debugMessage);\n  }\n}\n</pre>",
    "moreInfo_ko": "<h3>문서</h3>\n<ul>\n  <li> <a href=\"https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/io/Serializable.html\">Oracle SDK - java.io.Serializable</a> </li>\n</ul>"
  },
  {
    "id": "S5790",
    "key": "java:S5790",
    "name": "JUnit5 inner test classes should be annotated with @Nested",
    "type": "bug",
    "severity": "critical",
    "tags": [
      "junit",
      "tests"
    ],
    "why": "<p>If not annotated with <code>@Nested</code>, an inner class containing some tests will never be executed during tests execution. While you could\nstill be able to manually run its tests in an IDE, it won't be the case during the build. By contrast, a static nested class containing some tests\nshould not be annotated with <code>@Nested</code>, JUnit5 will not share setup and state with an instance of its enclosing class.</p>\n<p>This rule raises an issue on inner classes and static nested classes containing JUnit5 test methods which has a wrong usage of <code>@Nested</code>\nannotation.</p>\n<p>Note: This rule does not check if the context in which JUnit 5 is running (e.g. Maven Surefire Plugin) is properly configured to execute static\nnested classes, it could not be the case using the default configuration.</p>\n<h3>Noncompliant code example</h3>\n<pre>\nimport org.junit.jupiter.api.Test;\n\nclass MyJunit5Test {\n  @Test\n  void test() { /* ... */ }\n\n  class InnerClassTest { // Noncompliant, missing @Nested annotation\n    @Test\n    void test() { /* ... */ }\n  }\n\n  @Nested\n  static class StaticNestedClassTest { // Noncompliant, invalid usage of @Nested annotation\n    @Test\n    void test() { /* ... */ }\n  }\n}\n</pre>\n<h3>Compliant solution</h3>\n<pre>\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.api.Nested;\n\nclass MyJunit5Test {\n  @Test\n  void test() { /* ... */ }\n\n  @Nested\n  class InnerClassTest {\n    @Test\n    void test() { /* ... */ }\n  }\n\n  static class StaticNestedClassTest {\n    @Test\n    void test() { /* ... */ }\n  }\n}\n</pre>",
    "howToFix": "",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "JUnit5 내부 테스트 클래스에는 @Nested 어노테이션을 붙여야 합니다",
    "why_ko": "<p><code>@Nested</code> 어노테이션이 없으면 테스트를 포함하는 내부 클래스는 테스트 실행 중에 절대 실행되지 않습니다. IDE에서 수동으로 테스트를 실행할 수 있지만 빌드 중에는 그렇지 않습니다. 반대로 테스트를 포함하는 정적 중첩 클래스에는 <code>@Nested</code> 어노테이션을 붙이면 안 됩니다. JUnit5는 둘러싸는 클래스의 인스턴스와 설정 및 상태를 공유하지 않습니다.</p>\n<p>이 규칙은 <code>@Nested</code> 어노테이션을 잘못 사용하는 JUnit5 테스트 메서드를 포함하는 내부 클래스와 정적 중첩 클래스에 대해 문제를 제기합니다.</p>\n<p>참고: 이 규칙은 JUnit 5가 실행되는 컨텍스트(예: Maven Surefire 플러그인)가 정적 중첩 클래스를 실행하도록 올바르게 구성되었는지 확인하지 않습니다. 기본 구성을 사용하면 그렇지 않을 수 있습니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\nimport org.junit.jupiter.api.Test;\n\nclass MyJunit5Test {\n  @Test\n  void test() { /* ... */ }\n\n  class InnerClassTest { // 규칙 위반, @Nested 어노테이션 누락\n    @Test\n    void test() { /* ... */ }\n  }\n\n  @Nested\n  static class StaticNestedClassTest { // 규칙 위반, @Nested 어노테이션의 잘못된 사용\n    @Test\n    void test() { /* ... */ }\n  }\n}\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre>\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.api.Nested;\n\nclass MyJunit5Test {\n  @Test\n  void test() { /* ... */ }\n\n  @Nested\n  class InnerClassTest {\n    @Test\n    void test() { /* ... */ }\n  }\n\n  static class StaticNestedClassTest {\n    @Test\n    void test() { /* ... */ }\n  }\n}\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": ""
  },
  {
    "id": "S1696",
    "key": "java:S1696",
    "name": "\"NullPointerException\" should not be caught",
    "type": "code-smell",
    "severity": "major",
    "tags": [
      "cwe",
      "error-handling",
      "cert"
    ],
    "why": "<p><code>NullPointerException</code> should be avoided, not caught. Any situation in which <code>NullPointerException</code> is explicitly caught can\neasily be converted to a <code>null</code> test, and any behavior being carried out in the catch block can easily be moved to the \"is null\" branch of\nthe conditional.</p>\n<h3>Noncompliant code example</h3>\n<pre>\npublic int lengthPlus(String str) {\n  int len = 2;\n  try {\n    len += str.length();\n  }\n  catch (NullPointerException e) {\n    log.info(\"argument was null\");\n  }\n  return len;\n}\n</pre>\n<h3>Compliant solution</h3>\n<pre>\npublic int lengthPlus(String str) {\n  int len = 2;\n\n  if (str != null) {\n    len += str.length();\n  }\n  else {\n    log.info(\"argument was null\");\n  }\n  return len;\n}\n</pre>",
    "howToFix": "",
    "moreInfo": "<ul>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/395\">CWE-395 - Use of NullPointerException Catch to Detect NULL Pointer Dereference</a>\n  </li>\n  <li> CERT - <a href=\"https://wiki.sei.cmu.edu/confluence/display/java/ERR08-J.+Do+not+catch+NullPointerException+or+any+of+its+ancestors\">ERR08-J.\n  Do not catch NullPointerException or any of its ancestors</a> </li>\n</ul>",
    "status": "READY",
    "name_ko": "\"NullPointerException\"을 catch하면 안 됩니다",
    "why_ko": "<p><code>NullPointerException</code>은 catch하지 말고 피해야 합니다. <code>NullPointerException</code>을 명시적으로 catch하는 모든 상황은 쉽게 <code>null</code> 테스트로 변환할 수 있으며, catch 블록에서 수행되는 모든 동작은 쉽게 조건문의 \"is null\" 분기로 이동할 수 있습니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\npublic int lengthPlus(String str) {\n  int len = 2;\n  try {\n    len += str.length();\n  }\n  catch (NullPointerException e) {\n    log.info(\"argument was null\");\n  }\n  return len;\n}\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre>\npublic int lengthPlus(String str) {\n  int len = 2;\n\n  if (str != null) {\n    len += str.length();\n  }\n  else {\n    log.info(\"argument was null\");\n  }\n  return len;\n}\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": "<ul>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/395\">CWE-395 - NULL 포인터 역참조 감지를 위한 NullPointerException Catch 사용</a> </li>\n  <li> CERT - <a href=\"https://wiki.sei.cmu.edu/confluence/display/java/ERR08-J.+Do+not+catch+NullPointerException+or+any+of+its+ancestors\">ERR08-J. NullPointerException 또는 그 상위 클래스를 catch하지 마세요</a> </li>\n</ul>"
  },
  {
    "id": "S2110",
    "key": "java:S2110",
    "name": "Invalid \"Date\" values should not be used",
    "type": "bug",
    "severity": "major",
    "tags": [],
    "why": "<p>Whether the valid value ranges for <code>Date</code> fields start with 0 or 1 varies by field. For instance, month starts at 0, and day of month\nstarts at 1. Enter a date value that goes past the end of the valid range, and the date will roll without error or exception. For instance, enter 12\nfor month, and you'll get January of the following year.</p>\n<p>This rule checks for bad values used in conjunction with <code>java.util.Date</code>, <code>java.sql.Date</code>, and\n<code>java.util.Calendar</code>. Specifically, values outside of the valid ranges:</p>\n<table>\n  <colgroup>\n    <col style=\"width: 50%;\">\n    <col style=\"width: 50%;\">\n  </colgroup>\n  <thead>\n    <tr>\n      <th>Field</th>\n      <th>Valid</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td><p>month</p></td>\n      <td><p>0-11</p></td>\n    </tr>\n    <tr>\n      <td><p>date (day)</p></td>\n      <td><p>0-31</p></td>\n    </tr>\n    <tr>\n      <td><p>hour</p></td>\n      <td><p>0-23</p></td>\n    </tr>\n    <tr>\n      <td><p>minute</p></td>\n      <td><p>0-60</p></td>\n    </tr>\n    <tr>\n      <td><p>second</p></td>\n      <td><p>0-61</p></td>\n    </tr>\n  </tbody>\n</table>\n<p>Note that this rule does not check for invalid leap years, leap seconds (second = 61), or invalid uses of the 31st day of the month.</p>\n<h3>Noncompliant code example</h3>\n<pre>\nDate d = new Date();\nd.setDate(25);\nd.setYear(2014);\nd.setMonth(12);  // Noncompliant; rolls d into the next year\n\nCalendar c = new GregorianCalendar(2014, 12, 25);  // Noncompliant\nif (c.get(Calendar.MONTH) == 12) {  // Noncompliant; invalid comparison\n  // ...\n}\n</pre>\n<h3>Compliant solution</h3>\n<pre>\nDate d = new Date();\nd.setDate(25);\nd.setYear(2014);\nd.setMonth(11);\n\nCalendar c = new Gregorian Calendar(2014, 11, 25);\nif (c.get(Calendar.MONTH) == 11) {\n  // ...\n}\n</pre>",
    "howToFix": "",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "유효하지 않은 \"Date\" 값은 사용하면 안 됩니다",
    "why_ko": "<p><code>Date</code> 필드의 유효한 값 범위가 0으로 시작하는지 1로 시작하는지는 필드에 따라 다릅니다. 예를 들어, month는 0에서 시작하고, day of month는 1에서 시작합니다. 유효한 범위의 끝을 넘는 날짜 값을 입력하면 오류나 예외 없이 날짜가 롤오버됩니다. 예를 들어, month에 12를 입력하면 다음 해 1월이 됩니다.</p>\n<p>이 규칙은 <code>java.util.Date</code>, <code>java.sql.Date</code>, <code>java.util.Calendar</code>와 함께 사용되는 잘못된 값을 검사합니다. 구체적으로 유효한 범위를 벗어나는 값:</p>\n<table>\n  <colgroup>\n    <col style=\"width: 50%;\">\n    <col style=\"width: 50%;\">\n  </colgroup>\n  <thead>\n    <tr>\n      <th>필드</th>\n      <th>유효 범위</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td><p>month</p></td>\n      <td><p>0-11</p></td>\n    </tr>\n    <tr>\n      <td><p>date (day)</p></td>\n      <td><p>0-31</p></td>\n    </tr>\n    <tr>\n      <td><p>hour</p></td>\n      <td><p>0-23</p></td>\n    </tr>\n    <tr>\n      <td><p>minute</p></td>\n      <td><p>0-60</p></td>\n    </tr>\n    <tr>\n      <td><p>second</p></td>\n      <td><p>0-61</p></td>\n    </tr>\n  </tbody>\n</table>\n<p>이 규칙은 유효하지 않은 윤년, 윤초(second = 61), 또는 31일의 잘못된 사용을 검사하지 않습니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\nDate d = new Date();\nd.setDate(25);\nd.setYear(2014);\nd.setMonth(12);  // 규칙 위반; d가 다음 해로 롤오버됨\n\nCalendar c = new GregorianCalendar(2014, 12, 25);  // 규칙 위반\nif (c.get(Calendar.MONTH) == 12) {  // 규칙 위반; 유효하지 않은 비교\n  // ...\n}\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre>\nDate d = new Date();\nd.setDate(25);\nd.setYear(2014);\nd.setMonth(11);\n\nCalendar c = new Gregorian Calendar(2014, 11, 25);\nif (c.get(Calendar.MONTH) == 11) {\n  // ...\n}\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": ""
  },
  {
    "id": "S3078",
    "key": "java:S3078",
    "name": "\"volatile\" variables should not be used with compound operators",
    "type": "bug",
    "severity": "major",
    "tags": [
      "multi-threading",
      "cert"
    ],
    "why": "<p>Using compound operators as well as increments and decrements (and toggling, in the case of <code>boolean</code>s) on primitive fields are not\natomic operations. That is, they don't happen in a single step. For instance, when a <code>volatile</code> primitive field is incremented or\ndecremented you run the risk of data loss if threads interleave in the steps of the update. Instead, use a guaranteed-atomic class such as\n<code>AtomicInteger</code>, or synchronize the access.</p>\n<h3>Noncompliant code example</h3>\n<pre>\nprivate volatile int count = 0;\nprivate volatile boolean boo = false;\n\npublic void incrementCount() {\n  count++;  // Noncompliant\n}\n\npublic void toggleBoo(){\n  boo = !boo;  // Noncompliant\n}\n</pre>\n<h3>Compliant solution</h3>\n<pre>\nprivate AtomicInteger count = 0;\nprivate boolean boo = false;\n\npublic void incrementCount() {\n  count.incrementAndGet();\n}\n\npublic synchronized void toggleBoo() {\n  boo = !boo;\n}\n</pre>",
    "howToFix": "",
    "moreInfo": "<ul>\n  <li> <a href=\"https://wiki.sei.cmu.edu/confluence/x/SjdGBQ\">CERT, VNA02-J.</a> - Ensure that compound operations on shared variables are atomic\n  </li>\n</ul>",
    "status": "READY",
    "name_ko": "\"volatile\" 변수에 복합 연산자를 사용하면 안 됩니다",
    "why_ko": "<p>원시 필드에서 복합 연산자와 증가/감소 연산(그리고 <code>boolean</code>의 경우 토글)을 사용하는 것은 원자적 연산이 아닙니다. 즉, 단일 단계로 발생하지 않습니다. 예를 들어, <code>volatile</code> 원시 필드가 증가하거나 감소할 때 스레드가 업데이트 단계에서 인터리빙되면 데이터 손실 위험이 있습니다. 대신 <code>AtomicInteger</code>와 같은 보장된 원자적 클래스를 사용하거나 접근을 동기화하세요.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\nprivate volatile int count = 0;\nprivate volatile boolean boo = false;\n\npublic void incrementCount() {\n  count++;  // 규칙 위반\n}\n\npublic void toggleBoo(){\n  boo = !boo;  // 규칙 위반\n}\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre>\nprivate AtomicInteger count = 0;\nprivate boolean boo = false;\n\npublic void incrementCount() {\n  count.incrementAndGet();\n}\n\npublic synchronized void toggleBoo() {\n  boo = !boo;\n}\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": "<ul>\n  <li> <a href=\"https://wiki.sei.cmu.edu/confluence/x/SjdGBQ\">CERT, VNA02-J.</a> - 공유 변수에 대한 복합 연산이 원자적인지 확인하세요 </li>\n</ul>"
  },
  {
    "id": "S106",
    "key": "java:S106",
    "name": "Standard outputs should not be used directly to log anything",
    "type": "code-smell",
    "severity": "major",
    "tags": [
      "bad-practice",
      "cert"
    ],
    "why": "<p>In software development, logs serve as a record of events within an application, providing crucial insights for debugging. When logging, it is\nessential to ensure that the logs are:</p>\n<ul>\n  <li> easily accessible </li>\n  <li> uniformly formatted for readability </li>\n  <li> properly recorded </li>\n  <li> securely logged when dealing with sensitive data </li>\n</ul>\n<p>Those requirements are not met if a program directly writes to the standard outputs (e.g., System.out, System.err). That is why defining and using\na dedicated logger is highly recommended.</p>\n\n<p>The following noncompliant code:</p>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\nclass MyClass {\n  public void doSomething() {\n    System.out.println(\"My Message\");  // Noncompliant, output directly to System.out without a logger\n  }\n}\n</pre>\n<p>Could be replaced by:</p>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\nimport java.util.logging.Logger;\n\nclass MyClass {\n\n  Logger logger = Logger.getLogger(getClass().getName());\n\n  public void doSomething() {\n    // ...\n    logger.info(\"My Message\");  // Compliant, output via logger\n    // ...\n  }\n}\n</pre>",
    "howToFix": "",
    "moreInfo": "<h3>Documentation</h3>\n<ul>\n  <li> <a href=\"https://docs.oracle.com/javase/7/docs/api/java/util/logging/Logger.html\">Java SE 7 API Specification: java.util.logging.Logger</a>\n  </li>\n  <li> OWASP - <a href=\"https://owasp.org/Top10/A09_2021-Security_Logging_and_Monitoring_Failures/\">Top 10 2021 Category A9 - Security Logging and\n  Monitoring Failures</a> </li>\n  <li> OWASP - <a href=\"https://owasp.org/www-project-top-ten/2017/A3_2017-Sensitive_Data_Exposure\">Top 10 2017 Category A3 - Sensitive Data\n  Exposure</a> </li>\n  <li> <a href=\"https://wiki.sei.cmu.edu/confluence/x/nzdGBQ\">CERT, ERR02-J.</a> - Prevent exceptions while logging data </li>\n</ul>",
    "status": "READY",
    "name_ko": "표준 출력은 로깅에 직접 사용하면 안 됩니다",
    "why_ko": "<p>소프트웨어 개발에서 로그는 애플리케이션 내의 이벤트 기록으로서 디버깅을 위한 중요한 인사이트를 제공합니다. 로깅할 때 다음을 확인하는 것이 필수적입니다:</p>\n<ul>\n  <li> 쉽게 접근 가능 </li>\n  <li> 가독성을 위한 일관된 형식 </li>\n  <li> 적절하게 기록됨 </li>\n  <li> 민감한 데이터를 다룰 때 안전하게 로깅됨 </li>\n</ul>\n<p>프로그램이 표준 출력(예: System.out, System.err)에 직접 쓰면 이러한 요구 사항이 충족되지 않습니다. 그래서 전용 logger를 정의하고 사용하는 것이 강력히 권장됩니다.</p>\n\n<p>다음 규칙을 준수하지 않는 코드:</p>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\nclass MyClass {\n  public void doSomething() {\n    System.out.println(\"My Message\");  // 규칙 위반, logger 없이 System.out으로 직접 출력\n  }\n}\n</pre>\n<p>다음으로 대체할 수 있습니다:</p>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\nimport java.util.logging.Logger;\n\nclass MyClass {\n\n  Logger logger = Logger.getLogger(getClass().getName());\n\n  public void doSomething() {\n    // ...\n    logger.info(\"My Message\");  // 규칙 준수, logger를 통한 출력\n    // ...\n  }\n}\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": "<h3>문서</h3>\n<ul>\n  <li> <a href=\"https://docs.oracle.com/javase/7/docs/api/java/util/logging/Logger.html\">Java SE 7 API 명세: java.util.logging.Logger</a>\n  </li>\n  <li> OWASP - <a href=\"https://owasp.org/Top10/A09_2021-Security_Logging_and_Monitoring_Failures/\">Top 10 2021 Category A9 - 보안 로깅 및 모니터링 실패</a> </li>\n  <li> OWASP - <a href=\"https://owasp.org/www-project-top-ten/2017/A3_2017-Sensitive_Data_Exposure\">Top 10 2017 Category A3 - 민감한 데이터 노출</a> </li>\n  <li> <a href=\"https://wiki.sei.cmu.edu/confluence/x/nzdGBQ\">CERT, ERR02-J.</a> - 데이터 로깅 중 예외 방지 </li>\n</ul>"
  },
  {
    "id": "S5786",
    "key": "java:S5786",
    "name": "JUnit5 test classes and methods should have default package visibility",
    "type": "code-smell",
    "severity": "info",
    "tags": [
      "junit",
      "tests"
    ],
    "why": "<p>JUnit5 is more tolerant regarding the visibility of test classes and methods than JUnit4, which required everything to be <code>public</code>. Test\nclasses and methods can have any visibility except <code>private</code>. It is however recommended to use the default package visibility to improve\nreadability.</p>\n<blockquote>\n  <p>Test classes, test methods, and lifecycle methods are not required to be <code>public</code>, but they must not be <code>private</code>.</p>\n  <p>It is generally recommended to omit the public modifier for test classes, test methods, and lifecycle methods unless there is a technical reason\n  for doing so – for example, when a test class is extended by a test class in another package. Another technical reason for making classes and\n  methods public is to simplify testing on the module path when using the Java Module System.</p>\n</blockquote>  — JUnit5 User Guide\n<h3>What is the potential impact?</h3>\n<p>The code will be non-conventional and readability can be slightly affected.</p>\n<h3>Exceptions</h3>\n<p>This rule does not raise an issue when the visibility is set to <code>private</code>, because <code>private</code> test methods and classes are\nsystematically ignored by JUnit5, without a proper warning. In this case, there is also an impact on reliability and so it is handled by the rule\n<a href='/coding_rules#rule_key=java%3AS5810'>S5810</a>.</p>",
    "howToFix": "<p>You can simply change the visibility by removing the <code>public</code> or <code>protected</code> keywords.</p>\n\n<h4>Noncompliant code example</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\nimport org.junit.jupiter.api.Test;\n\npublic class MyClassTest { // Noncompliant - modifier can be removed\n  @Test\n  protected void test() { // Noncompliant - modifier can be removed\n    // ...\n  }\n}\n</pre>\n<h4>Compliant solution</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\nimport org.junit.jupiter.api.Test;\n\nclass MyClassTest {\n  @Test\n  void test() {\n    // ...\n  }\n}\n</pre>",
    "moreInfo": "<h3>Documentation</h3>\n<ul>\n  <li> <a href=\"https://junit.org/junit5/docs/current/user-guide/#writing-tests-classes-and-methods\">JUnit5 User Guide: Test Classes and Methods</a>\n  </li>\n</ul>",
    "status": "READY",
    "name_ko": "JUnit5 테스트 클래스와 메서드는 기본 패키지 가시성을 가져야 합니다",
    "why_ko": "<p>JUnit5는 모든 것이 <code>public</code>이어야 했던 JUnit4보다 테스트 클래스와 메서드의 가시성에 대해 더 관대합니다. 테스트 클래스와 메서드는 <code>private</code>을 제외한 모든 가시성을 가질 수 있습니다. 그러나 가독성을 향상시키기 위해 기본 패키지 가시성을 사용하는 것이 권장됩니다.</p>\n<blockquote>\n  <p>테스트 클래스, 테스트 메서드, 라이프사이클 메서드는 <code>public</code>일 필요가 없지만 <code>private</code>이어서는 안 됩니다.</p>\n  <p>기술적인 이유가 없는 한 테스트 클래스, 테스트 메서드, 라이프사이클 메서드에서 public 수정자를 생략하는 것이 일반적으로 권장됩니다 – 예를 들어 다른 패키지의 테스트 클래스가 테스트 클래스를 확장할 때. 클래스와 메서드를 public으로 만드는 또 다른 기술적 이유는 Java 모듈 시스템을 사용할 때 모듈 경로에서 테스트를 단순화하는 것입니다.</p>\n</blockquote>  — JUnit5 사용자 가이드\n<h3>잠재적 영향은 무엇입니까?</h3>\n<p>코드가 비관례적이 되고 가독성이 약간 영향을 받을 수 있습니다.</p>\n<h3>예외</h3>\n<p>이 규칙은 가시성이 <code>private</code>으로 설정되었을 때는 문제를 제기하지 않습니다. <code>private</code> 테스트 메서드와 클래스는 적절한 경고 없이 JUnit5에 의해 체계적으로 무시되기 때문입니다. 이 경우 신뢰성에도 영향이 있으므로 규칙 <a href='/coding_rules#rule_key=java%3AS5810'>S5810</a>에서 처리됩니다.</p>",
    "howToFix_ko": "<p><code>public</code> 또는 <code>protected</code> 키워드를 제거하여 가시성을 간단히 변경할 수 있습니다.</p>\n\n<h4>규칙을 준수하지 않는 코드 예시</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\nimport org.junit.jupiter.api.Test;\n\npublic class MyClassTest { // 규칙 위반 - 수정자를 제거할 수 있습니다\n  @Test\n  protected void test() { // 규칙 위반 - 수정자를 제거할 수 있습니다\n    // ...\n  }\n}\n</pre>\n<h4>규칙을 준수하는 해결책</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\nimport org.junit.jupiter.api.Test;\n\nclass MyClassTest {\n  @Test\n  void test() {\n    // ...\n  }\n}\n</pre>",
    "moreInfo_ko": "<h3>문서</h3>\n<ul>\n  <li> <a href=\"https://junit.org/junit5/docs/current/user-guide/#writing-tests-classes-and-methods\">JUnit5 사용자 가이드: 테스트 클래스와 메서드</a>\n  </li>\n</ul>"
  },
  {
    "id": "S110",
    "key": "java:S110",
    "name": "Inheritance tree of classes should not be too deep",
    "type": "code-smell",
    "severity": "major",
    "tags": [],
    "why": "<p>Inheritance is one of the most valuable concepts in object-oriented programming. It's a way to categorize and reuse code by creating collections of\nattributes and behaviors called classes, which can be based on previously created classes.</p>\n<p>But abusing this concept by creating a deep inheritance tree can lead to complex and unmaintainable source code. Often, an inheritance tree\nbecoming too deep is the symptom of systematic use of \"inheritance\" when other approaches like \"composition\" would be better suited.</p>\n<p>This rule raises an issue when the inheritance tree, starting from <code>Object</code>, has a greater depth than is allowed.</p>\n<p>The rule has one parameter to filter out classes of the count of inheritance. The following rules apply to define this parameter:</p>\n<ul>\n  <li> <code>?</code> matches a single character </li>\n  <li> <code>*</code> matches zero or more characters </li>\n  <li> <code>**</code> matches zero or more packages </li>\n</ul>\n<p>Examples:</p>\n<ul>\n  <li> <code>java.fwk.AbstractFwkClass</code>: the count stops when AbstractFwkClass class is reached. </li>\n  <li> <code>java.fwk.*</code>: any member of java.fwkPackage package is reached. </li>\n  <li> <code>java.fwk.**</code>: same as above, but including sub-packages. </li>\n</ul>\n<h2>Exceptions:</h2>\n<p>The rule stops counting when it encounters a class from one of the following packages (or sub-packages):</p>\n<ul>\n  <li> <code>android.**</code> </li>\n  <li> <code>com.intellij.**</code> </li>\n  <li> <code>com.persistit.**</code> </li>\n  <li> <code>javax.swing.**</code> </li>\n  <li> <code>org.eclipse.**</code> </li>\n  <li> <code>org.springframework.**</code> </li>\n</ul>",
    "howToFix": "",
    "moreInfo": "<h3>Documentation</h3>\n<p><a href=\"https://en.wikipedia.org/wiki/Composition_over_inheritance\">Composition over inheritance: difference between composition and inheritance\nin object-oriented programming</a></p>",
    "status": "READY",
    "name_ko": "클래스 상속 계층이 너무 깊으면 안 됩니다",
    "why_ko": "<p>상속은 객체 지향 프로그래밍에서 가장 가치 있는 개념 중 하나입니다. 이전에 만든 클래스를 기반으로 할 수 있는 클래스라는 속성과 동작의 컬렉션을 만들어 코드를 분류하고 재사용하는 방법입니다.</p>\n<p>하지만 깊은 상속 트리를 만들어 이 개념을 남용하면 복잡하고 유지 관리할 수 없는 소스 코드로 이어질 수 있습니다. 종종 상속 트리가 너무 깊어지는 것은 \"컴포지션\"과 같은 다른 접근 방식이 더 적합할 때 \"상속\"을 체계적으로 사용한 증상입니다.</p>\n<p>이 규칙은 <code>Object</code>에서 시작하는 상속 트리의 깊이가 허용된 것보다 클 때 이슈를 발생시킵니다.</p>\n<p>규칙에는 상속 카운트에서 클래스를 필터링하는 하나의 파라미터가 있습니다. 이 파라미터를 정의하는 데 다음 규칙이 적용됩니다:</p>\n<ul>\n  <li> <code>?</code>는 단일 문자와 일치 </li>\n  <li> <code>*</code>는 0개 이상의 문자와 일치 </li>\n  <li> <code>**</code>는 0개 이상의 패키지와 일치 </li>\n</ul>\n<p>예시:</p>\n<ul>\n  <li> <code>java.fwk.AbstractFwkClass</code>: AbstractFwkClass 클래스에 도달하면 카운트가 중지됩니다. </li>\n  <li> <code>java.fwk.*</code>: java.fwkPackage 패키지의 모든 멤버에 도달합니다. </li>\n  <li> <code>java.fwk.**</code>: 위와 동일하지만 하위 패키지를 포함합니다. </li>\n</ul>\n<h2>예외:</h2>\n<p>규칙은 다음 패키지(또는 하위 패키지) 중 하나의 클래스를 만나면 카운트를 중지합니다:</p>\n<ul>\n  <li> <code>android.**</code> </li>\n  <li> <code>com.intellij.**</code> </li>\n  <li> <code>com.persistit.**</code> </li>\n  <li> <code>javax.swing.**</code> </li>\n  <li> <code>org.eclipse.**</code> </li>\n  <li> <code>org.springframework.**</code> </li>\n</ul>",
    "howToFix_ko": "",
    "moreInfo_ko": "<h3>문서</h3>\n<p><a href=\"https://en.wikipedia.org/wiki/Composition_over_inheritance\">컴포지션이 상속보다 우선: 객체 지향 프로그래밍에서 컴포지션과 상속의 차이</a></p>"
  },
  {
    "id": "S4601",
    "key": "java:S4601",
    "name": "\"HttpSecurity\" URL patterns should be correctly ordered",
    "type": "vulnerability",
    "severity": "critical",
    "tags": [
      "spring"
    ],
    "why": "<p>Configured URL matchers are considered in the order they are declared. Especially, for a given resource, if a looser filter is defined before a\nstricter one, only the less secure configuration will apply. No request will ever reach the stricter rule.</p>\n<p>This rule raises an issue when:</p>\n<ul>\n  <li> A URL pattern ending with <code>**</code> precedes another one having the same prefix. E.g. <code>/admin/**</code> is defined before\n  <code>/admin/example/**</code> </li>\n  <li> A pattern without wildcard characters is preceded by another one that matches it. E.g.: <code>/page-index/db</code> is defined after\n  <code>/page*/**</code> </li>\n</ul>\n<h3>What is the potential impact?</h3>\n<p>Access control rules that have been defined but cannot be applied generally indicate an error in the filtering process. In most cases, this will\nhave consequences on the application's authorization and authentication mechanisms.</p>\n<h4>Authentication bypass</h4>\n<p>When the ignored access control rule is supposed to enforce the authentication on a resource, the consequence is a bypass of the authentication for\nthat resource. Depending on the scope of the ignored rule, a single feature or whole sections of the application can be left unprotected.</p>\n<p>Attackers could take advantage of such an issue to access the affected features without prior authentication, which may impact the confidentiality\nor integrity of sensitive, business, or personal data.</p>\n<h4>Privilege escalation</h4>\n<p>When the ignored access control rule is supposed to verify the role of an authenticated user, the consequence is a privilege escalation or\nauthorization bypass. An authenticated user with low privileges on the application will be able to access more critical features or sections of the\napplication.</p>\n<p>This could have financial consequences if the accessed features are normally accessed by paying users. It could also impact the confidentiality or\nintegrity of sensitive, business, or personal data, depending on the features.</p>",
    "howToFix": "<p>The following code is vulnerable because it defines access control configuration in the wrong order.</p>\n<h4>Noncompliant code example</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\nprotected void configure(HttpSecurity http) throws Exception {\n    http.authorizeRequests()\n      .antMatchers(\"/resources/**\", \"/signup\", \"/about\").permitAll()\n      .antMatchers(\"/admin/**\").hasRole(\"ADMIN\")\n      .antMatchers(\"/admin/login\").permitAll() // Noncompliant\n      .antMatchers(\"/**\", \"/home\").permitAll()\n      .antMatchers(\"/db/**\").access(\"hasRole('ADMIN') and hasRole('DBA')\") // Noncompliant\n      .and().formLogin().loginPage(\"/login\").permitAll().and().logout().permitAll();\n  }\n</pre>\n<h4>Compliant solution</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\n  protected void configure(HttpSecurity http) throws Exception {\n    http.authorizeRequests()\n      .antMatchers(\"/resources/**\", \"/signup\", \"/about\").permitAll()\n      .antMatchers(\"/admin/login\").permitAll()\n      .antMatchers(\"/admin/**\").hasRole(\"ADMIN\")\n      .antMatchers(\"/db/**\").access(\"hasRole('ADMIN') and hasRole('DBA')\")\n      .antMatchers(\"/**\", \"/home\").permitAll()\n      .and().formLogin().loginPage(\"/login\").permitAll().and().logout().permitAll();\n  }\n</pre>",
    "moreInfo": "<h3>Documentation</h3>\n<ul>\n  <li> Spring Documentation - <a href=\"https://docs.spring.io/spring-security/reference/servlet/authorization/authorize-http-requests.html\">Authorize\n  HttpServletRequests</a> </li>\n</ul>\n<h3>Standards</h3>\n<ul>\n  <li> OWASP - <a href=\"https://owasp.org/Top10/A01_2021-Broken_Access_Control/\">Top 10 2021 - Category A1 - Broken Access Control</a> </li>\n  <li> OWASP - <a href=\"https://owasp.org/www-project-top-ten/2017/A6_2017-Security_Misconfiguration\">Top 10 2017 - Category A6 - Security\n  Misconfiguration</a> </li>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/285\">CWE-285 - Improper Authorization</a> </li>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/287\">CWE-287 - Improper Authentication</a> </li>\n</ul>",
    "status": "READY",
    "name_ko": "HttpSecurity URL 패턴은 올바르게 정렬되어야 합니다",
    "why_ko": "<p>구성된 URL 매처는 선언된 순서대로 고려됩니다. 특히 주어진 리소스에 대해 더 엄격한 필터 전에 느슨한 필터가 정의되면 덜 안전한 구성만 적용됩니다. 어떤 요청도 더 엄격한 규칙에 도달하지 못합니다.</p>\n<p>이 규칙은 다음과 같은 경우 문제를 제기합니다:</p>\n<ul>\n  <li> <code>**</code>로 끝나는 URL 패턴이 동일한 접두사를 가진 다른 패턴보다 앞에 있는 경우. 예: <code>/admin/**</code>이 <code>/admin/example/**</code>보다 먼저 정의됨 </li>\n  <li> 와일드카드 문자가 없는 패턴이 이를 매칭하는 다른 패턴 뒤에 있는 경우. 예: <code>/page-index/db</code>가 <code>/page*/**</code> 뒤에 정의됨 </li>\n</ul>\n<h3>잠재적 영향은 무엇인가요?</h3>\n<p>정의되었지만 적용할 수 없는 접근 제어 규칙은 일반적으로 필터링 프로세스의 오류를 나타냅니다. 대부분의 경우 이는 애플리케이션의 권한 부여 및 인증 메커니즘에 영향을 미칩니다.</p>\n<h4>인증 우회</h4>\n<p>무시된 접근 제어 규칙이 리소스에 대한 인증을 강제해야 하는 경우 결과는 해당 리소스에 대한 인증 우회입니다. 무시된 규칙의 범위에 따라 단일 기능 또는 애플리케이션의 전체 섹션이 보호되지 않을 수 있습니다.</p>\n<p>공격자는 이러한 문제를 이용하여 사전 인증 없이 영향을 받는 기능에 접근할 수 있으며, 이는 민감한 비즈니스 또는 개인 데이터의 기밀성 또는 무결성에 영향을 미칠 수 있습니다.</p>\n<h4>권한 상승</h4>\n<p>무시된 접근 제어 규칙이 인증된 사용자의 역할을 확인해야 하는 경우 결과는 권한 상승 또는 권한 부여 우회입니다. 애플리케이션에서 낮은 권한을 가진 인증된 사용자가 더 중요한 기능이나 애플리케이션 섹션에 접근할 수 있게 됩니다.</p>\n<p>접근된 기능이 일반적으로 유료 사용자가 접근하는 경우 재정적 결과를 초래할 수 있습니다. 또한 기능에 따라 민감한 비즈니스 또는 개인 데이터의 기밀성 또는 무결성에 영향을 미칠 수 있습니다.</p>",
    "howToFix_ko": "<p>다음 코드는 잘못된 순서로 접근 제어 구성을 정의하기 때문에 취약합니다.</p>\n<h4>규칙을 준수하지 않는 코드 예시</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\nprotected void configure(HttpSecurity http) throws Exception {\n    http.authorizeRequests()\n      .antMatchers(\"/resources/**\", \"/signup\", \"/about\").permitAll()\n      .antMatchers(\"/admin/**\").hasRole(\"ADMIN\")\n      .antMatchers(\"/admin/login\").permitAll() // 규칙 위반\n      .antMatchers(\"/**\", \"/home\").permitAll()\n      .antMatchers(\"/db/**\").access(\"hasRole('ADMIN') and hasRole('DBA')\") // 규칙 위반\n      .and().formLogin().loginPage(\"/login\").permitAll().and().logout().permitAll();\n  }\n</pre>\n<h4>규칙을 준수하는 해결책</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\n  protected void configure(HttpSecurity http) throws Exception {\n    http.authorizeRequests()\n      .antMatchers(\"/resources/**\", \"/signup\", \"/about\").permitAll()\n      .antMatchers(\"/admin/login\").permitAll()\n      .antMatchers(\"/admin/**\").hasRole(\"ADMIN\")\n      .antMatchers(\"/db/**\").access(\"hasRole('ADMIN') and hasRole('DBA')\")\n      .antMatchers(\"/**\", \"/home\").permitAll()\n      .and().formLogin().loginPage(\"/login\").permitAll().and().logout().permitAll();\n  }\n</pre>",
    "moreInfo_ko": "<h3>문서</h3>\n<ul>\n  <li> Spring 문서 - <a href=\"https://docs.spring.io/spring-security/reference/servlet/authorization/authorize-http-requests.html\">HttpServletRequests 권한 부여</a> </li>\n</ul>\n<h3>표준</h3>\n<ul>\n  <li> OWASP - <a href=\"https://owasp.org/Top10/A01_2021-Broken_Access_Control/\">Top 10 2021 - 카테고리 A1 - 취약한 접근 제어</a> </li>\n  <li> OWASP - <a href=\"https://owasp.org/www-project-top-ten/2017/A6_2017-Security_Misconfiguration\">Top 10 2017 - 카테고리 A6 - 보안 구성 오류</a> </li>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/285\">CWE-285 - 부적절한 권한 부여</a> </li>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/287\">CWE-287 - 부적절한 인증</a> </li>\n</ul>"
  },
  {
    "id": "S1116",
    "key": "java:S1116",
    "name": "Empty statements should be removed",
    "type": "code-smell",
    "severity": "minor",
    "tags": [
      "unused",
      "cert"
    ],
    "why": "<p>Empty statements represented by a semicolon <code>;</code> are statements that do not perform any operation. They are often the result of a typo or\na misunderstanding of the language syntax. It is a good practice to remove empty statements since they don't add value and lead to confusion and\nerrors.</p>\n\n<h4>Noncompliant code example</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\nvoid doSomething() {\n  ; // Noncompliant - was used as a kind of TODO marker\n}\n\nvoid doSomethingElse() {\n  System.out.println(\"Hello, world!\");; // Noncompliant - double ;\n  // ...\n}\n</pre>\n<h4>Compliant solution</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\nvoid doSomething() {}\n\nvoid doSomethingElse() {\n  System.out.println(\"Hello, world!\");\n  // ...\n  for (int i = 0; i &lt; 3; i++) ; // Compliant if unique statement of a loop\n  // ...\n}\n</pre>",
    "howToFix": "",
    "moreInfo": "<h3>Documentation</h3>\n<ul>\n  <li> <a href=\"https://wiki.sei.cmu.edu/confluence/x/5dUxBQ\">CERT, MSC12-C.</a> - Detect and remove code that has no effect or is never executed\n  </li>\n  <li> <a href=\"https://wiki.sei.cmu.edu/confluence/x/IDZGBQ\">CERT, MSC51-J.</a> - Do not place a semicolon immediately following an if, for, or while\n  condition </li>\n  <li> <a href=\"https://wiki.sei.cmu.edu/confluence/x/WtYxBQ\">CERT, EXP15-C.</a> - Do not place a semicolon on the same line as an if, for, or while\n  statement </li>\n</ul>",
    "status": "READY",
    "name_ko": "빈 문장은 제거해야 합니다",
    "why_ko": "<p>세미콜론 <code>;</code>으로 표현되는 빈 문장은 어떤 작업도 수행하지 않는 문장입니다. 이는 종종 오타나 언어 문법에 대한 오해의 결과입니다. 빈 문장은 가치를 추가하지 않고 혼란과 오류를 유발하므로 제거하는 것이 좋은 관행입니다.</p>\n\n<h4>규칙을 준수하지 않는 코드 예시</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\nvoid doSomething() {\n  ; // 규칙 위반 - TODO 마커처럼 사용됨\n}\n\nvoid doSomethingElse() {\n  System.out.println(\"Hello, world!\");; // 규칙 위반 - 이중 ;\n  // ...\n}\n</pre>\n<h4>규칙을 준수하는 해결책</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\nvoid doSomething() {}\n\nvoid doSomethingElse() {\n  System.out.println(\"Hello, world!\");\n  // ...\n  for (int i = 0; i &lt; 3; i++) ; // 루프의 유일한 문장인 경우 규칙 준수\n  // ...\n}\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": "<h3>문서</h3>\n<ul>\n  <li> <a href=\"https://wiki.sei.cmu.edu/confluence/x/5dUxBQ\">CERT, MSC12-C.</a> - 효과가 없거나 실행되지 않는 코드를 탐지하고 제거하기\n  </li>\n  <li> <a href=\"https://wiki.sei.cmu.edu/confluence/x/IDZGBQ\">CERT, MSC51-J.</a> - if, for, while 조건 바로 뒤에 세미콜론을 두지 마세요\n  </li>\n  <li> <a href=\"https://wiki.sei.cmu.edu/confluence/x/WtYxBQ\">CERT, EXP15-C.</a> - if, for, while 문과 같은 줄에 세미콜론을 두지 마세요\n  </li>\n</ul>"
  },
  {
    "id": "S5856",
    "key": "java:S5856",
    "name": "Regular expressions should be syntactically valid",
    "type": "bug",
    "severity": "critical",
    "tags": [
      "regex"
    ],
    "why": "<p>Regular expressions have their own syntax that is understood by regular expression engines. Those engines will throw an exception at runtime if\nthey are given a regular expression that does not conform to that syntax.</p>\n<p>To avoid syntax errors, special characters should be escaped with backslashes when they are intended to be matched literally and references to\ncapturing groups should use the correctly spelled name or number of the group.</p>\n<p>To match a literal string instead of a regular expression, either all special characters should be escaped, the <code>Pattern.LITERAL</code> flag\nor methods that don't use regular expressions should be used.</p>\n<h3>Noncompliant code example</h3>\n<pre>\nPattern.compile(\"([\");\nstr.matches(\"([\");\nstr.replaceAll(\"([\", \"{\");\nstr.matches(\"(\\\\w+-(\\\\d+)\");\n</pre>\n<h3>Compliant solution</h3>\n<pre>\nPattern.compile(\"\\\\(\\\\[\");\nPattern.compile(\"([\", Pattern.LITERAL);\nstr.equals(\"([\");\nstr.replace(\"([\", \"{\");\nstr.matches(\"(\\\\w+)-(\\\\d+)\");\n</pre>",
    "howToFix": "",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "정규 표현식은 문법적으로 유효해야 합니다",
    "why_ko": "<p>정규 표현식은 정규 표현식 엔진이 이해하는 자체 구문을 가지고 있습니다. 해당 엔진은 구문에 맞지 않는 정규 표현식이 주어지면 런타임에 예외를 발생시킵니다.</p>\n<p>구문 오류를 피하려면 특수 문자를 문자 그대로 일치시키려 할 때 백슬래시로 이스케이프해야 하며, 캡처 그룹에 대한 참조는 올바르게 철자가 된 그룹의 이름이나 번호를 사용해야 합니다.</p>\n<p>정규 표현식 대신 리터럴 문자열을 일치시키려면 모든 특수 문자를 이스케이프하거나 <code>Pattern.LITERAL</code> 플래그를 사용하거나 정규 표현식을 사용하지 않는 메서드를 사용해야 합니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\nPattern.compile(\"([\");\nstr.matches(\"([\");\nstr.replaceAll(\"([\", \"{\");\nstr.matches(\"(\\\\w+-(\\\\d+)\");\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre>\nPattern.compile(\"\\\\(\\\\[\");\nPattern.compile(\"([\", Pattern.LITERAL);\nstr.equals(\"([\");\nstr.replace(\"([\", \"{\");\nstr.matches(\"(\\\\w+)-(\\\\d+)\");\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": ""
  },
  {
    "id": "S2444",
    "key": "java:S2444",
    "name": "Lazy initialization of \"static\" fields should be \"synchronized\"",
    "type": "code-smell",
    "severity": "critical",
    "tags": [
      "multi-threading"
    ],
    "why": "<p>In a multi-threaded situation, un-<code>synchronized</code> lazy initialization of static fields could mean that a second thread has access to a\nhalf-initialized object while the first thread is still creating it. Allowing such access could cause serious bugs. Instead. the initialization block\nshould be <code>synchronized</code>.</p>\n<p>Similarly, updates of such fields should also be <code>synchronized</code>.</p>\n<p>This rule raises an issue whenever a lazy static initialization is done on a class with at least one <code>synchronized</code> method, indicating\nintended usage in multi-threaded applications.</p>\n<h3>Noncompliant code example</h3>\n<pre>\nprivate static Properties fPreferences = null;\n\nprivate static Properties getPreferences() {\n        if (fPreferences == null) {\n            fPreferences = new Properties(); // Noncompliant\n            fPreferences.put(\"loading\", \"true\");\n            fPreferences.put(\"filterstack\", \"true\");\n            readPreferences();\n        }\n        return fPreferences;\n    }\n}\n</pre>\n<h3>Compliant solution</h3>\n<pre>\nprivate static Properties fPreferences = null;\n\nprivate static synchronized Properties getPreferences() {\n        if (fPreferences == null) {\n            fPreferences = new Properties();\n            fPreferences.put(\"loading\", \"true\");\n            fPreferences.put(\"filterstack\", \"true\");\n            readPreferences();\n        }\n        return fPreferences;\n    }\n}\n</pre>",
    "howToFix": "",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "\"static\" 필드의 지연 초기화는 \"synchronized\"여야 합니다",
    "why_ko": "<p>멀티스레드 상황에서 static 필드의 <code>synchronized</code>되지 않은 지연 초기화는 첫 번째 스레드가 아직 객체를 생성하는 동안 두 번째 스레드가 반쯤 초기화된 객체에 접근할 수 있음을 의미할 수 있습니다. 이러한 접근을 허용하면 심각한 버그가 발생할 수 있습니다. 대신 초기화 블록은 <code>synchronized</code>되어야 합니다.</p>\n<p>마찬가지로, 이러한 필드의 업데이트도 <code>synchronized</code>되어야 합니다.</p>\n<p>이 규칙은 적어도 하나의 <code>synchronized</code> 메서드가 있는 클래스에서 지연 정적 초기화가 수행될 때마다 문제를 제기하며, 이는 멀티스레드 애플리케이션에서 사용할 의도를 나타냅니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\nprivate static Properties fPreferences = null;\n\nprivate static Properties getPreferences() {\n        if (fPreferences == null) {\n            fPreferences = new Properties(); // 규칙 위반\n            fPreferences.put(\"loading\", \"true\");\n            fPreferences.put(\"filterstack\", \"true\");\n            readPreferences();\n        }\n        return fPreferences;\n    }\n}\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre>\nprivate static Properties fPreferences = null;\n\nprivate static synchronized Properties getPreferences() {\n        if (fPreferences == null) {\n            fPreferences = new Properties();\n            fPreferences.put(\"loading\", \"true\");\n            fPreferences.put(\"filterstack\", \"true\");\n            readPreferences();\n        }\n        return fPreferences;\n    }\n}\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": ""
  },
  {
    "id": "S3740",
    "key": "java:S3740",
    "name": "Raw types should not be used",
    "type": "code-smell",
    "severity": "major",
    "tags": [
      "pitfall"
    ],
    "why": "<p>A generic type is a generic class or interface that is parameterized over types. For example, <code>java.util.List</code> has one type parameter:\nthe type of its elements.</p>\n<p>Using generic types raw (without binding arguments to the type parameters) prevents compile-time type checking for expressions that use these type\nparameters. Explicit type casts are necessary for them, which do perform a runtime type check that may fail with a\n<code>ClassCastException</code>.</p>\n<h3>What is the potential impact?</h3>\n<p>The compiler cannot assert that the program is inherently type safe. When a cast fails, a <code>ClassCastException</code> is thrown during runtime\nand the program most likely crashes. Therefore, this issue might impact the availability and reliability of your application.</p>\n<h3>Exceptions</h3>\n<p>The rule does not raise an issue for the simple <code>instanceof</code> operator, which checks against runtime types where type parameter\ninformation has been erased. Since it does not return a rawly typed instance but a boolean value, it does not prevent compile-time type checking.</p>\n<p>This, however, is not the case for the <code>cast</code> operator as well as the extended <code>instanceof</code> operator which are both not an\nexception from this rule. Since they operate on the erased runtime type as well, they must use wildcard type arguments when checked against a\nparameterized type (see the examples).</p>",
    "howToFix": "<p>For any usage of parameterized types, bind the type parameters with type arguments. For example, when a function returns a list of strings, the\nreturn type is <code>List&lt;String&gt;</code>, where the type parameter <code>E</code> in interface <code>List&lt;E&gt;</code> is bound with the\nargument <code>String</code>.</p>\n<p>If the concrete binding is unknown, you still should not use the type raw. Use a wildcard type argument instead, with optional lower or upper\nbound, such as in <code>List&lt;?&gt;</code> for a list whose element type is unknown, or <code>List&lt;? extends Number&gt;</code> for a list whose\nelement type is <code>Number</code> or a subtype of it.</p>\n\n<h4>Noncompliant code example</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\n// List is supposed to store integers only\nList integers = new ArrayList&lt;&gt;();\n\n// Yet, we can add strings, because we did not give\n// this information to the compiler\nintegers.add(\"Hello World!\");\n\n// Type is checked during runtime and will throw a ClassCastException\nInteger a = (Integer) integers.get(0);\n</pre>\n<h4>Compliant solution</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\n// List is supposed to store integers, and we let the compiler know\nList&lt;Integer&gt; integers = new ArrayList&lt;&gt;();\n\n// Now we can add only integers.\n// Adding a string results in a compile time error.\nintegers.add(42);\n\n// No cast required anymore, and no possible ClassCastException\nInteger a = integers.get(0);\n</pre>\n<h4>Noncompliant code example</h4>\n<pre data-diff-id=\"2\" data-diff-type=\"noncompliant\">\nString getStringFromForcedList(Object object) {\n  // Cast expression and instanceof can check runtime type only.\n  // The solution is _not_ to skip the type argument in that case.\n  return object instanceof List stringList ? (String) stringList.getFirst(): \"\";\n}\n</pre>\n<h4>Compliant solution</h4>\n<pre data-diff-id=\"2\" data-diff-type=\"compliant\">\nString getStringFromForcedList(Object object) {\n  // The solution is to use a wildcard type argument in that case.\n  return object instanceof List&lt;?&gt; stringList ? (String) stringList.getFirst(): \"\";\n}\n</pre>\n<h4>Noncompliant code example</h4>\n<pre data-diff-id=\"3\" data-diff-type=\"noncompliant\">\nString getStringFromForcedList(Object object) {\n  return object instanceof List stringList ? (String) stringList.getFirst(): \"\";\n}\n\nString returnString() {\n  Object object = List.of(\"Hello\");\n  return getStringFromForcedList(object);\n}\n</pre>\n<h4>Compliant solution</h4>\n<pre data-diff-id=\"3\" data-diff-type=\"compliant\">\nObject getObjectFromForcedList(Object object) {\n  // You may also choose not to make assumptions about type arguments you cannot infer.\n  return object instanceof List&lt;?&gt; list ? list.getFirst(): \"\";\n}\n\nString returnString(Object object) {\n  // Instead, delegate the decision to use-site, which may have more information.\n  Object object = List.of(\"Hello\");\n  return (String) getObjectFromForcedList(object);\n}\n</pre>",
    "moreInfo": "<h3>Documentation</h3>\n<ul>\n  <li> <a href=\"https://docs.oracle.com/javase/tutorial/java/generics/rawTypes.html\">Raw types</a> in the Java Tutorial. </li>\n</ul>",
    "status": "READY",
    "name_ko": "Raw 타입을 사용하면 안 됩니다",
    "why_ko": "<p>제네릭 타입은 타입에 대해 매개변수화된 제네릭 클래스 또는 인터페이스입니다. 예를 들어, <code>java.util.List</code>는 하나의 타입 매개변수인 요소의 타입을 가집니다.</p>\n<p>제네릭 타입을 raw로 사용하면(타입 매개변수에 인수를 바인딩하지 않으면) 이러한 타입 매개변수를 사용하는 표현식에 대한 컴파일 시간 타입 검사가 방지됩니다. 명시적 타입 캐스트가 필요하며, 이는 <code>ClassCastException</code>으로 실패할 수 있는 런타임 타입 검사를 수행합니다.</p>\n<h3>잠재적 영향은 무엇인가요?</h3>\n<p>컴파일러는 프로그램이 본질적으로 타입 안전한지 확인할 수 없습니다. 캐스트가 실패하면 런타임 중에 <code>ClassCastException</code>이 발생하고 프로그램이 충돌할 가능성이 높습니다. 따라서 이 문제는 애플리케이션의 가용성과 신뢰성에 영향을 미칠 수 있습니다.</p>\n<h3>예외</h3>\n<p>이 규칙은 타입 매개변수 정보가 지워진 런타임 타입에 대해 검사하는 간단한 <code>instanceof</code> 연산자에 대해서는 문제를 제기하지 않습니다. raw 타입의 인스턴스가 아닌 boolean 값을 반환하므로 컴파일 시간 타입 검사를 방지하지 않습니다.</p>\n<p>그러나 <code>cast</code> 연산자와 확장된 <code>instanceof</code> 연산자는 이 규칙의 예외가 아닙니다. 이들도 지워진 런타임 타입에서 작동하므로 매개변수화된 타입에 대해 검사할 때 와일드카드 타입 인수를 사용해야 합니다(예제 참조).</p>",
    "howToFix_ko": "<p>매개변수화된 타입을 사용할 때마다 타입 매개변수를 타입 인수로 바인딩하세요. 예를 들어, 함수가 문자열 리스트를 반환할 때 반환 타입은 <code>List&lt;String&gt;</code>이며, 여기서 인터페이스 <code>List&lt;E&gt;</code>의 타입 매개변수 <code>E</code>는 인수 <code>String</code>으로 바인딩됩니다.</p>\n<p>구체적인 바인딩을 알 수 없더라도 타입을 raw로 사용하면 안 됩니다. 대신 와일드카드 타입 인수를 사용하세요. 선택적으로 하한 또는 상한이 있을 수 있습니다. 예를 들어 요소 타입을 알 수 없는 리스트의 경우 <code>List&lt;?&gt;</code>, 요소 타입이 <code>Number</code> 또는 그 하위 타입인 리스트의 경우 <code>List&lt;? extends Number&gt;</code>를 사용합니다.</p>\n\n<h4>규칙을 준수하지 않는 코드 예시</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\n// List는 정수만 저장해야 합니다\nList integers = new ArrayList&lt;&gt;();\n\n// 하지만 컴파일러에게 이 정보를 주지 않았기 때문에\n// 문자열을 추가할 수 있습니다\nintegers.add(\"Hello World!\");\n\n// 타입은 런타임에 검사되며 ClassCastException을 발생시킵니다\nInteger a = (Integer) integers.get(0);\n</pre>\n<h4>규칙을 준수하는 해결책</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\n// List는 정수를 저장해야 하며 컴파일러에게 알립니다\nList&lt;Integer&gt; integers = new ArrayList&lt;&gt;();\n\n// 이제 정수만 추가할 수 있습니다.\n// 문자열을 추가하면 컴파일 시간 오류가 발생합니다.\nintegers.add(42);\n\n// 더 이상 캐스트가 필요 없고 ClassCastException 가능성도 없습니다\nInteger a = integers.get(0);\n</pre>\n<h4>규칙을 준수하지 않는 코드 예시</h4>\n<pre data-diff-id=\"2\" data-diff-type=\"noncompliant\">\nString getStringFromForcedList(Object object) {\n  // 캐스트 표현식과 instanceof는 런타임 타입만 검사할 수 있습니다.\n  // 해결책은 그 경우에 타입 인수를 생략하는 것이 _아닙니다_.\n  return object instanceof List stringList ? (String) stringList.getFirst(): \"\";\n}\n</pre>\n<h4>규칙을 준수하는 해결책</h4>\n<pre data-diff-id=\"2\" data-diff-type=\"compliant\">\nString getStringFromForcedList(Object object) {\n  // 해결책은 그 경우에 와일드카드 타입 인수를 사용하는 것입니다.\n  return object instanceof List&lt;?&gt; stringList ? (String) stringList.getFirst(): \"\";\n}\n</pre>\n<h4>규칙을 준수하지 않는 코드 예시</h4>\n<pre data-diff-id=\"3\" data-diff-type=\"noncompliant\">\nString getStringFromForcedList(Object object) {\n  return object instanceof List stringList ? (String) stringList.getFirst(): \"\";\n}\n\nString returnString() {\n  Object object = List.of(\"Hello\");\n  return getStringFromForcedList(object);\n}\n</pre>\n<h4>규칙을 준수하는 해결책</h4>\n<pre data-diff-id=\"3\" data-diff-type=\"compliant\">\nObject getObjectFromForcedList(Object object) {\n  // 추론할 수 없는 타입 인수에 대해 가정하지 않도록 선택할 수도 있습니다.\n  return object instanceof List&lt;?&gt; list ? list.getFirst(): \"\";\n}\n\nString returnString(Object object) {\n  // 대신 더 많은 정보를 가질 수 있는 사용 위치에 결정을 위임합니다.\n  Object object = List.of(\"Hello\");\n  return (String) getObjectFromForcedList(object);\n}\n</pre>",
    "moreInfo_ko": "<h3>문서</h3>\n<ul>\n  <li> Java Tutorial의 <a href=\"https://docs.oracle.com/javase/tutorial/java/generics/rawTypes.html\">Raw 타입</a>. </li>\n</ul>"
  },
  {
    "id": "S2151",
    "key": "java:S2151",
    "name": "\"runFinalizersOnExit\" should not be called",
    "type": "bug",
    "severity": "critical",
    "tags": [
      "cert"
    ],
    "why": "<p>Enabling <code>runFinalizersOnExit</code> is unsafe as it might result in erratic behavior and deadlocks on application exit.</p>\n<p>Indeed, finalizers might be force-called on live objects while other threads are concurrently manipulating them.</p>\n<p>Instead, if you want to execute something when the virtual machine begins its shutdown sequence, you should attach a shutdown hook.</p>\n<h3>Noncompliant code example</h3>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\npublic static void main(String [] args) {\n  System.runFinalizersOnExit(true);  // Noncompliant\n}\n\nprotected void finalize(){\n  doShutdownOperations();\n}\n</pre>\n<h3>Compliant solution</h3>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\npublic static void main(String [] args) {\n  Thread myThread = new Thread( () -&gt; { doShutdownOperations(); });\n  Runtime.getRuntime().addShutdownHook(myThread);\n}\n</pre>",
    "howToFix": "",
    "moreInfo": "<ul>\n  <li> <a href=\"https://wiki.sei.cmu.edu/confluence/x/4jZGBQ\">CERT, MET12-J.</a> - Do not use finalizers </li>\n</ul>",
    "status": "READY",
    "name_ko": "\"runFinalizersOnExit\"를 호출하면 안 됩니다",
    "why_ko": "<p><code>runFinalizersOnExit</code>를 활성화하면 애플리케이션 종료 시 불규칙한 동작과 데드락이 발생할 수 있어 안전하지 않습니다.</p>\n<p>실제로 다른 스레드가 동시에 객체를 조작하는 동안 살아있는 객체에 대해 finalizer가 강제 호출될 수 있습니다.</p>\n<p>대신 가상 머신이 종료 시퀀스를 시작할 때 무언가를 실행하고 싶다면 shutdown hook을 연결해야 합니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\npublic static void main(String [] args) {\n  System.runFinalizersOnExit(true);  // 규칙 위반\n}\n\nprotected void finalize(){\n  doShutdownOperations();\n}\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\npublic static void main(String [] args) {\n  Thread myThread = new Thread( () -&gt; { doShutdownOperations(); });\n  Runtime.getRuntime().addShutdownHook(myThread);\n}\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": "<ul>\n  <li> <a href=\"https://wiki.sei.cmu.edu/confluence/x/4jZGBQ\">CERT, MET12-J.</a> - finalizer를 사용하지 마세요 </li>\n</ul>"
  },
  {
    "id": "S3039",
    "key": "java:S3039",
    "name": "Indexes to passed to \"String\" operations should be within the string's bounds",
    "type": "bug",
    "severity": "major",
    "tags": [],
    "why": "<p>There are various <code>String</code> operations that take one or more character indexes as arguments and return a portion of the original string.\nIndexing in this context is zero-based, meaning that the first character's index is <code>0</code>. As a result, given a string <code>myString</code>,\nits last character is at index <code>myString.length() - 1</code>.</p>\n<p>The <code>String</code> operation methods throw a <code>StringIndexOutOfBoundsException</code> when one of their index argument is smaller than 0\n(E.G.: -1). <code>String::substring</code> also throws this exception when the <code>beginIndex</code> or <code>endIndex</code> argument is larger\nthan <code>myString.length()</code>, and <code>String::charAt</code> when the <code>index</code> argument is larger than <code>myString.length() -\n1</code> For instance, it is not possible to use <code>String::charAt</code> to retrieve a value before the start or after the end of a string.\nFurthermore, it is not possible to use <code>String::substring</code> with <code>beginIndex &gt; endIndex</code> to reverse the order of characters in\na string.</p>\n<p>This rule raises an issue when a negative literal or an index that is too large is passed as an argument to the <code>String::substring</code>,\n<code>String::charAt</code>, and related methods. It also raises an issue when the start index passed to <code>String::substring</code> is larger than\nthe end index.</p>",
    "howToFix": "<p>Use non-negative indexes that are smaller than or equal to the length of the string in question with <code>String::substring</code> and strictly\nsmaller with <code>String::charAt</code>.</p>\n\n<h4>Noncompliant code example</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\nString speech = \"Lorem ipsum dolor sit amet\";\n\nString substr1 = speech.substring(-1, speech.length()); // Noncompliant, -1 is out of bounds\nString substr2 = speech.substring(speech.length(), 0);  // Noncompliant, the beginIndex must be smaller than or equal to the endIndex\nchar ch = speech.charAt(speech.length());               // Noncompliant, speech.length() is out of bounds\n</pre>\n<h4>Compliant solution</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\nString speech = \"Lorem ipsum dolor sit amet\";\n\nString substr1 = speech;                                         // Compliant, no string operation used\nString substr2 = new StringBuilder(speech).reverse().toString(); // Compliant, the string can be reversed using StringBuilder::reverse()\nchar ch = speech.charAt(speech.length() - 1);                    // Compliant, speech.length() - 1 is in bounds.\n</pre>",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "\"String\" 연산에 전달되는 인덱스는 문자열 범위 내에 있어야 합니다",
    "why_ko": "<p>하나 이상의 문자 인덱스를 인수로 받아 원본 문자열의 일부를 반환하는 다양한 <code>String</code> 연산이 있습니다. 이 컨텍스트에서 인덱싱은 0부터 시작하므로 첫 번째 문자의 인덱스는 <code>0</code>입니다. 따라서 문자열 <code>myString</code>이 주어지면 마지막 문자는 인덱스 <code>myString.length() - 1</code>에 있습니다.</p>\n<p><code>String</code> 연산 메서드는 인덱스 인수 중 하나가 0보다 작으면(예: -1) <code>StringIndexOutOfBoundsException</code>을 던집니다. <code>String::substring</code>은 <code>beginIndex</code> 또는 <code>endIndex</code> 인수가 <code>myString.length()</code>보다 크면 이 예외를 던지고, <code>String::charAt</code>은 <code>index</code> 인수가 <code>myString.length() - 1</code>보다 크면 이 예외를 던집니다. 예를 들어, <code>String::charAt</code>을 사용하여 문자열의 시작 전이나 끝 이후의 값을 검색하는 것은 불가능합니다. 또한, <code>beginIndex &gt; endIndex</code>인 <code>String::substring</code>을 사용하여 문자열의 문자 순서를 뒤집는 것도 불가능합니다.</p>\n<p>이 규칙은 음수 리터럴 또는 너무 큰 인덱스가 <code>String::substring</code>, <code>String::charAt</code> 및 관련 메서드에 인수로 전달될 때 문제를 제기합니다. 또한 <code>String::substring</code>에 전달된 시작 인덱스가 끝 인덱스보다 클 때도 문제를 제기합니다.</p>",
    "howToFix_ko": "<p><code>String::substring</code>에서는 문자열 길이보다 작거나 같은 음이 아닌 인덱스를 사용하고, <code>String::charAt</code>에서는 엄격하게 작은 인덱스를 사용하세요.</p>\n\n<h4>규칙을 준수하지 않는 코드 예시</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\nString speech = \"Lorem ipsum dolor sit amet\";\n\nString substr1 = speech.substring(-1, speech.length()); // 규칙 위반, -1은 범위를 벗어남\nString substr2 = speech.substring(speech.length(), 0);  // 규칙 위반, beginIndex는 endIndex보다 작거나 같아야 합니다\nchar ch = speech.charAt(speech.length());               // 규칙 위반, speech.length()는 범위를 벗어남\n</pre>\n<h4>규칙을 준수하는 해결책</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\nString speech = \"Lorem ipsum dolor sit amet\";\n\nString substr1 = speech;                                         // 규칙 준수, 문자열 연산이 사용되지 않음\nString substr2 = new StringBuilder(speech).reverse().toString(); // 규칙 준수, StringBuilder::reverse()를 사용하여 문자열을 뒤집을 수 있습니다\nchar ch = speech.charAt(speech.length() - 1);                    // 규칙 준수, speech.length() - 1은 범위 내에 있습니다.\n</pre>",
    "moreInfo_ko": ""
  },
  {
    "id": "S1141",
    "key": "java:S1141",
    "name": "Try-catch blocks should not be nested",
    "type": "code-smell",
    "severity": "major",
    "tags": [
      "error-handling",
      "confusing"
    ],
    "why": "<p>Nesting <code>try</code>/<code>catch</code> blocks severely impacts the readability of source code because it makes it too difficult to understand\nwhich block will catch which exception.</p>",
    "howToFix": "",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "Try-catch 블록은 중첩하면 안 됩니다",
    "why_ko": "<p><code>try</code>/<code>catch</code> 블록을 중첩하면 어떤 블록이 어떤 예외를 잡을지 이해하기 너무 어려워지기 때문에 소스 코드의 가독성에 심각한 영향을 미칩니다.</p>",
    "howToFix_ko": "",
    "moreInfo_ko": ""
  },
  {
    "id": "S3038",
    "key": "java:S3038",
    "name": "Abstract methods should not be redundant",
    "type": "code-smell",
    "severity": "minor",
    "tags": [
      "confusing"
    ],
    "why": "<p>There's no point in redundantly defining an <code>abstract</code> method with the same signature as a method in an <code>interface</code> that the\nclass <code>implements</code>. Any concrete child classes will have to implement the method either way.</p>\n<h3>Noncompliant code example</h3>\n<pre>\npublic interface Reportable {\n  String getReport();\n}\n\npublic abstract class AbstractRuleReport implements Reportable{\n  public abstract String getReport();  // Noncompliant\n\n  // ...\n}\n</pre>",
    "howToFix": "",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "중복된 추상 메서드가 있으면 안 됩니다",
    "why_ko": "<p>클래스가 <code>implements</code>하는 <code>interface</code>의 메서드와 동일한 시그니처를 가진 <code>abstract</code> 메서드를 중복으로 정의하는 것은 의미가 없습니다. 모든 구체적인 자식 클래스는 어차피 해당 메서드를 구현해야 합니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\npublic interface Reportable {\n  String getReport();\n}\n\npublic abstract class AbstractRuleReport implements Reportable{\n  public abstract String getReport();  // 규칙 위반\n\n  // ...\n}\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": ""
  },
  {
    "id": "S2629",
    "key": "java:S2629",
    "name": "\"Preconditions\" and logging arguments should not require evaluation",
    "type": "code-smell",
    "severity": "major",
    "tags": [
      "performance"
    ],
    "why": "<p>Some method calls can effectively be \"no-ops\", meaning that the invoked method does nothing, based on the application's configuration (eg: debug\nlogs in production). However, even if the method effectively does nothing, its arguments may still need to evaluated before the method is called.</p>\n<p>Passing message arguments that require further evaluation into a Guava <code>com.google.common.base.Preconditions</code> check can result in a\nperformance penalty. That is because whether or not they're needed, each argument must be resolved before the method is actually called.</p>\n<p>Similarly, passing concatenated strings into a logging method can also incur a needless performance hit because the concatenation will be performed\nevery time the method is called, whether or not the log level is low enough to show the message.</p>\n<p>Instead, you should structure your code to pass static or pre-computed values into <code>Preconditions</code> conditions check and logging\ncalls.</p>\n<p>Specifically, the built-in string formatting should be used instead of string concatenation, and if the message is the result of a method call,\nthen <code>Preconditions</code> should be skipped altogether, and the relevant exception should be conditionally thrown instead.</p>\n<h3>Noncompliant code example</h3>\n<pre>\nlogger.log(Level.DEBUG, \"Something went wrong: \" + message);  // Noncompliant; string concatenation performed even when log level too high to show DEBUG messages\n\nlogger.fine(\"An exception occurred with message: \" + message); // Noncompliant\n\nLOG.error(\"Unable to open file \" + csvPath, e);  // Noncompliant\n\nPreconditions.checkState(a &gt; 0, \"Arg must be positive, but got \" + a);  // Noncompliant. String concatenation performed even when a &gt; 0\n\nPreconditions.checkState(condition, formatMessage());  // Noncompliant. formatMessage() invoked regardless of condition\n\nPreconditions.checkState(condition, \"message: %s\", formatMessage());  // Noncompliant\n</pre>\n<h3>Compliant solution</h3>\n<pre>\nlogger.log(Level.DEBUG, \"Something went wrong: {0} \", message);  // String formatting only applied if needed\nlogger.log(Level.SEVERE, () -&gt; \"Something went wrong: \" + message); // since Java 8, we can use Supplier , which will be evaluated lazily\n\nlogger.fine(\"An exception occurred with message: {}\", message);  // SLF4J, Log4j\n\nLOG.error(\"Unable to open file {0}\", csvPath, e);\n\nif (LOG.isDebugEnabled()) {\n  LOG.debug(\"Unable to open file \" + csvPath, e);  // this is compliant, because it will not evaluate if log level is above debug.\n}\n\nPreconditions.checkState(arg &gt; 0, \"Arg must be positive, but got %d\", a);  // String formatting only applied if needed\n\nif (!condition) {\n  throw new IllegalStateException(formatMessage());  // formatMessage() only invoked conditionally\n}\n\nif (!condition) {\n  throw new IllegalStateException(\"message: \" + formatMessage());\n}\n</pre>\n<h3>Exceptions</h3>\n<p><code>catch</code> blocks are ignored, because the performance penalty is unimportant on exceptional paths (catch block should not be a part of\nstandard program flow). Getters are ignored as well as methods called on annotations which can be considered as getters. This rule accounts for\nexplicit test-level testing with SLF4J methods <code>isXXXEnabled</code> and ignores the bodies of such <code>if</code> statements.</p>",
    "howToFix": "",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "Preconditions와 로깅 인수는 평가가 필요하지 않아야 합니다",
    "why_ko": "<p>일부 메서드 호출은 애플리케이션의 구성에 따라 사실상 \"no-ops\"가 될 수 있습니다. 즉, 호출된 메서드가 아무것도 하지 않습니다(예: 프로덕션에서의 디버그 로그). 그러나 메서드가 사실상 아무것도 하지 않더라도 메서드가 호출되기 전에 인수가 평가되어야 할 수 있습니다.</p>\n<p>추가 평가가 필요한 메시지 인수를 Guava <code>com.google.common.base.Preconditions</code> 검사에 전달하면 성능 저하가 발생할 수 있습니다. 필요 여부에 관계없이 메서드가 실제로 호출되기 전에 각 인수가 해석되어야 하기 때문입니다.</p>\n<p>마찬가지로, 연결된 문자열을 로깅 메서드에 전달하면 로그 수준이 메시지를 표시할 만큼 낮은지 여부에 관계없이 메서드가 호출될 때마다 연결이 수행되므로 불필요한 성능 저하가 발생할 수 있습니다.</p>\n<p>대신, 정적이거나 미리 계산된 값을 <code>Preconditions</code> 조건 검사 및 로깅 호출에 전달하도록 코드를 구성해야 합니다.</p>\n<p>구체적으로, 문자열 연결 대신 내장 문자열 포맷팅을 사용해야 하며, 메시지가 메서드 호출의 결과인 경우 <code>Preconditions</code>를 완전히 건너뛰고 대신 관련 예외를 조건부로 발생시켜야 합니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\nlogger.log(Level.DEBUG, \"Something went wrong: \" + message);  // 규칙 위반; 로그 수준이 너무 높아 DEBUG 메시지를 표시하지 않을 때도 문자열 연결이 수행됨\n\nlogger.fine(\"An exception occurred with message: \" + message); // 규칙 위반\n\nLOG.error(\"Unable to open file \" + csvPath, e);  // 규칙 위반\n\nPreconditions.checkState(a &gt; 0, \"Arg must be positive, but got \" + a);  // 규칙 위반. a &gt; 0일 때도 문자열 연결이 수행됨\n\nPreconditions.checkState(condition, formatMessage());  // 규칙 위반. condition에 관계없이 formatMessage()가 호출됨\n\nPreconditions.checkState(condition, \"message: %s\", formatMessage());  // 규칙 위반\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre>\nlogger.log(Level.DEBUG, \"Something went wrong: {0} \", message);  // 필요한 경우에만 문자열 포맷팅 적용\nlogger.log(Level.SEVERE, () -&gt; \"Something went wrong: \" + message); // Java 8부터 지연 평가되는 Supplier 사용 가능\n\nlogger.fine(\"An exception occurred with message: {}\", message);  // SLF4J, Log4j\n\nLOG.error(\"Unable to open file {0}\", csvPath, e);\n\nif (LOG.isDebugEnabled()) {\n  LOG.debug(\"Unable to open file \" + csvPath, e);  // 규칙 준수, 로그 수준이 debug 이상이면 평가하지 않음\n}\n\nPreconditions.checkState(arg &gt; 0, \"Arg must be positive, but got %d\", a);  // 필요한 경우에만 문자열 포맷팅 적용\n\nif (!condition) {\n  throw new IllegalStateException(formatMessage());  // formatMessage()가 조건부로만 호출됨\n}\n\nif (!condition) {\n  throw new IllegalStateException(\"message: \" + formatMessage());\n}\n</pre>\n<h3>예외</h3>\n<p><code>catch</code> 블록은 무시됩니다. 예외 경로에서는 성능 저하가 중요하지 않기 때문입니다(catch 블록은 표준 프로그램 흐름의 일부가 아니어야 합니다). 게터도 무시되며 게터로 간주될 수 있는 어노테이션에서 호출되는 메서드도 마찬가지입니다. 이 규칙은 SLF4J 메서드 <code>isXXXEnabled</code>를 사용한 명시적 테스트 수준 테스트를 고려하며 이러한 <code>if</code> 문의 본문을 무시합니다.</p>",
    "howToFix_ko": "",
    "moreInfo_ko": ""
  },
  {
    "id": "S2445",
    "key": "java:S2445",
    "name": "Blocks should be synchronized on \"private final\" fields",
    "type": "bug",
    "severity": "major",
    "tags": [
      "cwe",
      "multi-threading",
      "cert"
    ],
    "why": "<p>Synchronizing on a class field synchronizes not on the field itself, but on the object assigned to it. So synchronizing on a non-<code>final</code>\nfield makes it possible for the field's value to change while a thread is in a block synchronized on the old value. That would allow a second thread,\nsynchronized on the new value, to enter the block at the same time.</p>\n<p>The story is very similar for synchronizing on parameters; two different threads running the method in parallel could pass two different object\ninstances in to the method as parameters, completely undermining the synchronization.</p>\n<h3>Noncompliant code example</h3>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\nprivate String color = \"red\";\n\nprivate void doSomething(){\n  synchronized(color) {  // Noncompliant; lock is actually on object instance \"red\" referred to by the color variable\n    //...\n    color = \"green\"; // other threads now allowed into this block\n    // ...\n  }\n  synchronized(new Object()) { // Noncompliant this is a no-op.\n     // ...\n  }\n}\n</pre>\n<h3>Compliant solution</h3>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\nprivate String color = \"red\";\nprivate final Object lockObj = new Object();\n\nprivate void doSomething(){\n  synchronized(lockObj) {\n    //...\n    color = \"green\";\n    // ...\n  }\n}\n</pre>",
    "howToFix": "",
    "moreInfo": "<ul>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/412\">CWE-412 - Unrestricted Externally Accessible Lock</a> </li>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/413\">CWE-413 - Improper Resource Locking</a> </li>\n  <li> <a href=\"https://wiki.sei.cmu.edu/confluence/x/djdGBQ\">CERT, LCK00-J.</a> - Use private final lock objects to synchronize classes that may\n  interact with untrusted code </li>\n</ul>",
    "status": "READY",
    "name_ko": "블록은 \"private final\" 필드에 대해 synchronized해야 합니다",
    "why_ko": "<p>클래스 필드에 대해 동기화하는 것은 필드 자체가 아니라 필드에 할당된 객체에 대해 동기화하는 것입니다. 따라서 non-<code>final</code> 필드에 대해 동기화하면 스레드가 이전 값에 대해 동기화된 블록에 있는 동안 필드 값이 변경될 수 있습니다. 이렇게 되면 새 값에 대해 동기화된 두 번째 스레드가 동시에 블록에 들어갈 수 있습니다.</p>\n<p>매개변수에 대한 동기화도 매우 유사합니다. 메서드를 병렬로 실행하는 두 개의 다른 스레드가 매개변수로 두 개의 다른 객체 인스턴스를 메서드에 전달할 수 있어, 동기화를 완전히 무력화시킵니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\nprivate String color = \"red\";\n\nprivate void doSomething(){\n  synchronized(color) {  // 규칙 위반; 잠금은 실제로 color 변수가 참조하는 객체 인스턴스 \"red\"에 있음\n    //...\n    color = \"green\"; // 이제 다른 스레드가 이 블록에 들어올 수 있음\n    // ...\n  }\n  synchronized(new Object()) { // 규칙 위반, 이것은 아무 작업도 하지 않음.\n     // ...\n  }\n}\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\nprivate String color = \"red\";\nprivate final Object lockObj = new Object();\n\nprivate void doSomething(){\n  synchronized(lockObj) {\n    //...\n    color = \"green\";\n    // ...\n  }\n}\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": "<ul>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/412\">CWE-412 - 제한되지 않은 외부 접근 가능 잠금</a> </li>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/413\">CWE-413 - 부적절한 리소스 잠금</a> </li>\n  <li> <a href=\"https://wiki.sei.cmu.edu/confluence/x/djdGBQ\">CERT, LCK00-J.</a> - 신뢰할 수 없는 코드와 상호 작용할 수 있는 클래스를 동기화하려면 private final 잠금 객체를 사용하십시오 </li>\n</ul>"
  },
  {
    "id": "S4968",
    "key": "java:S4968",
    "name": "The upper bound of type variables and wildcards should not be \"final\"",
    "type": "code-smell",
    "severity": "minor",
    "tags": [],
    "why": "<p>When a type variable or a wildcard declares an upper bound that is <code>final</code>, the parametrization is not generic at all because it accepts\none and only one type at runtime: the one that is <code>final</code>. Instead of using <code>Generics</code>, it's simpler to directly use the\nconcrete <code>final</code> class.</p>\n<h3>Noncompliant code example</h3>\n<pre>\npublic static &lt;T extends String&gt; T getMyString() { // Noncompliant; String is a \"final\" class and so can't be extended\n [...]\n}\n</pre>\n<h3>Compliant solution</h3>\n<pre>\npublic static String getMyString() { // Compliant\n  [...]\n}\n</pre>",
    "howToFix": "",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "타입 변수와 와일드카드의 상한은 final이면 안 됩니다",
    "why_ko": "<p>타입 변수 또는 와일드카드가 <code>final</code>인 상한을 선언하면 런타임에 하나의 타입, 즉 <code>final</code>인 타입만 허용하기 때문에 매개변수화가 전혀 제네릭이 아닙니다. <code>Generics</code>를 사용하는 대신 구체적인 <code>final</code> 클래스를 직접 사용하는 것이 더 간단합니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\npublic static &lt;T extends String&gt; T getMyString() { // 규칙 위반; String은 \"final\" 클래스이므로 확장할 수 없음\n [...]\n}\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre>\npublic static String getMyString() { // 규칙 준수\n  [...]\n}\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": ""
  },
  {
    "id": "S3254",
    "key": "java:S3254",
    "name": "Default annotation parameter values should not be passed as arguments",
    "type": "code-smell",
    "severity": "minor",
    "tags": [
      "finding",
      "clumsy"
    ],
    "why": "<p>Specifying the default value for an annotation parameter is redundant. Such values should be omitted in the interests of readability.</p>\n<h3>Noncompliant code example</h3>\n<pre>\n@MyAnnotation(arg = \"def\")  // Noncompliant\npublic class MyClass {\n  // ...\n}\npublic @interface MyAnnotation {\n  String arg() default \"def\";\n}\n</pre>\n<h3>Compliant solution</h3>\n<pre>\n@MyAnnotation\npublic class MyClass {\n  // ...\n}\npublic @interface MyAnnotation {\n  String arg() default \"def\";\n}\n</pre>",
    "howToFix": "",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "어노테이션의 기본 파라미터 값은 인자로 전달하지 않아야 합니다",
    "why_ko": "<p>어노테이션 파라미터에 기본값을 지정하는 것은 중복입니다. 이러한 값은 가독성을 위해 생략되어야 합니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\n@MyAnnotation(arg = \"def\")  // 규칙 위반\npublic class MyClass {\n  // ...\n}\npublic @interface MyAnnotation {\n  String arg() default \"def\";\n}\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre>\n@MyAnnotation\npublic class MyClass {\n  // ...\n}\npublic @interface MyAnnotation {\n  String arg() default \"def\";\n}\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": ""
  },
  {
    "id": "S6810",
    "key": "java:S6810",
    "name": "Async methods should return void or Future",
    "type": "bug",
    "severity": "major",
    "tags": [],
    "why": "<p>The Spring framework provides the annotation <code>Async</code> to mark a method (or all methods of a type) as a candidate for asynchronous\nexecution.</p>\n<p>Asynchronous methods do not necessarily, by their nature, return the result of their calculation immediately. Hence, it is unexpected and in clear\nbreach of the <code>Async</code> contract for such methods to have a return type that is neither <code>void</code> nor a <code>Future</code> type.</p>",
    "howToFix": "<p>Use <code>void</code> as the return type if the method is not expected to return a result. Otherwise, a <code>Future</code> should be returned,\nallowing the caller to retrieve the result once it is ready. It is permitted to return more specific subtypes that inherit from\n<code>Future</code>.</p>\n\n<h4>Noncompliant code example</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\n@Async\npublic String asyncMethod() {\n  ...\n}\n</pre>\n<h4>Compliant solution</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\n@Async\npublic Future&lt;String&gt; asyncMethod() {\n  ...\n}\n</pre>\n<p>Alternatively, if the method does not need to return a result:</p>\n<pre>\n@Async\npublic void asyncMethod() {\n  ...\n}\n</pre>",
    "moreInfo": "<h3>Documentation</h3>\n<ul>\n  <li> Spring Framework Documentation - <a\n  href=\"https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/scheduling/annotation/Async.html\">Annotation Interface\n  Async</a> </li>\n</ul>",
    "status": "READY",
    "name_ko": "Async 메서드는 void 또는 Future를 반환해야 합니다",
    "why_ko": "<p>Spring 프레임워크는 메서드(또는 타입의 모든 메서드)를 비동기 실행 후보로 표시하기 위해 <code>Async</code> 어노테이션을 제공합니다.</p>\n<p>비동기 메서드는 본질적으로 계산 결과를 즉시 반환하지 않습니다. 따라서 이러한 메서드가 <code>void</code>나 <code>Future</code> 타입이 아닌 반환 타입을 갖는 것은 예상치 못한 것이며 <code>Async</code> 계약을 명백히 위반하는 것입니다.</p>",
    "howToFix_ko": "<p>메서드가 결과를 반환할 필요가 없다면 반환 타입으로 <code>void</code>를 사용하세요. 그렇지 않으면 호출자가 결과가 준비되면 검색할 수 있도록 <code>Future</code>를 반환해야 합니다. <code>Future</code>에서 상속받는 더 구체적인 하위 타입을 반환하는 것은 허용됩니다.</p>\n\n<h4>규칙을 준수하지 않는 코드 예시</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\n@Async\npublic String asyncMethod() {\n  ...\n}\n</pre>\n<h4>규칙을 준수하는 해결책</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\n@Async\npublic Future&lt;String&gt; asyncMethod() {\n  ...\n}\n</pre>\n<p>또는 메서드가 결과를 반환할 필요가 없다면:</p>\n<pre>\n@Async\npublic void asyncMethod() {\n  ...\n}\n</pre>",
    "moreInfo_ko": "<h3>문서</h3>\n<ul>\n  <li> Spring Framework 문서 - <a href=\"https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/scheduling/annotation/Async.html\">어노테이션 인터페이스 Async</a> </li>\n</ul>"
  },
  {
    "id": "S7186",
    "key": "java:S7186",
    "name": "Methods returning \"Page\" or \"Slice\" must take \"Pageable\" as an input parameter",
    "type": "code-smell",
    "severity": "critical",
    "tags": [
      "spring"
    ],
    "why": "<p>Spring Data Repository supports paging for queries, allowing you to return results in small, manageable chunks rather than retrieving an entire\nlarge result set.</p>\n<p>The conventional approach to paginating data in Spring is to use the <code>Pageable</code> interface to control pagination and to store the query\nresults into a <code>Page</code> or <code>Slice</code>. If a query declaration in a <code>Spring Data Repository</code> returns a <code>Page</code> or\n<code>Slice</code> without taking a <code>Pageable</code> as an input, it raises a runtime exception.</p>\n<p>This rule raises an issue on queries in a <code>Repository</code> that return a <code>Page</code> or <code>Slice</code> without taking a\n<code>Pageable</code> as an input.</p>",
    "howToFix": "<p>Ensure that query methods returning a <code>Page</code> or <code>Slice</code> include a <code>Pageable</code> parameter in their method\nsignature.</p>\n\n<h4>Noncompliant code example</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\ninterface ItemRepository extends JpaRepository&lt;Item, Long&gt; {\n    Page&lt;Item&gt; findItems(); //non compliant, no Pageable parameter\n}\n</pre>\n<h4>Compliant solution</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\ninterface ItemRepository extends JpaRepository&lt;Item, Long&gt; {\n    Page&lt;Item&gt; findItems(Pageable pageable);\n}\n</pre>",
    "moreInfo": "<h3>Documentation</h3>\n<ul>\n  <li> Spring - <a href=\"https://docs.spring.io/spring-data/jpa/reference/jpa/query-methods.html\">JPA Query Methods</a> </li>\n  <li> Spring - <a\n  href=\"https://docs.spring.io/spring-data/jpa/reference/repositories/query-methods-details.html#repositories.paging-and-sorting\">Defining Query\n  Methods</a> </li>\n</ul>\n<h3>Articles &amp; blog posts</h3>\n<ul>\n  <li> Spring Guides - <a href=\"https://reflectoring.io/spring-boot-paging/\">Paging with Spring Boot</a> </li>\n</ul>",
    "status": "READY",
    "name_ko": "\"Page\" 또는 \"Slice\"를 반환하는 메서드는 \"Pageable\"을 입력 매개변수로 받아야 합니다",
    "why_ko": "<p>Spring Data Repository는 쿼리에 대한 페이징을 지원하여 전체 대용량 결과 집합을 검색하는 대신 작고 관리 가능한 청크로 결과를 반환할 수 있습니다.</p>\n<p>Spring에서 데이터를 페이징하는 일반적인 방법은 <code>Pageable</code> 인터페이스를 사용하여 페이지네이션을 제어하고 쿼리 결과를 <code>Page</code> 또는 <code>Slice</code>에 저장하는 것입니다. <code>Spring Data Repository</code>의 쿼리 선언이 <code>Pageable</code>을 입력으로 받지 않고 <code>Page</code> 또는 <code>Slice</code>를 반환하면 런타임 예외가 발생합니다.</p>\n<p>이 규칙은 <code>Pageable</code>을 입력으로 받지 않고 <code>Page</code> 또는 <code>Slice</code>를 반환하는 <code>Repository</code>의 쿼리에서 문제를 발생시킵니다.</p>",
    "howToFix_ko": "<p><code>Page</code> 또는 <code>Slice</code>를 반환하는 쿼리 메서드의 메서드 시그니처에 <code>Pageable</code> 매개변수를 포함하세요.</p>\n\n<h4>규칙을 준수하지 않는 코드 예시</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\ninterface ItemRepository extends JpaRepository&lt;Item, Long&gt; {\n    Page&lt;Item&gt; findItems(); // 규칙 위반, Pageable 매개변수 없음\n}\n</pre>\n<h4>규칙을 준수하는 해결책</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\ninterface ItemRepository extends JpaRepository&lt;Item, Long&gt; {\n    Page&lt;Item&gt; findItems(Pageable pageable);\n}\n</pre>",
    "moreInfo_ko": "<h3>문서</h3>\n<ul>\n  <li> Spring - <a href=\"https://docs.spring.io/spring-data/jpa/reference/jpa/query-methods.html\">JPA 쿼리 메서드</a> </li>\n  <li> Spring - <a href=\"https://docs.spring.io/spring-data/jpa/reference/repositories/query-methods-details.html#repositories.paging-and-sorting\">쿼리 메서드 정의</a> </li>\n</ul>\n<h3>기사 및 블로그 게시물</h3>\n<ul>\n  <li> Spring Guides - <a href=\"https://reflectoring.io/spring-boot-paging/\">Spring Boot로 페이징하기</a> </li>\n</ul>"
  },
  {
    "id": "S2384",
    "key": "java:S2384",
    "name": "Private mutable members should not be stored or returned directly",
    "type": "code-smell",
    "severity": "minor",
    "tags": [
      "cwe",
      "unpredictable",
      "cert"
    ],
    "why": "<p>Mutable objects are those whose state can be changed. For instance, an array is mutable, but a String is not. Private mutable class members should\nnever be returned to a caller or accepted and stored directly. Doing so leaves you vulnerable to unexpected changes in your class state.</p>\n<p>Instead use an unmodifiable <code>Collection</code> (via <code>Collections.unmodifiableCollection</code>,\n<code>Collections.unmodifiableList</code>, …​) or make a copy of the mutable object, and store or return the copy instead.</p>\n<p>This rule checks that private arrays, collections and Dates are not stored or returned directly.</p>\n<h3>Exceptions</h3>\n<p>The rule violation is not reported for mutable values stored in private methods if no non-private methods directly passes a mutable parameter to\nthem.</p>\n<p>Similarly, rule violations are not reported for mutable values returned by a private getter if that getter's value is not directly exposed by a\nnon-private method.</p>\n<h3>Noncompliant code example</h3>\n<pre>\nclass A {\n  private String[] strings;\n\n  public A () {\n    strings = new String[]{\"first\", \"second\"};\n  }\n\n  public String[] getStrings() {\n    return strings; // Noncompliant\n  }\n\n  public void setStrings(String[] strings) {\n    this.strings = strings;  // Noncompliant\n  }\n}\n\npublic class B {\n\n  private A a = new A();  // At this point a.strings = {\"first\", \"second\"};\n\n  public void wreakHavoc() {\n    a.getStrings()[0] = \"yellow\";  // a.strings = {\"yellow\", \"second\"};\n  }\n}\n</pre>\n<h3>Compliant solution</h3>\n<pre>\nclass A {\n  private String [] strings;\n\n  public A () {\n    strings = new String[]{\"first\", \"second\"};\n  }\n\n  public String[] getStrings() {\n    return getStringsInternal().clone();\n  }\n\n  private String[] getStringsInternal() {\n    return strings;\n  }\n\n  private void setStringsInternal(String[] strings) {\n    this.strings = strings;\n  }\n\n  public void setStrings(String[] strings) {\n    this.strings = strings.clone();\n  }\n}\n\npublic class B {\n\n  private A a = new A();  // At this point a.strings = {\"first\", \"second\"};\n\n  public void wreakHavoc() {\n    a.getStrings()[0] = \"yellow\";  // a.strings = {\"first\", \"second\"};\n  }\n}\n</pre>",
    "howToFix": "",
    "moreInfo": "<ul>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/374\">CWE-374 - Passing Mutable Objects to an Untrusted Method</a> </li>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/375\">CWE-375 - Returning a Mutable Object to an Untrusted Caller</a> </li>\n  <li> <a href=\"https://wiki.sei.cmu.edu/confluence/x/OTdGBQ\">CERT, OBJ05-J.</a> - Do not return references to private mutable class members </li>\n  <li> <a href=\"https://wiki.sei.cmu.edu/confluence/x/HTdGBQ\">CERT, OBJ06-J.</a> - Defensively copy mutable inputs and mutable internal components\n  </li>\n  <li> <a href=\"https://wiki.sei.cmu.edu/confluence/x/VzZGBQ\">CERT, OBJ13-J.</a> - Ensure that references to mutable objects are not exposed </li>\n</ul>",
    "status": "READY",
    "name_ko": "private 가변 멤버를 직접 저장하거나 반환하면 안 됩니다",
    "why_ko": "<p>가변 객체는 상태가 변경될 수 있는 객체입니다. 예를 들어 배열은 가변이지만 String은 그렇지 않습니다. private 가변 클래스 멤버는 호출자에게 반환하거나 직접 받아서 저장해서는 안 됩니다. 그렇게 하면 클래스 상태에 예기치 않은 변경이 발생할 수 있습니다.</p>\n<p>대신 수정 불가능한 <code>Collection</code>(<code>Collections.unmodifiableCollection</code>, <code>Collections.unmodifiableList</code>, …​을 통해)을 사용하거나 가변 객체의 복사본을 만들어 복사본을 저장하거나 반환하세요.</p>\n<p>이 규칙은 private 배열, 컬렉션 및 Date가 직접 저장되거나 반환되지 않는지 확인합니다.</p>\n<h3>예외</h3>\n<p>비-private 메서드가 가변 매개변수를 직접 전달하지 않는 경우 private 메서드에 저장된 가변 값에 대해서는 규칙 위반이 보고되지 않습니다.</p>\n<p>마찬가지로 해당 getter의 값이 비-private 메서드에 의해 직접 노출되지 않는 경우 private getter가 반환하는 가변 값에 대해서는 규칙 위반이 보고되지 않습니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\nclass A {\n  private String[] strings;\n\n  public A () {\n    strings = new String[]{\"first\", \"second\"};\n  }\n\n  public String[] getStrings() {\n    return strings; // 규칙 위반\n  }\n\n  public void setStrings(String[] strings) {\n    this.strings = strings;  // 규칙 위반\n  }\n}\n\npublic class B {\n\n  private A a = new A();  // 이 시점에서 a.strings = {\"first\", \"second\"};\n\n  public void wreakHavoc() {\n    a.getStrings()[0] = \"yellow\";  // a.strings = {\"yellow\", \"second\"};\n  }\n}\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre>\nclass A {\n  private String [] strings;\n\n  public A () {\n    strings = new String[]{\"first\", \"second\"};\n  }\n\n  public String[] getStrings() {\n    return getStringsInternal().clone();\n  }\n\n  private String[] getStringsInternal() {\n    return strings;\n  }\n\n  private void setStringsInternal(String[] strings) {\n    this.strings = strings;\n  }\n\n  public void setStrings(String[] strings) {\n    this.strings = strings.clone();\n  }\n}\n\npublic class B {\n\n  private A a = new A();  // 이 시점에서 a.strings = {\"first\", \"second\"};\n\n  public void wreakHavoc() {\n    a.getStrings()[0] = \"yellow\";  // a.strings = {\"first\", \"second\"};\n  }\n}\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": "<ul>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/374\">CWE-374 - 신뢰할 수 없는 메서드에 가변 객체 전달</a> </li>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/375\">CWE-375 - 신뢰할 수 없는 호출자에게 가변 객체 반환</a> </li>\n  <li> <a href=\"https://wiki.sei.cmu.edu/confluence/x/OTdGBQ\">CERT, OBJ05-J.</a> - private 가변 클래스 멤버에 대한 참조를 반환하지 마세요 </li>\n  <li> <a href=\"https://wiki.sei.cmu.edu/confluence/x/HTdGBQ\">CERT, OBJ06-J.</a> - 가변 입력과 가변 내부 컴포넌트를 방어적으로 복사하세요 </li>\n  <li> <a href=\"https://wiki.sei.cmu.edu/confluence/x/VzZGBQ\">CERT, OBJ13-J.</a> - 가변 객체에 대한 참조가 노출되지 않도록 하세요 </li>\n</ul>"
  },
  {
    "id": "S1117",
    "key": "java:S1117",
    "name": "Local variables should not shadow class fields",
    "type": "code-smell",
    "severity": "major",
    "tags": [
      "cert",
      "suspicious",
      "pitfall"
    ],
    "why": "<p>Shadowing occurs when a local variable has the same name as a variable or a field in an outer scope.</p>\n<p>This can lead to three main problems:</p>\n<ul>\n  <li> Confusion: The same name can refer to different variables in different parts of the scope, making the code hard to read and understand. </li>\n  <li> Unintended Behavior: You might accidentally use the wrong variable, leading to hard-to-detect bugs. </li>\n  <li> Maintenance Issues: If the inner variable is removed or renamed, the code's behavior might change unexpectedly because the outer variable is\n  now being used. </li>\n</ul>\n<p>To avoid these problems, rename the shadowing, shadowed, or both identifiers to accurately represent their purpose with unique and meaningful\nnames.</p>\n<p>This rule focuses on variables in methods that shadow a field.</p>\n<h3>Noncompliant code example</h3>\n<pre>\nclass Foo {\n  public int myField;\n\n  public void doSomething() {\n    int myField = 0; // Noncompliant\n    // ...\n  }\n}\n</pre>",
    "howToFix": "",
    "moreInfo": "<h3>Documentation</h3>\n<ul>\n  <li> CERT - <a href=\"https://wiki.sei.cmu.edu/confluence/display/java/DCL51-J.+Do+not+shadow+or+obscure+identifiers+in+subscopes\">DCL51-J. Do not\n  shadow or obscure identifiers in subscopes</a> </li>\n</ul>\n<h3>Related rules</h3>\n<ul>\n  <li> <a href='/coding_rules#rule_key=java%3AS2176'>S2176</a> - Class names should not shadow interfaces or superclasses </li>\n  <li> <a href='/coding_rules#rule_key=java%3AS2387'>S2387</a> - Child class fields should not shadow parent class fields </li>\n  <li> <a href='/coding_rules#rule_key=java%3AS4977'>S4977</a> - Type parameters should not shadow other type parameters </li>\n</ul>",
    "status": "READY",
    "name_ko": "지역 변수는 클래스 필드를 가리면 안 됩니다",
    "why_ko": "<p>새도잉은 지역 변수가 외부 스코프의 변수나 필드와 같은 이름을 가질 때 발생합니다.</p>\n<p>이는 세 가지 주요 문제를 야기할 수 있습니다:</p>\n<ul>\n  <li> 혼란: 같은 이름이 스코프의 다른 부분에서 다른 변수를 참조할 수 있어 코드를 읽고 이해하기 어렵게 만듭니다. </li>\n  <li> 의도하지 않은 동작: 실수로 잘못된 변수를 사용하여 감지하기 어려운 버그가 발생할 수 있습니다. </li>\n  <li> 유지보수 문제: 내부 변수가 제거되거나 이름이 변경되면, 이제 외부 변수가 사용되기 때문에 코드의 동작이 예기치 않게 변경될 수 있습니다. </li>\n</ul>\n<p>이러한 문제를 피하려면 새도잉하는 식별자, 새도잉되는 식별자, 또는 둘 모두의 이름을 고유하고 의미 있는 이름으로 변경하여 목적을 정확하게 나타내세요.</p>\n<p>이 규칙은 필드를 가리는 메서드 내 변수에 초점을 맞춥니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\nclass Foo {\n  public int myField;\n\n  public void doSomething() {\n    int myField = 0; // 규칙 위반\n    // ...\n  }\n}\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": "<h3>문서</h3>\n<ul>\n  <li> CERT - <a href=\"https://wiki.sei.cmu.edu/confluence/display/java/DCL51-J.+Do+not+shadow+or+obscure+identifiers+in+subscopes\">DCL51-J. 하위 스코프에서 식별자를 가리거나 숨기지 마세요</a> </li>\n</ul>\n<h3>관련 규칙</h3>\n<ul>\n  <li> <a href='/coding_rules#rule_key=java%3AS2176'>S2176</a> - 클래스 이름은 인터페이스나 슈퍼클래스를 가리면 안 됩니다 </li>\n  <li> <a href='/coding_rules#rule_key=java%3AS2387'>S2387</a> - 자식 클래스 필드는 부모 클래스 필드를 가리면 안 됩니다 </li>\n  <li> <a href='/coding_rules#rule_key=java%3AS4977'>S4977</a> - 타입 매개변수는 다른 타입 매개변수를 가리면 안 됩니다 </li>\n</ul>"
  },
  {
    "id": "S5857",
    "key": "java:S5857",
    "name": "Character classes should be preferred over reluctant quantifiers in regular expressions",
    "type": "code-smell",
    "severity": "minor",
    "tags": [
      "regex"
    ],
    "why": "<p>Using reluctant quantifiers (also known as lazy or non-greedy quantifiers) in patterns can often lead to needless backtracking, making the regex\nneedlessly inefficient and potentially vulnerable to <a href=\"https://www.regular-expressions.info/catastrophic.html\">catastrophic backtracking</a>.\nParticularly when using <code>.*?</code> or <code>.+?</code> to match anything up to some terminating character, it is usually a better idea to\ninstead use a greedily or possessively quantified negated character class containing the terminating character. For example <code>&lt;.+?&gt;</code>\nshould be replaced with <code>&lt;[^&gt;]++&gt;</code>.</p>\n<h3>Noncompliant code example</h3>\n<pre>\n&lt;.+?&gt;\n\".*?\"\n</pre>\n<h3>Compliant solution</h3>\n<pre>\n&lt;[^&gt;]++&gt;\n\"[^\"]*+\"\n</pre>\n<p>or</p>\n<pre>\n&lt;[^&gt;]+&gt;\n\"[^\"]*\"\n</pre>\n<h3>Exceptions</h3>\n<p>This rule only applies in cases where the reluctant quantifier can easily be replaced with a negated character class. That means the repetition has\nto be terminated by a single character or character class. Patterns such as the following, where the alternatives without reluctant quantifiers are\nmore complicated, are therefore not subject to this rule:</p>\n<pre>\n&lt;!--.*?--&gt;\n/\\*.*?\\*/\n</pre>",
    "howToFix": "",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "정규 표현식에서 비탐욕적 수량자보다 문자 클래스를 사용해야 합니다",
    "why_ko": "<p>패턴에서 비탐욕적 수량자(lazy 또는 non-greedy 수량자라고도 함)를 사용하면 불필요한 역추적이 발생하여 정규식이 불필요하게 비효율적이 되고 잠재적으로 <a href=\"https://www.regular-expressions.info/catastrophic.html\">재앙적 역추적</a>에 취약해질 수 있습니다.\n특히 <code>.*?</code> 또는 <code>.+?</code>를 사용하여 종료 문자까지 무엇이든 일치시킬 때, 대신 종료 문자를 포함하는 탐욕적 또는 소유적 수량화된 부정 문자 클래스를 사용하는 것이 더 좋습니다. 예를 들어 <code>&lt;.+?&gt;</code>는 <code>&lt;[^&gt;]++&gt;</code>로 대체해야 합니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\n&lt;.+?&gt;\n\".*?\"\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre>\n&lt;[^&gt;]++&gt;\n\"[^\"]*+\"\n</pre>\n<p>또는</p>\n<pre>\n&lt;[^&gt;]+&gt;\n\"[^\"]*\"\n</pre>\n<h3>예외</h3>\n<p>이 규칙은 비탐욕적 수량자를 부정 문자 클래스로 쉽게 대체할 수 있는 경우에만 적용됩니다. 즉, 반복이 단일 문자 또는 문자 클래스로 종료되어야 합니다. 다음과 같이 비탐욕적 수량자 없이 대안이 더 복잡한 패턴은 이 규칙의 적용을 받지 않습니다:</p>\n<pre>\n&lt;!--.*?--&gt;\n/\\*.*?\\*/\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": ""
  },
  {
    "id": "S6001",
    "key": "java:S6001",
    "name": "Back references in regular expressions should only refer to capturing groups that are matched before the reference",
    "type": "bug",
    "severity": "critical",
    "tags": [
      "regex"
    ],
    "why": "<p>When a back reference in a regex refers to a capturing group that hasn't been defined yet (or at all), it can never be matched. Named back\nreferences throw a <code>PatternSyntaxException</code> in that case; numeric back references fail silently when they can't match, simply making the\nmatch fail.</p>\n<p>When the group is defined before the back reference but on a different control path (like in <code>(.)|\\1</code> for example), this also leads to a\nsituation where the back reference can never match.</p>\n<h3>Noncompliant code example</h3>\n<pre>\nPattern.compile(\"\\\\1(.)\"); // Noncompliant, group 1 is defined after the back reference\nPattern.compile(\"(.)\\\\2\"); // Noncompliant, group 2 isn't defined at all\nPattern.compile(\"(.)|\\\\1\"); // Noncompliant, group 1 and the back reference are in different branches\nPattern.compile(\"(?&lt;x&gt;.)|\\\\k&lt;x&gt;\"); // Noncompliant, group x and the back reference are in different branches\n</pre>\n<h3>Compliant solution</h3>\n<pre>\nPattern.compile(\"(.)\\\\1\");\nPattern.compile(\"(?&lt;x&gt;.)\\\\k&lt;x&gt;\");\n</pre>",
    "howToFix": "",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "정규 표현식의 역참조는 참조 이전에 매칭된 캡처 그룹만 참조해야 합니다",
    "why_ko": "<p>정규식에서 역참조가 아직 정의되지 않았거나 전혀 정의되지 않은 캡처 그룹을 참조하면 절대 일치할 수 없습니다. 명명된 역참조는 그 경우 <code>PatternSyntaxException</code>을 throw합니다. 숫자 역참조는 일치할 수 없을 때 단순히 일치에 실패하면서 조용히 실패합니다.</p>\n<p>그룹이 역참조 이전에 정의되었지만 다른 제어 경로에 있는 경우(예: <code>(.)|\\1</code>) 이것도 역참조가 절대 일치할 수 없는 상황으로 이어집니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\nPattern.compile(\"\\\\1(.)\"); // 규칙 위반, 그룹 1이 역참조 후에 정의됨\nPattern.compile(\"(.)\\\\2\"); // 규칙 위반, 그룹 2가 전혀 정의되지 않음\nPattern.compile(\"(.)|\\\\1\"); // 규칙 위반, 그룹 1과 역참조가 다른 분기에 있음\nPattern.compile(\"(?&lt;x&gt;.)|\\\\k&lt;x&gt;\"); // 규칙 위반, 그룹 x와 역참조가 다른 분기에 있음\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre>\nPattern.compile(\"(.)\\\\1\");\nPattern.compile(\"(?&lt;x&gt;.)\\\\k&lt;x&gt;\");\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": ""
  },
  {
    "id": "S3346",
    "key": "java:S3346",
    "name": "Expressions used in \"assert\" should not produce side effects",
    "type": "bug",
    "severity": "major",
    "tags": [
      "cert"
    ],
    "why": "<p>Since <code>assert</code> statements aren't executed by default (they must be enabled with JVM flags) developers should never rely on their\nexecution the evaluation of any logic required for correct program function.</p>\n<h3>Noncompliant code example</h3>\n<pre>\nassert myList.remove(myList.get(0));  // Noncompliant\n</pre>\n<h3>Compliant solution</h3>\n<pre>\nboolean removed = myList.remove(myList.get(0));\nassert removed;\n</pre>",
    "howToFix": "",
    "moreInfo": "<ul>\n  <li> <a href=\"https://wiki.sei.cmu.edu/confluence/x/mjdGBQ\">CERT, EXP06-J.</a> - Expressions used in assertions must not produce side effects </li>\n</ul>",
    "status": "READY",
    "name_ko": "assert에 사용되는 표현식은 부작용을 발생시키면 안 됩니다",
    "why_ko": "<p><code>assert</code> 문은 기본적으로 실행되지 않으므로(JVM 플래그로 활성화해야 함) 개발자는 올바른 프로그램 기능에 필요한 로직의 평가를 assert 실행에 의존해서는 안 됩니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\nassert myList.remove(myList.get(0));  // 규칙 위반\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre>\nboolean removed = myList.remove(myList.get(0));\nassert removed;\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": "<ul>\n  <li> <a href=\"https://wiki.sei.cmu.edu/confluence/x/mjdGBQ\">CERT, EXP06-J.</a> - 어서션에 사용되는 표현식은 부작용을 발생시키면 안 됩니다 </li>\n</ul>"
  },
  {
    "id": "S107",
    "key": "java:S107",
    "name": "Methods should not have too many parameters",
    "type": "code-smell",
    "severity": "major",
    "tags": [
      "brain-overload"
    ],
    "why": "<p>Methods with a long parameter list are difficult to use because maintainers must figure out the role of each parameter and keep track of their\nposition.</p>\n<pre>\nvoid setCoordinates(int x1, int y1, int z1, int x2, int y2, int z2) { // Noncompliant\n    // ...\n}\n</pre>\n<p>The solution can be to:</p>\n<ul>\n  <li> Split the method into smaller ones </li>\n</ul>\n<pre>\n// Each function does a part of what the original setCoordinates function was doing, so confusion risks are lower\nvoid setOrigin(int x, int y, int z) {\n   // ...\n}\n\nvoid setSize(int width, int height, int depth) {\n   // ...\n}\n</pre>\n<ul>\n  <li> Find a better data structure for the parameters that group data in a way that makes sense for the specific application domain </li>\n</ul>\n<pre>\nclass Point // In geometry, Point is a logical structure to group data\n{\n    public int x;\n    public int y;\n    public int z;\n };\n\nvoid setCoordinates(Point p1, Point p2) {\n    // ...\n}\n</pre>\n<p>This rule raises an issue when a method has more parameters than the provided threshold.</p>\n<h3>Exceptions</h3>\n<p>Methods annotated with :</p>\n<ul>\n  <li> Spring's <code>@RequestMapping</code> (and related shortcut annotations, like <code>@GetRequest</code>) </li>\n  <li> JAX-RS API annotations (like <code>@javax.ws.rs.GET</code>) </li>\n  <li> Bean constructor injection with <code>@org.springframework.beans.factory.annotation.Autowired</code> </li>\n  <li> CDI constructor injection with <code>@javax.inject.Inject</code> </li>\n  <li> <code>@com.fasterxml.jackson.annotation.JsonCreator</code> </li>\n  <li> Micronaut's annotations (like <code>@io.micronaut.http.annotation.Get</code>) </li>\n</ul>\n<p>may have a lot of parameters, encapsulation being possible. Therefore the rule ignores such methods.</p>\n<p>Also, if a class annotated as a Spring component (like <code>@org.springframework.stereotype.Component</code>) has a single constructor, that\nconstructor will be considered <code>@Autowired</code> and ignored by the rule.</p>",
    "howToFix": "",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "메서드는 너무 많은 매개변수를 가지면 안 됩니다",
    "why_ko": "<p>매개변수 목록이 긴 메서드는 유지 관리자가 각 매개변수의 역할을 파악하고 위치를 추적해야 하므로 사용하기 어렵습니다.</p>\n<pre>\nvoid setCoordinates(int x1, int y1, int z1, int x2, int y2, int z2) { // 규칙 위반\n    // ...\n}\n</pre>\n<p>해결책은 다음과 같습니다:</p>\n<ul>\n  <li> 메서드를 더 작은 것들로 분할 </li>\n</ul>\n<pre>\n// 각 함수는 원래 setCoordinates 함수가 하던 것의 일부를 수행하므로 혼동 위험이 낮아집니다\nvoid setOrigin(int x, int y, int z) {\n   // ...\n}\n\nvoid setSize(int width, int height, int depth) {\n   // ...\n}\n</pre>\n<ul>\n  <li> 특정 애플리케이션 도메인에 맞는 방식으로 데이터를 그룹화하는 더 나은 데이터 구조를 찾기 </li>\n</ul>\n<pre>\nclass Point // 기하학에서 Point는 데이터를 그룹화하는 논리적 구조입니다\n{\n    public int x;\n    public int y;\n    public int z;\n };\n\nvoid setCoordinates(Point p1, Point p2) {\n    // ...\n}\n</pre>\n<p>이 규칙은 메서드의 매개변수가 제공된 임계값보다 많을 때 이슈를 발생시킵니다.</p>\n<h3>예외</h3>\n<p>다음으로 어노테이션된 메서드:</p>\n<ul>\n  <li> Spring의 <code>@RequestMapping</code> (및 <code>@GetRequest</code>와 같은 관련 단축 어노테이션) </li>\n  <li> JAX-RS API 어노테이션(<code>@javax.ws.rs.GET</code> 등) </li>\n  <li> <code>@org.springframework.beans.factory.annotation.Autowired</code>를 사용한 Bean 생성자 주입 </li>\n  <li> <code>@javax.inject.Inject</code>를 사용한 CDI 생성자 주입 </li>\n  <li> <code>@com.fasterxml.jackson.annotation.JsonCreator</code> </li>\n  <li> Micronaut의 어노테이션(<code>@io.micronaut.http.annotation.Get</code> 등) </li>\n</ul>\n<p>은 캡슐화가 가능하므로 많은 매개변수를 가질 수 있습니다. 따라서 규칙은 이러한 메서드를 무시합니다.</p>\n<p>또한 Spring 컴포넌트로 어노테이션된 클래스(<code>@org.springframework.stereotype.Component</code> 등)에 단일 생성자가 있는 경우, 해당 생성자는 <code>@Autowired</code>로 간주되어 규칙에서 무시됩니다.</p>",
    "howToFix_ko": "",
    "moreInfo_ko": ""
  },
  {
    "id": "S7190",
    "key": "java:S7190",
    "name": "Methods annotated with \"@BeforeTransaction\" or \"@AfterTransaction\" must respect the contract",
    "type": "code-smell",
    "severity": "critical",
    "tags": [
      "spring",
      "tests"
    ],
    "why": "<p>In tests configured with Spring's <code>@Transactional</code> annotation, methods annotated with <code>@BeforeTransaction</code> or\n<code>@AfterTransaction</code> must be void and have no arguments. These methods are executed before or after a transaction, respectively. Deviating\nfrom this contract by having a non-void return type or accepting arguments will cause Spring to throw a runtime error.</p>",
    "howToFix": "<p>Ensure that methods annotated with <code>@BeforeTransaction</code> or <code>@AfterTransaction</code> have a void return type and do not accept any\narguments.</p>\n\n<h4>Noncompliant code example</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\n@Transactional\npublic class TransactionalTest {\n\n    @BeforeTransaction\n    public String setupTransaction(int x) { // non-compliant, method should be void and have no argument\n        // Setup logic\n    }\n\n    @AfterTransaction\n    public int cleanupTransaction(int x) { // non-compliant, method should be void and have no argument\n        // Cleanup logic\n    }\n}\n</pre>\n<h4>Compliant solution</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\n@Transactional\npublic class TransactionalTest {\n\n    @BeforeTransaction\n    public void setupTransaction() {\n        // Setup logic\n    }\n\n    @AfterTransaction\n    public void cleanupTransaction() {\n        // Cleanup logic\n    }\n}\n</pre>",
    "moreInfo": "<h3>Documentation</h3>\n<ul>\n  <li> Spring - <a\n  href=\"https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/test/context/transaction/BeforeTransaction.html\">BeforeTransaction</a> </li>\n  <li> Spring - <a\n  href=\"https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/test/context/transaction/AfterTransaction.html\">AfterTransaction</a> </li>\n</ul>",
    "status": "READY",
    "name_ko": "\"@BeforeTransaction\" 또는 \"@AfterTransaction\" 어노테이션이 적용된 메서드는 규약을 준수해야 합니다",
    "why_ko": "<p>Spring의 <code>@Transactional</code> 어노테이션으로 구성된 테스트에서 <code>@BeforeTransaction</code> 또는 <code>@AfterTransaction</code>으로 어노테이션된 메서드는 void여야 하고 인수가 없어야 합니다. 이러한 메서드는 각각 트랜잭션 전 또는 후에 실행됩니다. void가 아닌 반환 타입을 갖거나 인수를 받아 이 규약에서 벗어나면 Spring이 런타임 오류를 발생시킵니다.</p>",
    "howToFix_ko": "<p><code>@BeforeTransaction</code> 또는 <code>@AfterTransaction</code>으로 어노테이션된 메서드가 void 반환 타입을 갖고 인수를 받지 않도록 하세요.</p>\n\n<h4>규칙을 준수하지 않는 코드 예시</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\n@Transactional\npublic class TransactionalTest {\n\n    @BeforeTransaction\n    public String setupTransaction(int x) { // 규칙 위반, 메서드는 void여야 하고 인수가 없어야 합니다\n        // 설정 로직\n    }\n\n    @AfterTransaction\n    public int cleanupTransaction(int x) { // 규칙 위반, 메서드는 void여야 하고 인수가 없어야 합니다\n        // 정리 로직\n    }\n}\n</pre>\n<h4>규칙을 준수하는 해결책</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\n@Transactional\npublic class TransactionalTest {\n\n    @BeforeTransaction\n    public void setupTransaction() {\n        // 설정 로직\n    }\n\n    @AfterTransaction\n    public void cleanupTransaction() {\n        // 정리 로직\n    }\n}\n</pre>",
    "moreInfo_ko": "<h3>문서</h3>\n<ul>\n  <li> Spring - <a href=\"https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/test/context/transaction/BeforeTransaction.html\">BeforeTransaction</a> </li>\n  <li> Spring - <a href=\"https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/test/context/transaction/AfterTransaction.html\">AfterTransaction</a> </li>\n</ul>"
  },
  {
    "id": "S5841",
    "key": "java:S5841",
    "name": "AssertJ assertions \"allMatch\" and \"doesNotContain\" should also test for emptiness",
    "type": "bug",
    "severity": "minor",
    "tags": [
      "tests",
      "assertj"
    ],
    "why": "<p>AssertJ assertions <code>allMatch</code> and <code>doesNotContain</code> on an empty list always&nbsp;returns true whatever the content of the\npredicate. Despite being correct, you should make explicit if you expect an empty list or not, by adding\n<code>isEmpty()</code>/<code>isNotEmpty()</code> in addition to calling the assertion, or by testing the list's content further. It will justify the\nuseless predicate to improve clarity or increase the reliability of the test.</p>\n<p>This rule raises an issue when any of the methods listed are used without asserting that the list is empty or not and without testing the\ncontent.</p>\n<p>Targetted methods:</p>\n<ul>\n  <li> <code>allMatch</code> </li>\n  <li> <code>allSatisfy</code> </li>\n  <li> <code>doesNotContain</code> </li>\n  <li> <code>doesNotContainSequence</code> </li>\n  <li> <code>doesNotContainSubsequence</code> </li>\n  <li> <code>doesNotContainAnyElementsOf</code> </li>\n</ul>\n<h3>Noncompliant code example</h3>\n<pre>\nList&lt;String&gt; logs = getLogs();\n\nassertThat(logs).allMatch(e -&gt; e.contains(\"error\")); // Noncompliant, this test pass if logs are empty!\nassertThat(logs).doesNotContain(\"error\"); // Noncompliant, do you expect any log?\n</pre>\n<h3>Compliant solution</h3>\n<pre>\nList&lt;String&gt; logs = getLogs();\n\nassertThat(logs).isNotEmpty().allMatch(e -&gt; e.contains(\"error\"));\n// Or\nassertThat(logs).hasSize(5).allMatch(e -&gt; e.contains(\"error\"));\n// Or\nassertThat(logs).isEmpty();\n\n// Despite being redundant, this is also acceptable since it explains why you expect an empty list\nassertThat(logs).doesNotContain(\"error\").isEmpty();\n// or test the content of the list further\nassertThat(logs).contains(\"warning\").doesNotContain(\"error\");\n</pre>",
    "howToFix": "",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "AssertJ의 \"allMatch\"와 \"doesNotContain\" assertion은 빈 컬렉션 여부도 테스트해야 합니다",
    "why_ko": "<p>빈 리스트에서 AssertJ의 <code>allMatch</code>와 <code>doesNotContain</code> assertion은 predicate의 내용이 무엇이든 항상 true를 반환합니다. 이것이 올바르더라도 빈 리스트를 예상하는지 여부를 명시적으로 해야 합니다. assertion 호출 외에 <code>isEmpty()</code>/<code>isNotEmpty()</code>를 추가하거나 리스트의 내용을 추가로 테스트하여 명확성을 높이거나 테스트의 신뢰성을 높이세요.</p>\n<p>이 규칙은 나열된 메서드 중 하나가 리스트가 비어 있는지 여부를 assert하지 않고 내용을 테스트하지 않고 사용될 때 문제를 제기합니다.</p>\n<p>대상 메서드:</p>\n<ul>\n  <li> <code>allMatch</code> </li>\n  <li> <code>allSatisfy</code> </li>\n  <li> <code>doesNotContain</code> </li>\n  <li> <code>doesNotContainSequence</code> </li>\n  <li> <code>doesNotContainSubsequence</code> </li>\n  <li> <code>doesNotContainAnyElementsOf</code> </li>\n</ul>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\nList&lt;String&gt; logs = getLogs();\n\nassertThat(logs).allMatch(e -&gt; e.contains(\"error\")); // 규칙 위반, logs가 비어 있으면 이 테스트가 통과합니다!\nassertThat(logs).doesNotContain(\"error\"); // 규칙 위반, 로그가 있을 것으로 예상합니까?\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre>\nList&lt;String&gt; logs = getLogs();\n\nassertThat(logs).isNotEmpty().allMatch(e -&gt; e.contains(\"error\"));\n// 또는\nassertThat(logs).hasSize(5).allMatch(e -&gt; e.contains(\"error\"));\n// 또는\nassertThat(logs).isEmpty();\n\n// 중복되지만 빈 리스트를 예상하는 이유를 설명하므로 허용됩니다\nassertThat(logs).doesNotContain(\"error\").isEmpty();\n// 또는 리스트의 내용을 추가로 테스트\nassertThat(logs).contains(\"warning\").doesNotContain(\"error\");\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": ""
  },
  {
    "id": "S6914",
    "key": "java:S6914",
    "name": "Use Fused Location to optimize battery power",
    "type": "code-smell",
    "severity": "major",
    "tags": [
      "android",
      "sustainability"
    ],
    "why": "<p>The location awareness feature can significantly drain the device's battery.</p>\n<p>The recommended way to maximize the battery life is to use the <em>fused location provider</em> which combines signals from GPS, Wi-Fi, and cell\nnetworks, as well as accelerometer, gyroscope, magnetometer and other sensors. The <code>FusedLocationProviderClient</code> automatically chooses the\nbest method to retrieve a device's location based on the device's context.</p>\n<p>The rule flags an issue when <code>android.location.LocationManager</code> or <code>com.google.android.gms.location.LocationClient</code> is used\ninstead of <code>com.google.android.gms.location.FusedLocationProviderClient</code>.</p>\n<h3>What is the potential impact?</h3>\n<ul>\n  <li> <em>Usability</em>: the non-optimized location API consumer more battery. </li>\n  <li> <em>Sustainability</em>: the extra energy required has a negative impact on the environment. </li>\n</ul>",
    "howToFix": "<p>Replace the usages of <code>android.location.LocationManager</code> or <code>com.google.android.gms.location.LocationClient</code> with\n<code>com.google.android.gms.location.FusedLocationProviderClient</code>.</p>\n\n<h4>Noncompliant code example</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\npublic class LocationsActivity extends Activity {\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        // ...\n\n        LocationManager locationManager = (LocationManager) this.getSystemService(Context.LOCATION_SERVICE); // Noncompliant\n\n        LocationListener locationListener = new LocationListener() {\n            public void onLocationChanged(Location location) {\n                // Use the location object as needed\n            }\n        };\n\n        locationManager.requestLocationUpdates(LocationManager.GPS_PROVIDER, 0, 0, locationListener);\n    }\n}\n</pre>\n<h4>Compliant solution</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\npublic class LocationsActivity extends Activity {\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        // ...\n\n        FusedLocationProviderClient fusedLocationClient = LocationServices.getFusedLocationProviderClient(this); // Compliant\n\n        fusedLocationClient.getLastLocation()\n            .addOnSuccessListener(this, location -&gt; {\n                // Use the location object as needed\n            });\n    }\n}\n</pre>",
    "moreInfo": "<h3>Documentation</h3>\n<ul>\n  <li> <a href=\"https://developers.google.com/android/reference/com/google/android/gms/location/FusedLocationProviderClient.html\">Google Play Services\n  - FusedLocationProviderClient</a> </li>\n  <li> <a href=\"https://developer.android.com/develop/sensors-and-location/location/battery\">Android Developers - Optimize location for battery</a>\n  </li>\n  <li> <a href=\"https://developer.android.com/reference/android/location/package-summary\">Android Developers - Android Location</a> </li>\n</ul>",
    "status": "READY",
    "name_ko": "배터리 전력 최적화를 위해 Fused Location을 사용해야 합니다",
    "why_ko": "<p>위치 인식 기능은 기기의 배터리를 상당히 소모할 수 있습니다.</p>\n<p>배터리 수명을 극대화하는 권장 방법은 GPS, Wi-Fi, 셀룰러 네트워크의 신호와 가속도계, 자이로스코프, 자력계 및 기타 센서를 결합하는 <em>융합 위치 제공자(fused location provider)</em>를 사용하는 것입니다. <code>FusedLocationProviderClient</code>는 기기의 상황에 따라 위치를 검색하는 최적의 방법을 자동으로 선택합니다.</p>\n<p>이 규칙은 <code>com.google.android.gms.location.FusedLocationProviderClient</code> 대신 <code>android.location.LocationManager</code> 또는 <code>com.google.android.gms.location.LocationClient</code>가 사용될 때 문제를 발생시킵니다.</p>\n<h3>잠재적 영향은 무엇인가요?</h3>\n<ul>\n  <li> <em>사용성</em>: 최적화되지 않은 위치 API는 더 많은 배터리를 소모합니다. </li>\n  <li> <em>지속 가능성</em>: 필요한 추가 에너지는 환경에 부정적인 영향을 미칩니다. </li>\n</ul>","howToFix_ko": "<p><code>android.location.LocationManager</code> 또는 <code>com.google.android.gms.location.LocationClient</code>의 사용을 <code>com.google.android.gms.location.FusedLocationProviderClient</code>로 교체하세요.</p>\n\n<h4>규칙을 준수하지 않는 코드 예시</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\npublic class LocationsActivity extends Activity {\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        // ...\n\n        LocationManager locationManager = (LocationManager) this.getSystemService(Context.LOCATION_SERVICE); // 규칙 위반\n\n        LocationListener locationListener = new LocationListener() {\n            public void onLocationChanged(Location location) {\n                // 필요에 따라 location 객체를 사용\n            }\n        };\n\n        locationManager.requestLocationUpdates(LocationManager.GPS_PROVIDER, 0, 0, locationListener);\n    }\n}\n</pre>\n<h4>규칙을 준수하는 해결책</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\npublic class LocationsActivity extends Activity {\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        // ...\n\n        FusedLocationProviderClient fusedLocationClient = LocationServices.getFusedLocationProviderClient(this); // 규칙 준수\n\n        fusedLocationClient.getLastLocation()\n            .addOnSuccessListener(this, location -&gt; {\n                // 필요에 따라 location 객체를 사용\n            });\n    }\n}\n</pre>",
    "moreInfo_ko": "<h3>문서</h3>\n<ul>\n  <li> <a href=\"https://developers.google.com/android/reference/com/google/android/gms/location/FusedLocationProviderClient.html\">Google Play Services - FusedLocationProviderClient</a> </li>\n  <li> <a href=\"https://developer.android.com/develop/sensors-and-location/location/battery\">Android Developers - 배터리를 위한 위치 최적화</a> </li>\n  <li> <a href=\"https://developer.android.com/reference/android/location/package-summary\">Android Developers - Android Location</a> </li>\n</ul>"
  },
  {
    "id": "S4929",
    "key": "java:S4929",
    "name": "\"read(byte[],int,int)\" should be overridden",
    "type": "code-smell",
    "severity": "minor",
    "tags": [
      "performance"
    ],
    "why": "<p>When directly subclassing <code>java.io.InputStream</code> or <code>java.io.FilterInputStream</code>, the only requirement is that you implement\nthe method <code>read()</code>. However most uses for such streams don't read a single byte at a time and the default implementation for\n<code>read(byte[],int,int)</code> will call <code>read(int)</code> for every single byte in the array which can create a lot of overhead and is\nutterly inefficient. It is therefore strongly recommended that subclasses provide an efficient implementation of\n<code>read(byte[],int,int)</code>.</p>\n<p>This rule raises an issue when a direct subclass of <code>java.io.InputStream</code> or <code>java.io.FilterInputStream</code> doesn't provide an\noverride of <code>read(byte[],int,int)</code>.</p>\n<h3>Noncompliant code example</h3>\n<pre>\npublic class MyInputStream extends java.io.InputStream {\n  private FileInputStream fin;\n\n  public MyInputStream(File file) throws IOException {\n    fin = new FileInputStream(file);\n  }\n\n  @Override\n  public int read() throws IOException {\n    return fin.read();\n  }\n}\n</pre>\n<h3>Compliant solution</h3>\n<pre>\npublic class MyInputStream extends java.io.InputStream {\n  private FileInputStream fin;\n\n  public MyInputStream(File file) throws IOException {\n    fin = new FileInputStream(file);\n  }\n\n  @Override\n  public int read() throws IOException {\n    return fin.read();\n  }\n\n  @Override\n  public int read(byte[] b, int off, int len) throws IOException {\n    return fin.read(b, off, len);\n  }\n}\n</pre>\n<h3>Exceptions</h3>\n<p>This rule doesn't raise an issue when the class is declared <code>abstract</code>.</p>",
    "howToFix": "",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "read(byte[],int,int)를 오버라이드해야 합니다",
    "why_ko": "<p><code>java.io.InputStream</code> 또는 <code>java.io.FilterInputStream</code>을 직접 상속할 때 유일한 요구 사항은 <code>read()</code> 메서드를 구현하는 것입니다. 그러나 이러한 스트림의 대부분의 사용 사례는 한 번에 한 바이트를 읽지 않으며, <code>read(byte[],int,int)</code>의 기본 구현은 배열의 모든 단일 바이트에 대해 <code>read(int)</code>를 호출하여 많은 오버헤드를 생성하고 매우 비효율적입니다. 따라서 서브클래스가 <code>read(byte[],int,int)</code>의 효율적인 구현을 제공하는 것이 강력히 권장됩니다.</p>\n<p>이 규칙은 <code>java.io.InputStream</code> 또는 <code>java.io.FilterInputStream</code>의 직접 서브클래스가 <code>read(byte[],int,int)</code>의 오버라이드를 제공하지 않을 때 문제를 제기합니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\npublic class MyInputStream extends java.io.InputStream {\n  private FileInputStream fin;\n\n  public MyInputStream(File file) throws IOException {\n    fin = new FileInputStream(file);\n  }\n\n  @Override\n  public int read() throws IOException {\n    return fin.read();\n  }\n}\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre>\npublic class MyInputStream extends java.io.InputStream {\n  private FileInputStream fin;\n\n  public MyInputStream(File file) throws IOException {\n    fin = new FileInputStream(file);\n  }\n\n  @Override\n  public int read() throws IOException {\n    return fin.read();\n  }\n\n  @Override\n  public int read(byte[] b, int off, int len) throws IOException {\n    return fin.read(b, off, len);\n  }\n}\n</pre>\n<h3>예외</h3>\n<p>이 규칙은 클래스가 <code>abstract</code>로 선언된 경우 문제를 제기하지 않습니다.</p>",
    "howToFix_ko": "",
    "moreInfo_ko": ""
  },
  {
    "id": "S1228",
    "key": "java:S1228",
    "name": "Packages should have a javadoc file 'package-info.java'",
    "type": "code-smell",
    "severity": "minor",
    "tags": [
      "convention"
    ],
    "why": "<p>Each package in a Java project should include a <code>package-info.java</code> file. The purpose of this file is to document the Java package using\njavadoc and declare package annotations.</p>\n<h3>Compliant solution</h3>\n<pre>\n/**\n* This package has non null parameters and is documented.\n**/\n@ParametersAreNonnullByDefault\npackage org.foo.bar;\n</pre>",
    "howToFix": "",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "패키지는 javadoc 파일 'package-info.java'를 가져야 합니다",
    "why_ko": "<p>Java 프로젝트의 각 패키지에는 <code>package-info.java</code> 파일이 포함되어야 합니다. 이 파일의 목적은 javadoc을 사용하여 Java 패키지를 문서화하고 패키지 어노테이션을 선언하는 것입니다.</p>\n<h3>규칙을 준수하는 해결책</h3>\n<pre>\n/**\n* 이 패키지는 null이 아닌 파라미터를 가지며 문서화되어 있습니다.\n**/\n@ParametersAreNonnullByDefault\npackage org.foo.bar;\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": ""
  },
  {
    "id": "S2111",
    "key": "java:S2111",
    "name": "\"BigDecimal(double)\" should not be used",
    "type": "bug",
    "severity": "major",
    "tags": [
      "cert"
    ],
    "why": "<p>The <code>BigDecimal</code> is used to represents immutable, arbitrary-precision signed decimal numbers.</p>\n<p>Differently from the <code>BigDecimal</code>, the <code>double</code> primitive type and the <code>Double</code> type have limited precision due to\nthe use of double-precision 64-bit IEEE 754 floating point. Because of floating point imprecision, the <code>BigDecimal(double)</code> constructor can\nbe somewhat unpredictable.</p>\n<p>For example writing <code>new BigDecimal(0.1)</code> doesn't create a BigDecimal which is exactly equal to 0.1, but it is equal to\n0.1000000000000000055511151231257827021181583404541015625. This is because 0.1 cannot be represented exactly as a double (or, for that matter, as a\nbinary fraction of any finite length).</p>",
    "howToFix": "<p>Use <code>BigDecimal.valueOf</code>, which uses a string under the covers to eliminate floating point rounding errors, or the constructor that\ntakes a <code>String</code> argument.</p>\n\n<h4>Noncompliant code example</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\ndouble d = 1.1;\n\nBigDecimal bd1 = new BigDecimal(d);   // Noncompliant\nBigDecimal bd2 = new BigDecimal(1.1); // Noncompliant\n</pre>\n<h4>Compliant solution</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\ndouble d = 1.1;\n\nBigDecimal bd1 = BigDecimal.valueOf(d); // Compliant\nBigDecimal bd2 = new BigDecimal(\"1.1\"); // Compliant\n</pre>",
    "moreInfo": "<h3>Documentation</h3>\n<ul>\n  <li> <a href=\"https://docs.oracle.com/en/java/javase/20/docs/api/java.base/java/math/BigDecimal.html\">Oracle - BigDecimal</a> </li>\n  <li> <a href=\"https://wiki.sei.cmu.edu/confluence/x/kzdGBQ\">CERT, NUM10-J</a> - Do not construct BigDecimal objects from floating-point literals\n  </li>\n</ul>",
    "status": "READY",
    "name_ko": "\"BigDecimal(double)\"은 사용하면 안 됩니다",
    "why_ko": "<p><code>BigDecimal</code>은 불변의 임의 정밀도 부호 있는 십진수를 나타내는 데 사용됩니다.</p>\n<p><code>BigDecimal</code>과 달리, <code>double</code> 기본 타입과 <code>Double</code> 타입은 배정밀도 64비트 IEEE 754 부동 소수점 사용으로 인해 제한된 정밀도를 가집니다. 부동 소수점 부정확성 때문에 <code>BigDecimal(double)</code> 생성자는 다소 예측 불가능할 수 있습니다.</p>\n<p>예를 들어 <code>new BigDecimal(0.1)</code>을 작성하면 정확히 0.1과 같은 BigDecimal이 생성되지 않고, 0.1000000000000000055511151231257827021181583404541015625와 같습니다. 이는 0.1이 double로 (또는 어떤 유한 길이의 이진 분수로도) 정확히 표현될 수 없기 때문입니다.</p>",
    "howToFix_ko": "<p>부동 소수점 반올림 오류를 제거하기 위해 내부적으로 문자열을 사용하는 <code>BigDecimal.valueOf</code>를 사용하거나 <code>String</code> 인수를 받는 생성자를 사용하세요.</p>\n\n<h4>규칙을 준수하지 않는 코드 예시</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\ndouble d = 1.1;\n\nBigDecimal bd1 = new BigDecimal(d);   // 규칙 위반\nBigDecimal bd2 = new BigDecimal(1.1); // 규칙 위반\n</pre>\n<h4>규칙을 준수하는 해결책</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\ndouble d = 1.1;\n\nBigDecimal bd1 = BigDecimal.valueOf(d); // 규칙 준수\nBigDecimal bd2 = new BigDecimal(\"1.1\"); // 규칙 준수\n</pre>",
    "moreInfo_ko": "<h3>문서</h3>\n<ul>\n  <li> <a href=\"https://docs.oracle.com/en/java/javase/20/docs/api/java.base/java/math/BigDecimal.html\">Oracle - BigDecimal</a> </li>\n  <li> <a href=\"https://wiki.sei.cmu.edu/confluence/x/kzdGBQ\">CERT, NUM10-J</a> - 부동 소수점 리터럴로 BigDecimal 객체를 생성하지 마세요 </li>\n</ul>"
  },
  {
    "id": "S3242",
    "key": "java:S3242",
    "name": "Method parameters should be declared with base types",
    "type": "code-smell",
    "severity": "minor",
    "tags": [
      "api-design"
    ],
    "why": "<p>For maximum reusability, methods should accept parameters with as little specialization as possible. So unless specific features from a child class\nare required by a method, a type higher up the class hierarchy should be used instead.</p>\n<h3>Noncompliant code example</h3>\n<pre>\npublic void printSize(ArrayList&lt;Object&gt; list) {  // Collection can be used instead\n    System.out.println(list.size());\n}\n\npublic static void loop(List&lt;Object&gt; list) { // java.lang.Iterable can be used instead\n   for (Object o : list) {\n     o.toString();\n  }\n}\n</pre>\n<h3>Compliant solution</h3>\n<pre>\npublic void printSize(Collection&lt;?&gt; list) {  // Collection can be used instead\n    System.out.println(list.size());\n}\n\npublic static void loop(Iterable&lt;?&gt; list) { // java.lang.Iterable can be used instead\n   for (Object o : list) {\n     o.toString();\n  }\n}\n</pre>\n<h3>Exceptions</h3>\n<p>Parameters in non-public methods are not checked, because such methods are not intended to be generally reusable. <code>java.lang.String</code>\nparameters are excluded, because String is immutable and can not be always substituted for more generic type. Parameters used in any other context\nthan method invocation or enhanced for loop are also excluded.</p>",
    "howToFix": "",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "메서드 매개변수는 기본 타입으로 선언해야 합니다",
    "why_ko": "<p>최대한의 재사용성을 위해 메서드는 가능한 한 특수화되지 않은 매개변수를 받아들여야 합니다. 따라서 메서드에서 자식 클래스의 특정 기능이 필요하지 않는 한, 클래스 계층 구조에서 더 상위에 있는 타입을 대신 사용해야 합니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\npublic void printSize(ArrayList&lt;Object&gt; list) {  // Collection을 대신 사용할 수 있음\n    System.out.println(list.size());\n}\n\npublic static void loop(List&lt;Object&gt; list) { // java.lang.Iterable을 대신 사용할 수 있음\n   for (Object o : list) {\n     o.toString();\n  }\n}\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre>\npublic void printSize(Collection&lt;?&gt; list) {  // Collection을 대신 사용할 수 있음\n    System.out.println(list.size());\n}\n\npublic static void loop(Iterable&lt;?&gt; list) { // java.lang.Iterable을 대신 사용할 수 있음\n   for (Object o : list) {\n     o.toString();\n  }\n}\n</pre>\n<h3>예외</h3>\n<p>non-public 메서드의 매개변수는 이러한 메서드가 일반적으로 재사용하도록 의도되지 않았기 때문에 검사하지 않습니다. <code>java.lang.String</code> 매개변수는 String이 불변이고 항상 더 일반적인 타입으로 대체될 수 없기 때문에 제외됩니다. 메서드 호출이나 향상된 for 루프가 아닌 다른 컨텍스트에서 사용되는 매개변수도 제외됩니다.</p>",
    "howToFix_ko": "",
    "moreInfo_ko": ""
  },
  {
    "id": "S6806",
    "key": "java:S6806",
    "name": "Model attributes should follow the Java identifier naming convention",
    "type": "bug",
    "severity": "major",
    "tags": [],
    "why": "<p>Spring Expression Language (SpEL) is an expression language used in the Spring Framework for evaluating and manipulating objects, properties, and\nconditions within Spring-based applications.</p>\n<p><code>org.springframework.ui.Model</code> is an interface in the Spring Framework that represents a container for data that can be passed between a\ncontroller and a view in a Spring MVC web application, allowing for data sharing during the request-response cycle.</p>\n<p>Attributes added to the <code>org.springframework.ui.Model</code> should follow the Java identifier naming convention, which means they must start\nwith a letter <code>a-z, A-Z</code>, underscore <code>_</code>, or a dollar sign <code>$</code> and may be followed by letters, digits, underscores,\nor dollar signs.</p>\n<p>Failure to do so may result in SpEL parsing errors when using these attributes in template engines.</p>",
    "howToFix": "<p>Follow the Java identifier naming convention.</p>\n\n<h4>Noncompliant code example</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\nmodel.addAttribute(\" a\", 100); // Noncompliant (starts with a space)\nmodel.addAttribute(\"a-b\", 7);  // Noncompliant (contains a hyphen)\nmodel.addAttribute(\"1c\", 42);  // Noncompliant (starts with a digit)\n</pre>\n<h4>Compliant solution</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\nmodel.addAttribute(\"a\", 100);\nmodel.addAttribute(\"b\", 42);\nmodel.addAttribute(\"_c\", 7);\nmodel.addAttribute(\"$d\", 8);\n</pre>",
    "moreInfo": "<h3>Documentation</h3>\n<ul>\n  <li> <a href=\"https://www.oracle.com/java/technologies/javase/codeconventions-namingconventions.html\">Java SE - naming conventions</a> </li>\n  <li> <a href=\"https://docs.spring.io/spring-framework/reference/core/expressions.html\">Spring Expression Language (SpEL)</a> </li>\n  <li> <a href=\"https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/ui/Model.html\">Spring IO Docs - Interface\n  Model</a> </li>\n</ul>",
    "status": "READY",
    "name_ko": "Model 속성은 Java 식별자 명명 규칙을 따라야 합니다",
    "why_ko": "<p>Spring Expression Language (SpEL)는 Spring 기반 애플리케이션 내에서 객체, 프로퍼티 및 조건을 평가하고 조작하기 위해 Spring Framework에서 사용되는 표현 언어입니다.</p>\n<p><code>org.springframework.ui.Model</code>은 Spring MVC 웹 애플리케이션에서 컨트롤러와 뷰 사이에 전달할 수 있는 데이터 컨테이너를 나타내는 Spring Framework의 인터페이스로, 요청-응답 주기 동안 데이터 공유를 허용합니다.</p>\n<p><code>org.springframework.ui.Model</code>에 추가된 속성은 Java 식별자 명명 규칙을 따라야 합니다. 즉, 문자 <code>a-z, A-Z</code>, 밑줄 <code>_</code> 또는 달러 기호 <code>$</code>로 시작해야 하며 그 뒤에 문자, 숫자, 밑줄 또는 달러 기호가 올 수 있습니다.</p>\n<p>이를 따르지 않으면 템플릿 엔진에서 이러한 속성을 사용할 때 SpEL 파싱 오류가 발생할 수 있습니다.</p>",
    "howToFix_ko": "<p>Java 식별자 명명 규칙을 따르세요.</p>\n\n<h4>규칙을 준수하지 않는 코드 예시</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\nmodel.addAttribute(\" a\", 100); // 규칙 위반 (공백으로 시작)\nmodel.addAttribute(\"a-b\", 7);  // 규칙 위반 (하이픈 포함)\nmodel.addAttribute(\"1c\", 42);  // 규칙 위반 (숫자로 시작)\n</pre>\n<h4>규칙을 준수하는 해결책</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\nmodel.addAttribute(\"a\", 100);\nmodel.addAttribute(\"b\", 42);\nmodel.addAttribute(\"_c\", 7);\nmodel.addAttribute(\"$d\", 8);\n</pre>",
    "moreInfo_ko": "<h3>문서</h3>\n<ul>\n  <li> <a href=\"https://www.oracle.com/java/technologies/javase/codeconventions-namingconventions.html\">Java SE - 명명 규칙</a> </li>\n  <li> <a href=\"https://docs.spring.io/spring-framework/reference/core/expressions.html\">Spring Expression Language (SpEL)</a> </li>\n  <li> <a href=\"https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/ui/Model.html\">Spring IO Docs - 인터페이스 Model</a> </li>\n</ul>"
  },
  {
    "id": "S2701",
    "key": "java:S2701",
    "name": "Literal boolean values and nulls should not be used in assertions",
    "type": "code-smell",
    "severity": "minor",
    "tags": [
      "junit",
      "tests"
    ],
    "why": "<p>There's no reason to use literal boolean values or nulls in assertions. Instead of using them with <em>assertEquals</em>, <em>assertNotEquals</em>\nand similar methods, you should be using <em>assertTrue</em>, <em>assertFalse</em>, <em>assertNull</em> or <em>assertNotNull</em> instead (or\n<em>isNull</em> etc. when using Fest). Using them with assertions unrelated to equality (such as <em>assertNull</em>) is most likely a bug.</p>\n<p>Supported frameworks:</p>\n<ul>\n  <li> JUnit3 </li>\n  <li> JUnit4 </li>\n  <li> JUnit5 </li>\n  <li> Fest assert </li>\n</ul>\n<h3>Noncompliant code example</h3>\n<pre>\nAssert.assertTrue(true);  // Noncompliant\nassertThat(null).isNull(); // Noncompliant\n\nassertEquals(true, something()); // Noncompliant\nassertNotEquals(null, something()); // Noncompliant\n</pre>\n<h3>Compliant solution</h3>\n<pre>\nassertTrue(something());\nassertNotNull(something());\n</pre>",
    "howToFix": "",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "리터럴 boolean 값과 null을 assertion에서 사용하면 안 됩니다",
    "why_ko": "<p>assertion에서 리터럴 boolean 값이나 null을 사용할 이유가 없습니다. <em>assertEquals</em>, <em>assertNotEquals</em> 및 유사한 메서드와 함께 사용하는 대신 <em>assertTrue</em>, <em>assertFalse</em>, <em>assertNull</em> 또는 <em>assertNotNull</em>을 사용해야 합니다(Fest를 사용할 때는 <em>isNull</em> 등). 동등성과 관련 없는 assertion(<em>assertNull</em> 등)과 함께 사용하면 버그일 가능성이 높습니다.</p>\n<p>지원되는 프레임워크:</p>\n<ul>\n  <li> JUnit3 </li>\n  <li> JUnit4 </li>\n  <li> JUnit5 </li>\n  <li> Fest assert </li>\n</ul>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\nAssert.assertTrue(true);  // 규칙 위반\nassertThat(null).isNull(); // 규칙 위반\n\nassertEquals(true, something()); // 규칙 위반\nassertNotEquals(null, something()); // 규칙 위반\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre>\nassertTrue(something());\nassertNotNull(something());\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": ""
  },
  {
    "id": "S4790",
    "key": "java:S4790",
    "name": "Using weak hashing algorithms is security-sensitive",
    "type": "security-hotspot",
    "severity": "critical",
    "tags": [
      "cwe"
    ],
    "why": "<p>Cryptographic hash algorithms such as <code>MD2</code>, <code>MD4</code>, <code>MD5</code>, <code>MD6</code>, <code>HAVAL-128</code>,\n<code>DSA</code> (which uses <code>SHA-1</code>), <code>RIPEMD</code>, <code>RIPEMD-128</code>, <code>RIPEMD-160</code>and <code>SHA-1</code> are no\nlonger considered secure, because it is possible to have <code>collisions</code> (little computational effort is enough to find two or more different\ninputs that produce the same hash).</p>\n<p>Message authentication code (MAC) algorithms such as <code>HMAC-MD5</code> or <code>HMAC-SHA1</code> use weak hash functions as building blocks.\nAlthough they are not all proven to be weak, they are considered legacy algorithms and should be avoided.</p>\n",
    "howToFix": "<h2>Recommended Secure Coding Practices</h2>\n<p>Safer alternatives, such as <code>SHA-256</code>, <code>SHA-512</code>, <code>SHA-3</code> are recommended, and for password hashing, it's even\nbetter to use algorithms that do not compute too \"quickly\", like <code>bcrypt</code>, <code>scrypt</code>, <code>argon2</code> or <code>pbkdf2</code>\nbecause it slows down <code>brute force attacks</code>.</p>\n<h2>Compliant Solution</h2>\n<pre>\nMessageDigest md1 = MessageDigest.getInstance(\"SHA-512\"); // Compliant\n</pre>\n<h2>See</h2>\n<ul>\n  <li> OWASP - <a href=\"https://owasp.org/Top10/A02_2021-Cryptographic_Failures/\">Top 10 2021 Category A2 - Cryptographic Failures</a> </li>\n  <li> OWASP - <a href=\"https://owasp.org/www-project-top-ten/2017/A3_2017-Sensitive_Data_Exposure\">Top 10 2017 Category A3 - Sensitive Data\n  Exposure</a> </li>\n  <li> OWASP - <a href=\"https://owasp.org/www-project-top-ten/2017/A6_2017-Security_Misconfiguration\">Top 10 2017 Category A6 - Security\n  Misconfiguration</a> </li>\n  <li> OWASP - <a href=\"https://mas.owasp.org/checklists/MASVS-CRYPTO/\">Mobile AppSec Verification Standard - Cryptography Requirements</a> </li>\n  <li> OWASP - <a href=\"https://owasp.org/www-project-mobile-top-10/2016-risks/m5-insufficient-cryptography\">Mobile Top 10 2016 Category M5 -\n  Insufficient Cryptography</a> </li>\n  <li> OWASP - <a href=\"https://owasp.org/www-project-mobile-top-10/2023-risks/m10-insufficient-cryptography\">Mobile Top 10 2024 Category M10 -\n  Insufficient Cryptography</a> </li>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/1240\">CWE-1240 - Use of a Risky Cryptographic Primitive</a> </li>\n</ul>",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "취약한 해싱 알고리즘 사용은 보안에 민감합니다",
    "why_ko": "<p><code>MD2</code>, <code>MD4</code>, <code>MD5</code>, <code>MD6</code>, <code>HAVAL-128</code>, <code>DSA</code>(<code>SHA-1</code> 사용), <code>RIPEMD</code>, <code>RIPEMD-128</code>, <code>RIPEMD-160</code> 및 <code>SHA-1</code>과 같은 암호화 해시 알고리즘은 <code>충돌</code>이 가능하기 때문에(동일한 해시를 생성하는 두 개 이상의 다른 입력을 찾는 데 적은 계산 노력으로 충분함) 더 이상 안전하다고 간주되지 않습니다.</p>\n<p><code>HMAC-MD5</code> 또는 <code>HMAC-SHA1</code>과 같은 메시지 인증 코드(MAC) 알고리즘은 취약한 해시 함수를 빌딩 블록으로 사용합니다. 모두 취약한 것으로 입증되지는 않았지만 레거시 알고리즘으로 간주되어 피해야 합니다.</p>\n",
    "howToFix_ko": "<h2>권장되는 보안 코딩 관행</h2>\n<p><code>SHA-256</code>, <code>SHA-512</code>, <code>SHA-3</code>과 같은 더 안전한 대안이 권장되며, 비밀번호 해싱의 경우 <code>무차별 대입 공격</code>을 늦추기 때문에 <code>bcrypt</code>, <code>scrypt</code>, <code>argon2</code> 또는 <code>pbkdf2</code>와 같이 너무 \"빠르게\" 계산하지 않는 알고리즘을 사용하는 것이 더 좋습니다.</p>\n<h2>규칙을 준수하는 해결책</h2>\n<pre>\nMessageDigest md1 = MessageDigest.getInstance(\"SHA-512\"); // 규칙 준수\n</pre>\n<h2>참고</h2>\n<ul>\n  <li> OWASP - <a href=\"https://owasp.org/Top10/A02_2021-Cryptographic_Failures/\">Top 10 2021 카테고리 A2 - 암호화 실패</a> </li>\n  <li> OWASP - <a href=\"https://owasp.org/www-project-top-ten/2017/A3_2017-Sensitive_Data_Exposure\">Top 10 2017 카테고리 A3 - 민감한 데이터 노출</a> </li>\n  <li> OWASP - <a href=\"https://owasp.org/www-project-top-ten/2017/A6_2017-Security_Misconfiguration\">Top 10 2017 카테고리 A6 - 보안 구성 오류</a> </li>\n  <li> OWASP - <a href=\"https://mas.owasp.org/checklists/MASVS-CRYPTO/\">Mobile AppSec 검증 표준 - 암호화 요구 사항</a> </li>\n  <li> OWASP - <a href=\"https://owasp.org/www-project-mobile-top-10/2016-risks/m5-insufficient-cryptography\">Mobile Top 10 2016 카테고리 M5 - 불충분한 암호화</a> </li>\n  <li> OWASP - <a href=\"https://owasp.org/www-project-mobile-top-10/2023-risks/m10-insufficient-cryptography\">Mobile Top 10 2024 카테고리 M10 - 불충분한 암호화</a> </li>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/1240\">CWE-1240 - 위험한 암호화 기본 요소 사용</a> </li>\n</ul>",
    "moreInfo_ko": ""
  },
  {
    "id": "S1068",
    "key": "java:S1068",
    "name": "Unused \"private\" fields should be removed",
    "type": "code-smell",
    "severity": "major",
    "tags": [
      "unused"
    ],
    "why": "<p>If a <code>private</code> field is declared but not used locally, its limited visibility makes it dead code.</p>\n<p>This is either a sign that some logic is missing or that the code should be cleaned.</p>\n<p>Cleaning out dead code decreases the size of the maintained codebase, making it easier to understand and preventing bugs from being introduced.</p>\n<pre>\npublic class MyClass {\n  private int foo = 42; // Noncompliant: foo is unused and should be removed\n\n  public int compute(int a) {\n    return a * 42;\n  }\n\n}\n</pre>\n<p>Note that this rule does not take reflection into account, which means that issues will be raised on <code>private</code> fields that are only\naccessed using the reflection API.</p>\n<h3>Exceptions</h3>\n<p>The rule admits 3 exceptions:</p>\n<ul>\n  <li> Serialization ID fields </li>\n</ul>\n<p>The Java serialization runtime associates with each serializable class a version number called <code>serialVersionUID</code>, which is used during\ndeserialization to verify that the sender and receiver of a serialized object have loaded classes for that object that are compatible for\nserialization.</p>\n<p>A serializable class can declare its own <code>serialVersionUID</code> explicitly by declaring a field named <code>serialVersionUID</code> that\nmust be static, final, and of type long. By definition, those <code>serialVersionUID</code> fields should not be reported by this rule:</p>\n<pre>\npublic class MyClass implements java.io.Serializable {\n  private static final long serialVersionUID = 42L;  // Compliant by exception\n}\n</pre>\n<ul>\n  <li> Annotated fields and classes annotated with Lombok annotations </li>\n</ul>\n<p>The unused field in this class will not be reported by the rule as it is annotated, except if annotation class <code>SomeAnnotation</code> is\nlisted in the <code>ignoreAnnotations</code> parameter (see Parameters).</p>\n<pre>\npublic class MyClass {\n  @SomeAnnotation\n  private int unused;  // Compliant by exception\n}\n</pre>\n<ul>\n  <li> Fields from classes with native methods </li>\n</ul>\n<p>The unused field in this class will not be reported by the rule as it might be used by native code.</p>\n<pre>\npublic class MyClass {\n  private int unused = 42;  // Compliant by exception\n  private native static void doSomethingNative();\n}\n</pre>",
    "howToFix": "",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "사용되지 않는 \"private\" 필드는 제거해야 합니다",
    "why_ko": "<p><code>private</code> 필드가 선언되었지만 로컬에서 사용되지 않으면, 제한된 가시성으로 인해 죽은 코드가 됩니다.</p>\n<p>이것은 일부 로직이 누락되었거나 코드를 정리해야 한다는 신호입니다.</p>\n<p>죽은 코드를 정리하면 유지보수해야 하는 코드베이스의 크기가 줄어들어 이해하기 쉬워지고 버그가 도입되는 것을 방지합니다.</p>\n<pre>\npublic class MyClass {\n  private int foo = 42; // 규칙 위반: foo는 사용되지 않으므로 제거해야 합니다\n\n  public int compute(int a) {\n    return a * 42;\n  }\n\n}\n</pre>\n<p>이 규칙은 리플렉션을 고려하지 않으므로, 리플렉션 API를 통해서만 접근하는 <code>private</code> 필드에 대해서도 이슈가 발생합니다.</p>\n<h3>예외 사항</h3>\n<p>이 규칙은 3가지 예외를 인정합니다:</p>\n<ul>\n  <li> 직렬화 ID 필드 </li>\n</ul>\n<p>Java 직렬화 런타임은 각 직렬화 가능 클래스에 <code>serialVersionUID</code>라는 버전 번호를 연관시키며, 이는 역직렬화 중에 직렬화된 객체의 발신자와 수신자가 직렬화에 호환되는 클래스를 로드했는지 확인하는 데 사용됩니다.</p>\n<p>직렬화 가능 클래스는 static, final, long 타입이어야 하는 <code>serialVersionUID</code>라는 이름의 필드를 선언하여 자체 <code>serialVersionUID</code>를 명시적으로 선언할 수 있습니다. 정의상, 이러한 <code>serialVersionUID</code> 필드는 이 규칙에 의해 보고되지 않아야 합니다:</p>\n<pre>\npublic class MyClass implements java.io.Serializable {\n  private static final long serialVersionUID = 42L;  // 예외로 규칙 준수\n}\n</pre>\n<ul>\n  <li> 어노테이션이 붙은 필드와 Lombok 어노테이션이 붙은 클래스 </li>\n</ul>\n<p>이 클래스의 사용되지 않는 필드는 어노테이션이 붙어 있으므로 규칙에 의해 보고되지 않습니다. 단, 어노테이션 클래스 <code>SomeAnnotation</code>이 <code>ignoreAnnotations</code> 매개변수에 나열된 경우는 제외입니다(매개변수 참조).</p>\n<pre>\npublic class MyClass {\n  @SomeAnnotation\n  private int unused;  // 예외로 규칙 준수\n}\n</pre>\n<ul>\n  <li> 네이티브 메서드가 있는 클래스의 필드 </li>\n</ul>\n<p>이 클래스의 사용되지 않는 필드는 네이티브 코드에서 사용될 수 있으므로 규칙에 의해 보고되지 않습니다.</p>\n<pre>\npublic class MyClass {\n  private int unused = 42;  // 예외로 규칙 준수\n  private native static void doSomethingNative();\n}\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": ""
  },
  {
    "id": "S2097",
    "key": "java:S2097",
    "name": "\"equals(Object obj)\" should test the argument's type",
    "type": "bug",
    "severity": "minor",
    "tags": [],
    "why": "<p>The <code>Object#equals(Object obj)</code> method is used to compare two objects to see if they are equal.</p>\n<p>The <code>obj</code> parameter's type is <code>Object</code>, this means that an object of any type can be passed as a parameter to this\nmethod.</p>\n<p>Any class overriding <code>Object#equals(Object obj)</code> should respect this contract, accept any object as an argument, and return\n<code>false</code> when the argument's type differs from the expected type. The <code>obj</code> parameter's type can be checked using\n<code>instanceof</code> or by comparing the <code>getClass()</code> value:</p>\n<pre>\n@Override\npublic boolean equals(Object obj) {\n  // ...\n  if (this.getClass() != obj.getClass()) {\n    return false;\n  }\n  // ...\n}\n</pre>\n<p>However, it is an issue to assume that the <code>equals</code> method will only be used to compare objects of the same type. Casting the\n<code>obj</code> parameter without a prior test will throw a <code>ClassCastException</code> instead of returning false.</p>\n<pre>\npublic class MyClass {\n  @Override\n  public boolean equals(Object obj) {\n    MyClass that = (MyClass) obj; // may throw a ClassCastException\n    // ...\n  }\n  // ...\n}\n</pre>\n<p>This rule raises an issue when <code>obj</code> parameter's type has not been tested before a cast operation.</p>",
    "howToFix": "<p>Ensure the <code>obj</code> parameter's type is checked by comparing <code>this.getClass()</code> and <code>obj.getClass()</code>, or use the\n<code>instanceof</code> operator to test `obj's type.</p>\n\n<h4>Noncompliant code example</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\npublic class MyClass {\n  @Override\n  public boolean equals(Object obj) {\n    if (this == obj) {\n      return true;\n    }\n    if (obj == null) {\n      return false;\n    }\n    MyClass that = (MyClass) obj; // Noncompliant, may throw a ClassCastException\n    // ...\n  }\n  // ...\n}\n</pre>\n<h4>Compliant solution</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\npublic class MyClass {\n  @Override\n  public boolean equals(Object obj) {\n    if (this == obj) {\n      return true;\n    }\n    if (obj == null || this.getClass() != obj.getClass()) {\n      return false;\n    }\n    MyClass that = (MyClass) obj; // Compliant, obj's type is MyClass\n    // ...\n  }\n  // ...\n}\n</pre>",
    "moreInfo": "<h3>Documentation</h3>\n<ul>\n  <li> <a href=\"https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/Object.html#equals(java.lang.Object)\">Oracle SDK -\n  java.lang.Object#equals(Object obj)</a> </li>\n</ul>",
    "status": "READY",
    "name_ko": "\"equals(Object obj)\"는 인자의 타입을 검사해야 합니다",
    "why_ko": "<p><code>Object#equals(Object obj)</code> 메서드는 두 객체가 동일한지 비교하는 데 사용됩니다.</p>\n<p><code>obj</code> 파라미터의 타입은 <code>Object</code>입니다. 이는 모든 타입의 객체가 이 메서드에 파라미터로 전달될 수 있음을 의미합니다.</p>\n<p><code>Object#equals(Object obj)</code>를 재정의하는 모든 클래스는 이 계약을 존중하고, 모든 객체를 인자로 받아들이고, 인자의 타입이 예상 타입과 다를 때 <code>false</code>를 반환해야 합니다. <code>obj</code> 파라미터의 타입은 <code>instanceof</code>를 사용하거나 <code>getClass()</code> 값을 비교하여 확인할 수 있습니다:</p>\n<pre>\n@Override\npublic boolean equals(Object obj) {\n  // ...\n  if (this.getClass() != obj.getClass()) {\n    return false;\n  }\n  // ...\n}\n</pre>\n<p>그러나 <code>equals</code> 메서드가 동일한 타입의 객체를 비교하는 데만 사용될 것이라고 가정하는 것은 문제입니다. 사전 테스트 없이 <code>obj</code> 파라미터를 캐스팅하면 false를 반환하는 대신 <code>ClassCastException</code>을 던집니다.</p>\n<pre>\npublic class MyClass {\n  @Override\n  public boolean equals(Object obj) {\n    MyClass that = (MyClass) obj; // ClassCastException을 던질 수 있음\n    // ...\n  }\n  // ...\n}\n</pre>\n<p>이 규칙은 캐스트 작업 전에 <code>obj</code> 파라미터의 타입이 테스트되지 않은 경우 문제를 제기합니다.</p>",
    "howToFix_ko": "<p><code>this.getClass()</code>와 <code>obj.getClass()</code>를 비교하거나 <code>instanceof</code> 연산자를 사용하여 obj의 타입을 테스트하여 <code>obj</code> 파라미터의 타입이 확인되었는지 확인하세요.</p>\n\n<h4>규칙을 준수하지 않는 코드 예시</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\npublic class MyClass {\n  @Override\n  public boolean equals(Object obj) {\n    if (this == obj) {\n      return true;\n    }\n    if (obj == null) {\n      return false;\n    }\n    MyClass that = (MyClass) obj; // 규칙 위반, ClassCastException을 던질 수 있음\n    // ...\n  }\n  // ...\n}\n</pre>\n<h4>규칙을 준수하는 해결책</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\npublic class MyClass {\n  @Override\n  public boolean equals(Object obj) {\n    if (this == obj) {\n      return true;\n    }\n    if (obj == null || this.getClass() != obj.getClass()) {\n      return false;\n    }\n    MyClass that = (MyClass) obj; // 규칙 준수, obj의 타입은 MyClass\n    // ...\n  }\n  // ...\n}\n</pre>",
    "moreInfo_ko": "<h3>문서</h3>\n<ul>\n  <li> <a href=\"https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/Object.html#equals(java.lang.Object)\">Oracle SDK - java.lang.Object#equals(Object obj)</a> </li>\n</ul>"
  },
  {
    "id": "S1711",
    "key": "java:S1711",
    "name": "Standard functional interfaces should not be redefined",
    "type": "code-smell",
    "severity": "major",
    "tags": [
      "java8"
    ],
    "why": "<p>Just as there is little justification for writing your own String class, there is no good reason to re-define one of the existing, standard\nfunctional interfaces.</p>\n<p>Doing so may seem tempting, since it would allow you to specify a little extra context with the name. But in the long run, it will be a source of\nconfusion, because maintenance programmers will wonder what is different between the custom functional interface and the standard one.</p>\n<h3>Noncompliant code example</h3>\n<pre>\n@FunctionalInterface\npublic interface MyInterface { // Noncompliant\n\tdouble toDouble(int a);\n}\n\n@FunctionalInterface\npublic interface ExtendedBooleanSupplier { // Noncompliant\n  boolean get();\n  default boolean isFalse() {\n    return !get();\n  }\n}\n\npublic class MyClass {\n    private int a;\n    public double myMethod(MyInterface instance){\n\treturn instance.toDouble(a);\n    }\n}\n</pre>\n<h3>Compliant solution</h3>\n<pre>\n@FunctionalInterface\npublic interface ExtendedBooleanSupplier extends BooleanSupplier { // Compliant, extends java.util.function.BooleanSupplier\n  default boolean isFalse() {\n    return !getAsBoolean();\n  }\n}\n\npublic class MyClass {\n    private int a;\n    public double myMethod(IntToDoubleFunction instance){\n\treturn instance.applyAsDouble(a);\n    }\n}\n</pre>",
    "howToFix": "",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "표준 함수형 인터페이스를 재정의하면 안 됩니다",
    "why_ko": "<p>자신만의 String 클래스를 작성해야 할 정당한 이유가 거의 없는 것처럼, 기존의 표준 함수형 인터페이스 중 하나를 재정의해야 할 좋은 이유도 없습니다.</p>\n<p>이름에 약간의 추가 컨텍스트를 지정할 수 있으므로 그렇게 하는 것이 매력적으로 보일 수 있습니다. 그러나 장기적으로는 유지보수 프로그래머가 사용자 정의 함수형 인터페이스와 표준 인터페이스 간의 차이점이 무엇인지 궁금해할 것이므로 혼란의 원인이 될 것입니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\n@FunctionalInterface\npublic interface MyInterface { // 규칙 위반\n\tdouble toDouble(int a);\n}\n\n@FunctionalInterface\npublic interface ExtendedBooleanSupplier { // 규칙 위반\n  boolean get();\n  default boolean isFalse() {\n    return !get();\n  }\n}\n\npublic class MyClass {\n    private int a;\n    public double myMethod(MyInterface instance){\n\treturn instance.toDouble(a);\n    }\n}\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre>\n@FunctionalInterface\npublic interface ExtendedBooleanSupplier extends BooleanSupplier { // 규칙 준수, java.util.function.BooleanSupplier를 확장\n  default boolean isFalse() {\n    return !getAsBoolean();\n  }\n}\n\npublic class MyClass {\n    private int a;\n    public double myMethod(IntToDoubleFunction instance){\n\treturn instance.applyAsDouble(a);\n    }\n}\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": ""
  },
  {
    "id": "S4143",
    "key": "java:S4143",
    "name": "Map values should not be replaced unconditionally",
    "type": "bug",
    "severity": "major",
    "tags": [
      "suspicious"
    ],
    "why": "<p>Storing a value inside a collection at a given key or index and then unconditionally overwriting it without reading the initial value is a case of\na \"dead store\".</p>\n<pre>\nletters.put(\"a\", \"Apple\");\nletters.put(\"a\", \"Boy\");  // Noncompliant\n\ntowns[i] = \"London\";\ntowns[i] = \"Chicago\";  // Noncompliant\n</pre>\n<p>This practice is redundant and will cause confusion for the reader. More importantly, it is often an error and not what the developer intended to\ndo.</p>",
    "howToFix": "",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "Map 값을 무조건적으로 교체하면 안 됩니다",
    "why_ko": "<p>주어진 키 또는 인덱스에서 컬렉션 내에 값을 저장한 다음 초기 값을 읽지 않고 무조건 덮어쓰는 것은 \"죽은 저장소\"의 경우입니다.</p>\n<pre>\nletters.put(\"a\", \"Apple\");\nletters.put(\"a\", \"Boy\");  // 규칙 위반\n\ntowns[i] = \"London\";\ntowns[i] = \"Chicago\";  // 규칙 위반\n</pre>\n<p>이 관행은 중복되며 읽는 사람에게 혼란을 줄 것입니다. 더 중요한 것은, 이것은 종종 오류이며 개발자가 의도한 바가 아닙니다.</p>",
    "howToFix_ko": "",
    "moreInfo_ko": ""
  },
  {
    "id": "S5247",
    "key": "java:S5247",
    "name": "Disabling auto-escaping in template engines is security-sensitive",
    "type": "security-hotspot",
    "severity": "major",
    "tags": [
      "cwe"
    ],
    "why": "<p>To reduce the risk of cross-site scripting attacks, templating systems, such as <code>Twig</code>, <code>Django</code>, <code>Smarty</code>,\n<code>Groovy's template engine</code>, allow configuration of automatic variable escaping before rendering templates. When escape occurs, characters\nthat make sense to the browser (eg: &lt;a&gt;) will be transformed/replaced with escaped/sanitized values (eg: &amp; lt;a&amp; gt; ).</p>\n<p>Auto-escaping is not a magic feature to annihilate all cross-site scripting attacks, it depends on <a\nhref=\"https://twig.symfony.com/doc/3.x/filters/escape.html\">the strategy applied</a> and the context, for example a \"html auto-escaping\" strategy\n(which only transforms html characters into <a href=\"https://developer.mozilla.org/en-US/docs/Glossary/Entity\">html entities</a>) will not be relevant\nwhen variables are used in a <a href=\"https://en.wikipedia.org/wiki/HTML_attribute\">html attribute</a> because '<code>:</code>' character is not\nescaped and thus an attack as below is possible:</p>\n<pre>\n&lt;a href=\"{{ myLink }}\"&gt;link&lt;/a&gt; // myLink = javascript:alert(document.cookie)\n&lt;a href=\"javascript:alert(document.cookie)\"&gt;link&lt;/a&gt; // JS injection (XSS attack)\n</pre>\n",
    "howToFix": "<h2>Recommended Secure Coding Practices</h2>\n<p>Enable auto-escaping by default and continue to review the use of inputs in order to be sure that the chosen auto-escaping strategy is the right\none.</p>\n<h2>Compliant Solution</h2>\n<p>With <a href=\"https://github.com/samskivert/jmustache\">JMustache by samskivert</a>:</p>\n<pre>\nMustache.compiler().compile(template).execute(context); // Compliant, auto-escaping is enabled by default\nMustache.compiler().escapeHTML(true).compile(template).execute(context); // Compliant\n</pre>\n<p>With <a href=\"https://freemarker.apache.org/\">Freemarker</a>. See <a\nhref=\"https://freemarker.apache.org/docs/api/freemarker/template/Configuration.html#setAutoEscapingPolicy-int-\">\"setAutoEscapingPolicy\"\ndocumentation</a> for more details.</p>\n<pre>\nfreemarker.template.Configuration configuration = new freemarker.template.Configuration();\nconfiguration.setAutoEscapingPolicy(ENABLE_IF_DEFAULT_AUTO_ESCAPING_POLICY); // Compliant\n</pre>\n<h2>See</h2>\n<ul>\n  <li> OWASP - <a href=\"https://owasp.org/Top10/A03_2021-Injection/\">Top 10 2021 Category A3 - Injection</a> </li>\n  <li> <a href=\"https://github.com/OWASP/CheatSheetSeries/blob/master/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.md\">OWASP Cheat\n  Sheet</a> - XSS Prevention Cheat Sheet </li>\n  <li> OWASP - <a href=\"https://owasp.org/www-project-top-ten/2017/A7_2017-Cross-Site_Scripting_(XSS)\">Top 10 2017 Category A7 - Cross-Site Scripting\n  (XSS)</a> </li>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/79\">CWE-79 - Improper Neutralization of Input During Web Page Generation ('Cross-site\n  Scripting')</a> </li>\n</ul>",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "템플릿 엔진에서 자동 이스케이프 비활성화는 보안에 민감합니다",
    "why_ko": "<p>크로스 사이트 스크립팅 공격의 위험을 줄이기 위해 <code>Twig</code>, <code>Django</code>, <code>Smarty</code>, <code>Groovy의 템플릿 엔진</code>과 같은 템플릿 시스템은 템플릿을 렌더링하기 전에 자동 변수 이스케이프 구성을 허용합니다. 이스케이프가 발생하면 브라우저에 의미가 있는 문자(예: &lt;a&gt;)가 이스케이프/정제된 값(예: &amp; lt;a&amp; gt;)으로 변환/대체됩니다.</p>\n<p>자동 이스케이프는 모든 크로스 사이트 스크립팅 공격을 제거하는 마법 기능이 아니며, <a href=\"https://twig.symfony.com/doc/3.x/filters/escape.html\">적용된 전략</a>과 컨텍스트에 따라 다릅니다. 예를 들어 \"html 자동 이스케이프\" 전략(html 문자만 <a href=\"https://developer.mozilla.org/en-US/docs/Glossary/Entity\">html 엔티티</a>로 변환)은 변수가 <a href=\"https://en.wikipedia.org/wiki/HTML_attribute\">html 속성</a>에서 사용될 때 관련이 없습니다. '<code>:</code>' 문자가 이스케이프되지 않아 아래와 같은 공격이 가능하기 때문입니다:</p>\n<pre>\n&lt;a href=\"{{ myLink }}\"&gt;link&lt;/a&gt; // myLink = javascript:alert(document.cookie)\n&lt;a href=\"javascript:alert(document.cookie)\"&gt;link&lt;/a&gt; // JS 주입 (XSS 공격)\n</pre>\n",
    "howToFix_ko": "<h2>권장 보안 코딩 방법</h2>\n<p>기본적으로 자동 이스케이프를 활성화하고 선택한 자동 이스케이프 전략이 올바른지 확인하기 위해 입력 사용을 계속 검토하세요.</p>\n<h2>규칙을 준수하는 해결책</h2>\n<p><a href=\"https://github.com/samskivert/jmustache\">samskivert의 JMustache</a> 사용:</p>\n<pre>\nMustache.compiler().compile(template).execute(context); // 규칙 준수, 자동 이스케이프가 기본적으로 활성화됨\nMustache.compiler().escapeHTML(true).compile(template).execute(context); // 규칙 준수\n</pre>\n<p><a href=\"https://freemarker.apache.org/\">Freemarker</a> 사용. 자세한 내용은 <a href=\"https://freemarker.apache.org/docs/api/freemarker/template/Configuration.html#setAutoEscapingPolicy-int-\">\"setAutoEscapingPolicy\" 문서</a>를 참조하세요.</p>\n<pre>\nfreemarker.template.Configuration configuration = new freemarker.template.Configuration();\nconfiguration.setAutoEscapingPolicy(ENABLE_IF_DEFAULT_AUTO_ESCAPING_POLICY); // 규칙 준수\n</pre>\n<h2>참고</h2>\n<ul>\n  <li> OWASP - <a href=\"https://owasp.org/Top10/A03_2021-Injection/\">상위 10가지 2021 카테고리 A3 - 인젝션</a> </li>\n  <li> <a href=\"https://github.com/OWASP/CheatSheetSeries/blob/master/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.md\">OWASP 치트 시트</a> - XSS 방지 치트 시트 </li>\n  <li> OWASP - <a href=\"https://owasp.org/www-project-top-ten/2017/A7_2017-Cross-Site_Scripting_(XSS)\">상위 10가지 2017 카테고리 A7 - 크로스 사이트 스크립팅(XSS)</a> </li>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/79\">CWE-79 - 웹 페이지 생성 중 입력의 부적절한 무효화('크로스 사이트 스크립팅')</a> </li>\n</ul>",
    "moreInfo_ko": ""
  },
  {
    "id": "S4682",
    "key": "java:S4682",
    "name": "\"@CheckForNull\" or \"@Nullable\" should not be used on primitive types",
    "type": "code-smell",
    "severity": "minor",
    "tags": [],
    "why": "<p>By definition, primitive types are not Objects and so they cannot be <code>null</code>. Adding <code>@CheckForNull</code> or <code>@Nullable</code>\non primitive types is redundant and may lead to misunderstandings.</p>\n<p>This rule raises an issue when <code>@CheckForNull</code> or <code>@Nullable</code> is set on a method returning a primitive type: byte, short,\nint, long, float, double, boolean, char.</p>\n<h3>Noncompliant code example</h3>\n<pre>\n@CheckForNull\nboolean isFoo() {\n ...\n}\n</pre>\n<h3>Compliant solution</h3>\n<pre>\nboolean isFoo() {\n ...\n}\n</pre>",
    "howToFix": "",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "primitive 타입에 \"@CheckForNull\" 또는 \"@Nullable\"을 사용하면 안 됩니다",
    "why_ko": "<p>정의상 primitive 타입은 객체가 아니므로 <code>null</code>이 될 수 없습니다. primitive 타입에 <code>@CheckForNull</code> 또는 <code>@Nullable</code>을 추가하는 것은 중복되며 오해를 초래할 수 있습니다.</p>\n<p>이 규칙은 primitive 타입(byte, short, int, long, float, double, boolean, char)을 반환하는 메서드에 <code>@CheckForNull</code> 또는 <code>@Nullable</code>이 설정된 경우 문제를 제기합니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\n@CheckForNull\nboolean isFoo() {\n ...\n}\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre>\nboolean isFoo() {\n ...\n}\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": ""
  },
  {
    "id": "S1195",
    "key": "java:S1195",
    "name": "Array designators \"[]\" should be located after the type in method signatures",
    "type": "code-smell",
    "severity": "minor",
    "tags": [
      "convention"
    ],
    "why": "<p>Placing the array designators <code>[]</code> after the type helps maintain backward compatibility with older versions of the Java SE platform.\nThis syntax contributes to better readability as it becomes easier to distinguish between array types and non-array types. It helps convey the\nintention of the method to both the developer implementing it and the developer using it.</p>\n<h3>Noncompliant code example</h3>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\npublic class Cube {\n    private int magicNumbers[] = { 42 };      // Noncompliant\n    public int getVector()[] { /* ... */ }    // Noncompliant\n    public int[] getMatrix()[] { /* ... */ }  // Noncompliant\n}\n</pre>\n<h3>Compliant solution</h3>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\npublic class Cube {\n    private int[] magicNumbers = { 42 };      // Compliant\n    public int[] getVector() { /* ... */ }    // Compliant\n    public int[][] getMatrix() { /* ... */ }  // Compliant\n}\n</pre>",
    "howToFix": "",
    "moreInfo": "<h3>Documentation</h3>\n<ul>\n  <li> <a href=\"https://docs.oracle.com/javase/specs/jls/se20/html/jls-10.html\">Oracle Java Language Specification</a> - Arrays </li>\n</ul>",
    "status": "READY",
    "name_ko": "배열 지정자 \"[]\"는 메서드 시그니처에서 타입 뒤에 위치해야 합니다",
    "why_ko": "<p>배열 지정자 <code>[]</code>를 타입 뒤에 배치하면 Java SE 플랫폼의 이전 버전과의 하위 호환성을 유지하는 데 도움이 됩니다. 이 구문은 배열 타입과 비배열 타입을 더 쉽게 구별할 수 있게 하여 가독성을 향상시킵니다. 이를 구현하는 개발자와 사용하는 개발자 모두에게 메서드의 의도를 전달하는 데 도움이 됩니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\npublic class Cube {\n    private int magicNumbers[] = { 42 };      // 규칙 위반\n    public int getVector()[] { /* ... */ }    // 규칙 위반\n    public int[] getMatrix()[] { /* ... */ }  // 규칙 위반\n}\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\npublic class Cube {\n    private int[] magicNumbers = { 42 };      // 규칙 준수\n    public int[] getVector() { /* ... */ }    // 규칙 준수\n    public int[][] getMatrix() { /* ... */ }  // 규칙 준수\n}\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": "<h3>문서</h3>\n<ul>\n  <li> <a href=\"https://docs.oracle.com/javase/specs/jls/se20/html/jls-10.html\">Oracle Java 언어 명세</a> - 배열 </li>\n</ul>"
  },
  {
    "id": "S4544",
    "key": "java:S4544",
    "name": "Using unsafe Jackson deserialization configuration is security-sensitive",
    "type": "security-hotspot",
    "severity": "critical",
    "tags": [
      "cwe"
    ],
    "why": "<p>Using unsafe Jackson deserialization configuration is security-sensitive. It has led in the past to the following vulnerabilities:</p>\n<ul>\n  <li> <a href=\"https://www.cve.org/CVERecord?id=CVE-2017-4995\">CVE-2017-4995</a> </li>\n  <li> <a href=\"https://www.cve.org/CVERecord?id=CVE-2018-19362\">CVE-2018-19362</a> </li>\n</ul>\n<p>When Jackson is configured to allow Polymorphic Type Handling (aka PTH), formerly known as Polymorphic Deserialization, \"deserialization gadgets\"\nmay allow an attacker to perform remote code execution.</p>\n<p>This rule raises an issue when:</p>\n<ul>\n  <li> <code>enableDefaultTyping()</code> is called on an instance of <code>com.fasterxml.jackson.databind.ObjectMapper</code> or\n  <code>org.codehaus.jackson.map.ObjectMapper</code>. </li>\n  <li> or when the annotation <code>@JsonTypeInfo</code> is set at class, interface or field levels and configured with <code>use =\n  JsonTypeInfo.Id.CLASS</code> or <code>use = Id.MINIMAL_CLASS</code>. </li>\n</ul>\n",
    "howToFix": "<h2>Recommended Secure Coding Practices</h2>\n<ul>\n  <li> Use the latest patch versions of <code>jackson-databind</code> blocking the already discovered \"deserialization gadgets\". </li>\n  <li> Avoid using the default typing configuration: <code>ObjectMapper.enableDefaultTyping()</code>. </li>\n  <li> If possible, use <code>@JsonTypeInfo(use = Id.NAME)</code> instead of <code>@JsonTypeInfo(use = Id.CLASS)</code> or <code>@JsonTypeInfo(use =\n  Id. MINIMAL_CLASS)</code> and so rely on <code>@JsonTypeName</code> and <code>@JsonSubTypes</code>. </li>\n</ul>\n<h2>See</h2>\n<ul>\n  <li> OWASP - <a href=\"https://owasp.org/Top10/A08_2021-Software_and_Data_Integrity_Failures/\">Top 10 2021 Category A8 - Software and Data Integrity\n  Failures</a> </li>\n  <li> OWASP - <a href=\"https://owasp.org/www-project-top-ten/2017/A8_2017-Insecure_Deserialization\">Top 10 2017 Category A8 - Insecure\n  Deserialization</a> </li>\n  <li> OWASP - <a href=\"https://owasp.org/www-community/vulnerabilities/Deserialization_of_untrusted_data\">Deserialization of untrusted data</a> </li>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/502\">CWE-502 - Deserialization of Untrusted Data</a> </li>\n  <li> <a href=\"https://medium.com/@cowtowncoder/on-jackson-cves-dont-panic-here-is-what-you-need-to-know-54cd0d6e8062\">On Jackson CVEs: Don't\n  Panic</a> </li>\n  <li> <a href=\"https://nvd.nist.gov/vuln/detail/CVE-2017-15095\">CVE-2017-1509</a> </li>\n  <li> <a href=\"https://nvd.nist.gov/vuln/detail/CVE-2017-7525\">CVE-2017-7525</a> </li>\n  <li> Derived from FindSecBugs rule <a\n  href=\"https://find-sec-bugs.github.io/bugs.htm#JACKSON_UNSAFE_DESERIALIZATION\">JACKSON_UNSAFE_DESERIALIZATION</a> </li>\n</ul>",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "안전하지 않은 Jackson 역직렬화 설정 사용은 보안에 민감합니다",
    "why_ko": "<p>안전하지 않은 Jackson 역직렬화 설정 사용은 보안에 민감합니다. 과거에 다음과 같은 취약점으로 이어졌습니다:</p>\n<ul>\n  <li> <a href=\"https://www.cve.org/CVERecord?id=CVE-2017-4995\">CVE-2017-4995</a> </li>\n  <li> <a href=\"https://www.cve.org/CVERecord?id=CVE-2018-19362\">CVE-2018-19362</a> </li>\n</ul>\n<p>Jackson이 다형성 타입 처리(Polymorphic Type Handling, PTH), 이전에는 다형성 역직렬화라고 알려진 기능을 허용하도록 설정되면 \"역직렬화 가젯\"이 공격자가 원격 코드 실행을 수행할 수 있게 할 수 있습니다.</p>\n<p>이 규칙은 다음과 같은 경우에 문제를 제기합니다:</p>\n<ul>\n  <li> <code>com.fasterxml.jackson.databind.ObjectMapper</code> 또는 <code>org.codehaus.jackson.map.ObjectMapper</code> 인스턴스에서 <code>enableDefaultTyping()</code>이 호출될 때 </li>\n  <li> 또는 <code>@JsonTypeInfo</code> 어노테이션이 클래스, 인터페이스 또는 필드 수준에서 설정되고 <code>use = JsonTypeInfo.Id.CLASS</code> 또는 <code>use = Id.MINIMAL_CLASS</code>로 구성될 때 </li>\n</ul>\n",
    "howToFix_ko": "<h2>권장 보안 코딩 방법</h2>\n<ul>\n  <li> 이미 발견된 \"역직렬화 가젯\"을 차단하는 <code>jackson-databind</code>의 최신 패치 버전을 사용하세요. </li>\n  <li> 기본 타이핑 설정 사용을 피하세요: <code>ObjectMapper.enableDefaultTyping()</code>. </li>\n  <li> 가능하면 <code>@JsonTypeInfo(use = Id.CLASS)</code> 또는 <code>@JsonTypeInfo(use = Id.MINIMAL_CLASS)</code> 대신 <code>@JsonTypeInfo(use = Id.NAME)</code>을 사용하고 <code>@JsonTypeName</code> 및 <code>@JsonSubTypes</code>에 의존하세요. </li>\n</ul>\n<h2>참고</h2>\n<ul>\n  <li> OWASP - <a href=\"https://owasp.org/Top10/A08_2021-Software_and_Data_Integrity_Failures/\">Top 10 2021 Category A8 - Software and Data Integrity Failures</a> </li>\n  <li> OWASP - <a href=\"https://owasp.org/www-project-top-ten/2017/A8_2017-Insecure_Deserialization\">Top 10 2017 Category A8 - Insecure Deserialization</a> </li>\n  <li> OWASP - <a href=\"https://owasp.org/www-community/vulnerabilities/Deserialization_of_untrusted_data\">Deserialization of untrusted data</a> </li>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/502\">CWE-502 - Deserialization of Untrusted Data</a> </li>\n  <li> <a href=\"https://medium.com/@cowtowncoder/on-jackson-cves-dont-panic-here-is-what-you-need-to-know-54cd0d6e8062\">On Jackson CVEs: Don't Panic</a> </li>\n  <li> <a href=\"https://nvd.nist.gov/vuln/detail/CVE-2017-15095\">CVE-2017-1509</a> </li>\n  <li> <a href=\"https://nvd.nist.gov/vuln/detail/CVE-2017-7525\">CVE-2017-7525</a> </li>\n  <li> FindSecBugs 규칙에서 파생됨 <a href=\"https://find-sec-bugs.github.io/bugs.htm#JACKSON_UNSAFE_DESERIALIZATION\">JACKSON_UNSAFE_DESERIALIZATION</a> </li>\n</ul>",
    "moreInfo_ko": ""
  },
  {
    "id": "S2185",
    "key": "java:S2185",
    "name": "Do not perform unnecessary mathematical operations",
    "type": "code-smell",
    "severity": "major",
    "tags": [
      "clumsy"
    ],
    "why": "<p>Some mathematical operations are unnecessary and should not be performed because their results are predictable.</p>\n<p>For instance, <code>anyValue % 1</code> will always return 0, as any integer value can be divided by 1 without remainder.</p>\n<p>Similarly, casting a non-floating-point to a floating-point value and then passing it to <code>Math.round</code>, <code>Math.ceil</code>, or\n<code>Math.floor</code> is also unnecessary, as the result will always be the original value.</p>\n<p>The following operations are unnecessary when given any constant value: <code>Math.abs</code>, <code>Math.ceil</code>, <code>Math.floor</code>,\n<code>Math.rint</code>, <code>Math.round</code>. Instead, use the result of the operation directly.</p>\n<p>The following operations are unnecessary with certain constants and can be replaced by the result of the operation directly:</p>\n<table>\n  <colgroup>\n    <col style=\"width: 50%;\">\n    <col style=\"width: 50%;\">\n  </colgroup>\n  <thead>\n    <tr>\n      <th>Operation</th>\n      <th>Value</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td><p>acos</p></td>\n      <td><p>0.0 or 1.0</p></td>\n    </tr>\n    <tr>\n      <td><p>asin</p></td>\n      <td><p>0.0 or 1.0</p></td>\n    </tr>\n    <tr>\n      <td><p>atan</p></td>\n      <td><p>0.0 or 1.0</p></td>\n    </tr>\n    <tr>\n      <td><p>atan2</p></td>\n      <td><p>0.0</p></td>\n    </tr>\n    <tr>\n      <td><p>cbrt</p></td>\n      <td><p>0.0 or 1.0</p></td>\n    </tr>\n    <tr>\n      <td><p>cos</p></td>\n      <td><p>0.0</p></td>\n    </tr>\n    <tr>\n      <td><p>cosh</p></td>\n      <td><p>0.0</p></td>\n    </tr>\n    <tr>\n      <td><p>exp</p></td>\n      <td><p>0.0 or 1.0</p></td>\n    </tr>\n    <tr>\n      <td><p>expm1</p></td>\n      <td><p>0.0</p></td>\n    </tr>\n    <tr>\n      <td><p>log</p></td>\n      <td><p>0.0 or 1.0</p></td>\n    </tr>\n    <tr>\n      <td><p>log10</p></td>\n      <td><p>0.0 or 1.0</p></td>\n    </tr>\n    <tr>\n      <td><p>sin</p></td>\n      <td><p>0.0</p></td>\n    </tr>\n    <tr>\n      <td><p>sinh</p></td>\n      <td><p>0.0</p></td>\n    </tr>\n    <tr>\n      <td><p>sqrt</p></td>\n      <td><p>0.0 or 1.0</p></td>\n    </tr>\n    <tr>\n      <td><p>tan</p></td>\n      <td><p>0.0</p></td>\n    </tr>\n    <tr>\n      <td><p>tanh</p></td>\n      <td><p>0.0</p></td>\n    </tr>\n    <tr>\n      <td><p>toDegrees</p></td>\n      <td><p>0.0 or 1.0</p></td>\n    </tr>\n    <tr>\n      <td><p>toRadians</p></td>\n      <td><p>0.0</p></td>\n    </tr>\n  </tbody>\n</table>",
    "howToFix": "<p>Ask yourself if the questionable operation represents the desired calculation or if a value used is erroneous. If the calculation is correct,\nreplace it with the result to avoid having to perform the unnecessary operation at runtime.</p>\n\n<h4>Noncompliant code example</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\npublic void doMath(int a) {\n  double res1 = Math.floor((double)a); // Noncompliant, the result will always be equal to '(double) a'\n  double res2 = Math.ceil(4.2);        // Noncompliant, the result will always be 5.0\n  double res3 = Math.atan(0.0);        // Noncompliant, the result will always be 0.0\n}\n</pre>\n<h4>Compliant solution</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\npublic void doMath(int a) {\n  double res1 = a;    // Compliant\n  double res2 = 5.0;  // Compliant\n  double res3 = 0.0;  // Compliant\n}\n</pre>",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "불필요한 수학 연산을 수행하면 안 됩니다",
    "why_ko": "<p>일부 수학 연산은 불필요하며 결과를 예측할 수 있으므로 수행해서는 안 됩니다.</p>\n<p>예를 들어 <code>anyValue % 1</code>은 모든 정수 값을 1로 나머지 없이 나눌 수 있으므로 항상 0을 반환합니다.</p>\n<p>마찬가지로 비부동 소수점을 부동 소수점 값으로 캐스팅한 다음 <code>Math.round</code>, <code>Math.ceil</code> 또는 <code>Math.floor</code>에 전달하는 것도 불필요합니다. 결과는 항상 원래 값이기 때문입니다.</p>\n<p>다음 연산들은 상수 값이 주어질 때 불필요합니다: <code>Math.abs</code>, <code>Math.ceil</code>, <code>Math.floor</code>, <code>Math.rint</code>, <code>Math.round</code>. 대신 연산 결과를 직접 사용하세요.</p>\n<p>다음 연산들은 특정 상수와 함께 사용할 때 불필요하며 연산 결과로 직접 대체할 수 있습니다:</p>\n<table>\n  <colgroup>\n    <col style=\"width: 50%;\">\n    <col style=\"width: 50%;\">\n  </colgroup>\n  <thead>\n    <tr>\n      <th>연산</th>\n      <th>값</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td><p>acos</p></td>\n      <td><p>0.0 또는 1.0</p></td>\n    </tr>\n    <tr>\n      <td><p>asin</p></td>\n      <td><p>0.0 또는 1.0</p></td>\n    </tr>\n    <tr>\n      <td><p>atan</p></td>\n      <td><p>0.0 또는 1.0</p></td>\n    </tr>\n    <tr>\n      <td><p>atan2</p></td>\n      <td><p>0.0</p></td>\n    </tr>\n    <tr>\n      <td><p>cbrt</p></td>\n      <td><p>0.0 또는 1.0</p></td>\n    </tr>\n    <tr>\n      <td><p>cos</p></td>\n      <td><p>0.0</p></td>\n    </tr>\n    <tr>\n      <td><p>cosh</p></td>\n      <td><p>0.0</p></td>\n    </tr>\n    <tr>\n      <td><p>exp</p></td>\n      <td><p>0.0 또는 1.0</p></td>\n    </tr>\n    <tr>\n      <td><p>expm1</p></td>\n      <td><p>0.0</p></td>\n    </tr>\n    <tr>\n      <td><p>log</p></td>\n      <td><p>0.0 또는 1.0</p></td>\n    </tr>\n    <tr>\n      <td><p>log10</p></td>\n      <td><p>0.0 또는 1.0</p></td>\n    </tr>\n    <tr>\n      <td><p>sin</p></td>\n      <td><p>0.0</p></td>\n    </tr>\n    <tr>\n      <td><p>sinh</p></td>\n      <td><p>0.0</p></td>\n    </tr>\n    <tr>\n      <td><p>sqrt</p></td>\n      <td><p>0.0 또는 1.0</p></td>\n    </tr>\n    <tr>\n      <td><p>tan</p></td>\n      <td><p>0.0</p></td>\n    </tr>\n    <tr>\n      <td><p>tanh</p></td>\n      <td><p>0.0</p></td>\n    </tr>\n    <tr>\n      <td><p>toDegrees</p></td>\n      <td><p>0.0 또는 1.0</p></td>\n    </tr>\n    <tr>\n      <td><p>toRadians</p></td>\n      <td><p>0.0</p></td>\n    </tr>\n  </tbody>\n</table>",
    "howToFix_ko": "<p>문제가 되는 연산이 원하는 계산을 나타내는지 또는 사용된 값이 잘못되었는지 확인하세요. 계산이 올바르다면 런타임에 불필요한 연산을 수행하지 않도록 결과로 대체하세요.</p>\n\n<h4>규칙을 준수하지 않는 코드 예시</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\npublic void doMath(int a) {\n  double res1 = Math.floor((double)a); // 규칙 위반, 결과는 항상 '(double) a'와 같음\n  double res2 = Math.ceil(4.2);        // 규칙 위반, 결과는 항상 5.0\n  double res3 = Math.atan(0.0);        // 규칙 위반, 결과는 항상 0.0\n}\n</pre>\n<h4>규칙을 준수하는 해결책</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\npublic void doMath(int a) {\n  double res1 = a;    // 규칙 준수\n  double res2 = 5.0;  // 규칙 준수\n  double res3 = 0.0;  // 규칙 준수\n}\n</pre>",
    "moreInfo_ko": ""
  },
  {
    "id": "S2886",
    "key": "java:S2886",
    "name": "Getters and setters should be synchronized in pairs",
    "type": "bug",
    "severity": "major",
    "tags": [
      "multi-threading",
      "cert"
    ],
    "why": "<p>A synchronized method is a method marked with the <code>synchronized</code> keyword, meaning it can only be accessed by one thread at a time. If\nmultiple threads try to access the synchronized method simultaneously, they will be blocked until the method is available.</p>\n<p>Synchronized methods prevent race conditions and data inconsistencies in multi-threaded environments. Ensuring that only one thread can access a\nmethod at a time, prevents multiple threads from modifying the same data simultaneously, and causing conflicts.</p>\n<p>When one part of a getter/setter pair is <code>synchronized</code> the other should be too. Failure to synchronize both sides may result in\ninconsistent behavior at runtime as callers access an inconsistent method state.</p>\n<p>This rule raises an issue when either the method or the contents of one method in a getter/setter pair are synchronized, but the other is not.</p>",
    "howToFix": "<p>Synchronize both <code>get</code> and <code>set</code> methods by marking the method with the <code>synchronize</code> keyword or using a\n<code>synchronize</code> block inside them.</p>\n\n<h4>Noncompliant code example</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\npublic class Person {\n  String name;\n  int age;\n\n  public synchronized void setName(String name) {\n    this.name = name;\n  }\n\n  public String getName() {  // Noncompliant\n    return this.name;\n  }\n\n  public void setAge(int age) {  // Noncompliant\n    this.age = age;\n  }\n\n  public int getAge() {\n    synchronized (this) {\n      return this.age;\n    }\n  }\n}\n</pre>\n<h4>Compliant solution</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\npublic class Person {\n  String name;\n  int age;\n\n  public synchronized void setName(String name) {\n    this.name = name;\n  }\n\n  public synchronized String getName() {\n    return this.name;\n  }\n\n  public void setAge(int age) {\n    synchronized (this) {\n      this.age = age;\n   }\n  }\n\n  public int getAge() {\n    synchronized (this) {\n      return this.age;\n    }\n  }\n}\n</pre>",
    "moreInfo": "<h3>Documentation</h3>\n<ul>\n  <li> <a href=\"https://docs.oracle.com/javase/tutorial/essential/concurrency/syncmeth.html\">Oracle Java - Synchronized Methods</a> </li>\n  <li> <a href=\"https://docs.oracle.com/javase/specs/jls/se20/html/jls-8.html#jls-8.4.3.6\">Oracle SE 20 - Synchronized Methods</a> </li>\n</ul>\n<h3>Articles &amp; blog posts</h3>\n<ul>\n  <li> <a href=\"https://web.mit.edu/6.005/www/fa14/classes/18-thread-safety/\">MIT - Thread safety</a> </li>\n  <li> <a href=\"https://www.baeldung.com/java-thread-safety\">Baeldung - Thread safety</a> </li>\n</ul>\n<h3>Standards</h3>\n<ul>\n  <li> <a href=\"https://wiki.sei.cmu.edu/confluence/x/4jdGBQ\">CERT, VNA01-J.</a> - Ensure visibility of shared references to immutable objects </li>\n  <li> STIG Viewer - <a href=\"https://stigviewer.com/stigs/application_security_and_development/2024-12-06/finding/V-222567\">Application Security and\n  Development: V-222567</a> - The application must not be vulnerable to race conditions. </li>\n</ul>",
    "status": "READY",
    "name_ko": "Getter와 Setter는 쌍으로 synchronized 되어야 합니다",
    "why_ko": "<p>synchronized 메서드는 <code>synchronized</code> 키워드로 표시된 메서드로, 한 번에 하나의 스레드만 액세스할 수 있습니다. 여러 스레드가 동시에 synchronized 메서드에 액세스하려고 하면 메서드가 사용 가능해질 때까지 차단됩니다.</p>\n<p>synchronized 메서드는 멀티스레드 환경에서 경쟁 조건과 데이터 불일치를 방지합니다. 한 번에 하나의 스레드만 메서드에 액세스할 수 있도록 하면 여러 스레드가 동시에 동일한 데이터를 수정하여 충돌을 일으키는 것을 방지합니다.</p>\n<p>getter/setter 쌍의 한 부분이 <code>synchronized</code>되면 다른 부분도 마찬가지여야 합니다. 양쪽 모두 동기화하지 않으면 호출자가 일관되지 않은 메서드 상태에 액세스하여 런타임에 일관되지 않은 동작이 발생할 수 있습니다.</p>\n<p>이 규칙은 getter/setter 쌍에서 메서드 또는 메서드 내용 중 하나만 동기화되고 다른 하나는 동기화되지 않을 때 문제를 제기합니다.</p>",
    "howToFix_ko": "<p><code>synchronize</code> 키워드로 메서드를 표시하거나 내부에서 <code>synchronize</code> 블록을 사용하여 <code>get</code> 및 <code>set</code> 메서드를 모두 동기화하세요.</p>\n\n<h4>규칙을 준수하지 않는 코드 예시</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\npublic class Person {\n  String name;\n  int age;\n\n  public synchronized void setName(String name) {\n    this.name = name;\n  }\n\n  public String getName() {  // 규칙 위반\n    return this.name;\n  }\n\n  public void setAge(int age) {  // 규칙 위반\n    this.age = age;\n  }\n\n  public int getAge() {\n    synchronized (this) {\n      return this.age;\n    }\n  }\n}\n</pre>\n<h4>규칙을 준수하는 해결책</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\npublic class Person {\n  String name;\n  int age;\n\n  public synchronized void setName(String name) {\n    this.name = name;\n  }\n\n  public synchronized String getName() {\n    return this.name;\n  }\n\n  public void setAge(int age) {\n    synchronized (this) {\n      this.age = age;\n   }\n  }\n\n  public int getAge() {\n    synchronized (this) {\n      return this.age;\n    }\n  }\n}\n</pre>",
    "moreInfo_ko": "<h3>문서</h3>\n<ul>\n  <li> <a href=\"https://docs.oracle.com/javase/tutorial/essential/concurrency/syncmeth.html\">Oracle Java - Synchronized Methods</a> </li>\n  <li> <a href=\"https://docs.oracle.com/javase/specs/jls/se20/html/jls-8.html#jls-8.4.3.6\">Oracle SE 20 - Synchronized Methods</a> </li>\n</ul>\n<h3>관련 문서 및 블로그 게시물</h3>\n<ul>\n  <li> <a href=\"https://web.mit.edu/6.005/www/fa14/classes/18-thread-safety/\">MIT - Thread safety</a> </li>\n  <li> <a href=\"https://www.baeldung.com/java-thread-safety\">Baeldung - Thread safety</a> </li>\n</ul>\n<h3>표준</h3>\n<ul>\n  <li> <a href=\"https://wiki.sei.cmu.edu/confluence/x/4jdGBQ\">CERT, VNA01-J.</a> - 불변 객체에 대한 공유 참조의 가시성 보장 </li>\n  <li> STIG Viewer - <a href=\"https://stigviewer.com/stigs/application_security_and_development/2024-12-06/finding/V-222567\">Application Security and Development: V-222567</a> - 애플리케이션은 경쟁 조건에 취약하면 안 됩니다. </li>\n</ul>"
  },
  {
    "id": "S6353",
    "key": "java:S6353",
    "name": "Regular expression quantifiers and character classes should be used concisely",
    "type": "code-smell",
    "severity": "minor",
    "tags": [
      "regex"
    ],
    "why": "<p>A regular expression is a sequence of characters that specifies a match pattern in text. Among the most important concepts are:</p>\n<ul>\n  <li> Character classes: defines a set of characters, any one of which can occur in an input string for a match to succeed. </li>\n  <li> Quantifiers: used to specify how many instances of a character, group, or character class must be present in the input for a match. </li>\n  <li> Wildcard (<code>.</code>): matches all characters except line terminators (also matches them if the <code>s</code> flag is set). </li>\n</ul>\n<p>Many of these features include shortcuts of widely used expressions, so there is more than one way to construct a regular expression to achieve the\nsame results. For example, to match a two-digit number, one could write <code>[0-9]{2,2}</code> or <code>\\d{2}</code>. The latter is not only shorter\nbut easier to read and thus to maintain.</p>\n<p>This rule recommends replacing some quantifiers and character classes with more concise equivalents:</p>\n<ul>\n  <li> <code>\\d</code> for <code>[0-9]</code> and <code>\\D</code> for <code>[^0-9]</code> </li>\n  <li> <code>\\w</code> for <code>[A-Za-z0-9_]</code> and <code>\\W</code> for <code>[^A-Za-z0-9_]</code> </li>\n  <li> <code>.</code> for character classes matching everything (e.g. <code>[\\w\\W]</code>, <code>[\\d\\D]</code>, or <code>[\\s\\S]</code> with\n  <code>s</code> flag) </li>\n  <li> <code>x?</code> for <code>x{0,1}</code>, <code>x*</code> for <code>x{0,}</code>, <code>x+</code> for <code>x{1,}</code>, <code>x{N}</code> for\n  <code>x{N,N}</code> </li>\n</ul>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\n\"[0-9]\"        // Noncompliant - same as \"\\\\d\"\n\"[^0-9]\"       // Noncompliant - same as \"\\\\D\"\n\"[A-Za-z0-9_]\" // Noncompliant - same as \"\\\\w\"\n\"[\\\\w\\\\W]\"     // Noncompliant - same as \".\"\n\"a{0,}\"        // Noncompliant - same as \"a*\"\n</pre>\n<p>Use the more concise version to make the regex expression more readable.</p>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\n\"\\\\d\"\n\"\\\\D\"\n\"\\\\w\"\n\".\"\n\"a*\"\n</pre>",
    "howToFix": "",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "정규 표현식 수량자와 문자 클래스는 간결하게 사용해야 합니다",
    "why_ko": "<p>정규 표현식은 텍스트에서 매칭 패턴을 지정하는 문자 시퀀스입니다. 가장 중요한 개념은 다음과 같습니다:</p>\n<ul>\n  <li> 문자 클래스: 매칭이 성공하려면 입력 문자열에서 발생할 수 있는 문자 집합을 정의합니다. </li>\n  <li> 수량자: 매칭을 위해 입력에 문자, 그룹 또는 문자 클래스의 인스턴스가 얼마나 있어야 하는지 지정하는 데 사용됩니다. </li>\n  <li> 와일드카드 (<code>.</code>): 줄 종결자를 제외한 모든 문자를 매칭합니다(<code>s</code> 플래그가 설정된 경우 줄 종결자도 매칭). </li>\n</ul>\n<p>이러한 기능 중 많은 것이 널리 사용되는 표현식의 단축키를 포함하므로 동일한 결과를 얻기 위해 정규 표현식을 구성하는 방법이 여러 가지 있습니다. 예를 들어 두 자리 숫자를 매칭하려면 <code>[0-9]{2,2}</code> 또는 <code>\\d{2}</code>를 작성할 수 있습니다. 후자는 더 짧을 뿐만 아니라 읽기 쉬우므로 유지 관리도 쉽습니다.</p>\n<p>이 규칙은 일부 수량자와 문자 클래스를 더 간결한 동등물로 대체할 것을 권장합니다:</p>\n<ul>\n  <li> <code>[0-9]</code> 대신 <code>\\d</code>, <code>[^0-9]</code> 대신 <code>\\D</code> </li>\n  <li> <code>[A-Za-z0-9_]</code> 대신 <code>\\w</code>, <code>[^A-Za-z0-9_]</code> 대신 <code>\\W</code> </li>\n  <li> 모든 것을 매칭하는 문자 클래스(예: <code>[\\w\\W]</code>, <code>[\\d\\D]</code> 또는 <code>s</code> 플래그가 있는 <code>[\\s\\S]</code>) 대신 <code>.</code> </li>\n  <li> <code>x{0,1}</code> 대신 <code>x?</code>, <code>x{0,}</code> 대신 <code>x*</code>, <code>x{1,}</code> 대신 <code>x+</code>, <code>x{N,N}</code> 대신 <code>x{N}</code> </li>\n</ul>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\n\"[0-9]\"        // 규칙 위반 - \"\\\\d\"와 동일\n\"[^0-9]\"       // 규칙 위반 - \"\\\\D\"와 동일\n\"[A-Za-z0-9_]\" // 규칙 위반 - \"\\\\w\"와 동일\n\"[\\\\w\\\\W]\"     // 규칙 위반 - \".\"와 동일\n\"a{0,}\"        // 규칙 위반 - \"a*\"와 동일\n</pre>\n<p>정규식 표현식을 더 읽기 쉽게 만들기 위해 더 간결한 버전을 사용하세요.</p>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\n\"\\\\d\"\n\"\\\\D\"\n\"\\\\w\"\n\".\"\n\"a*\"\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": ""
  },
  {
    "id": "S3014",
    "key": "java:S3014",
    "name": "\"ThreadGroup\" should not be used",
    "type": "code-smell",
    "severity": "blocker",
    "tags": [
      "design",
      "cert",
      "suspicious"
    ],
    "why": "<p>The <code>ThreadGroup</code> class contains many deprecated methods like <code>allowThreadSuspension</code>, <code>resume</code>,\n<code>stop</code>, and <code>suspend</code>. Also, some of the non-deprecated methods are obsolete or not thread-safe, and still others are insecure\n(<code>activeCount</code>, <code>enumerate</code>). For these reasons, any use of <code>ThreadGroup</code> is suspicious and should be avoided.</p>",
    "howToFix": "<p>Instead, use implementations of <code>java.util.concurrent.ExecutorService</code> to safely manage groups of threads.</p>\n\n<h4>Noncompliant code example</h4>\n<pre>\nclass NetworkHandler {\n\n  void startThreadInGroup(ThreadGroup tg) { // Noncompliant, use an ExecutorService instead, which is more secure\n    Thread thread = new Thread(tg, \"controller\");\n    thread.start();\n  }\n\n}\n</pre>\n<h4>Compliant solution</h4>\n<pre>\nclass NetworkHandler {\n\n  void handleThreadsProperly() {\n    ThreadFactory threadFactory = Executors.defaultThreadFactory();\n    ThreadPoolExecutor executorPool = new ThreadPoolExecutor(3, 10, 5, TimeUnit.SECONDS, new ArrayBlockingQueue&lt;Runnable&gt;(2), threadFactory);\n    for (int i = 0; i &lt; 10; i++) {\n      executorPool.execute(new Thread(\"Job: \" + i));\n    }\n    executorPool.shutdown();\n  }\n\n}\n</pre>",
    "moreInfo": "<ul>\n  <li> <a href=\"https://wiki.sei.cmu.edu/confluence/x/YzdGBQ\">CERT, THI01-J.</a> - Do not invoke ThreadGroup methods </li>\n</ul>",
    "status": "READY",
    "name_ko": "\"ThreadGroup\"은 사용하면 안 됩니다",
    "why_ko": "<p><code>ThreadGroup</code> 클래스에는 <code>allowThreadSuspension</code>, <code>resume</code>, <code>stop</code>, <code>suspend</code>와 같은 많은 deprecated 메서드가 포함되어 있습니다. 또한 일부 deprecated되지 않은 메서드도 구식이거나 스레드 안전하지 않으며, <code>activeCount</code>, <code>enumerate</code>와 같은 다른 메서드는 안전하지 않습니다. 이러한 이유로 <code>ThreadGroup</code>의 모든 사용은 의심스럽고 피해야 합니다.</p>",
    "howToFix_ko": "<p>대신 <code>java.util.concurrent.ExecutorService</code>의 구현체를 사용하여 스레드 그룹을 안전하게 관리하세요.</p>\n\n<h4>규칙을 준수하지 않는 코드 예시</h4>\n<pre>\nclass NetworkHandler {\n\n  void startThreadInGroup(ThreadGroup tg) { // 규칙 위반, 더 안전한 ExecutorService를 대신 사용하세요\n    Thread thread = new Thread(tg, \"controller\");\n    thread.start();\n  }\n\n}\n</pre>\n<h4>규칙을 준수하는 해결책</h4>\n<pre>\nclass NetworkHandler {\n\n  void handleThreadsProperly() {\n    ThreadFactory threadFactory = Executors.defaultThreadFactory();\n    ThreadPoolExecutor executorPool = new ThreadPoolExecutor(3, 10, 5, TimeUnit.SECONDS, new ArrayBlockingQueue&lt;Runnable&gt;(2), threadFactory);\n    for (int i = 0; i &lt; 10; i++) {\n      executorPool.execute(new Thread(\"Job: \" + i));\n    }\n    executorPool.shutdown();\n  }\n\n}\n</pre>",
    "moreInfo_ko": "<ul>\n  <li> <a href=\"https://wiki.sei.cmu.edu/confluence/x/YzdGBQ\">CERT, THI01-J.</a> - ThreadGroup 메서드를 호출하지 마세요 </li>\n</ul>"
  },
  {
    "id": "S6216",
    "key": "java:S6216",
    "name": "Reflection should not be used to increase accessibility of records' fields",
    "type": "bug",
    "severity": "major",
    "tags": [
      "java16"
    ],
    "why": "<p>In general, altering or bypassing the accessibility of classes, methods, or fields violates the encapsulation principle and could lead to runtime\nerrors. For records the case is even trickier: you cannot change the visibility of records's fields and trying to update the existing value will lead\nto <code>IllegalAccessException</code> at runtime.</p>\n<p>This rule raises an issue when reflection is used to change the visibility of a record's field, and when it is used to directly update a record's\nfield value.</p>\n<h3>Noncompliant code example</h3>\n<pre>\nrecord Person(String name, int age) {}\n\nPerson person = new Person(\"A\", 26);\nField field = Person.class.getDeclaredField(\"name\");\nfield.setAccessible(true); // secondary\nfield.set(person, \"B\"); // Noncompliant\n</pre>",
    "howToFix": "",
    "moreInfo": "<ul>\n  <li> <a href=\"https://docs.oracle.com/javase/specs/jls/se16/html/jls-8.html#jls-8.10\">Records specification</a> </li>\n</ul>",
    "status": "READY",
    "name_ko": "Record 필드의 접근성을 높이기 위해 Reflection을 사용하면 안 됩니다",
    "why_ko": "<p>일반적으로 클래스, 메서드 또는 필드의 접근성을 변경하거나 우회하는 것은 캡슐화 원칙을 위반하며 런타임 오류로 이어질 수 있습니다. Record의 경우 더 까다롭습니다: record 필드의 가시성을 변경할 수 없으며 기존 값을 업데이트하려고 하면 런타임에 <code>IllegalAccessException</code>이 발생합니다.</p>\n<p>이 규칙은 리플렉션을 사용하여 record 필드의 가시성을 변경하거나 record 필드 값을 직접 업데이트할 때 문제를 보고합니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\nrecord Person(String name, int age) {}\n\nPerson person = new Person(\"A\", 26);\nField field = Person.class.getDeclaredField(\"name\");\nfield.setAccessible(true); // 부차적\nfield.set(person, \"B\"); // 규칙 위반\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": "<ul>\n  <li> <a href=\"https://docs.oracle.com/javase/specs/jls/se16/html/jls-8.html#jls-8.10\">Record 명세</a> </li>\n</ul>"
  },
  {
    "id": "S1479",
    "key": "java:S1479",
    "name": "\"switch\" statements should not have too many \"case\" clauses",
    "type": "code-smell",
    "severity": "major",
    "tags": [
      "brain-overload"
    ],
    "why": "<p>When <code>switch</code> statements have large sets of <code>case</code> clauses, it is usually an attempt to map two sets of data. A real map\nstructure would be more readable and maintainable, and should be used instead.</p>\n<h3>Exceptions</h3>\n<p>This rule ignores <code>switch</code>es over <code>Enum</code>s and empty, fall-through cases.</p>",
    "howToFix": "",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "\"switch\" 문은 너무 많은 \"case\" 절을 가지면 안 됩니다",
    "why_ko": "<p><code>switch</code> 문에 <code>case</code> 절이 많은 경우, 이는 일반적으로 두 데이터 세트를 매핑하려는 시도입니다. 실제 맵 구조가 더 읽기 쉽고 유지보수하기 쉬우므로 대신 사용해야 합니다.</p>\n<h3>예외</h3>\n<p>이 규칙은 <code>Enum</code>에 대한 <code>switch</code>와 비어 있거나 fall-through인 케이스는 무시합니다.</p>",
    "howToFix_ko": "",
    "moreInfo_ko": ""
  },
  {
    "id": "S5969",
    "key": "java:S5969",
    "name": "Mocking all non-private methods of a class should be avoided",
    "type": "code-smell",
    "severity": "critical",
    "tags": [
      "tests",
      "mockito"
    ],
    "why": "<p>If you end up mocking every non-private method of a class in order to write tests, it is a strong sign that your test became too complex, or that\nyou misunderstood the way you are supposed to use the mocking mechanism.</p>\n<p>You should either refactor the test code into multiple units, or consider using the class itself, by either directly instantiating it, or creating\na new one inheriting from it, with the expected behavior.</p>\n<p>This rule reports an issue when every member of a given class are mocked.</p>\n<h3>Noncompliant code example</h3>\n<pre>\n@Test\nvoid test_requiring_MyClass() {\n  MyClass myClassMock = mock(MyClass.class); // Noncompliant\n  when(myClassMock.f()).thenReturn(1);\n  when(myClassMock.g()).thenReturn(2);\n  //...\n}\n\nabstract class MyClass {\n  abstract int f();\n  abstract int g();\n}\n</pre>\n<h3>Compliant solution</h3>\n<pre>\n@Test\nvoid test_requiring_MyClass() {\n  MyClass myClass = new MyClassForTest();\n  //...\n}\n\nclass MyClassForTest extends MyClass {\n\n  @Override\n  int f() {\n    return 1;\n  }\n\n  @Override\n  int g() {\n    return 2;\n  }\n}\n</pre>\n<p>or</p>\n<pre>\n@Test\nvoid test_requiring_f() {\n  MyClass myClassMock = mock(MyClass.class);\n  when(myClassMock.f()).thenReturn(1);\n  //...\n}\n\n@Test\nvoid test_requiring_g() {\n  MyClass myClassMock = mock(MyClass.class);\n  when(myClassMock.g()).thenReturn(2);\n  //...\n}\n\nabstract class MyClass {\n  abstract int f();\n  abstract int g();\n}\n</pre>",
    "howToFix": "",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "클래스의 모든 non-private 메서드를 mocking하는 것은 피해야 합니다",
    "why_ko": "<p>테스트를 작성하기 위해 클래스의 모든 non-private 메서드를 mocking하게 되면, 테스트가 너무 복잡해졌거나 mocking 메커니즘을 사용해야 하는 방식을 오해했다는 강한 신호입니다.</p>\n<p>테스트 코드를 여러 단위로 리팩터링하거나, 직접 인스턴스화하거나 예상되는 동작을 가진 새로운 클래스를 상속하여 클래스 자체를 사용하는 것을 고려해야 합니다.</p>\n<p>이 규칙은 주어진 클래스의 모든 멤버가 mocking될 때 문제를 보고합니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\n@Test\nvoid test_requiring_MyClass() {\n  MyClass myClassMock = mock(MyClass.class); // 규칙 위반\n  when(myClassMock.f()).thenReturn(1);\n  when(myClassMock.g()).thenReturn(2);\n  //...\n}\n\nabstract class MyClass {\n  abstract int f();\n  abstract int g();\n}\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre>\n@Test\nvoid test_requiring_MyClass() {\n  MyClass myClass = new MyClassForTest();\n  //...\n}\n\nclass MyClassForTest extends MyClass {\n\n  @Override\n  int f() {\n    return 1;\n  }\n\n  @Override\n  int g() {\n    return 2;\n  }\n}\n</pre>\n<p>또는</p>\n<pre>\n@Test\nvoid test_requiring_f() {\n  MyClass myClassMock = mock(MyClass.class);\n  when(myClassMock.f()).thenReturn(1);\n  //...\n}\n\n@Test\nvoid test_requiring_g() {\n  MyClass myClassMock = mock(MyClass.class);\n  when(myClassMock.g()).thenReturn(2);\n  //...\n}\n\nabstract class MyClass {\n  abstract int f();\n  abstract int g();\n}\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": ""
  },
  {
    "id": "S2039",
    "key": "java:S2039",
    "name": "Member variable visibility should be specified",
    "type": "code-smell",
    "severity": "minor",
    "tags": [],
    "why": "<p>Failing to explicitly declare the visibility of a member variable could result it in having a visibility you don't expect, and potentially leave it\nopen to unexpected modification by other classes.</p>\n<p>The default access level modifier may be intentional; in that case, this rule can report false positives.</p>\n<h3>Noncompliant code example</h3>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\nclass Ball {\n  String color = \"red\";  // Noncompliant\n}\nenum A {\n  B;\n  int a;  // Noncompliant\n}\n</pre>\n<h3>Compliant solution</h3>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\nclass Ball {\n  private String color = \"red\";  // Compliant\n}\nenum A {\n  B;\n  private int a;  // Compliant\n}\n</pre>\n<h3>Exceptions</h3>\n<ul>\n  <li> Members with comments containing the word <code>modifier</code> are ignored, as it indicates the modifier is intentionally omitted. </li>\n  <li> Members annotated with the <code>@VisibleForTesting</code> annotation are ignored, as it indicates that visibility has been purposely relaxed\n  to make the code testable. </li>\n</ul>\n<pre>\nclass Cone {\n  @VisibleForTesting\n  Logger logger; // Compliant\n}\n</pre>",
    "howToFix": "",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "멤버 변수의 가시성을 지정해야 합니다",
    "why_ko": "<p>멤버 변수의 가시성을 명시적으로 선언하지 않으면 예상치 못한 가시성을 갖게 될 수 있으며, 다른 클래스에 의한 예기치 않은 수정에 노출될 수 있습니다.</p>\n<p>기본 접근 수준 수정자는 의도적일 수 있습니다; 이 경우 이 규칙은 오탐을 보고할 수 있습니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\nclass Ball {\n  String color = \"red\";  // 규칙 위반\n}\nenum A {\n  B;\n  int a;  // 규칙 위반\n}\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\nclass Ball {\n  private String color = \"red\";  // 규칙 준수\n}\nenum A {\n  B;\n  private int a;  // 규칙 준수\n}\n</pre>\n<h3>예외</h3>\n<ul>\n  <li> <code>modifier</code>라는 단어가 포함된 주석이 있는 멤버는 수정자가 의도적으로 생략되었음을 나타내므로 무시됩니다. </li>\n  <li> <code>@VisibleForTesting</code> 어노테이션이 붙은 멤버는 코드를 테스트 가능하게 하기 위해 가시성이 의도적으로 완화되었음을 나타내므로 무시됩니다. </li>\n</ul>\n<pre>\nclass Cone {\n  @VisibleForTesting\n  Logger logger; // 규칙 준수\n}\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": ""
  },
  {
    "id": "S6241",
    "key": "java:S6241",
    "name": "Region should be set explicitly when creating a new \"AwsClient\"",
    "type": "code-smell",
    "severity": "major",
    "tags": [
      "startup-time",
      "aws"
    ],
    "why": "<p>If the region is not specified when creating a new AwsClient with an <a\nhref=\"https://sdk.amazonaws.com/java/api/latest/software/amazon/awssdk/awscore/client/builder/AwsClientBuilder.html\">AwsClientBuilder</a>, the AWS SDK\nwill execute some logic to identify the endpoint automatically.</p>\n<p>While it will probably identify the correct one, this extra logic will slow down startup time, already known to be a hotspot.</p>\n<p>You should therefore always define the logic to set the region yourself. This is typically done by retrieving the region from the Lambda provided\nAWS_REGION environment variable.</p>\n<p>This will make the code more explicit and spare initialization time.</p>\n<p>This rule reports an issue when the region is not set when creating an AwsClient.</p>\n<h3>Noncompliant code example</h3>\n<pre>\nS3Client.builder()\n    .credentialsProvider(EnvironmentVariableCredentialsProvider.create())\n    .build();\n</pre>\n<h3>Compliant solution</h3>\n<pre>\nS3Client.builder()\n    .region(Region.of(System.getenv(SdkSystemSetting.AWS_REGION.environmentVariable()))\n    .credentialsProvider(EnvironmentVariableCredentialsProvider.create())\n    .build();\n</pre>",
    "howToFix": "",
    "moreInfo": "<ul>\n  <li> <a href=\"https://aws.amazon.com/fr/blogs/developer/tuning-the-aws-java-sdk-2-x-to-reduce-startup-time/\">Tuning the AWS Java SDK 2.x to reduce\n  startup time</a> </li>\n  <li> <a href=\"https://docs.aws.amazon.com/sdk-for-java/latest/developer-guide/lambda-optimize-starttime.html\">Optimizing cold start performance for\n  AWS Lambda</a> </li>\n  <li> <a href=\"https://docs.aws.amazon.com/lambda/latest/dg/configuration-envvars.html\">Environment variable configuration</a> </li>\n  <li> <a\n  href=\"https://docs.aws.amazon.com/sdk-for-java/v1/developer-guide/java-dg-region-selection.html#automatically-determine-the-aws-region-from-the-environment\">Automatically Determine the AWS Region</a> </li>\n</ul>",
    "status": "READY",
    "name_ko": "새 \"AwsClient\" 생성 시 Region을 명시적으로 설정해야 합니다",
    "why_ko": "<p><a href=\"https://sdk.amazonaws.com/java/api/latest/software/amazon/awssdk/awscore/client/builder/AwsClientBuilder.html\">AwsClientBuilder</a>로 새 AwsClient를 생성할 때 region이 지정되지 않으면 AWS SDK는 엔드포인트를 자동으로 식별하는 로직을 실행합니다.</p>\n<p>올바른 것을 식별할 가능성이 높지만, 이 추가 로직은 이미 핫스팟으로 알려진 시작 시간을 느리게 합니다.</p>\n<p>따라서 항상 region을 직접 설정하는 로직을 정의해야 합니다. 일반적으로 Lambda가 제공하는 AWS_REGION 환경 변수에서 region을 가져와서 수행합니다.</p>\n<p>이렇게 하면 코드가 더 명시적이고 초기화 시간을 절약할 수 있습니다.</p>\n<p>이 규칙은 AwsClient를 생성할 때 region이 설정되지 않으면 문제를 보고합니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\nS3Client.builder()\n    .credentialsProvider(EnvironmentVariableCredentialsProvider.create())\n    .build();\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre>\nS3Client.builder()\n    .region(Region.of(System.getenv(SdkSystemSetting.AWS_REGION.environmentVariable()))\n    .credentialsProvider(EnvironmentVariableCredentialsProvider.create())\n    .build();\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": "<ul>\n  <li> <a href=\"https://aws.amazon.com/fr/blogs/developer/tuning-the-aws-java-sdk-2-x-to-reduce-startup-time/\">AWS Java SDK 2.x를 튜닝하여 시작 시간 단축</a> </li>\n  <li> <a href=\"https://docs.aws.amazon.com/sdk-for-java/latest/developer-guide/lambda-optimize-starttime.html\">AWS Lambda 콜드 스타트 성능 최적화</a> </li>\n  <li> <a href=\"https://docs.aws.amazon.com/lambda/latest/dg/configuration-envvars.html\">환경 변수 구성</a> </li>\n  <li> <a href=\"https://docs.aws.amazon.com/sdk-for-java/v1/developer-guide/java-dg-region-selection.html#automatically-determine-the-aws-region-from-the-environment\">환경에서 AWS Region 자동 결정</a> </li>\n</ul>"
  },
  {
    "id": "S3937",
    "key": "java:S3937",
    "name": "Number patterns should be regular",
    "type": "code-smell",
    "severity": "critical",
    "tags": [
      "suspicious"
    ],
    "why": "<p>The use of punctuation characters to separate subgroups in a number can make the number more readable. For instance consider 1,000,000,000 versus\n1000000000. But when the grouping is irregular, such as 1,000,00,000; it indicates an error.</p>\n<p>This rule raises an issue when underscores (<code>_</code>) are used to break a number into irregular subgroups.</p>\n<h3>Noncompliant code example</h3>\n<pre>\nint thousand = 100_0;\nint tenThousand = 100_00;\nint million = 1_000_00_000;\n</pre>\n<h3>Compliant solution</h3>\n<pre>\nint thousand = 1000;\nint tenThousand = 10_000;\nint tenThousandWithout = 10000;\nint duos = 1_00_00;\nint million = 100_000_000;\n</pre>\n<h3>Exceptions</h3>\n<p>No issue will be raised on binary numbers (starting with <code>0b</code> or <code>0B</code>). Binary number bits are often grouped corresponding to\ncertain meanings, resulting in irregular bit group sizes.</p>\n<pre>\nint configValue1 = 0b00_000_10_1; // Compliant\nint configValue2 = 0B00_000_10_1; // Compliant\n</pre>",
    "howToFix": "",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "숫자 패턴은 규칙적이어야 합니다",
    "why_ko": "<p>숫자에서 하위 그룹을 구분하기 위해 구두점 문자를 사용하면 숫자를 더 읽기 쉽게 만들 수 있습니다. 예를 들어 1,000,000,000과 1000000000을 비교해 보세요. 그러나 1,000,00,000과 같이 그룹화가 불규칙하면 오류를 나타냅니다.</p>\n<p>이 규칙은 밑줄(<code>_</code>)을 사용하여 숫자를 불규칙한 하위 그룹으로 나눌 때 문제를 제기합니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\nint thousand = 100_0;\nint tenThousand = 100_00;\nint million = 1_000_00_000;\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre>\nint thousand = 1000;\nint tenThousand = 10_000;\nint tenThousandWithout = 10000;\nint duos = 1_00_00;\nint million = 100_000_000;\n</pre>\n<h3>예외</h3>\n<p>이진수(<code>0b</code> 또는 <code>0B</code>로 시작)에서는 문제가 제기되지 않습니다. 이진수 비트는 특정 의미에 해당하는 그룹으로 묶이는 경우가 많아 불규칙한 비트 그룹 크기가 발생합니다.</p>\n<pre>\nint configValue1 = 0b00_000_10_1; // 규칙 준수\nint configValue2 = 0B00_000_10_1; // 규칙 준수\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": ""
  },
  {
    "id": "S2275",
    "key": "java:S2275",
    "name": "Printf-style format strings should not lead to unexpected behavior at runtime",
    "type": "bug",
    "severity": "blocker",
    "tags": [
      "cert"
    ],
    "why": "<p>Because <code>printf</code>-style format strings are interpreted at runtime, rather than validated by the Java compiler, they can contain errors\nthat lead to unexpected behavior or runtime errors. This rule statically validates the good behavior of <code>printf</code>-style formats when calling\nthe <code>format(...)</code> methods of <code>java.util.Formatter</code>, <code>java.lang.String</code>, <code>java.io.PrintStream</code>,\n<code>MessageFormat</code>, and <code>java.io.PrintWriter</code> classes and the <code>printf(...)</code> methods of <code>java.io.PrintStream</code>\nor <code>java.io.PrintWriter</code> classes.</p>\n<h3>Noncompliant code example</h3>\n<pre>\nString.format(\"The value of my integer is %d\", \"Hello World\");  // Noncompliant; an 'int' is expected rather than a String\nString.format(\"Duke's Birthday year is %tX\", c);  //Noncompliant; X is not a supported time conversion character\nString.format(\"Display %0$d and then %d\", 1);   //Noncompliant; arguments are numbered starting from 1\nString.format(\"Not enough arguments %d and %d\", 1);  //Noncompliant; the second argument is missing\nString.format(\"%&lt; is equals to %d\", 2);   //Noncompliant; the argument index '&lt;' refers to the previous format specifier but there isn't one\n\nMessageFormat.format(\"Result {1}.\", value); // Noncompliant; Not enough arguments. (first element is {0})\nMessageFormat.format(\"Result {{0}.\", value); // Noncompliant; Unbalanced number of curly brace (single curly braces should be escaped)\nMessageFormat.format(\"Result ' {0}\", value); // Noncompliant; Unbalanced number of quotes (single quote must be escaped)\n\njava.util.logging.Logger logger;\nlogger.log(java.util.logging.Level.SEVERE, \"Result {1}!\", 14); // Noncompliant - Not enough arguments.\n\norg.slf4j.Logger slf4jLog;\norg.slf4j.Marker marker;\n\nslf4jLog.debug(marker, \"message {}\"); // Noncompliant - Not enough arguments.\n\norg.apache.logging.log4j.Logger log4jLog;\nlog4jLog.debug(\"message {}\"); // Noncompliant - Not enough arguments.\n</pre>\n<h3>Compliant solution</h3>\n<pre>\nString.format(\"The value of my integer is %d\", 3);\nString.format(\"Duke's Birthday year is %tY\", c);\nString.format(\"Display %1$d and then %d\", 1);\nString.format(\"Not enough arguments %d and %d\", 1, 2);\nString.format(\"%d is equals to %&lt;\", 2);\n\nMessageFormat.format(\"Result {0}.\", value);\nMessageFormat.format(\"Result {0} &amp; {1}.\", value, value);\nMessageFormat.format(\"Result {0}.\", myObject);\n\njava.util.logging.Logger logger;\nlogger.log(java.util.logging.Level.SEVERE, \"Result {1},{2}!\", 14, 2);\n\norg.slf4j.Logger slf4jLog;\norg.slf4j.Marker marker;\n\nslf4jLog.debug(marker, \"message {}\", 1);\n\norg.apache.logging.log4j.Logger log4jLog;\nlog4jLog.debug(\"message {}\", 1);\n</pre>",
    "howToFix": "",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "Printf 스타일 포맷 문자열이 런타임에 예기치 않은 동작을 유발하면 안 됩니다",
    "why_ko": "<p><code>printf</code> 스타일 포맷 문자열은 Java 컴파일러에 의해 검증되지 않고 런타임에 해석되므로 예기치 않은 동작이나 런타임 오류를 유발하는 오류를 포함할 수 있습니다. 이 규칙은 <code>java.util.Formatter</code>, <code>java.lang.String</code>, <code>java.io.PrintStream</code>, <code>MessageFormat</code>, <code>java.io.PrintWriter</code> 클래스의 <code>format(...)</code> 메서드와 <code>java.io.PrintStream</code> 또는 <code>java.io.PrintWriter</code> 클래스의 <code>printf(...)</code> 메서드를 호출할 때 <code>printf</code> 스타일 포맷의 올바른 동작을 정적으로 검증합니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\nString.format(\"The value of my integer is %d\", \"Hello World\");  // 규칙 위반; String이 아닌 'int'가 예상됨\nString.format(\"Duke's Birthday year is %tX\", c);  // 규칙 위반; X는 지원되는 시간 변환 문자가 아님\nString.format(\"Display %0$d and then %d\", 1);   // 규칙 위반; 인수는 1부터 번호가 매겨짐\nString.format(\"Not enough arguments %d and %d\", 1);  // 규칙 위반; 두 번째 인수가 누락됨\nString.format(\"%&lt; is equals to %d\", 2);   // 규칙 위반; 인수 인덱스 '&lt;'는 이전 포맷 지정자를 참조하지만 없음\n\nMessageFormat.format(\"Result {1}.\", value); // 규칙 위반; 인수가 충분하지 않음 (첫 번째 요소는 {0})\nMessageFormat.format(\"Result {{0}.\", value); // 규칙 위반; 중괄호 수가 불균형 (단일 중괄호는 이스케이프해야 함)\nMessageFormat.format(\"Result ' {0}\", value); // 규칙 위반; 따옴표 수가 불균형 (단일 따옴표는 이스케이프해야 함)\n\njava.util.logging.Logger logger;\nlogger.log(java.util.logging.Level.SEVERE, \"Result {1}!\", 14); // 규칙 위반 - 인수가 충분하지 않음\n\norg.slf4j.Logger slf4jLog;\norg.slf4j.Marker marker;\n\nslf4jLog.debug(marker, \"message {}\"); // 규칙 위반 - 인수가 충분하지 않음\n\norg.apache.logging.log4j.Logger log4jLog;\nlog4jLog.debug(\"message {}\"); // 규칙 위반 - 인수가 충분하지 않음\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre>\nString.format(\"The value of my integer is %d\", 3);\nString.format(\"Duke's Birthday year is %tY\", c);\nString.format(\"Display %1$d and then %d\", 1);\nString.format(\"Not enough arguments %d and %d\", 1, 2);\nString.format(\"%d is equals to %&lt;\", 2);\n\nMessageFormat.format(\"Result {0}.\", value);\nMessageFormat.format(\"Result {0} &amp; {1}.\", value, value);\nMessageFormat.format(\"Result {0}.\", myObject);\n\njava.util.logging.Logger logger;\nlogger.log(java.util.logging.Level.SEVERE, \"Result {1},{2}!\", 14, 2);\n\norg.slf4j.Logger slf4jLog;\norg.slf4j.Marker marker;\n\nslf4jLog.debug(marker, \"message {}\", 1);\n\norg.apache.logging.log4j.Logger log4jLog;\nlog4jLog.debug(\"message {}\", 1);\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": ""
  },
  {
    "id": "S3034",
    "key": "java:S3034",
    "name": "Raw byte values should not be used in bitwise operations in combination with shifts",
    "type": "bug",
    "severity": "major",
    "tags": [
      "cert"
    ],
    "why": "<p>In Java, numeric promotions happen when two operands of an arithmetic expression have different sizes. More specifically, narrower operands get\npromoted to the type of wider operands. For instance, an operation between a <code>byte</code> and an <code>int</code>, will trigger a promotion of\nthe <code>byte</code> operand, converting it into an <code>int</code>.</p>\n<p>When this happens, the sequence of 8 bits that represents the <code>byte</code> will need to be extended to match the 32-bit long sequence that\nrepresents the <code>int</code> operand. Since Java uses two's complement notation for signed number types, the promotion will fill the missing\nleading bits with zeros or ones, depending on the sign of the value. For instance, the byte <code>0b1000_0000</code> (equal to <code>-128</code> in\ndecimal notation), when promoted to <code>int</code>, will become <code>0b1111_1111_1111_1111_1111_1111_1000_0000</code>.</p>\n<p>When performing shifting or bitwise operations without considering that bytes are signed, the bits added during the promotion may have unexpected\neffects on the final result of the operations.</p>",
    "howToFix": "<p>This rule raises an issue any time a <code>byte</code> value is used as an operand combined with shifts without being masked.</p>\n<p>To prevent such accidental value conversions, you can mask promoted bytes to only consider the least significant 8 bits. Masking can be achieved\nwith the bitwise AND operator <code>&amp;</code> and the appropriate mask of <code>0xff</code> (255 in decimal and <code>0b1111_1111</code> in binary)\nor, since Java 8, with the more convenient <code>Byte.toUnsignedInt(byte b)</code> or <code>Byte.toUnsignedLong(byte b)</code>.</p>\n\n<h4>Noncompliant code example</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\n  public static void main(String[] args) {\n    byte[] bytes12 = BigInteger.valueOf(12).toByteArray(); // This byte array will be simply [12]\n    System.out.println(intFromBuffer(bytes12)); // In this case, the bytes promotion will not cause any issues, and \"12\" will be printed.\n\n    // Here the bytes will be [2, -128] since 640 in binary is represented as 0b0000_0010_1000_0000\n    // which is equivalent to the concatenation of 2 bytes: 0b0000_0010 = 2, and 0b1000_0000 = -128\n    byte[] bytes640 = BigInteger.valueOf(640).toByteArray();\n\n    // In this case, the shifting operation combined with the bitwise OR, will produce the wrong binary string and \"-128\" will be printed.\n    System.out.println(intFromBuffer(bytes640));\n  }\n\n  static int intFromBuffer(byte[] bytes) {\n    int originalInt = 0;\n    for (int i = 0; i &lt; bytes.length; i++) {\n      // Here the right operand of the bitwise OR, which is a byte, will be promoted to an `int`\n      // and if its value was negative, the added ones in front of the binary string will alter the value of the `originalInt`\n      originalInt = (originalInt &lt;&lt; 8) | bytes[i]; // Noncompliant\n    }\n    return originalInt;\n  }\n</pre>\n<h4>Compliant solution</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\n  public static void main(String[] args) {\n    byte[] bytes12 = BigInteger.valueOf(12).toByteArray(); // This byte array will be simply [12]\n    System.out.println(intFromBuffer(bytes12)); // In this case, the bytes promotion will not cause any issues, and \"12\" will be printed.\n\n    // Here the bytes will be [2, -128] since 640 in binary is represented as 0b0000_0010_1000_0000\n    // which is equivalent to the concatenation of 2 bytes: 0b0000_0010 = 2, and 0b1000_0000 = -128\n    byte[] bytes640 = BigInteger.valueOf(640).toByteArray();\n\n    // This will correctly print \"640\" now.\n    System.out.println(intFromBuffer(bytes640));\n  }\n\n  static int intFromBuffer(byte[] bytes) {\n    int originalInt = 0;\n    for (int i = 0; i &lt; bytes.length; i++) {\n      originalInt = (originalInt &lt;&lt; 8) | Byte.toUnsignedInt(bytes[i]); // Compliant, only the relevant 8 least significant bits will affect the bitwise OR\n    }\n    return originalInt;\n  }\n</pre>",
    "moreInfo": "<ul>\n  <li> <a href=\"https://wiki.sei.cmu.edu/confluence/x/kDZGBQ\">CERT, NUM52-J.</a> - Be aware of numeric promotion behavior </li>\n  <li> <a href=\"https://en.wikipedia.org/wiki/Signed_number_representations#Two.27s_complement\">Wikipedia</a> - Two's complement </li>\n</ul>",
    "status": "READY",
    "name_ko": "시프트 연산과 함께 비트 연산에서 raw byte 값을 사용하면 안 됩니다",
    "why_ko": "<p>Java에서 산술 표현식의 두 피연산자가 서로 다른 크기를 가지면 숫자 승격이 발생합니다. 구체적으로, 더 좁은 피연산자가 더 넓은 피연산자의 타입으로 승격됩니다. 예를 들어, <code>byte</code>와 <code>int</code> 사이의 연산은 <code>byte</code> 피연산자를 <code>int</code>로 변환하는 승격을 트리거합니다.</p>\n<p>이것이 발생하면, <code>byte</code>를 나타내는 8비트 시퀀스는 <code>int</code> 피연산자를 나타내는 32비트 시퀀스와 일치하도록 확장되어야 합니다. Java는 부호 있는 숫자 타입에 2의 보수 표기법을 사용하므로, 승격은 값의 부호에 따라 누락된 선행 비트를 0 또는 1로 채웁니다. 예를 들어, 바이트 <code>0b1000_0000</code>(10진수 표기법으로 <code>-128</code>과 같음)은 <code>int</code>로 승격될 때 <code>0b1111_1111_1111_1111_1111_1111_1000_0000</code>이 됩니다.</p>\n<p>바이트가 부호 있음을 고려하지 않고 시프트 또는 비트 연산을 수행하면, 승격 중에 추가된 비트가 연산의 최종 결과에 예상치 못한 영향을 미칠 수 있습니다.</p>",
    "howToFix_ko": "<p>이 규칙은 <code>byte</code> 값이 마스킹 없이 시프트와 결합된 피연산자로 사용될 때마다 문제를 제기합니다.</p>\n<p>이러한 우발적인 값 변환을 방지하려면, 승격된 바이트를 마스킹하여 가장 낮은 8비트만 고려하도록 할 수 있습니다. 마스킹은 비트 AND 연산자 <code>&amp;</code>와 적절한 마스크 <code>0xff</code>(10진수로 255, 2진수로 <code>0b1111_1111</code>)를 사용하거나, Java 8부터는 더 편리한 <code>Byte.toUnsignedInt(byte b)</code> 또는 <code>Byte.toUnsignedLong(byte b)</code>를 사용하여 수행할 수 있습니다.</p>\n\n<h4>규칙을 준수하지 않는 코드 예시</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\n  public static void main(String[] args) {\n    byte[] bytes12 = BigInteger.valueOf(12).toByteArray(); // 이 바이트 배열은 단순히 [12]가 됩니다\n    System.out.println(intFromBuffer(bytes12)); // 이 경우 바이트 승격이 문제를 일으키지 않으며 \"12\"가 출력됩니다.\n\n    // 여기서 바이트는 [2, -128]이 됩니다. 640은 2진수로 0b0000_0010_1000_0000으로 표현되기 때문입니다\n    // 이는 2바이트의 연결과 같습니다: 0b0000_0010 = 2, 그리고 0b1000_0000 = -128\n    byte[] bytes640 = BigInteger.valueOf(640).toByteArray();\n\n    // 이 경우 시프트 연산과 비트 OR의 결합이 잘못된 2진 문자열을 생성하고 \"-128\"이 출력됩니다.\n    System.out.println(intFromBuffer(bytes640));\n  }\n\n  static int intFromBuffer(byte[] bytes) {\n    int originalInt = 0;\n    for (int i = 0; i &lt; bytes.length; i++) {\n      // 여기서 비트 OR의 오른쪽 피연산자인 바이트가 `int`로 승격됩니다\n      // 값이 음수인 경우 2진 문자열 앞에 추가된 1들이 `originalInt`의 값을 변경합니다\n      originalInt = (originalInt &lt;&lt; 8) | bytes[i]; // 규칙 위반\n    }\n    return originalInt;\n  }\n</pre>\n<h4>규칙을 준수하는 해결책</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\n  public static void main(String[] args) {\n    byte[] bytes12 = BigInteger.valueOf(12).toByteArray(); // 이 바이트 배열은 단순히 [12]가 됩니다\n    System.out.println(intFromBuffer(bytes12)); // 이 경우 바이트 승격이 문제를 일으키지 않으며 \"12\"가 출력됩니다.\n\n    // 여기서 바이트는 [2, -128]이 됩니다. 640은 2진수로 0b0000_0010_1000_0000으로 표현되기 때문입니다\n    // 이는 2바이트의 연결과 같습니다: 0b0000_0010 = 2, 그리고 0b1000_0000 = -128\n    byte[] bytes640 = BigInteger.valueOf(640).toByteArray();\n\n    // 이제 \"640\"이 올바르게 출력됩니다.\n    System.out.println(intFromBuffer(bytes640));\n  }\n\n  static int intFromBuffer(byte[] bytes) {\n    int originalInt = 0;\n    for (int i = 0; i &lt; bytes.length; i++) {\n      originalInt = (originalInt &lt;&lt; 8) | Byte.toUnsignedInt(bytes[i]); // 규칙 준수, 관련된 8개의 최하위 비트만 비트 OR에 영향을 미칩니다\n    }\n    return originalInt;\n  }\n</pre>",
    "moreInfo_ko": "<ul>\n  <li> <a href=\"https://wiki.sei.cmu.edu/confluence/x/kDZGBQ\">CERT, NUM52-J.</a> - 숫자 승격 동작에 주의하세요 </li>\n  <li> <a href=\"https://en.wikipedia.org/wiki/Signed_number_representations#Two.27s_complement\">Wikipedia</a> - 2의 보수 </li>\n</ul>"
  },
  {
    "id": "S6373",
    "key": "java:S6373",
    "name": "XML parsers should not allow inclusion of arbitrary files",
    "type": "vulnerability",
    "severity": "blocker",
    "tags": [
      "symbolic-execution"
    ],
    "why": "<p>When the XML parser will encounter an <code>xinclude</code> element, it will try to load the file pointed to by the <code>href</code> attribute\ninto the document. Included files can either be local files found on the file system of the application server, or remote files that are downloaded\nover HTTP, SMB, or other protocols, depending on the capabilities of the application and server.</p>\n<p>The files that can be accessed that way are only limited by the entitlement of the application on the local system and the network filtering the\nserver is subject to.</p>\n<p>This issue is particularly severe when the XML parser is used to parse untrusted documents. For example, when user-submitted XML messages are\nparsed that way.</p>\n<h3>What is the potential impact?</h3>\n<p>Allowing the inclusion of arbitrary files in XML documents can have two main consequences depending on what type of file is included: local or\nremote.</p>\n<h4>Sensitive file disclosure</h4>\n<p>If the application allows the inclusion of arbitrary files through the use of the <code>xinclude</code> element, it might be used to disclose\narbitrary files from the local file system. Depending on the application's permissions on the file system, configuration files, runtime secrets, or\nPersonally Identifiable Information could be leaked.</p>\n<p>This is particularly true if the affected parser is used to process untrusted XML documents.</p>\n<h4>Server-side request forgery</h4>\n<p>When used to retrieve remote files, the application will send network requests to remote hosts. Moreover, it will do so from its current network\nlocation, which can have severe consequences if the application server is located on a sensitive network, such as the company corporate network or a\nDMZ hosting other applications.</p>\n<p>Attackers exploiting this issue could try to access internal backend services or corporate file shares. It could allow them to access more\nsensitive files, bypass authentication mechanisms from frontend applications, or exploit further vulnerabilities in the local services. Note that, in\nsome cases, the requests sent from the application can be automatically authenticated on federated locations. This is often the case in Windows\nenvironments when using Active Directory federated authentication.</p>",
    "howToFix": "<p>The following code is vulnerable because it explicitly enables the <code>xinclude</code> feature.</p>\n<h4>Noncompliant code example</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\nimport javax.xml.parsers.SAXParserFactory;\n\nSAXParserFactory factory = SAXParserFactory.newInstance();\n\nfactory.setXIncludeAware(true); // Noncompliant\nfactory.setFeature(\"http://apache.org/xml/features/xinclude\", true); // Noncompliant\n</pre>\n<h4>Compliant solution</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\nimport javax.xml.parsers.SAXParserFactory;\n\nSAXParserFactory factory = SAXParserFactory.newInstance();\n\nfactory.setXIncludeAware(false);\nfactory.setFeature(\"http://apache.org/xml/features/xinclude\", false);\n</pre>",
    "moreInfo": "<h3>Documentation</h3>\n<ul>\n  <li> OWASP - <a href=\"https://cheatsheetseries.owasp.org/cheatsheets/XML_External_Entity_Prevention_Cheat_Sheet.html#java\">OWASP XXE Prevention\n  Cheat Sheet</a> </li>\n  <li> Java documentation - <a\n  href=\"https://docs.oracle.com/en/java/javase/13/security/java-api-xml-processing-jaxp-security-guide.html#GUID-8CD65EF5-D113-4D5C-A564-B875C8625FAC\">XML External Entity Injection Attack</a> </li>\n  <li> W3C - <a href=\"https://www.w3.org/TR/xinclude-11/\">XML Inclusions (XInclude) Version 1.1</a> </li>\n</ul>\n<h3>Standards</h3>\n<ul>\n  <li> OWASP - <a href=\"https://owasp.org/www-project-top-ten/2017/A4_2017-XML_External_Entities_(XXE)\">Top 10 2017 - Category A4 - XML External\n  Entities (XXE)</a> </li>\n  <li> OWASP - <a href=\"https://owasp.org/Top10/A05_2021-Security_Misconfiguration/\">Top 10 2021 - Category A5 - Security Misconfiguration</a> </li>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/611\">CWE-611 - Improper Restriction of XML External Entity Reference</a> </li>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/827\">CWE-827 - Improper Control of Document Type Definition</a> </li>\n  <li> STIG Viewer - <a href=\"https://stigviewer.com/stig/application_security_and_development/2023-06-08/finding/V-222608\">Application Security and\n  Development: V-222608</a> - The application must not be vulnerable to XML-oriented attacks. </li>\n</ul>",
    "status": "READY",
    "name_ko": "XML 파서는 임의 파일 포함을 허용하면 안 됩니다",
    "why_ko": "<p>XML 파서가 <code>xinclude</code> 요소를 만나면 <code>href</code> 속성이 가리키는 파일을 문서에 로드하려고 시도합니다. 포함된 파일은 애플리케이션 서버의 파일 시스템에 있는 로컬 파일이거나 애플리케이션과 서버의 기능에 따라 HTTP, SMB 또는 기타 프로토콜을 통해 다운로드되는 원격 파일일 수 있습니다.</p>\n<p>이 방식으로 접근할 수 있는 파일은 로컬 시스템에서 애플리케이션의 권한과 서버가 적용받는 네트워크 필터링에 의해서만 제한됩니다.</p>\n<p>이 문제는 XML 파서가 신뢰할 수 없는 문서를 구문 분석하는 데 사용될 때 특히 심각합니다. 예를 들어 사용자가 제출한 XML 메시지가 이 방식으로 구문 분석되는 경우입니다.</p>\n<h3>잠재적 영향은 무엇인가요?</h3>\n<p>XML 문서에 임의 파일 포함을 허용하면 포함된 파일 유형(로컬 또는 원격)에 따라 두 가지 주요 결과가 발생할 수 있습니다.</p>\n<h4>민감한 파일 노출</h4>\n<p>애플리케이션이 <code>xinclude</code> 요소를 사용하여 임의 파일 포함을 허용하면 로컬 파일 시스템에서 임의 파일을 노출하는 데 사용될 수 있습니다. 파일 시스템에 대한 애플리케이션의 권한에 따라 구성 파일, 런타임 비밀 또는 개인 식별 정보가 유출될 수 있습니다.</p>\n<p>이는 영향받는 파서가 신뢰할 수 없는 XML 문서를 처리하는 데 사용되는 경우 특히 그렇습니다.</p>\n<h4>서버 측 요청 위조</h4>\n<p>원격 파일을 검색하는 데 사용될 때 애플리케이션은 원격 호스트에 네트워크 요청을 보냅니다. 또한 현재 네트워크 위치에서 이를 수행하므로 애플리케이션 서버가 회사 내부 네트워크나 다른 애플리케이션을 호스팅하는 DMZ와 같은 민감한 네트워크에 있는 경우 심각한 결과를 초래할 수 있습니다.</p>\n<p>이 문제를 악용하는 공격자는 내부 백엔드 서비스나 회사 파일 공유에 접근하려고 시도할 수 있습니다. 이를 통해 더 민감한 파일에 접근하거나 프런트엔드 애플리케이션의 인증 메커니즘을 우회하거나 로컬 서비스의 추가 취약점을 악용할 수 있습니다. 일부 경우 애플리케이션에서 보낸 요청이 연합 위치에서 자동으로 인증될 수 있습니다. 이는 Active Directory 연합 인증을 사용하는 Windows 환경에서 자주 발생합니다.</p>",
    "howToFix_ko": "<p>다음 코드는 <code>xinclude</code> 기능을 명시적으로 활성화하기 때문에 취약합니다.</p>\n<h4>규칙을 준수하지 않는 코드 예시</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\nimport javax.xml.parsers.SAXParserFactory;\n\nSAXParserFactory factory = SAXParserFactory.newInstance();\n\nfactory.setXIncludeAware(true); // 규칙 위반\nfactory.setFeature(\"http://apache.org/xml/features/xinclude\", true); // 규칙 위반\n</pre>\n<h4>규칙을 준수하는 해결책</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\nimport javax.xml.parsers.SAXParserFactory;\n\nSAXParserFactory factory = SAXParserFactory.newInstance();\n\nfactory.setXIncludeAware(false);\nfactory.setFeature(\"http://apache.org/xml/features/xinclude\", false);\n</pre>",
    "moreInfo_ko": "<h3>문서</h3>\n<ul>\n  <li> OWASP - <a href=\"https://cheatsheetseries.owasp.org/cheatsheets/XML_External_Entity_Prevention_Cheat_Sheet.html#java\">OWASP XXE 예방 치트 시트</a> </li>\n  <li> Java documentation - <a href=\"https://docs.oracle.com/en/java/javase/13/security/java-api-xml-processing-jaxp-security-guide.html#GUID-8CD65EF5-D113-4D5C-A564-B875C8625FAC\">XML 외부 엔티티 인젝션 공격</a> </li>\n  <li> W3C - <a href=\"https://www.w3.org/TR/xinclude-11/\">XML Inclusions (XInclude) 버전 1.1</a> </li>\n</ul>\n<h3>표준</h3>\n<ul>\n  <li> OWASP - <a href=\"https://owasp.org/www-project-top-ten/2017/A4_2017-XML_External_Entities_(XXE)\">Top 10 2017 - Category A4 - XML 외부 엔티티(XXE)</a> </li>\n  <li> OWASP - <a href=\"https://owasp.org/Top10/A05_2021-Security_Misconfiguration/\">Top 10 2021 - Category A5 - 보안 구성 오류</a> </li>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/611\">CWE-611 - XML 외부 엔티티 참조의 부적절한 제한</a> </li>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/827\">CWE-827 - 문서 타입 정의의 부적절한 제어</a> </li>\n  <li> STIG Viewer - <a href=\"https://stigviewer.com/stig/application_security_and_development/2023-06-08/finding/V-222608\">Application Security and Development: V-222608</a> - 애플리케이션은 XML 기반 공격에 취약하면 안 됩니다. </li>\n</ul>"
  },
  {
    "id": "S4030",
    "key": "java:S4030",
    "name": "Collection contents should be used",
    "type": "code-smell",
    "severity": "minor",
    "tags": [
      "performance",
      "unused",
      "suspicious"
    ],
    "why": "<p>If a collection is declared and populated but its values are never read anywhere in the code, it can be considered unused. This often arises from\nincomplete refactoring, copy-pasting errors, or typos. Unused collections can lead to wasted memory and degraded application performance.\nAdditionally, their presence makes the code harder to read and understand.</p>",
    "howToFix": "<p>Remove unused collection.</p>\n\n<h4>Noncompliant code example</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\nint getLength(String a, String b, String c) {\n  List&lt;String&gt; strings = new ArrayList&lt;&gt;();  // Noncompliant: List is declared and populated but never read.\n  strings.add(a);\n  strings.add(b);\n  strings.add(c);\n\n  return a.length() + b.length() + c.length();\n}\n</pre>\n<h4>Compliant solution</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\nint getLength(String a, String b, String c) {\n  return a.length() + b.length() + c.length();\n}\n</pre>",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "Collection 내용을 사용해야 합니다",
    "why_ko": "<p>컬렉션이 선언되고 채워졌지만 코드 어디에서도 값이 읽히지 않으면 사용되지 않는 것으로 간주할 수 있습니다. 이는 불완전한 리팩토링, 복사-붙여넣기 오류 또는 오타에서 자주 발생합니다. 사용되지 않는 컬렉션은 메모리 낭비와 애플리케이션 성능 저하를 초래할 수 있습니다. 또한 그 존재로 인해 코드를 읽고 이해하기 어려워집니다.</p>",
    "howToFix_ko": "<p>사용되지 않는 컬렉션을 제거하세요.</p>\n\n<h4>규칙을 준수하지 않는 코드 예시</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\nint getLength(String a, String b, String c) {\n  List&lt;String&gt; strings = new ArrayList&lt;&gt;();  // 규칙 위반: List가 선언되고 채워졌지만 읽히지 않습니다.\n  strings.add(a);\n  strings.add(b);\n  strings.add(c);\n\n  return a.length() + b.length() + c.length();\n}\n</pre>\n<h4>규칙을 준수하는 해결책</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\nint getLength(String a, String b, String c) {\n  return a.length() + b.length() + c.length();\n}\n</pre>",
    "moreInfo_ko": ""
  },
  {
    "id": "S3599",
    "key": "java:S3599",
    "name": "Double Brace Initialization should not be used",
    "type": "bug",
    "severity": "minor",
    "tags": [
      "leak"
    ],
    "why": "<p>Because Double Brace Initialization (DBI) creates an anonymous class with a reference to the instance of the owning object, its use can lead to\nmemory leaks if the anonymous inner class is returned and held by other objects. Even when there's no leak, DBI is so obscure that it's bound to\nconfuse most maintainers.</p>\n<p>For collections, use <code>Arrays.asList</code> instead, or explicitly add each item directly to the collection.</p>\n<h3>Noncompliant code example</h3>\n<pre>\nMap source = new HashMap(){{ // Noncompliant\n    put(\"firstName\", \"John\");\n    put(\"lastName\", \"Smith\");\n}};\n</pre>\n<h3>Compliant solution</h3>\n<pre>\nMap source = new HashMap();\n// ...\nsource.put(\"firstName\", \"John\");\nsource.put(\"lastName\", \"Smith\");\n// ...\n</pre>",
    "howToFix": "",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "Double Brace Initialization을 사용하면 안 됩니다",
    "why_ko": "<p>Double Brace Initialization(DBI)은 소유 객체의 인스턴스에 대한 참조가 있는 익명 클래스를 생성하기 때문에, 익명 내부 클래스가 반환되어 다른 객체에 의해 유지되면 메모리 누수가 발생할 수 있습니다. 누수가 없더라도 DBI는 너무 난해하여 대부분의 유지 관리자를 혼란스럽게 할 수 있습니다.</p>\n<p>컬렉션의 경우 대신 <code>Arrays.asList</code>를 사용하거나 각 항목을 컬렉션에 직접 명시적으로 추가하세요.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\nMap source = new HashMap(){{ // 규칙 위반\n    put(\"firstName\", \"John\");\n    put(\"lastName\", \"Smith\");\n}};\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre>\nMap source = new HashMap();\n// ...\nsource.put(\"firstName\", \"John\");\nsource.put(\"lastName\", \"Smith\");\n// ...\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": ""
  },
  {
    "id": "S3063",
    "key": "java:S3063",
    "name": "\"StringBuilder\" data should be used",
    "type": "code-smell",
    "severity": "major",
    "tags": [
      "performance"
    ],
    "why": "<p><code>StringBuffer</code> and <code>StringBuilder</code> instances that are <code>append</code>ed but never <code>toString</code>ed needlessly\nclutter the code, and worse are a drag on performance. Either they should be removed, or the missing <code>toString</code> call added.</p>\n<h3>Noncompliant code example</h3>\n<pre>\npublic void doSomething(List&lt;String&gt; strings) {\n\n  StringBuilder sb = new StringBuilder();  // Noncompliant\n  sb.append(\"Got: \");\n  for (String str : strings) {\n    sb.append(str).append(\", \");\n    // ...\n  }\n}\n</pre>\n<h3>Compliant solution</h3>\n<pre>\npublic void doSomething(List&lt;String&gt; strings) {\n\n  for (String str : strings) {\n    // ...\n  }\n}\n</pre>\n<p>or</p>\n<pre>\npublic void doSomething(List&lt;String&gt; strings) {\n\n  StringBuilder sb = new StringBuilder();\n  sb.append(\"Got: \");\n  for (String str : strings) {\n    sb.append(str).append(\", \");\n    // ...\n  }\n\n  LOGGER.info(sb.toString);\n}\n</pre>\n<h3>Exceptions</h3>\n<p>This rule ignores <code>StringBuffer</code>s and <code>StringBuilder</code>s that are passed as method arguments on the grounds that they are\nlikely <code>toString</code>ed there.</p>",
    "howToFix": "",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "\"StringBuilder\" 데이터를 사용해야 합니다",
    "why_ko": "<p><code>append</code>되었지만 <code>toString</code>되지 않은 <code>StringBuffer</code> 및 <code>StringBuilder</code> 인스턴스는 코드를 불필요하게 복잡하게 만들고, 더 나쁜 것은 성능 저하를 유발합니다. 이들을 제거하거나 누락된 <code>toString</code> 호출을 추가해야 합니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\npublic void doSomething(List&lt;String&gt; strings) {\n\n  StringBuilder sb = new StringBuilder();  // 규칙 위반\n  sb.append(\"Got: \");\n  for (String str : strings) {\n    sb.append(str).append(\", \");\n    // ...\n  }\n}\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre>\npublic void doSomething(List&lt;String&gt; strings) {\n\n  for (String str : strings) {\n    // ...\n  }\n}\n</pre>\n<p>또는</p>\n<pre>\npublic void doSomething(List&lt;String&gt; strings) {\n\n  StringBuilder sb = new StringBuilder();\n  sb.append(\"Got: \");\n  for (String str : strings) {\n    sb.append(str).append(\", \");\n    // ...\n  }\n\n  LOGGER.info(sb.toString);\n}\n</pre>\n<h3>예외</h3>\n<p>이 규칙은 메서드 인수로 전달되는 <code>StringBuffer</code> 및 <code>StringBuilder</code>는 무시합니다. 해당 위치에서 <code>toString</code>될 가능성이 높기 때문입니다.</p>",
    "howToFix_ko": "",
    "moreInfo_ko": ""
  },
  {
    "id": "S2222",
    "key": "java:S2222",
    "name": "Locks should be released on all paths",
    "type": "bug",
    "severity": "critical",
    "tags": [
      "symbolic-execution",
      "cwe",
      "multi-threading"
    ],
    "why": "<p>If a lock is acquired and released within a method, then it must be released along all execution paths of that method.</p>\n<p>Failing to do so will expose the conditional locking logic to the method's callers and hence be deadlock-prone.</p>\n<h3>Noncompliant code example</h3>\n<pre>\npublic class MyClass {\n  public void doSomething() {\n    Lock lock = new Lock();\n    lock.lock(); // Noncompliant\n    if (isInitialized()) {\n      // ...\n      lock.unlock();\n    }\n  }\n}\n</pre>\n<h3>Compliant solution</h3>\n<pre>\npublic class MyClass {\n  public void doSomething() {\n    Lock lock = new Lock();\n    if (isInitialized()) {\n      lock.lock();\n      // ...\n      lock.unlock();\n    }\n  }\n}\n</pre>",
    "howToFix": "",
    "moreInfo": "<ul>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/459\">CWE-459 - Incomplete Cleanup</a> </li>\n</ul>",
    "status": "READY",
    "name_ko": "Lock은 모든 경로에서 해제되어야 합니다",
    "why_ko": "<p>메서드 내에서 lock이 획득되고 해제된다면, 해당 메서드의 모든 실행 경로에서 해제되어야 합니다.</p>\n<p>그렇게 하지 않으면 조건부 잠금 로직이 메서드 호출자에게 노출되어 데드락이 발생하기 쉬워집니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\npublic class MyClass {\n  public void doSomething() {\n    Lock lock = new Lock();\n    lock.lock(); // 규칙 위반\n    if (isInitialized()) {\n      // ...\n      lock.unlock();\n    }\n  }\n}\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre>\npublic class MyClass {\n  public void doSomething() {\n    Lock lock = new Lock();\n    if (isInitialized()) {\n      lock.lock();\n      // ...\n      lock.unlock();\n    }\n  }\n}\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": "<ul>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/459\">CWE-459 - 불완전한 정리</a> </li>\n</ul>"
  },
  {
    "id": "S2388",
    "key": "java:S2388",
    "name": "Inner class calls to super class methods should be unambiguous",
    "type": "code-smell",
    "severity": "major",
    "tags": [
      "pitfall"
    ],
    "why": "<p>An inner class that extends another type can call methods from both the outer class and parent type directly, without prepending\n<code>super.</code> or <code>Outer.this.</code>.</p>\n<p>When both the outer and parent classes contain a method with the same name, the compiler will resolve an unqualified call to the parent type's\nimplementation. The maintainer or a future reader may confuse the method call as calling the outer class's implementation, even though it really calls\nthe super type's.</p>\n<p>To make matters worse, the maintainer sees the outer class's implementation in the same file as the call in the inner class, while the parent type\nis often declared in another file. The maintainer may not even be aware of the ambiguity present, as they do not see the parent's implementation.</p>",
    "howToFix": "<p>Explicitly call the super type's method by prepending <code>super.</code> to the method call. If the intention was to call the outer class's\nimplementation, prepend <code>Outer.this.</code> instead.</p>\n\n<h4>Noncompliant code example</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\npublic class Parent {\n  public void foo() { ... }\n}\n\npublic class Outer {\n  public void foo() { ... }\n\n  public class Inner extends Parent {\n    public void doSomething() {\n      foo();  // Noncompliant, it is not explicit if Outer#foo or Parent#foo is the intended implementation to be called.\n      // ...\n    }\n  }\n}\n</pre>\n<h4>Compliant solution</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\npublic class Parent {\n  public void foo() { ... }\n}\n\npublic class Outer {\n  public void foo() { ... }\n\n  public class Inner extends Parent {\n    public void doSomething() {\n      super.foo(); // Compliant, it is explicit that Parent#foo is the desired implementation to be called.\n      // ...\n    }\n  }\n}\n</pre>",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "내부 클래스에서 상위 클래스 메서드 호출은 명확해야 합니다",
    "why_ko": "<p>다른 타입을 확장하는 내부 클래스는 <code>super.</code> 또는 <code>Outer.this.</code>를 붙이지 않고 외부 클래스와 부모 타입의 메서드를 직접 호출할 수 있습니다.</p>\n<p>외부 클래스와 부모 클래스 모두 같은 이름의 메서드를 포함하는 경우 컴파일러는 한정되지 않은 호출을 부모 타입의 구현으로 해석합니다. 유지보수자나 미래의 독자는 실제로는 상위 타입의 메서드를 호출함에도 불구하고 외부 클래스의 구현을 호출하는 것으로 혼동할 수 있습니다.</p>\n<p>더 나쁜 것은 유지보수자가 내부 클래스의 호출과 같은 파일에서 외부 클래스의 구현을 보는 반면, 부모 타입은 종종 다른 파일에 선언되어 있다는 것입니다. 유지보수자는 부모의 구현을 보지 못하기 때문에 존재하는 모호성을 인식하지 못할 수도 있습니다.</p>",
    "howToFix_ko": "<p>메서드 호출에 <code>super.</code>를 붙여 상위 타입의 메서드를 명시적으로 호출하세요. 외부 클래스의 구현을 호출하려는 의도였다면 대신 <code>Outer.this.</code>를 붙이세요.</p>\n\n<h4>규칙을 준수하지 않는 코드 예시</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\npublic class Parent {\n  public void foo() { ... }\n}\n\npublic class Outer {\n  public void foo() { ... }\n\n  public class Inner extends Parent {\n    public void doSomething() {\n      foo();  // 규칙 위반, Outer#foo 또는 Parent#foo 중 어느 구현을 호출하려는 것인지 명확하지 않음\n      // ...\n    }\n  }\n}\n</pre>\n<h4>규칙을 준수하는 해결책</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\npublic class Parent {\n  public void foo() { ... }\n}\n\npublic class Outer {\n  public void foo() { ... }\n\n  public class Inner extends Parent {\n    public void doSomething() {\n      super.foo(); // 규칙 준수, Parent#foo가 호출하려는 구현임이 명확함\n      // ...\n    }\n  }\n}\n</pre>",
    "moreInfo_ko": ""
  },
  {
    "id": "S2737",
    "key": "java:S2737",
    "name": "\"catch\" clauses should do more than rethrow",
    "type": "code-smell",
    "severity": "minor",
    "tags": [
      "error-handling",
      "unused",
      "finding",
      "clumsy"
    ],
    "why": "<p>A <code>catch</code> clause that only rethrows the caught exception has the same effect as omitting the <code>catch</code> altogether and letting\nit bubble up automatically.</p>\n<pre>\npublic String readFile(File f) throws IOException {\n  String content;\n  try {\n    content = readFromDisk(f);\n  } catch (IOException e) {\n    throw e;\n  }\n  return content;\n}\n</pre>\n<p>Such clauses should either be removed or populated with the appropriate logic.</p>\n<pre>\npublic String readFile(File f) throws IOException {\n  return readFromDisk(f);\n}\n</pre>\n<p>or</p>\n<pre>\npublic String readFile(File f) throws IOException {\n  String content;\n  try {\n    content = readFromDisk(f);\n  } catch (IOException e) {\n    logger.LogError(e);\n    throw e;\n  }\n  return content;\n}\n</pre>\n<p>In the case of try-with-resources, the try should remain even without a catch clause, to keep the resource management</p>\n<pre>\nString readFirstLine(FileReader fileReader) throws IOException {\n  try (BufferedReader br = new BufferedReader(fileReader)) {\n     return br.readLine();\n  } catch (IOException e) { // Noncompliant\n  throw e;\n}\n</pre>\n<p>becomes</p>\n<pre>\nString readFirstLine(FileReader fileReader) throws IOException {\n  try (BufferedReader br = new BufferedReader(fileReader)) {\n     return br.readLine();\n  }\n}\n</pre>",
    "howToFix": "",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "catch 절은 단순히 다시 던지는 것 이상을 수행해야 합니다",
    "why_ko": "<p>잡은 예외를 다시 던지기만 하는 <code>catch</code> 절은 <code>catch</code>를 완전히 생략하고 자동으로 버블업되도록 하는 것과 동일한 효과를 가집니다.</p>\n<pre>\npublic String readFile(File f) throws IOException {\n  String content;\n  try {\n    content = readFromDisk(f);\n  } catch (IOException e) {\n    throw e;\n  }\n  return content;\n}\n</pre>\n<p>이러한 절은 제거하거나 적절한 로직으로 채워야 합니다.</p>\n<pre>\npublic String readFile(File f) throws IOException {\n  return readFromDisk(f);\n}\n</pre>\n<p>또는</p>\n<pre>\npublic String readFile(File f) throws IOException {\n  String content;\n  try {\n    content = readFromDisk(f);\n  } catch (IOException e) {\n    logger.LogError(e);\n    throw e;\n  }\n  return content;\n}\n</pre>\n<p>try-with-resources의 경우, 리소스 관리를 유지하기 위해 catch 절이 없어도 try는 유지되어야 합니다</p>\n<pre>\nString readFirstLine(FileReader fileReader) throws IOException {\n  try (BufferedReader br = new BufferedReader(fileReader)) {\n     return br.readLine();\n  } catch (IOException e) { // 규칙 위반\n  throw e;\n}\n</pre>\n<p>다음과 같이 변경합니다</p>\n<pre>\nString readFirstLine(FileReader fileReader) throws IOException {\n  try (BufferedReader br = new BufferedReader(fileReader)) {\n     return br.readLine();\n  }\n}\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": ""
  },
  {
    "id": "S4925",
    "key": "java:S4925",
    "name": "\"Class.forName()\" should not load JDBC 4.0+ drivers",
    "type": "code-smell",
    "severity": "major",
    "tags": [
      "obsolete"
    ],
    "why": "<p>In the past, it was required to load a JDBC driver before creating a <code>java.sql.Connection</code>. Nowadays, when using JDBC 4.0 drivers, this\nis no longer required and <code>Class.forName()</code> can be safely removed because JDBC 4.0 (JDK 6) drivers available in the classpath are\nautomatically loaded.</p>\n<p>This rule raises an issue when <code>Class.forName()</code> is used with one of the following values:</p>\n<ul>\n  <li> <code>com.mysql.jdbc.Driver</code> </li>\n  <li> <code>oracle.jdbc.driver.OracleDriver</code> </li>\n  <li> <code>com.ibm.db2.jdbc.app.DB2Driver</code> </li>\n  <li> <code>com.ibm.db2.jdbc.net.DB2Driver</code> </li>\n  <li> <code>com.sybase.jdbc.SybDriver</code> </li>\n  <li> <code>com.sybase.jdbc2.jdbc.SybDriver</code> </li>\n  <li> <code>com.teradata.jdbc.TeraDriver</code> </li>\n  <li> <code>com.microsoft.sqlserver.jdbc.SQLServerDriver</code> </li>\n  <li> <code>org.postgresql.Driver</code> </li>\n  <li> <code>sun.jdbc.odbc.JdbcOdbcDriver</code> </li>\n  <li> <code>org.hsqldb.jdbc.JDBCDriver</code> </li>\n  <li> <code>org.h2.Driver</code> </li>\n  <li> <code>org.firebirdsql.jdbc.FBDriver</code> </li>\n  <li> <code>net.sourceforge.jtds.jdbc.Driver</code> </li>\n  <li> <code>com.ibm.db2.jcc.DB2Driver</code> </li>\n</ul>\n<h3>Noncompliant code example</h3>\n<pre>\nimport java.sql.Connection;\nimport java.sql.DriverManager;\nimport java.sql.SQLException;\n\npublic class Demo {\n  private static final String DRIVER_CLASS_NAME = \"org.postgresql.Driver\";\n  private final Connection connection;\n\n  public Demo(String serverURI) throws SQLException, ClassNotFoundException {\n    Class.forName(DRIVER_CLASS_NAME); // Noncompliant; no longer required to load the JDBC Driver using Class.forName()\n    connection = DriverManager.getConnection(serverURI);\n  }\n}\n</pre>\n<h3>Compliant solution</h3>\n<pre>\nimport java.sql.Connection;\nimport java.sql.DriverManager;\nimport java.sql.SQLException;\n\npublic class Demo {\n    private final Connection connection;\n\n    public Demo(String serverURI) throws SQLException {\n        connection = DriverManager.getConnection(serverURI);\n    }\n}\n</pre>",
    "howToFix": "",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "Class.forName()으로 JDBC 4.0+ 드라이버를 로드하면 안 됩니다",
    "why_ko": "<p>과거에는 <code>java.sql.Connection</code>을 생성하기 전에 JDBC 드라이버를 로드해야 했습니다. 요즘에는 JDBC 4.0 드라이버를 사용할 때 이것이 더 이상 필요하지 않으며 클래스패스에서 사용 가능한 JDBC 4.0(JDK 6) 드라이버가 자동으로 로드되므로 <code>Class.forName()</code>을 안전하게 제거할 수 있습니다.</p>\n<p>이 규칙은 <code>Class.forName()</code>이 다음 값 중 하나와 함께 사용될 때 문제를 제기합니다:</p>\n<ul>\n  <li> <code>com.mysql.jdbc.Driver</code> </li>\n  <li> <code>oracle.jdbc.driver.OracleDriver</code> </li>\n  <li> <code>com.ibm.db2.jdbc.app.DB2Driver</code> </li>\n  <li> <code>com.ibm.db2.jdbc.net.DB2Driver</code> </li>\n  <li> <code>com.sybase.jdbc.SybDriver</code> </li>\n  <li> <code>com.sybase.jdbc2.jdbc.SybDriver</code> </li>\n  <li> <code>com.teradata.jdbc.TeraDriver</code> </li>\n  <li> <code>com.microsoft.sqlserver.jdbc.SQLServerDriver</code> </li>\n  <li> <code>org.postgresql.Driver</code> </li>\n  <li> <code>sun.jdbc.odbc.JdbcOdbcDriver</code> </li>\n  <li> <code>org.hsqldb.jdbc.JDBCDriver</code> </li>\n  <li> <code>org.h2.Driver</code> </li>\n  <li> <code>org.firebirdsql.jdbc.FBDriver</code> </li>\n  <li> <code>net.sourceforge.jtds.jdbc.Driver</code> </li>\n  <li> <code>com.ibm.db2.jcc.DB2Driver</code> </li>\n</ul>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\nimport java.sql.Connection;\nimport java.sql.DriverManager;\nimport java.sql.SQLException;\n\npublic class Demo {\n  private static final String DRIVER_CLASS_NAME = \"org.postgresql.Driver\";\n  private final Connection connection;\n\n  public Demo(String serverURI) throws SQLException, ClassNotFoundException {\n    Class.forName(DRIVER_CLASS_NAME); // 규칙 위반; Class.forName()을 사용하여 JDBC 드라이버를 로드할 필요가 없음\n    connection = DriverManager.getConnection(serverURI);\n  }\n}\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre>\nimport java.sql.Connection;\nimport java.sql.DriverManager;\nimport java.sql.SQLException;\n\npublic class Demo {\n    private final Connection connection;\n\n    public Demo(String serverURI) throws SQLException {\n        connection = DriverManager.getConnection(serverURI);\n    }\n}\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": ""
  },
  {
    "id": "S5322",
    "key": "java:S5322",
    "name": "Receiving intents is security-sensitive",
    "type": "security-hotspot",
    "severity": "critical",
    "tags": [
      "cwe",
      "android"
    ],
    "why": "<p>Android applications can receive broadcasts from the system or other applications. Receiving intents is security-sensitive. For example, it has led\nin the past to the following vulnerabilities:</p>\n<ul>\n  <li> <a href=\"https://www.cve.org/CVERecord?id=CVE-2019-1677\">CVE-2019-1677</a> </li>\n  <li> <a href=\"https://www.cve.org/CVERecord?id=CVE-2015-1275\">CVE-2015-1275</a> </li>\n</ul>\n<p>Receivers can be declared in the manifest or in the code to make them context-specific. If the receiver is declared in the manifest Android will\nstart the application if it is not already running once a matching broadcast is received. The receiver is an entry point into the application.</p>\n<p>Other applications can send potentially malicious broadcasts, so it is important to consider broadcasts as untrusted and to limit the applications\nthat can send broadcasts to the receiver.</p>\n<p>Permissions can be specified to restrict broadcasts to authorized applications. Restrictions can be enforced by both the sender and receiver of a\nbroadcast. If permissions are specified when registering a broadcast receiver, then only broadcasters who were granted this permission can send a\nmessage to the receiver.</p>\n<p>This rule raises an issue when a receiver is registered without specifying any broadcast permission.</p>\n",
    "howToFix": "<h2>Recommended Secure Coding Practices</h2>\n<p>Restrict the access to broadcasted intents. See the <a\nhref=\"https://developer.android.com/guide/components/broadcasts.html#restricting_broadcasts_with_permissions\">Android documentation</a> for more\ninformation.</p>\n<h2>Compliant Solution</h2>\n<pre>\nimport android.content.BroadcastReceiver;\nimport android.content.Context;\nimport android.content.IntentFilter;\nimport android.os.Build;\nimport android.os.Handler;\nimport android.support.annotation.RequiresApi;\n\npublic class MyIntentReceiver {\n\n    @RequiresApi(api = Build.VERSION_CODES.O)\n    public void register(Context context, BroadcastReceiver receiver,\n                         IntentFilter filter,\n                         String broadcastPermission,\n                         Handler scheduler,\n                         int flags) {\n\n        context.registerReceiver(receiver, filter, broadcastPermission, scheduler);\n        context.registerReceiver(receiver, filter, broadcastPermission, scheduler, flags);\n    }\n}\n</pre>\n<h2>See</h2>\n<ul>\n  <li> OWASP - <a href=\"https://mas.owasp.org/checklists/MASVS-PLATFORM/\">Mobile AppSec Verification Standard - Platform Interaction Requirements</a>\n  </li>\n  <li> OWASP - <a href=\"https://owasp.org/www-project-mobile-top-10/2016-risks/m1-improper-platform-usage\">Mobile Top 10 2016 Category M1 - Improper\n  Platform Usage</a> </li>\n  <li> OWASP - <a href=\"https://owasp.org/www-project-mobile-top-10/2023-risks/m3-insecure-authentication-authorization\">Mobile Top 10 2024 Category\n  M3 - Insecure Authentication/Authorization</a> </li>\n  <li> OWASP - <a href=\"https://owasp.org/www-project-mobile-top-10/2023-risks/m4-insufficient-input-output-validation\">Mobile Top 10 2024 Category M4\n  - Insufficient Input/Output Validation</a> </li>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/925\">CWE-925 - Improper Verification of Intent by Broadcast Receiver</a> </li>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/926\">CWE-926 - Improper Export of Android Application Components</a> </li>\n  <li> <a href=\"https://developer.android.com/guide/components/broadcasts.html#restricting_broadcasts_with_permissions\">Android documentation</a> -\n  Broadcast Overview - Security considerations and best practices </li>\n</ul>",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "Intent 수신은 보안에 민감합니다",
    "why_ko": "<p>Android 애플리케이션은 시스템이나 다른 애플리케이션으로부터 브로드캐스트를 수신할 수 있습니다. Intent 수신은 보안에 민감합니다. 예를 들어, 이는 과거에 다음과 같은 취약점으로 이어졌습니다:</p>\n<ul>\n  <li> <a href=\"https://www.cve.org/CVERecord?id=CVE-2019-1677\">CVE-2019-1677</a> </li>\n  <li> <a href=\"https://www.cve.org/CVERecord?id=CVE-2015-1275\">CVE-2015-1275</a> </li>\n</ul>\n<p>수신자는 매니페스트나 코드에서 선언하여 컨텍스트별로 만들 수 있습니다. 수신자가 매니페스트에 선언되면 일치하는 브로드캐스트가 수신되면 아직 실행 중이 아닌 경우 Android가 애플리케이션을 시작합니다. 수신자는 애플리케이션의 진입점입니다.</p>\n<p>다른 애플리케이션이 잠재적으로 악의적인 브로드캐스트를 보낼 수 있으므로 브로드캐스트를 신뢰할 수 없는 것으로 간주하고 수신자에게 브로드캐스트를 보낼 수 있는 애플리케이션을 제한하는 것이 중요합니다.</p>\n<p>권한을 지정하여 브로드캐스트를 인가된 애플리케이션으로 제한할 수 있습니다. 제한은 브로드캐스트의 발신자와 수신자 모두에 의해 시행될 수 있습니다. 브로드캐스트 수신자를 등록할 때 권한이 지정되면 이 권한이 부여된 브로드캐스터만 수신자에게 메시지를 보낼 수 있습니다.</p>\n<p>이 규칙은 브로드캐스트 권한을 지정하지 않고 수신자가 등록될 때 문제를 제기합니다.</p>\n",
    "howToFix_ko": "<h2>권장 보안 코딩 방법</h2>\n<p>브로드캐스트된 Intent에 대한 접근을 제한하세요. 자세한 내용은 <a href=\"https://developer.android.com/guide/components/broadcasts.html#restricting_broadcasts_with_permissions\">Android 문서</a>를 참조하세요.</p>\n<h2>규칙을 준수하는 해결책</h2>\n<pre>\nimport android.content.BroadcastReceiver;\nimport android.content.Context;\nimport android.content.IntentFilter;\nimport android.os.Build;\nimport android.os.Handler;\nimport android.support.annotation.RequiresApi;\n\npublic class MyIntentReceiver {\n\n    @RequiresApi(api = Build.VERSION_CODES.O)\n    public void register(Context context, BroadcastReceiver receiver,\n                         IntentFilter filter,\n                         String broadcastPermission,\n                         Handler scheduler,\n                         int flags) {\n\n        context.registerReceiver(receiver, filter, broadcastPermission, scheduler);\n        context.registerReceiver(receiver, filter, broadcastPermission, scheduler, flags);\n    }\n}\n</pre>\n<h2>참고</h2>\n<ul>\n  <li> OWASP - <a href=\"https://mas.owasp.org/checklists/MASVS-PLATFORM/\">모바일 AppSec 검증 표준 - 플랫폼 상호작용 요구 사항</a> </li>\n  <li> OWASP - <a href=\"https://owasp.org/www-project-mobile-top-10/2016-risks/m1-improper-platform-usage\">모바일 상위 10가지 2016 카테고리 M1 - 부적절한 플랫폼 사용</a> </li>\n  <li> OWASP - <a href=\"https://owasp.org/www-project-mobile-top-10/2023-risks/m3-insecure-authentication-authorization\">모바일 상위 10가지 2024 카테고리 M3 - 안전하지 않은 인증/권한 부여</a> </li>\n  <li> OWASP - <a href=\"https://owasp.org/www-project-mobile-top-10/2023-risks/m4-insufficient-input-output-validation\">모바일 상위 10가지 2024 카테고리 M4 - 불충분한 입력/출력 검증</a> </li>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/925\">CWE-925 - 브로드캐스트 수신자의 부적절한 Intent 검증</a> </li>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/926\">CWE-926 - Android 애플리케이션 구성 요소의 부적절한 내보내기</a> </li>\n  <li> <a href=\"https://developer.android.com/guide/components/broadcasts.html#restricting_broadcasts_with_permissions\">Android 문서</a> - 브로드캐스트 개요 - 보안 고려 사항 및 모범 사례 </li>\n</ul>",
    "moreInfo_ko": ""
  },
  {
    "id": "S7466",
    "key": "java:S7466",
    "name": "Unnamed variable declarations should use the \"var\" identifier",
    "type": "code-smell",
    "severity": "minor",
    "tags": [
      "java22"
    ],
    "why": "<p>The syntax of some Java constructs, such as enhanced for loops, requires that you declare a variable that you may have no use for. To solve this\nissue, Java 22 introduced an unnamed variable pattern, <code>_</code>. This feature removes the need to name variables that are syntactically required\nbut otherwise unused. Moreover, it clearly indicates the intent not to use the variable.</p>\n<p>To further minimize clutter, unnamed variables should use the <code>var</code> pattern rather than explicit type declarations. In addition to\nminimizing clutter, removing the type makes the code easier to maintain. Indeed, if the type was to change in future, the code would remain the\nsame.</p>\n<h3>Exceptions</h3>\n<p>This rule does not apply to basic <code>for</code> loops and local variable declarations in a block.</p>",
    "howToFix": "<p>Replace the local variable type with <code>var</code>.</p>\n\n<h4>Noncompliant code example</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\nfor (String _ : myIterable) { // Noncompliant\n  // ...\n}\n\n\ntry (Resource _ = new Resource()) { // Noncompliant\n  // ...\n}\n</pre>\n<h4>Compliant solution</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\nfor (var _ : myIterable) {\n  // ....\n}\n\ntry (var _ = new Resource()) {\n  // ...\n}\n</pre>",
    "moreInfo": "<h3>Documentation</h3>\n<ul>\n  <li> OpenJDK - <a href=\"https://openjdk.org/jeps/456\">JEP 456: Unnamed Variables &amp; Patterns</a> </li>\n</ul>",
    "status": "READY",
    "name_ko": "이름 없는 변수 선언은 \"var\" 식별자를 사용해야 합니다",
    "why_ko": "<p>향상된 for 루프와 같은 일부 Java 구문의 문법은 사용하지 않을 수도 있는 변수를 선언해야 합니다. 이 문제를 해결하기 위해 Java 22에서는 이름 없는 변수 패턴 <code>_</code>를 도입했습니다. 이 기능은 문법적으로 필요하지만 그 외에는 사용되지 않는 변수의 이름을 지정할 필요를 없앱니다. 또한 변수를 사용하지 않겠다는 의도를 명확하게 나타냅니다.</p>\n<p>혼란을 더 최소화하려면 이름 없는 변수는 명시적 타입 선언 대신 <code>var</code> 패턴을 사용해야 합니다. 혼란을 최소화하는 것 외에도 타입을 제거하면 코드를 더 쉽게 유지 관리할 수 있습니다. 실제로 타입이 향후 변경되더라도 코드는 동일하게 유지됩니다.</p>\n<h3>예외</h3>\n<p>이 규칙은 기본 <code>for</code> 루프와 블록 내의 지역 변수 선언에는 적용되지 않습니다.</p>",
    "howToFix_ko": "<p>지역 변수 타입을 <code>var</code>로 교체하세요.</p>\n\n<h4>규칙을 준수하지 않는 코드 예시</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\nfor (String _ : myIterable) { // 규칙 위반\n  // ...\n}\n\n\ntry (Resource _ = new Resource()) { // 규칙 위반\n  // ...\n}\n</pre>\n<h4>규칙을 준수하는 해결책</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\nfor (var _ : myIterable) {\n  // ....\n}\n\ntry (var _ = new Resource()) {\n  // ...\n}\n</pre>",
    "moreInfo_ko": "<h3>문서</h3>\n<ul>\n  <li> OpenJDK - <a href=\"https://openjdk.org/jeps/456\">JEP 456: 이름 없는 변수 및 패턴</a> </li>\n</ul>"
  },
  {
    "id": "S2234",
    "key": "java:S2234",
    "name": "Parameters should be passed in the correct order",
    "type": "code-smell",
    "severity": "major",
    "tags": [],
    "why": "<p>When the names of parameters in a method call match the names of the method arguments, it contributes to clearer, more readable code. However, when\nthe names match, but are passed in a different order than the method arguments, it indicates a mistake in the parameter order which will likely lead\nto unexpected results.</p>\n<h3>Noncompliant code example</h3>\n<pre>\npublic double divide(int divisor, int dividend) {\n  return divisor/dividend;\n}\n\npublic void doTheThing() {\n  int divisor = 15;\n  int dividend = 5;\n\n  double result = divide(dividend, divisor);  // Noncompliant; operation succeeds, but result is unexpected\n  //...\n}\n</pre>\n<h3>Compliant solution</h3>\n<pre>\npublic double divide(int divisor, int dividend) {\n  return divisor/dividend;\n}\n\npublic void doTheThing() {\n  int divisor = 15;\n  int dividend = 5;\n\n  double result = divide(divisor, dividend);\n  //...\n}\n</pre>",
    "howToFix": "",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "매개변수는 올바른 순서로 전달해야 합니다",
    "why_ko": "<p>메서드 호출에서 매개변수 이름이 메서드 인수 이름과 일치하면 더 명확하고 읽기 쉬운 코드에 기여합니다. 그러나 이름이 일치하지만 메서드 인수와 다른 순서로 전달되면 매개변수 순서에 실수가 있음을 나타내며 이로 인해 예상치 못한 결과가 발생할 가능성이 높습니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\npublic double divide(int divisor, int dividend) {\n  return divisor/dividend;\n}\n\npublic void doTheThing() {\n  int divisor = 15;\n  int dividend = 5;\n\n  double result = divide(dividend, divisor);  // 규칙 위반; 연산은 성공하지만 결과가 예상과 다름\n  //...\n}\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre>\npublic double divide(int divisor, int dividend) {\n  return divisor/dividend;\n}\n\npublic void doTheThing() {\n  int divisor = 15;\n  int dividend = 5;\n\n  double result = divide(divisor, dividend);\n  //...\n}\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": ""
  },
  {
    "id": "S2326",
    "key": "java:S2326",
    "name": "Unused type parameters should be removed",
    "type": "code-smell",
    "severity": "major",
    "tags": [
      "unused"
    ],
    "why": "<p>Type parameters that aren't used are dead code, which can only distract and possibly confuse developers during maintenance. Therefore, unused type\nparameters should be removed.</p>\n<h3>Noncompliant code example</h3>\n<pre>\nint &lt;T&gt; Add(int a, int b) // Noncompliant; &lt;T&gt; is ignored\n{\n  return a + b;\n}\n</pre>\n<h3>Compliant solution</h3>\n<pre>\nint Add(int a, int b)\n{\n  return a + b;\n}\n</pre>",
    "howToFix": "",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "사용하지 않는 타입 매개변수는 제거해야 합니다",
    "why_ko": "<p>사용되지 않는 타입 매개변수는 죽은 코드로, 유지보수 중에 개발자의 주의를 분산시키고 혼란을 줄 수 있습니다. 따라서 사용하지 않는 타입 매개변수는 제거해야 합니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\nint &lt;T&gt; Add(int a, int b) // 규칙 위반; &lt;T&gt;가 무시됨\n{\n  return a + b;\n}\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre>\nint Add(int a, int b)\n{\n  return a + b;\n}\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": ""
  },
  {
    "id": "S3864",
    "key": "java:S3864",
    "name": "\"Stream.peek\" should be used with caution",
    "type": "code-smell",
    "severity": "major",
    "tags": [
      "java8",
      "pitfall"
    ],
    "why": "<p>According to its JavaDocs, the intermediate Stream operation <code>java.util.Stream.peek()</code> \"exists mainly to support debugging\"\npurposes.</p>\n<p>A key difference with other intermediate Stream operations is that the Stream implementation is free to skip calls to <code>peek()</code> for\noptimization purpose. This can lead to <code>peek()</code> being unexpectedly called only for some or none of the elements in the Stream.</p>\n<p>As a consequence, relying on <code>peek()</code> without careful consideration can lead to error-prone code.</p>\n<p>This rule raises an issue for each use of peek() to be sure that it is challenged and validated by the team to be meant for production\ndebugging/logging purposes.</p>\n<h3>Noncompliant code example</h3>\n<pre>\nStream.of(\"one\", \"two\", \"three\", \"four\")\n         .filter(e -&gt; e.length() &gt; 3)\n         .peek(e -&gt; System.out.println(\"Filtered value: \" + e)); // Noncompliant\n</pre>\n<h3>Compliant solution</h3>\n<pre>\nStream.of(\"one\", \"two\", \"three\", \"four\")\n         .filter(e -&gt; e.length() &gt; 3)\n         .foreach(e -&gt; System.out.println(\"Filtered value: \" + e));\n</pre>",
    "howToFix": "",
    "moreInfo": "<ul>\n  <li> <a href=\"https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html#peek-java.util.function.Consumer-\">Java 8 API Documentation</a>\n  </li>\n  <li> 4comprehension: <a href=\"https://4comprehension.com/idiomatic-peeking/\">Idiomatic Peeking with Java Stream API</a> </li>\n  <li> Data Geekery: <a href=\"https://blog.jooq.org/2014/06/13/java-8-friday-10-subtle-mistakes-when-using-the-streams-api/\">10 Subtle Mistakes When\n  Using the Streams API</a> </li>\n</ul>",
    "status": "READY",
    "name_ko": "\"Stream.peek\"은 주의해서 사용해야 합니다",
    "why_ko": "<p>JavaDocs에 따르면, 중간 Stream 연산 <code>java.util.Stream.peek()</code>은 \"주로 디버깅 목적을 지원하기 위해 존재합니다\".</p>\n<p>다른 중간 Stream 연산과의 주요 차이점은 Stream 구현이 최적화 목적으로 <code>peek()</code> 호출을 자유롭게 건너뛸 수 있다는 것입니다. 이로 인해 <code>peek()</code>이 Stream의 일부 또는 전혀 없는 요소에 대해서만 예기치 않게 호출될 수 있습니다.</p>\n<p>결과적으로, 신중한 고려 없이 <code>peek()</code>에 의존하면 오류가 발생하기 쉬운 코드가 될 수 있습니다.</p>\n<p>이 규칙은 peek()의 각 사용에 대해 문제를 제기하여 프로덕션 디버깅/로깅 목적인지 팀이 도전하고 검증할 수 있도록 합니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\nStream.of(\"one\", \"two\", \"three\", \"four\")\n         .filter(e -&gt; e.length() &gt; 3)\n         .peek(e -&gt; System.out.println(\"Filtered value: \" + e)); // 규칙 위반\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre>\nStream.of(\"one\", \"two\", \"three\", \"four\")\n         .filter(e -&gt; e.length() &gt; 3)\n         .foreach(e -&gt; System.out.println(\"Filtered value: \" + e));\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": "<ul>\n  <li> <a href=\"https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html#peek-java.util.function.Consumer-\">Java 8 API 문서</a> </li>\n  <li> 4comprehension: <a href=\"https://4comprehension.com/idiomatic-peeking/\">Java Stream API로 관용적인 Peeking</a> </li>\n  <li> Data Geekery: <a href=\"https://blog.jooq.org/2014/06/13/java-8-friday-10-subtle-mistakes-when-using-the-streams-api/\">Streams API 사용 시 10가지 미묘한 실수</a> </li>\n</ul>"
  },
  {
    "id": "S2131",
    "key": "java:S2131",
    "name": "Primitives should not be boxed just for \"String\" conversion",
    "type": "code-smell",
    "severity": "major",
    "tags": [],
    "why": "<p>\"Boxing\" is the process of putting a primitive value into a primitive-wrapper object. When that's done purely to use the wrapper class'\n<code>toString</code> method, it's a waste of memory and cycles because those methods are <code>static</code>, and can therefore be used without a\nclass instance. Similarly, using the <code>static</code> method <code>valueOf</code> in the primitive-wrapper classes with a non-<code>String</code>\nargument should be avoided.</p>\n<h3>Noncompliant code example</h3>\n<pre>\nint myInt = 4;\nString myIntString = (new Integer(myInt)).toString(); // Noncompliant; creates &amp; discards an Integer object\nmyIntString = Integer.valueOf(myInt).toString(); // Noncompliant\n</pre>\n<h3>Compliant solution</h3>\n<pre>\nint myInt = 4;\nString myIntString = Integer.toString(myInt);\n</pre>",
    "howToFix": "",
    "moreInfo": "",
    "status": "DEPRECATED",
    "name_ko": "String 변환만을 위해 primitive를 박싱하면 안 됩니다",
    "why_ko": "<p>\"박싱\"은 primitive 값을 primitive-wrapper 객체에 넣는 과정입니다. 래퍼 클래스의 <code>toString</code> 메서드를 사용하기 위해서만 이 작업을 수행하면 그러한 메서드가 <code>static</code>이고 클래스 인스턴스 없이 사용할 수 있기 때문에 메모리와 사이클의 낭비입니다. 마찬가지로 primitive-wrapper 클래스에서 <code>String</code>이 아닌 인수로 <code>static</code> 메서드 <code>valueOf</code>를 사용하는 것도 피해야 합니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\nint myInt = 4;\nString myIntString = (new Integer(myInt)).toString(); // 규칙 위반; Integer 객체를 생성하고 버림\nmyIntString = Integer.valueOf(myInt).toString(); // 규칙 위반\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre>\nint myInt = 4;\nString myIntString = Integer.toString(myInt);\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": ""
  },
  {
    "id": "S1121",
    "key": "java:S1121",
    "name": "Assignments should not be made from within sub-expressions",
    "type": "code-smell",
    "severity": "major",
    "tags": [
      "cwe",
      "cert",
      "suspicious"
    ],
    "why": "<p>A common code smell that can hinder the clarity of source code is making assignments within sub-expressions. This practice involves assigning a\nvalue to a variable inside a larger expression, such as within a loop or a conditional statement.</p>\n<p>This practice essentially gives a side-effect to a larger expression, thus making it less readable. This often leads to confusion and potential\nerrors.</p>\n<h3>Exceptions</h3>\n<p>This rule ignores assignments in conditions of <code>while</code> statements and assignments enclosed in relational expressions.</p>\n<pre>\nvoid processInput(BufferedReader br) {\n  String line;\n  while ((line = br.readLine()) != null) {\n    processLine(line);\n  }\n}\n\nObject foo;\nif ((foo = bar()) != null) {\n  // do something with \"foo\"\n}\n</pre>\n<p>This rule also ignores chained assignments, including compound assignments.</p>\n<pre>\nint j, i = j = 0;\nint k = (j += 1);\nbyte[] result, bresult;\nresult = (bresult = new byte[len]);\n</pre>",
    "howToFix": "<p>Making assignments within sub-expressions can hinder the clarity of source code.</p>\n<p>This practice essentially gives a side-effect to a larger expression, thus making it less readable. This often leads to confusion and potential\nerrors.</p>\n<p>Extracting assignments into separate statements is encouraged to keep the code clear and straightforward.</p>\n\n<h4>Noncompliant code example</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\nString str;\nif (!(str = cont.substring(pos1, pos2)).isEmpty()) {  // Noncompliant\n  // do something with \"str\"\n}\n</pre>\n<h4>Compliant solution</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\nString str = cont.substring(pos1, pos2);\nif (!str.isEmpty()) {\n  // do something with \"str\"\n}\n</pre>",
    "moreInfo": "<ul>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/481\">CWE-481 - Assigning instead of Comparing</a> </li>\n  <li> <a href=\"https://wiki.sei.cmu.edu/confluence/x/ITZGBQ\">CERT, EXP51-J.</a> - Do not perform assignments in conditional expressions </li>\n</ul>",
    "status": "READY",
    "name_ko": "하위 표현식 내에서 할당하면 안 됩니다",
    "why_ko": "<p>소스 코드의 명확성을 저해할 수 있는 일반적인 코드 스멜은 하위 표현식 내에서 할당하는 것입니다. 이 관행은 루프나 조건문과 같은 더 큰 표현식 내에서 변수에 값을 할당하는 것을 포함합니다.</p>\n<p>이 관행은 본질적으로 더 큰 표현식에 부수 효과를 주어 가독성을 떨어뜨립니다. 이는 종종 혼란과 잠재적인 오류로 이어집니다.</p>\n<h3>예외 사항</h3>\n<p>이 규칙은 <code>while</code> 문의 조건에서의 할당과 관계 표현식에 둘러싸인 할당을 무시합니다.</p>\n<pre>\nvoid processInput(BufferedReader br) {\n  String line;\n  while ((line = br.readLine()) != null) {\n    processLine(line);\n  }\n}\n\nObject foo;\nif ((foo = bar()) != null) {\n  // \"foo\"로 무언가 수행\n}\n</pre>\n<p>이 규칙은 복합 할당을 포함한 연쇄 할당도 무시합니다.</p>\n<pre>\nint j, i = j = 0;\nint k = (j += 1);\nbyte[] result, bresult;\nresult = (bresult = new byte[len]);\n</pre>",
    "howToFix_ko": "<p>하위 표현식 내에서 할당하면 소스 코드의 명확성을 저해할 수 있습니다.</p>\n<p>이 관행은 본질적으로 더 큰 표현식에 부수 효과를 주어 가독성을 떨어뜨립니다. 이는 종종 혼란과 잠재적인 오류로 이어집니다.</p>\n<p>코드를 명확하고 직관적으로 유지하기 위해 할당을 별도의 문으로 추출하는 것이 권장됩니다.</p>\n\n<h4>규칙을 준수하지 않는 코드 예시</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\nString str;\nif (!(str = cont.substring(pos1, pos2)).isEmpty()) {  // 규칙 위반\n  // \"str\"로 무언가 수행\n}\n</pre>\n<h4>규칙을 준수하는 해결책</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\nString str = cont.substring(pos1, pos2);\nif (!str.isEmpty()) {\n  // \"str\"로 무언가 수행\n}\n</pre>",
    "moreInfo_ko": "<ul>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/481\">CWE-481 - 비교 대신 할당</a> </li>\n  <li> <a href=\"https://wiki.sei.cmu.edu/confluence/x/ITZGBQ\">CERT, EXP51-J.</a> - 조건 표현식에서 할당을 수행하지 마세요 </li>\n</ul>"
  },
  {
    "id": "S4266",
    "key": "java:S4266",
    "name": "\"Stream.collect()\" calls should not be redundant",
    "type": "code-smell",
    "severity": "minor",
    "tags": [
      "clumsy"
    ],
    "why": "<p>When using the <code>Stream</code> API, call chains should be simplified as much as possible to improve readability and maintainability.</p>\n<p>This rule raises an issue when one of the following substitution can be made:</p>\n<table>\n  <colgroup>\n    <col style=\"width: 50%;\">\n    <col style=\"width: 50%;\">\n  </colgroup>\n  <thead>\n    <tr>\n      <th>Original</th>\n      <th>Preferred</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td><p><code>stream.collect(counting())</code></p></td>\n      <td><p><code>stream.count()</code></p></td>\n    </tr>\n    <tr>\n      <td><p><code>stream.collect(maxBy(comparator))</code></p></td>\n      <td><p><code>stream.max(comparator)</code></p></td>\n    </tr>\n    <tr>\n      <td><p><code>stream.collect(minBy(comparator))</code></p></td>\n      <td><p><code>stream.min(comparator)</code></p></td>\n    </tr>\n    <tr>\n      <td><p><code>stream.collect(mapping(mapper))</code></p></td>\n      <td><p><code>stream.map(mapper).collect()</code></p></td>\n    </tr>\n    <tr>\n      <td><p><code>stream.collect(reducing(...))</code></p></td>\n      <td><p><code>stream.reduce(...)</code></p></td>\n    </tr>\n    <tr>\n      <td><p><code>stream.collect(summingInt(mapper))</code></p></td>\n      <td><p><code>stream.mapToInt(mapper).sum()</code></p></td>\n    </tr>\n    <tr>\n      <td><p><code>stream.collect(summingLong(mapper))</code></p></td>\n      <td><p><code>stream.mapToLong(mapper).sum()</code></p></td>\n    </tr>\n    <tr>\n      <td><p><code>stream.collect(summingDouble(mapper))</code></p></td>\n      <td><p><code>stream.mapToDouble(mapper).sum()</code></p></td>\n    </tr>\n  </tbody>\n</table>\n<h3>Noncompliant code example</h3>\n<pre>\nint count = stream.collect(counting());  // Noncompliant\n</pre>\n<h3>Compliant solution</h3>\n<pre>\nint count = stream.count();\n</pre>",
    "howToFix": "",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "\"Stream.collect()\" 호출이 중복되면 안 됩니다",
    "why_ko": "<p><code>Stream</code> API를 사용할 때 가독성과 유지보수성을 향상시키기 위해 호출 체인을 가능한 한 단순화해야 합니다.</p>\n<p>이 규칙은 다음 대체 중 하나가 가능할 때 문제를 제기합니다:</p>\n<table>\n  <colgroup>\n    <col style=\"width: 50%;\">\n    <col style=\"width: 50%;\">\n  </colgroup>\n  <thead>\n    <tr>\n      <th>원본</th>\n      <th>권장</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td><p><code>stream.collect(counting())</code></p></td>\n      <td><p><code>stream.count()</code></p></td>\n    </tr>\n    <tr>\n      <td><p><code>stream.collect(maxBy(comparator))</code></p></td>\n      <td><p><code>stream.max(comparator)</code></p></td>\n    </tr>\n    <tr>\n      <td><p><code>stream.collect(minBy(comparator))</code></p></td>\n      <td><p><code>stream.min(comparator)</code></p></td>\n    </tr>\n    <tr>\n      <td><p><code>stream.collect(mapping(mapper))</code></p></td>\n      <td><p><code>stream.map(mapper).collect()</code></p></td>\n    </tr>\n    <tr>\n      <td><p><code>stream.collect(reducing(...))</code></p></td>\n      <td><p><code>stream.reduce(...)</code></p></td>\n    </tr>\n    <tr>\n      <td><p><code>stream.collect(summingInt(mapper))</code></p></td>\n      <td><p><code>stream.mapToInt(mapper).sum()</code></p></td>\n    </tr>\n    <tr>\n      <td><p><code>stream.collect(summingLong(mapper))</code></p></td>\n      <td><p><code>stream.mapToLong(mapper).sum()</code></p></td>\n    </tr>\n    <tr>\n      <td><p><code>stream.collect(summingDouble(mapper))</code></p></td>\n      <td><p><code>stream.mapToDouble(mapper).sum()</code></p></td>\n    </tr>\n  </tbody>\n</table>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\nint count = stream.collect(counting());  // 규칙 위반\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre>\nint count = stream.count();\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": ""
  },
  {
    "id": "S127",
    "key": "java:S127",
    "name": "\"for\" loop stop conditions should be invariant",
    "type": "code-smell",
    "severity": "major",
    "tags": [
      "pitfall"
    ],
    "why": "<p>A <code>for</code> loop termination condition should test the loop counter against an invariant value that does not change during the execution of\nthe loop. Invariant termination conditions make the program logic easier to understand and maintain.</p>\n<p>This rule tracks three types of non-invariant termination conditions:</p>\n<ul>\n  <li> When the loop counters are updated in the body of the <code>for</code> loop </li>\n  <li> When the termination condition depends on a method call </li>\n  <li> When the termination condition depends on an object property since such properties could change during the execution of the loop. </li>\n</ul>",
    "howToFix": "<h4>Noncompliant code example</h4>\n<p>Make the termination condition invariant by using a constant or a local variable instead of an expression that could change during the execution of\nthe loop.</p>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\nfor (int i = 0; i &lt; foo(); i++) { // Noncompliant, \"foo()\" is not an invariant\n  // ...\n}\n</pre>\n<h4>Compliant solution</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\nint end = foo();\nfor (int i = 0; i &lt; end; i++) { // Compliant, \"end\" does not change during loop execution\n  // ...\n}\n</pre>\n<h4>Noncompliant code example</h4>\n<p>If this is impossible and the counter variable must be updated in the loop's body, use a <code>while</code> or <code>do</code> <code>while</code>\nloop instead of a <code>for</code> loop.</p>\n<pre data-diff-id=\"2\" data-diff-type=\"noncompliant\">\nfor (int i = 0; i &lt; 10; i++) {\n  // ...\n  if (condition) i++; // Noncompliant, i is updated from within body\n  // ...\n}\n</pre>\n<h4>Compliant solution</h4>\n<pre data-diff-id=\"2\" data-diff-type=\"compliant\">\nint i = 0;\nwhile (i++ &lt; 10) { // Compliant\n  // ...\n  if (condition) sum++;\n  // ...\n}\n</pre>",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "\"for\" 루프 종료 조건은 불변이어야 합니다",
    "why_ko": "<p><code>for</code> 루프 종료 조건은 루프 실행 중에 변경되지 않는 불변 값에 대해 루프 카운터를 테스트해야 합니다. 불변 종료 조건은 프로그램 로직을 이해하고 유지 관리하기 쉽게 만듭니다.</p>\n<p>이 규칙은 세 가지 유형의 비불변 종료 조건을 추적합니다:</p>\n<ul>\n  <li> <code>for</code> 루프 본문에서 루프 카운터가 업데이트되는 경우 </li>\n  <li> 종료 조건이 메서드 호출에 의존하는 경우 </li>\n  <li> 종료 조건이 객체 속성에 의존하는 경우 (이러한 속성은 루프 실행 중에 변경될 수 있으므로) </li>\n</ul>",
    "howToFix_ko": "<h4>규칙을 준수하지 않는 코드 예시</h4>\n<p>루프 실행 중에 변경될 수 있는 표현식 대신 상수나 지역 변수를 사용하여 종료 조건을 불변으로 만드세요.</p>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\nfor (int i = 0; i &lt; foo(); i++) { // 규칙 위반, \"foo()\"는 불변이 아님\n  // ...\n}\n</pre>\n<h4>규칙을 준수하는 해결책</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\nint end = foo();\nfor (int i = 0; i &lt; end; i++) { // 규칙 준수, \"end\"는 루프 실행 중 변경되지 않음\n  // ...\n}\n</pre>\n<h4>규칙을 준수하지 않는 코드 예시</h4>\n<p>이것이 불가능하고 카운터 변수를 루프 본문에서 업데이트해야 하는 경우 <code>for</code> 루프 대신 <code>while</code> 또는 <code>do</code> <code>while</code> 루프를 사용하세요.</p>\n<pre data-diff-id=\"2\" data-diff-type=\"noncompliant\">\nfor (int i = 0; i &lt; 10; i++) {\n  // ...\n  if (condition) i++; // 규칙 위반, i가 본문 내에서 업데이트됨\n  // ...\n}\n</pre>\n<h4>규칙을 준수하는 해결책</h4>\n<pre data-diff-id=\"2\" data-diff-type=\"compliant\">\nint i = 0;\nwhile (i++ &lt; 10) { // 규칙 준수\n  // ...\n  if (condition) sum++;\n  // ...\n}\n</pre>",
    "moreInfo_ko": ""
  },
  {
    "id": "S2166",
    "key": "java:S2166",
    "name": "Classes named like \"Exception\" should extend \"Exception\" or a subclass",
    "type": "code-smell",
    "severity": "major",
    "tags": [
      "convention",
      "error-handling",
      "pitfall"
    ],
    "why": "<p>Clear, communicative naming is important in code. It helps maintainers and API users understand the intentions for and uses of a unit of code.\nUsing \"exception\" in the name of a class that does not extend <code>Exception</code> or one of its subclasses is a clear violation of the expectation\nthat a class' name will indicate what it is and/or does.</p>\n<h3>Noncompliant code example</h3>\n<pre>\npublic class FruitException {  // Noncompliant; this has nothing to do with Exception\n  private Fruit expected;\n  private String unusualCharacteristics;\n  private boolean appropriateForCommercialExploitation;\n  // ...\n}\n\npublic class CarException {  // Noncompliant; the extends clause was forgotten?\n  public CarException(String message, Throwable cause) {\n  // ...\n</pre>\n<h3>Compliant solution</h3>\n<pre>\npublic class FruitSport {\n  private Fruit expected;\n  private String unusualCharacteristics;\n  private boolean appropriateForCommercialExploitation;\n  // ...\n}\n\npublic class CarException extends Exception {\n  public CarException(String message, Throwable cause) {\n  // ...\n</pre>",
    "howToFix": "",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "\"Exception\"과 유사한 이름의 클래스는 \"Exception\" 또는 그 하위 클래스를 확장해야 합니다",
    "why_ko": "<p>명확하고 의미 있는 이름 지정은 코드에서 중요합니다. 유지보수자와 API 사용자가 코드 단위의 의도와 용도를 이해하는 데 도움이 됩니다. <code>Exception</code> 또는 그 하위 클래스를 확장하지 않는 클래스 이름에 \"exception\"을 사용하는 것은 클래스의 이름이 그것이 무엇인지 및/또는 무엇을 하는지를 나타낼 것이라는 기대를 명백히 위반하는 것입니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\npublic class FruitException {  // 규칙 위반; Exception과 아무 관련 없음\n  private Fruit expected;\n  private String unusualCharacteristics;\n  private boolean appropriateForCommercialExploitation;\n  // ...\n}\n\npublic class CarException {  // 규칙 위반; extends 절을 잊었나요?\n  public CarException(String message, Throwable cause) {\n  // ...\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre>\npublic class FruitSport {\n  private Fruit expected;\n  private String unusualCharacteristics;\n  private boolean appropriateForCommercialExploitation;\n  // ...\n}\n\npublic class CarException extends Exception {\n  public CarException(String message, Throwable cause) {\n  // ...\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": ""
  },
  {
    "id": "S2189",
    "key": "java:S2189",
    "name": "Loops should not be infinite",
    "type": "bug",
    "severity": "blocker",
    "tags": [
      "symbolic-execution",
      "cert"
    ],
    "why": "<p>An infinite loop will never end while the program runs, meaning you have to kill the program to get out of the loop. Every loop should have an end\ncondition, whether by meeting the loop's termination condition or via a <code>break</code> statement.</p>\n<h3>Noncompliant code example</h3>\n<pre>\nfor (;;) {  // Noncompliant; end condition omitted\n  // ...\n}\n</pre>\n<pre data-diff-id=\"2\" data-diff-type=\"noncompliant\">\nint j;\nwhile (true) { // Noncompliant; end condition omitted\n  j++;\n}\n</pre>\n<pre data-diff-id=\"3\" data-diff-type=\"noncompliant\">\nint k;\nboolean b = true;\nwhile (b) { // Noncompliant; b never written to in loop\n  k++;\n}\n</pre>\n<h3>Compliant solution</h3>\n<pre data-diff-id=\"2\" data-diff-type=\"compliant\">\nint j;\nwhile (true) { // reachable end condition added\n  j++;\n  if (j  == Integer.MIN_VALUE) {  // true at Integer.MAX_VALUE +1\n    break;\n  }\n}\n</pre>\n<pre data-diff-id=\"3\" data-diff-type=\"compliant\">\nint k;\nboolean b = true;\nwhile (b) {\n  k++;\n  b = k &lt; Integer.MAX_VALUE;\n}\n</pre>",
    "howToFix": "",
    "moreInfo": "<h3>Standards</h3>\n<ul>\n  <li> <a href=\"https://wiki.sei.cmu.edu/confluence/x/lzZGBQ\">CERT, MSC01-J.</a> - Do not use an empty infinite loop </li>\n</ul>",
    "status": "READY",
    "name_ko": "무한 루프가 있으면 안 됩니다",
    "why_ko": "<p>무한 루프는 프로그램이 실행되는 동안 절대 끝나지 않으므로 루프에서 벗어나려면 프로그램을 종료해야 합니다. 모든 루프는 루프의 종료 조건을 충족하거나 <code>break</code> 문을 통해 종료 조건을 가져야 합니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\nfor (;;) {  // 규칙 위반; 종료 조건 생략됨\n  // ...\n}\n</pre>\n<pre data-diff-id=\"2\" data-diff-type=\"noncompliant\">\nint j;\nwhile (true) { // 규칙 위반; 종료 조건 생략됨\n  j++;\n}\n</pre>\n<pre data-diff-id=\"3\" data-diff-type=\"noncompliant\">\nint k;\nboolean b = true;\nwhile (b) { // 규칙 위반; 루프에서 b가 절대 변경되지 않음\n  k++;\n}\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre data-diff-id=\"2\" data-diff-type=\"compliant\">\nint j;\nwhile (true) { // 도달 가능한 종료 조건 추가됨\n  j++;\n  if (j  == Integer.MIN_VALUE) {  // Integer.MAX_VALUE +1에서 true\n    break;\n  }\n}\n</pre>\n<pre data-diff-id=\"3\" data-diff-type=\"compliant\">\nint k;\nboolean b = true;\nwhile (b) {\n  k++;\n  b = k &lt; Integer.MAX_VALUE;\n}\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": "<h3>표준</h3>\n<ul>\n  <li> <a href=\"https://wiki.sei.cmu.edu/confluence/x/lzZGBQ\">CERT, MSC01-J.</a> - 빈 무한 루프를 사용하지 마세요 </li>\n</ul>"
  },
  {
    "id": "S1176",
    "key": "java:S1176",
    "name": "Public types, methods and fields (API) should be documented with Javadoc",
    "type": "code-smell",
    "severity": "major",
    "tags": [
      "convention"
    ],
    "why": "<p>Undocumented APIs pose significant challenges in software development for several reasons:</p>\n<ul>\n  <li> <strong>Lack of Clarity:</strong> developers struggling to understand how to use the API correctly. This can lead to misuse and unexpected\n  results. </li>\n  <li> <strong>Increased Development Time:</strong> developers spending extra time reading and understanding the source code, which slows down the\n  development process. </li>\n  <li> <strong>Error Prone:</strong> developers are more likely to make mistakes that lead to bugs or system crashes when the intent or the error\n  handling of an API is not clear. </li>\n  <li> <strong>Difficult Maintenance and Updates:</strong> developers may not understand the existing functionality well enough to add new features\n  without breaking the existing ones. </li>\n  <li> <strong>Poor Collaboration:</strong> collaboration, when there is lack of documentation, leads to confusion and inconsistencies. </li>\n</ul>\n<p>It is recommended to document the API using <strong>JavaDoc</strong> to clarify what is the contract of the API. This is especially important for\npublic APIs, as they are used by other developers.</p>\n<h3>Exceptions</h3>\n<p>The following public methods and constructors are not taken into account by this rule:</p>\n<ul>\n  <li> Getters and setters. </li>\n  <li> Methods overriding another method (usually annotated with <code>@Override</code>). </li>\n  <li> Empty constructors. </li>\n  <li> Static constants. </li>\n</ul>",
    "howToFix": "<p>On top of a main description for each member of a public API, the following <strong>Javadoc</strong> elements are required to be described:</p>\n<ul>\n  <li> Parameters, using <code>@param parameterName</code>. </li>\n  <li> Thrown exceptions, using <code>@throws exceptionName</code>. </li>\n  <li> Method return values, using <code>@return</code>. </li>\n  <li> Generic types, using <code>@param &lt;T&gt;</code>. </li>\n</ul>\n<p>Furthermore, the following guidelines should be followed:</p>\n<ul>\n  <li> At least 1 line of description. </li>\n  <li> All parameters documented with <code>@param</code>, and names should match. </li>\n  <li> All checked exceptions should be documented with <code>@throws</code> </li>\n  <li> <code>@return</code> present and documented when method return type is not <code>void</code>. </li>\n  <li> Placeholders like <code>\"TODO\"</code>, <code>\"FIXME\"</code>, <code>\"…​\"</code> should be avoided. </li>\n</ul>\n<p>For the parameters of the rule, the following rules are applied:</p>\n<ul>\n  <li> <code>?</code> matches a single character </li>\n  <li> <code>*</code> matches zero or more characters </li>\n  <li> <code>**</code> matches zero or more packages </li>\n</ul>\n<p>Examples:</p>\n<ul>\n  <li> <code>java.internal.InternalClass</code> will match only <code>InternalClass</code> class. </li>\n  <li> <code>java.internal.*</code> will match any member of <code>java.internal</code> package. </li>\n  <li> <code>java.internal.**</code> same as above, but including sub-packages. </li>\n</ul>\n\n<h4>Noncompliant code example</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\n/**\n  * This is a Javadoc comment\n  */\npublic class MyClass&lt;T&gt; implements Runnable {   // Noncompliant - missing '@param &lt;T&gt;'\n\n  public static final int DEFAULT_STATUS = 0;   // Compliant - static constant\n  private int status;                           // Compliant - not public\n\n  public String message;                        // Noncompliant\n\n  public MyClass() {                            // Noncompliant - missing documentation\n    this.status = DEFAULT_STATUS;\n  }\n\n  public void setStatus(int status) {           // Compliant - setter\n    this.status = status;\n  }\n\n  @Override\n  public void run() {                           // Compliant - has @Override annotation\n  }\n\n  protected void doSomething() {                // Compliant - not public\n  }\n\n  public void doSomething2(int value) {         // Noncompliant\n  }\n\n  public int doSomething3(int value) {          // Noncompliant\n    return value;\n  }\n}\n</pre>\n<h4>Compliant solution</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\n/**\n  * This is a Javadoc comment\n  * @param &lt;T&gt; the parameter of the class\n  */\npublic class MyClass&lt;T&gt; implements Runnable {\n\n  public static final int DEFAULT_STATUS = 0;\n  private int status;\n\n  /**\n    * This is a Javadoc comment\n    */\n  public String message;\n\n  /**\n   * Class comment...\n   */\n  public MyClass() {\n    this.status = DEFAULT_STATUS;\n  }\n\n  public void setStatus(int status) {\n    this.status = status;\n  }\n\n  @Override\n  public void run() {\n  }\n\n  protected void doSomething() {\n  }\n\n  /**\n    * Will do something.\n    * @param value the value to be used\n    */\n  public void doSomething(int value) {\n  }\n\n  /**\n    *  {@inheritDoc}\n    */\n  public int doSomething(int value) {\n    return value;\n  }\n}\n</pre>",
    "moreInfo": "<h3>Documentation</h3>\n<ul>\n  <li> Oracle - <a href=\"https://docs.oracle.com/javase/8/docs/technotes/tools/windows/javadoc.html\">JavaDoc</a> </li>\n</ul>\n<h3>Articles &amp; blog posts</h3>\n<ul>\n  <li> Technical Writer HQ - <a href=\"https://technicalwriterhq.com/documentation/api-documentation/how-to-write-api-documentation/\">How to write API\n  documentation</a> </li>\n  <li> FreeCodeCamp - <a href=\"https://www.freecodecamp.org/news/how-to-write-api-documentation-like-a-pro/\">How to write API documentation like a\n  pro</a> </li>\n</ul>",
    "status": "READY",
    "name_ko": "Public 타입, 메서드, 필드(API)는 Javadoc으로 문서화해야 합니다",
    "why_ko": "<p>문서화되지 않은 API는 여러 가지 이유로 소프트웨어 개발에서 상당한 문제를 야기합니다:</p>\n<ul>\n  <li> <strong>명확성 부족:</strong> 개발자가 API를 올바르게 사용하는 방법을 이해하는 데 어려움을 겪습니다. 이는 오용과 예상치 못한 결과로 이어질 수 있습니다. </li>\n  <li> <strong>개발 시간 증가:</strong> 개발자가 소스 코드를 읽고 이해하는 데 추가 시간을 소비하여 개발 프로세스가 느려집니다. </li>\n  <li> <strong>오류 발생 가능성:</strong> API의 의도나 오류 처리가 명확하지 않을 때 개발자가 버그나 시스템 충돌로 이어지는 실수를 할 가능성이 더 높습니다. </li>\n  <li> <strong>유지보수 및 업데이트 어려움:</strong> 개발자가 기존 기능을 손상시키지 않고 새로운 기능을 추가할 만큼 기존 기능을 충분히 이해하지 못할 수 있습니다. </li>\n  <li> <strong>협업 저하:</strong> 문서화가 부족할 때 협업은 혼란과 불일치로 이어집니다. </li>\n</ul>\n<p>API의 계약이 무엇인지 명확히 하기 위해 <strong>JavaDoc</strong>을 사용하여 API를 문서화하는 것이 권장됩니다. 이는 다른 개발자가 사용하는 public API에 특히 중요합니다.</p>\n<h3>예외 사항</h3>\n<p>다음 public 메서드와 생성자는 이 규칙에서 고려되지 않습니다:</p>\n<ul>\n  <li> Getter와 setter </li>\n  <li> 다른 메서드를 오버라이드하는 메서드(일반적으로 <code>@Override</code>로 어노테이션됨) </li>\n  <li> 빈 생성자 </li>\n  <li> static 상수 </li>\n</ul>",
    "howToFix_ko": "<p>public API의 각 멤버에 대한 주요 설명 외에도 다음 <strong>Javadoc</strong> 요소를 설명해야 합니다:</p>\n<ul>\n  <li> 매개변수, <code>@param parameterName</code> 사용 </li>\n  <li> 발생하는 예외, <code>@throws exceptionName</code> 사용 </li>\n  <li> 메서드 반환 값, <code>@return</code> 사용 </li>\n  <li> 제네릭 타입, <code>@param &lt;T&gt;</code> 사용 </li>\n</ul>\n<p>또한 다음 가이드라인을 따라야 합니다:</p>\n<ul>\n  <li> 최소 1줄의 설명 </li>\n  <li> 모든 매개변수는 <code>@param</code>으로 문서화하고 이름이 일치해야 함 </li>\n  <li> 모든 checked 예외는 <code>@throws</code>로 문서화해야 함 </li>\n  <li> 메서드 반환 타입이 <code>void</code>가 아닐 때 <code>@return</code>이 존재하고 문서화되어야 함 </li>\n  <li> <code>\"TODO\"</code>, <code>\"FIXME\"</code>, <code>\"…​\"</code>와 같은 플레이스홀더는 피해야 함 </li>\n</ul>\n<p>규칙의 매개변수에는 다음 규칙이 적용됩니다:</p>\n<ul>\n  <li> <code>?</code>는 단일 문자와 일치 </li>\n  <li> <code>*</code>는 0개 이상의 문자와 일치 </li>\n  <li> <code>**</code>는 0개 이상의 패키지와 일치 </li>\n</ul>\n<p>예시:</p>\n<ul>\n  <li> <code>java.internal.InternalClass</code>는 <code>InternalClass</code> 클래스만 일치합니다. </li>\n  <li> <code>java.internal.*</code>는 <code>java.internal</code> 패키지의 모든 멤버와 일치합니다. </li>\n  <li> <code>java.internal.**</code>는 위와 동일하지만 하위 패키지도 포함합니다. </li>\n</ul>\n\n<h4>규칙을 준수하지 않는 코드 예시</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\n/**\n  * Javadoc 주석입니다\n  */\npublic class MyClass&lt;T&gt; implements Runnable {   // 규칙 위반 - '@param &lt;T&gt;' 누락\n\n  public static final int DEFAULT_STATUS = 0;   // 규칙 준수 - static 상수\n  private int status;                           // 규칙 준수 - public이 아님\n\n  public String message;                        // 규칙 위반\n\n  public MyClass() {                            // 규칙 위반 - 문서화 누락\n    this.status = DEFAULT_STATUS;\n  }\n\n  public void setStatus(int status) {           // 규칙 준수 - setter\n    this.status = status;\n  }\n\n  @Override\n  public void run() {                           // 규칙 준수 - @Override 어노테이션 있음\n  }\n\n  protected void doSomething() {                // 규칙 준수 - public이 아님\n  }\n\n  public void doSomething2(int value) {         // 규칙 위반\n  }\n\n  public int doSomething3(int value) {          // 규칙 위반\n    return value;\n  }\n}\n</pre>\n<h4>규칙을 준수하는 해결책</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\n/**\n  * Javadoc 주석입니다\n  * @param &lt;T&gt; 클래스의 매개변수\n  */\npublic class MyClass&lt;T&gt; implements Runnable {\n\n  public static final int DEFAULT_STATUS = 0;\n  private int status;\n\n  /**\n    * Javadoc 주석입니다\n    */\n  public String message;\n\n  /**\n   * 클래스 주석...\n   */\n  public MyClass() {\n    this.status = DEFAULT_STATUS;\n  }\n\n  public void setStatus(int status) {\n    this.status = status;\n  }\n\n  @Override\n  public void run() {\n  }\n\n  protected void doSomething() {\n  }\n\n  /**\n    * 무언가를 수행합니다.\n    * @param value 사용할 값\n    */\n  public void doSomething(int value) {\n  }\n\n  /**\n    *  {@inheritDoc}\n    */\n  public int doSomething(int value) {\n    return value;\n  }\n}\n</pre>",
    "moreInfo_ko": "<h3>문서</h3>\n<ul>\n  <li> Oracle - <a href=\"https://docs.oracle.com/javase/8/docs/technotes/tools/windows/javadoc.html\">JavaDoc</a> </li>\n</ul>\n<h3>관련 글 및 블로그 포스트</h3>\n<ul>\n  <li> Technical Writer HQ - <a href=\"https://technicalwriterhq.com/documentation/api-documentation/how-to-write-api-documentation/\">API 문서 작성 방법</a> </li>\n  <li> FreeCodeCamp - <a href=\"https://www.freecodecamp.org/news/how-to-write-api-documentation-like-a-pro/\">전문가처럼 API 문서 작성하기</a> </li>\n</ul>"
  },
  {
    "id": "S1199",
    "key": "java:S1199",
    "name": "Nested code blocks should not be used",
    "type": "code-smell",
    "severity": "minor",
    "tags": [
      "bad-practice"
    ],
    "why": "<p>Nested code blocks create new scopes where variables declared within are inaccessible from the outside, and their lifespan ends with the block.</p>\n<p>Although this may appear beneficial, their usage within a function often suggests that the function is overloaded. Thus, it may violate the Single\nResponsibility Principle, and the function needs to be broken down into smaller functions.</p>\n<p>The presence of nested blocks that don't affect the control flow might suggest possible mistakes in the code.</p>\n<h3>Exceptions</h3>\n<p>The usage of a code block after a <code>case</code> is allowed.</p>",
    "howToFix": "<p>The nested code blocks should be extracted into separate methods.</p>\n\n<h4>Noncompliant code example</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\nclass Example {\n\n    private final Deque&lt;Integer&gt; stack = new LinkedList&lt;&gt;();\n\n    public void evaluate(int operator) {\n      switch (operator) {\n        case ADD: {\n          /* ... */\n          { // Noncompliant - Extract this nested code block into a method\n            int a = stack.pop();\n            int b = stack.pop();\n            int result = a + b;\n            stack.push(result);\n          }\n          /* ... */\n          break;\n        }\n        /* ... */\n      }\n    }\n}\n</pre>\n<h4>Compliant solution</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\nclass Example {\n\n    private final Deque&lt;Integer&gt; stack = new LinkedList&lt;&gt;();\n\n    public void evaluate(int operator) {\n      switch (operator) {\n        case ADD: {\n          /* ... */\n          evaluateAdd();\n          /* ... */\n          break;\n        }\n        /* ... */\n      }\n    }\n\n    private void evaluateAdd() {\n      int a = stack.pop();\n      int b = stack.pop();\n      int result = a + b;\n      stack.push(result);\n    }\n}\n</pre>",
    "moreInfo": "<h3>Documentation</h3>\n<ul>\n  <li> Wikipedia - <a href=\"https://en.wikipedia.org/wiki/Single-responsibility_principle\">Single Responsibility Principle</a> </li>\n  <li> Baeldung - <a href=\"https://www.baeldung.com/java-single-responsibility-principle\">Single Responsibility Principle</a> </li>\n</ul>",
    "status": "READY",
    "name_ko": "중첩된 코드 블록은 사용하면 안 됩니다",
    "why_ko": "<p>중첩된 코드 블록은 내부에 선언된 변수가 외부에서 접근할 수 없고 수명이 블록과 함께 끝나는 새로운 스코프를 만듭니다.</p>\n<p>이것이 유익해 보일 수 있지만, 함수 내에서 이러한 사용은 종종 함수가 과부하되었음을 시사합니다. 따라서 단일 책임 원칙을 위반할 수 있으며, 함수를 더 작은 함수로 분해해야 합니다.</p>\n<p>제어 흐름에 영향을 주지 않는 중첩 블록의 존재는 코드에서 가능한 실수를 암시할 수 있습니다.</p>\n<h3>예외 사항</h3>\n<p><code>case</code> 뒤에 코드 블록을 사용하는 것은 허용됩니다.</p>",
    "howToFix_ko": "<p>중첩된 코드 블록은 별도의 메서드로 추출해야 합니다.</p>\n\n<h4>규칙을 준수하지 않는 코드 예시</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\nclass Example {\n\n    private final Deque&lt;Integer&gt; stack = new LinkedList&lt;&gt;();\n\n    public void evaluate(int operator) {\n      switch (operator) {\n        case ADD: {\n          /* ... */\n          { // 규칙 위반 - 이 중첩된 코드 블록을 메서드로 추출하세요\n            int a = stack.pop();\n            int b = stack.pop();\n            int result = a + b;\n            stack.push(result);\n          }\n          /* ... */\n          break;\n        }\n        /* ... */\n      }\n    }\n}\n</pre>\n<h4>규칙을 준수하는 해결책</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\nclass Example {\n\n    private final Deque&lt;Integer&gt; stack = new LinkedList&lt;&gt;();\n\n    public void evaluate(int operator) {\n      switch (operator) {\n        case ADD: {\n          /* ... */\n          evaluateAdd();\n          /* ... */\n          break;\n        }\n        /* ... */\n      }\n    }\n\n    private void evaluateAdd() {\n      int a = stack.pop();\n      int b = stack.pop();\n      int result = a + b;\n      stack.push(result);\n    }\n}\n</pre>",
    "moreInfo_ko": "<h3>문서</h3>\n<ul>\n  <li> Wikipedia - <a href=\"https://en.wikipedia.org/wiki/Single-responsibility_principle\">단일 책임 원칙</a> </li>\n  <li> Baeldung - <a href=\"https://www.baeldung.com/java-single-responsibility-principle\">단일 책임 원칙</a> </li>\n</ul>"
  },
  {
    "id": "S5973",
    "key": "java:S5973",
    "name": "Tests should be stable",
    "type": "code-smell",
    "severity": "major",
    "tags": [
      "tests",
      "unpredictable",
      "design"
    ],
    "why": "<p>Unstable / flaky tests are tests which sometimes pass and sometimes fail, without any code change. Obviously, they slow down developments when\ndevelopers have to rerun failed tests. However, the real problem is that you can't completely trust these tests, they might fail for many different\nreasons and you don't know if any of them will happen in production.</p>\n<p>Some tools, such as TestNG, enable developers to automatically retry flaky tests. This might be acceptable as a temporary solution, but it should\neventually be fixed. The more flaky tests you add, the more chances there are for a bug to arrive in production.</p>\n<p>This rule raises an issue when the annotation <code>org.testng.annotations.Test</code> is given a <code>successPercentage</code> argument with a\nvalue lower than <code>100</code>.</p>\n<h3>Noncompliant code example</h3>\n<pre>\nimport org.testng.annotations.Test;\n\npublic class PercentageTest {\n    @Test(successPercentage = 80, invocationCount = 10)  // Noncompliant. The test is allowed to fail 2 times.\n    public void flakyTest() {\n    }\n}\n</pre>",
    "howToFix": "",
    "moreInfo": "<ul>\n  <li> TestNG documentation - <a href=\"https://testng.org/#_annotations\">Annotations</a> </li>\n  <li> Spotify Engineering - <a\n  href=\"https://engineering.atspotify.com/2019/11/18/test-flakiness-methods-for-identifying-and-dealing-with-flaky-tests/\">Test Flakiness - Methods\n  for identifying and dealing with flaky tests</a> </li>\n</ul>",
    "status": "READY",
    "name_ko": "테스트는 안정적이어야 합니다",
    "why_ko": "<p>불안정한(flaky) 테스트는 코드 변경 없이도 때때로 통과하고 때때로 실패하는 테스트입니다. 분명히 개발자가 실패한 테스트를 다시 실행해야 할 때 개발 속도가 느려집니다. 그러나 진짜 문제는 이러한 테스트를 완전히 신뢰할 수 없다는 것입니다. 여러 가지 이유로 실패할 수 있으며 그 중 어느 것이 프로덕션에서 발생할지 알 수 없습니다.</p>\n<p>TestNG와 같은 일부 도구는 개발자가 flaky 테스트를 자동으로 재시도할 수 있게 합니다. 이것은 임시 해결책으로는 허용될 수 있지만 결국에는 수정되어야 합니다. flaky 테스트를 더 많이 추가할수록 버그가 프로덕션에 도달할 가능성이 더 커집니다.</p>\n<p>이 규칙은 <code>org.testng.annotations.Test</code> 어노테이션에 <code>100</code>보다 낮은 값의 <code>successPercentage</code> 인수가 주어질 때 문제를 제기합니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\nimport org.testng.annotations.Test;\n\npublic class PercentageTest {\n    @Test(successPercentage = 80, invocationCount = 10)  // 규칙 위반. 테스트가 2번 실패하는 것이 허용됩니다.\n    public void flakyTest() {\n    }\n}\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": "<ul>\n  <li> TestNG 문서 - <a href=\"https://testng.org/#_annotations\">어노테이션</a> </li>\n  <li> Spotify Engineering - <a href=\"https://engineering.atspotify.com/2019/11/18/test-flakiness-methods-for-identifying-and-dealing-with-flaky-tests/\">테스트 불안정성 - flaky 테스트 식별 및 처리 방법</a> </li>\n</ul>"
  },
  {
    "id": "S6830",
    "key": "java:S6830",
    "name": "Bean names should adhere to the naming conventions",
    "type": "code-smell",
    "severity": "major",
    "tags": [
      "spring"
    ],
    "why": "<p>Consistent naming of beans is important for the readability and maintainability of the code. More precisely, according to the Spring\ndocumentation:</p>\n<pre>\nNaming beans consistently makes your configuration easier to read and understand. Also, if you use Spring AOP, it helps a lot when applying advice to a set of beans related by name.\n</pre>\n<p>Not following accepted conventions can introduce inconsistent naming, especially when multiple developers work on the same project, leading to\ntechnical debt.</p>\n<p>The spring documentation establishes a naming convention that consists of camel-cased names with a leading lowercase letter.</p>\n<p>This rule raises an issue when a bean name defined in one of the following annotations does not adhere to the naming convention:</p>\n<ul>\n  <li> <code>@Bean</code> </li>\n  <li> <code>@Configuration</code> </li>\n  <li> <code>@Controller</code> </li>\n  <li> <code>@Component</code> </li>\n  <li> <code>@Qualifier</code> </li>\n  <li> <code>@Repository</code> </li>\n  <li> <code>@Service</code> </li>\n</ul>",
    "howToFix": "<p>Change the bean's name to adhere to the naming conventions. Names should be camel-cased and start with a lowercase letter, for example,\n<code>myBean</code>.</p>\n\n<h4>Noncompliant code example</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\n@Bean(name = \"MyBean\") // Noncompliant, the first letter of the name should be lowercase\npublic MyBean myBean() {\n    ...\n</pre>\n<h4>Compliant solution</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\n@Bean(name = \"myBean\") // Compliant\npublic MyBean myBean() {\n    ...\n</pre>\n<h4>Noncompliant code example</h4>\n<pre data-diff-id=\"2\" data-diff-type=\"noncompliant\">\n@Service(\"my_service\") // Noncompliant, the name should be camel-cased\npublic class MyService {\n    ...\n</pre>\n<h4>Compliant solution</h4>\n<pre data-diff-id=\"2\" data-diff-type=\"compliant\">\n@Service(\"myService\") // Compliant\npublic class MyService {\n    ...\n</pre>",
    "moreInfo": "<h3>Documentation</h3>\n<ul>\n  <li> Spring Framework Documentation - <a href=\"https://docs.spring.io/spring-framework/reference/core/beans/definition.html#beans-beanname\">3.3 Bean\n  overview</a> </li>\n</ul>\n<h3>Articles &amp; blog posts</h3>\n<ul>\n  <li> Java Guides - <a href=\"https://www.javaguides.net/2019/03/spring-boot-best-practices.html\">Spring Boot Best Practices</a> </li>\n</ul>",
    "status": "READY",
    "name_ko": "Bean 이름은 명명 규칙을 준수해야 합니다",
    "why_ko": "<p>일관된 빈 명명은 코드의 가독성과 유지 관리성에 중요합니다. 더 정확하게는 Spring 문서에 따르면:</p>\n<pre>\n빈을 일관되게 명명하면 구성을 읽고 이해하기 쉬워집니다. 또한 Spring AOP를 사용하는 경우 이름으로 관련된 빈 집합에 어드바이스를 적용할 때 많은 도움이 됩니다.\n</pre>\n<p>허용된 규칙을 따르지 않으면 특히 여러 개발자가 동일한 프로젝트에서 작업할 때 일관되지 않은 명명이 발생하여 기술 부채로 이어질 수 있습니다.</p>\n<p>Spring 문서는 소문자로 시작하는 카멜 케이스 이름으로 구성된 명명 규칙을 설정합니다.</p>\n<p>이 규칙은 다음 어노테이션 중 하나에서 정의된 빈 이름이 명명 규칙을 준수하지 않을 때 문제를 발생시킵니다:</p>\n<ul>\n  <li> <code>@Bean</code> </li>\n  <li> <code>@Configuration</code> </li>\n  <li> <code>@Controller</code> </li>\n  <li> <code>@Component</code> </li>\n  <li> <code>@Qualifier</code> </li>\n  <li> <code>@Repository</code> </li>\n  <li> <code>@Service</code> </li>\n</ul>",
    "howToFix_ko": "<p>빈 이름을 명명 규칙을 준수하도록 변경하세요. 이름은 카멜 케이스여야 하고 소문자로 시작해야 합니다. 예: <code>myBean</code>.</p>\n\n<h4>규칙을 준수하지 않는 코드 예시</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\n@Bean(name = \"MyBean\") // 규칙 위반, 이름의 첫 글자는 소문자여야 합니다\npublic MyBean myBean() {\n    ...\n</pre>\n<h4>규칙을 준수하는 해결책</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\n@Bean(name = \"myBean\") // 규칙 준수\npublic MyBean myBean() {\n    ...\n</pre>\n<h4>규칙을 준수하지 않는 코드 예시</h4>\n<pre data-diff-id=\"2\" data-diff-type=\"noncompliant\">\n@Service(\"my_service\") // 규칙 위반, 이름은 카멜 케이스여야 합니다\npublic class MyService {\n    ...\n</pre>\n<h4>규칙을 준수하는 해결책</h4>\n<pre data-diff-id=\"2\" data-diff-type=\"compliant\">\n@Service(\"myService\") // 규칙 준수\npublic class MyService {\n    ...\n</pre>",
    "moreInfo_ko": "<h3>문서</h3>\n<ul>\n  <li> Spring Framework 문서 - <a href=\"https://docs.spring.io/spring-framework/reference/core/beans/definition.html#beans-beanname\">3.3 Bean 개요</a> </li>\n</ul>\n<h3>기사 및 블로그 게시물</h3>\n<ul>\n  <li> Java Guides - <a href=\"https://www.javaguides.net/2019/03/spring-boot-best-practices.html\">Spring Boot 모범 사례</a> </li>\n</ul>"
  },
  {
    "id": "S1160",
    "key": "java:S1160",
    "name": "Public methods should throw at most one checked exception",
    "type": "code-smell",
    "severity": "major",
    "tags": [
      "error-handling"
    ],
    "why": "<p>Using checked exceptions forces method callers to deal with errors, either by propagating them or by handling them. Throwing exceptions makes them\nfully part of the API of the method.</p>\n<p>But to keep the complexity for callers reasonable, methods should not throw more than one kind of checked exception.</p>\n<h3>Noncompliant code example</h3>\n<pre>\npublic void delete() throws IOException, SQLException {      // Noncompliant\n  /* ... */\n}\n</pre>\n<h3>Compliant solution</h3>\n<pre>\npublic void delete() throws SomeApplicationLevelException {\n  /* ... */\n}\n</pre>\n<h3>Exceptions</h3>\n<p>Overriding methods are not checked by this rule and are allowed to throw several checked exceptions.</p>",
    "howToFix": "",
    "moreInfo": "",
    "status": "READY",
    "name_ko": "public 메서드는 최대 하나의 checked exception만 던져야 합니다",
    "why_ko": "<p>checked exception을 사용하면 메서드 호출자가 예외를 전파하거나 처리하여 오류를 처리하도록 강제합니다. 예외를 던지면 메서드 API의 완전한 일부가 됩니다.</p>\n<p>그러나 호출자의 복잡성을 합리적으로 유지하려면 메서드가 둘 이상의 checked exception을 던지면 안 됩니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\npublic void delete() throws IOException, SQLException {      // 규칙 위반\n  /* ... */\n}\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre>\npublic void delete() throws SomeApplicationLevelException {\n  /* ... */\n}\n</pre>\n<h3>예외</h3>\n<p>오버라이딩 메서드는 이 규칙에 의해 확인되지 않으며 여러 checked exception을 던질 수 있습니다.</p>",
    "howToFix_ko": "",
    "moreInfo_ko": ""
  },
  {
    "id": "S2259",
    "key": "java:S2259",
    "name": "Null pointers should not be dereferenced",
    "type": "bug",
    "severity": "major",
    "tags": [
      "symbolic-execution",
      "cwe",
      "cert"
    ],
    "why": "<p>A reference to <code>null</code> should never be dereferenced/accessed. Doing so will cause a <code>NullPointerException</code> to be thrown. At\nbest, such an exception will cause abrupt program termination. At worst, it could expose debugging information that would be useful to an attacker, or\nit could allow an attacker to bypass security measures.</p>\n<p>Note that when they are present, this rule takes advantage of nullability annotations, like <code>@CheckForNull</code> or <code>@Nonnull</code>,\ndefined in <a href=\"https://jcp.org/en/jsr/detail?id=305\">JSR-305</a> to understand which values can be null or not. <code>@Nonnull</code> will be\nignored if used on the parameter of the <code>equals</code> method, which by contract should always work with null.</p>",
    "howToFix": "<h4>Noncompliant code example</h4>\n<p>The variable <code>myObject</code> is equal to <code>null</code>, meaning it has no value:</p>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\npublic void method() {\n  Object myObject = null;\n  System.out.println(myObject.toString()); // Noncompliant: myObject is null\n}\n</pre>\n<p>The parameter <code>input</code> might be <code>null</code> as suggested by the <code>if</code> condition:</p>\n<pre data-diff-id=\"2\" data-diff-type=\"noncompliant\">\npublic void method(Object input)\n{\n  if (input == null)\n  {\n    // ...\n  }\n  System.out.println(input.toString()); // Noncompliant\n}\n</pre>\n<p>The unboxing triggered in the return statement will throw a <code>NullPointerException</code>:</p>\n<pre data-diff-id=\"3\" data-diff-type=\"noncompliant\">\npublic boolean method() {\n  Boolean boxed = null;\n  return boxed; // Noncompliant\n}\n</pre>\n<p>Both <code>conn</code> and <code>stmt</code> might be <code>null</code> in case an exception was thrown in the try{} block:</p>\n<pre data-diff-id=\"4\" data-diff-type=\"noncompliant\">\nConnection conn = null;\nStatement stmt = null;\ntry {\n  conn = DriverManager.getConnection(DB_URL,USER,PASS);\n  stmt = conn.createStatement();\n  // ...\n} catch(Exception e) {\n  e.printStackTrace();\n} finally {\n  stmt.close();  // Noncompliant\n  conn.close();  // Noncompliant\n}\n</pre>\n<p>As <code>getName()</code> is annotated with <code>@CheckForNull</code>, there is a risk of <code>NullPointerException</code> here:</p>\n<pre data-diff-id=\"5\" data-diff-type=\"noncompliant\">\n@CheckForNull\nString getName() {...}\n\npublic boolean isNameEmpty() {\n  return getName().length() == 0; // Noncompliant\n}\n</pre>\n<p>As <code>merge(…​)</code> parameter is annotated with <code>@Nonnull</code>, passing an identified potential null value (thanks to @CheckForNull)\nis not safe:</p>\n<pre data-diff-id=\"6\" data-diff-type=\"noncompliant\">\nprivate void merge(@Nonnull Color firstColor, @Nonnull Color secondColor) {...}\n\npublic void append(@CheckForNull Color color) {\n  merge(currentColor, color);  // Noncompliant: color should be null-checked because merge(...) doesn't accept nullable parameters\n}\n</pre>\n<h4>Compliant solution</h4>\n<p>Ensuring the variable <code>myObject</code> has a value resolves the issue:</p>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\npublic void method() {\n  Object myObject = new Object();\n  System.out.println(myObject.toString()); // Compliant: myObject is not null\n}\n</pre>\n<p>Preventing the non-compliant code to be executed by returning early:</p>\n<pre data-diff-id=\"2\" data-diff-type=\"compliant\">\npublic void method(Object input)\n{\n  if (input == null)\n  {\n    return;\n  }\n  System.out.println(input.toString()); // Compliant: if 'input' is null, this is unreachable\n}\n</pre>\n<p>Ensuring that no unboxing of <code>null</code> value can happen resolves the issue</p>\n<pre data-diff-id=\"3\" data-diff-type=\"compliant\">\npublic boolean method() {\n  Boolean boxed = true;\n  return boxed; // Compliant\n}\n</pre>\n<p>Ensuring that both <code>conn</code> and <code>stmt</code> are not <code>null</code> resolves the issue:</p>\n<pre data-diff-id=\"4\" data-diff-type=\"compliant\">\nConnection conn = null;\nStatement stmt = null;\ntry {\n  conn = DriverManager.getConnection(DB_URL,USER,PASS);\n  stmt = conn.createStatement();\n  // ...\n} catch(Exception e) {\n  e.printStackTrace();\n} finally {\n  if (stmt != null) {\n    stmt.close();  // Compliant\n  }\n  if (conn != null) {\n    conn.close();  // Compliant\n  }\n}\n</pre>\n<p>Checking the returned value of <code>getName()</code> resolves the issue:</p>\n<pre data-diff-id=\"5\" data-diff-type=\"compliant\">\n@CheckForNull\nString getName() {...}\n\npublic boolean isNameEmpty() {\n  String name = getName();\n  if (name != null) {\n    return name.length() == 0; // Compliant\n  } else {\n    // ...\n  }\n}\n</pre>\n<p>Ensuring that the provided <code>color</code> is not <code>null</code> resolves the issue:</p>\n<pre data-diff-id=\"6\" data-diff-type=\"compliant\">\nprivate void merge(@Nonnull Color firstColor, @Nonnull Color secondColor) {...}\n\npublic void append(@CheckForNull Color color) {\n  if (color != null) {\n    merge(currentColor, color);  // Compliant\n  }\n}\n</pre>",
    "moreInfo": "<ul>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/476\">CWE-476 - NULL Pointer Dereference</a> </li>\n  <li> CERT, EXP34-C. - <a href=\"https://wiki.sei.cmu.edu/confluence/x/QdcxBQ\">Do not dereference null pointers</a> </li>\n  <li> CERT, EXP01-J. - <a href=\"https://wiki.sei.cmu.edu/confluence/x/aDdGBQ\">Do not use a null in a case where an object is required</a> </li>\n</ul>",
    "status": "READY",
    "name_ko": "null 포인터를 역참조하면 안 됩니다",
    "why_ko": "<p><code>null</code>에 대한 참조는 절대로 역참조/접근해서는 안 됩니다. 그렇게 하면 <code>NullPointerException</code>이 발생합니다. 최선의 경우 이러한 예외는 프로그램의 갑작스러운 종료를 야기합니다. 최악의 경우 공격자에게 유용한 디버깅 정보가 노출되거나 공격자가 보안 조치를 우회할 수 있게 됩니다.</p>\n<p>이 규칙은 <a href=\"https://jcp.org/en/jsr/detail?id=305\">JSR-305</a>에 정의된 <code>@CheckForNull</code> 또는 <code>@Nonnull</code>과 같은 null 가능성 어노테이션이 있는 경우 이를 활용하여 어떤 값이 null이 될 수 있는지 여부를 파악합니다. <code>@Nonnull</code>은 계약상 항상 null과 함께 작동해야 하는 <code>equals</code> 메서드의 매개변수에 사용된 경우 무시됩니다.</p>",
    "howToFix_ko": "<h4>규칙을 준수하지 않는 코드 예시</h4>\n<p>변수 <code>myObject</code>가 <code>null</code>과 같습니다. 즉, 값이 없습니다:</p>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\npublic void method() {\n  Object myObject = null;\n  System.out.println(myObject.toString()); // 규칙 위반: myObject가 null임\n}\n</pre>\n<p><code>if</code> 조건에서 알 수 있듯이 매개변수 <code>input</code>이 <code>null</code>일 수 있습니다:</p>\n<pre data-diff-id=\"2\" data-diff-type=\"noncompliant\">\npublic void method(Object input)\n{\n  if (input == null)\n  {\n    // ...\n  }\n  System.out.println(input.toString()); // 규칙 위반\n}\n</pre>\n<p>return 문에서 트리거되는 언박싱이 <code>NullPointerException</code>을 발생시킵니다:</p>\n<pre data-diff-id=\"3\" data-diff-type=\"noncompliant\">\npublic boolean method() {\n  Boolean boxed = null;\n  return boxed; // 규칙 위반\n}\n</pre>\n<p>try{} 블록에서 예외가 발생한 경우 <code>conn</code>과 <code>stmt</code> 모두 <code>null</code>일 수 있습니다:</p>\n<pre data-diff-id=\"4\" data-diff-type=\"noncompliant\">\nConnection conn = null;\nStatement stmt = null;\ntry {\n  conn = DriverManager.getConnection(DB_URL,USER,PASS);\n  stmt = conn.createStatement();\n  // ...\n} catch(Exception e) {\n  e.printStackTrace();\n} finally {\n  stmt.close();  // 규칙 위반\n  conn.close();  // 규칙 위반\n}\n</pre>\n<p><code>getName()</code>이 <code>@CheckForNull</code>로 어노테이션되어 있으므로 여기서 <code>NullPointerException</code> 위험이 있습니다:</p>\n<pre data-diff-id=\"5\" data-diff-type=\"noncompliant\">\n@CheckForNull\nString getName() {...}\n\npublic boolean isNameEmpty() {\n  return getName().length() == 0; // 규칙 위반\n}\n</pre>\n<p><code>merge(…​)</code> 매개변수가 <code>@Nonnull</code>로 어노테이션되어 있으므로 (@CheckForNull 덕분에) 식별된 잠재적 null 값을 전달하는 것은 안전하지 않습니다:</p>\n<pre data-diff-id=\"6\" data-diff-type=\"noncompliant\">\nprivate void merge(@Nonnull Color firstColor, @Nonnull Color secondColor) {...}\n\npublic void append(@CheckForNull Color color) {\n  merge(currentColor, color);  // 규칙 위반: merge(...)가 nullable 매개변수를 허용하지 않으므로 color는 null 검사를 해야 함\n}\n</pre>\n<h4>규칙을 준수하는 해결책</h4>\n<p>변수 <code>myObject</code>에 값이 있도록 보장하면 문제가 해결됩니다:</p>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\npublic void method() {\n  Object myObject = new Object();\n  System.out.println(myObject.toString()); // 규칙 준수: myObject가 null이 아님\n}\n</pre>\n<p>일찍 반환하여 규칙을 준수하지 않는 코드가 실행되는 것을 방지합니다:</p>\n<pre data-diff-id=\"2\" data-diff-type=\"compliant\">\npublic void method(Object input)\n{\n  if (input == null)\n  {\n    return;\n  }\n  System.out.println(input.toString()); // 규칙 준수: 'input'이 null이면 이 코드는 도달 불가\n}\n</pre>\n<p><code>null</code> 값의 언박싱이 발생하지 않도록 보장하면 문제가 해결됩니다:</p>\n<pre data-diff-id=\"3\" data-diff-type=\"compliant\">\npublic boolean method() {\n  Boolean boxed = true;\n  return boxed; // 규칙 준수\n}\n</pre>\n<p><code>conn</code>과 <code>stmt</code> 모두 <code>null</code>이 아님을 보장하면 문제가 해결됩니다:</p>\n<pre data-diff-id=\"4\" data-diff-type=\"compliant\">\nConnection conn = null;\nStatement stmt = null;\ntry {\n  conn = DriverManager.getConnection(DB_URL,USER,PASS);\n  stmt = conn.createStatement();\n  // ...\n} catch(Exception e) {\n  e.printStackTrace();\n} finally {\n  if (stmt != null) {\n    stmt.close();  // 규칙 준수\n  }\n  if (conn != null) {\n    conn.close();  // 규칙 준수\n  }\n}\n</pre>\n<p><code>getName()</code>의 반환 값을 확인하면 문제가 해결됩니다:</p>\n<pre data-diff-id=\"5\" data-diff-type=\"compliant\">\n@CheckForNull\nString getName() {...}\n\npublic boolean isNameEmpty() {\n  String name = getName();\n  if (name != null) {\n    return name.length() == 0; // 규칙 준수\n  } else {\n    // ...\n  }\n}\n</pre>\n<p>제공된 <code>color</code>가 <code>null</code>이 아님을 보장하면 문제가 해결됩니다:</p>\n<pre data-diff-id=\"6\" data-diff-type=\"compliant\">\nprivate void merge(@Nonnull Color firstColor, @Nonnull Color secondColor) {...}\n\npublic void append(@CheckForNull Color color) {\n  if (color != null) {\n    merge(currentColor, color);  // 규칙 준수\n  }\n}\n</pre>",
    "moreInfo_ko": "<ul>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/476\">CWE-476 - NULL 포인터 역참조</a> </li>\n  <li> CERT, EXP34-C. - <a href=\"https://wiki.sei.cmu.edu/confluence/x/QdcxBQ\">null 포인터를 역참조하지 마세요</a> </li>\n  <li> CERT, EXP01-J. - <a href=\"https://wiki.sei.cmu.edu/confluence/x/aDdGBQ\">객체가 필요한 곳에 null을 사용하지 마세요</a> </li>\n</ul>"
  },
  {
    "id": "S2127",
    "key": "java:S2127",
    "name": "\"Double.longBitsToDouble\" should take \"long\" as argument",
    "type": "bug",
    "severity": "major",
    "tags": [],
    "why": "<p><code>Double.longBitsToDouble</code> converts the bit pattern into its corresponding floating-point representation. The method expects a 64-bit\nlong argument to interpret the bits as a double value correctly.</p>\n<p>When the argument is a smaller data type, the cast to <code>long</code> may lead to a different value than expected due to the interpretation of\nthe most significant bit, which, in turn, results in <code>Double.longBitsToDouble</code> returning an incorrect value.</p>\n<h3>Noncompliant code example</h3>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\nint i = 0x80003800;\nDouble.longBitsToDouble(i);   // Noncompliant - NaN\n</pre>\n<h3>Compliant solution</h3>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\nlong i = 0x80003800L;\nDouble.longBitsToDouble(i);   // Compliant - 1.0610049784E-314\n</pre>",
    "howToFix": "",
    "moreInfo": "<h3>Documentation</h3>\n<ul>\n  <li> <a href=\"https://docs.oracle.com/en/java/javase/20/docs/api/java.base/java/lang/Double.html#doubleToLongBits(double)\">Oracle Java SE -\n  Double.doubleToLongBits</a> </li>\n</ul>\n<h3>Articles &amp; blog posts</h3>\n<ul>\n  <li> <a href=\"https://en.wikipedia.org/wiki/Double-precision_floating-point_format\">Wikipedia - Double Precision floating point format</a> </li>\n  <li> <a href=\"https://en.wikipedia.org/wiki/Single-precision_floating-point_format\">Wikipedia - Single Precision floating point format</a> </li>\n</ul>",
    "status": "READY",
    "name_ko": "\"Double.longBitsToDouble\"은 \"long\"을 인수로 받아야 합니다",
    "why_ko": "<p><code>Double.longBitsToDouble</code>은 비트 패턴을 해당하는 부동 소수점 표현으로 변환합니다. 이 메서드는 비트를 double 값으로 올바르게 해석하기 위해 64비트 long 인수를 기대합니다.</p>\n<p>인수가 더 작은 데이터 타입인 경우, <code>long</code>으로의 캐스트는 최상위 비트의 해석으로 인해 예상과 다른 값을 초래할 수 있으며, 이로 인해 <code>Double.longBitsToDouble</code>이 잘못된 값을 반환합니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\nint i = 0x80003800;\nDouble.longBitsToDouble(i);   // 규칙 위반 - NaN\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\nlong i = 0x80003800L;\nDouble.longBitsToDouble(i);   // 규칙 준수 - 1.0610049784E-314\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": "<h3>문서</h3>\n<ul>\n  <li> <a href=\"https://docs.oracle.com/en/java/javase/20/docs/api/java.base/java/lang/Double.html#doubleToLongBits(double)\">Oracle Java SE - Double.doubleToLongBits</a> </li>\n</ul>\n<h3>관련 문서 및 블로그 게시물</h3>\n<ul>\n  <li> <a href=\"https://en.wikipedia.org/wiki/Double-precision_floating-point_format\">Wikipedia - 배정밀도 부동 소수점 형식</a> </li>\n  <li> <a href=\"https://en.wikipedia.org/wiki/Single-precision_floating-point_format\">Wikipedia - 단정밀도 부동 소수점 형식</a> </li>\n</ul>"
  },
  {
    "id": "S3366",
    "key": "java:S3366",
    "name": "\"this\" should not be exposed from constructors",
    "type": "code-smell",
    "severity": "major",
    "tags": [
      "multi-threading",
      "cert",
      "suspicious"
    ],
    "why": "<p>In single-threaded environments, the use of <code>this</code> in constructors is normal, and expected. But in multi-threaded environments, it could\nexpose partially-constructed objects to other threads, and should be used with caution.</p>\n<p>The classic example is a class with a <code>static</code> list of its instances. If the constructor stores <code>this</code> in the list, another\nthread could access the object before it's fully-formed. Even when the storage of <code>this</code> is the last instruction in the constructor,\nthere's still a danger if the class is not <code>final</code>. In that case, the initialization of subclasses won't be complete before\n<code>this</code> is exposed.</p>\n<p>This rule raises an issue when <code>this</code> is assigned to any globally-visible object in a constructor, and when it is passed to the method\nof another object in a constructor</p>\n<h3>Noncompliant code example</h3>\n<pre>\npublic class Monument {\n\n  public static final List&lt;Monument&gt; ALL_MONUMENTS = new ArrayList()&lt;&gt;;\n  // ...\n\n  public Monument(String location, ...) {\n    ALL_MONUMENTS.add(this);  // Noncompliant; passed to a method of another object\n\n    this.location = location;\n    // ...\n  }\n}\n</pre>\n<h3>Exceptions</h3>\n<p>This rule ignores instances of assigning <code>this</code> directly to a <code>static</code> field of the same class because that case is covered\nby <a href='/coding_rules#rule_key=java%3AS3010'>S3010</a> .</p>",
    "howToFix": "",
    "moreInfo": "<ul>\n  <li> <a href=\"https://wiki.sei.cmu.edu/confluence/x/iDdGBQ\">CERT, TSM01-J.</a> - Do not let the this reference escape during object construction\n  </li>\n  <li> <a href=\"https://wiki.sei.cmu.edu/confluence/x/vzdGBQ\">CERT, TSM03-J.</a> - Do not publish partially initialized objects </li>\n</ul>",
    "status": "READY",
    "name_ko": "생성자에서 \"this\"를 노출하면 안 됩니다",
    "why_ko": "<p>단일 스레드 환경에서 생성자에서 <code>this</code>를 사용하는 것은 정상적이고 예상되는 동작입니다. 그러나 멀티스레드 환경에서는 부분적으로 생성된 객체를 다른 스레드에 노출시킬 수 있으므로 주의해서 사용해야 합니다.</p>\n<p>전형적인 예는 인스턴스의 <code>static</code> 목록을 가진 클래스입니다. 생성자가 목록에 <code>this</code>를 저장하면 다른 스레드가 완전히 형성되기 전에 객체에 액세스할 수 있습니다. <code>this</code>의 저장이 생성자의 마지막 명령어인 경우에도 클래스가 <code>final</code>이 아니면 여전히 위험합니다. 이 경우 <code>this</code>가 노출되기 전에 서브클래스의 초기화가 완료되지 않습니다.</p>\n<p>이 규칙은 생성자에서 <code>this</code>가 전역적으로 보이는 객체에 할당되거나 생성자에서 다른 객체의 메서드에 전달될 때 문제를 제기합니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\npublic class Monument {\n\n  public static final List&lt;Monument&gt; ALL_MONUMENTS = new ArrayList()&lt;&gt;;\n  // ...\n\n  public Monument(String location, ...) {\n    ALL_MONUMENTS.add(this);  // 규칙 위반; 다른 객체의 메서드에 전달됨\n\n    this.location = location;\n    // ...\n  }\n}\n</pre>\n<h3>예외</h3>\n<p>이 규칙은 <code>this</code>를 동일한 클래스의 <code>static</code> 필드에 직접 할당하는 경우를 무시합니다. 해당 경우는 <a href='/coding_rules#rule_key=java%3AS3010'>S3010</a>에서 다루기 때문입니다.</p>",
    "howToFix_ko": "",
    "moreInfo_ko": "<ul>\n  <li> <a href=\"https://wiki.sei.cmu.edu/confluence/x/iDdGBQ\">CERT, TSM01-J.</a> - 객체 생성 중에 this 참조가 탈출하지 않도록 하세요\n  </li>\n  <li> <a href=\"https://wiki.sei.cmu.edu/confluence/x/vzdGBQ\">CERT, TSM03-J.</a> - 부분적으로 초기화된 객체를 공개하지 마세요 </li>\n</ul>"
  },
  {
    "id": "S2062",
    "key": "java:S2062",
    "name": "\"readResolve\" methods should be inheritable",
    "type": "code-smell",
    "severity": "critical",
    "tags": [
      "pitfall"
    ],
    "why": "<p>Developers may want to add some logic to handle deserialized objects before they are returned to the caller. This can be achieved by implementing\nthe <code>readResolve</code> method.</p>\n<p>Non-final classes implementing <code>readResolve</code> should not set its visibility to <code>private</code> as this would make it unavailable to\nchild classes. Instead, mark <code>readResolve</code> as <code>protected</code>, allowing it to be inherited.</p>\n\n<h4>Noncompliant code example</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\npublic class Fruit implements Serializable {\n  private static final long serialVersionUID = 1;\n\n  private Object readResolve() throws ObjectStreamException // Noncompliant, `readResolve` should not be private\n  {...}\n\n  //...\n}\n\npublic class Raspberry extends Fruit implements Serializable { // This class has no access to the parent's \"readResolve\" method\n  //...\n}\n</pre>\n<h4>Compliant solution</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\npublic class Fruit implements Serializable {\n  private static final long serialVersionUID = 1;\n\n  protected Object readResolve() throws ObjectStreamException // Compliant, `readResolve` is protected\n  {...}\n\n  //...\n}\n\npublic class Raspberry extends Fruit implements Serializable { // This class has access to the parent's \"readResolve\"\n  //...\n}\n</pre>",
    "howToFix": "",
    "moreInfo": "<ul>\n  <li> <a href=\"https://docs.oracle.com/javase/8/docs/platform/serialization/spec/input.html#a5903\">Java Object Serialization Specification - Object\n  Input Classes</a> </li>\n</ul>",
    "status": "READY",
    "name_ko": "\"readResolve\" 메서드는 상속 가능해야 합니다",
    "why_ko": "<p>개발자는 역직렬화된 객체가 호출자에게 반환되기 전에 처리하기 위한 일부 로직을 추가하고 싶을 수 있습니다. 이는 <code>readResolve</code> 메서드를 구현하여 달성할 수 있습니다.</p>\n<p><code>readResolve</code>를 구현하는 non-final 클래스는 가시성을 <code>private</code>으로 설정하면 안 됩니다. 이렇게 하면 자식 클래스에서 사용할 수 없게 됩니다. 대신 <code>readResolve</code>를 <code>protected</code>로 표시하여 상속될 수 있게 하세요.</p>\n\n<h4>규칙을 준수하지 않는 코드 예시</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\npublic class Fruit implements Serializable {\n  private static final long serialVersionUID = 1;\n\n  private Object readResolve() throws ObjectStreamException // 규칙 위반, `readResolve`는 private이 아니어야 합니다\n  {...}\n\n  //...\n}\n\npublic class Raspberry extends Fruit implements Serializable { // 이 클래스는 부모의 \"readResolve\" 메서드에 액세스할 수 없습니다\n  //...\n}\n</pre>\n<h4>규칙을 준수하는 해결책</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\npublic class Fruit implements Serializable {\n  private static final long serialVersionUID = 1;\n\n  protected Object readResolve() throws ObjectStreamException // 규칙 준수, `readResolve`가 protected입니다\n  {...}\n\n  //...\n}\n\npublic class Raspberry extends Fruit implements Serializable { // 이 클래스는 부모의 \"readResolve\"에 액세스할 수 있습니다\n  //...\n}\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": "<ul>\n  <li> <a href=\"https://docs.oracle.com/javase/8/docs/platform/serialization/spec/input.html#a5903\">Java Object Serialization Specification - Object Input Classes</a> </li>\n</ul>"
  },
  {
    "id": "S131",
    "key": "java:S131",
    "name": "\"switch\" statements should have \"default\" clauses",
    "type": "code-smell",
    "severity": "critical",
    "tags": [
      "cwe",
      "cert"
    ],
    "why": "<p>The requirement for a final <code>default</code> clause is defensive programming. The clause should either take appropriate action, or contain a\nsuitable comment as to why no action is taken.</p>\n<h3>Noncompliant code example</h3>\n<pre>\nswitch (param) {  //missing default clause\n  case 0:\n    doSomething();\n    break;\n  case 1:\n    doSomethingElse();\n    break;\n}\n\nswitch (param) {\n  default: // default clause should be the last one\n    error();\n    break;\n  case 0:\n    doSomething();\n    break;\n  case 1:\n    doSomethingElse();\n    break;\n}\n</pre>\n<h3>Compliant solution</h3>\n<pre>\nswitch (param) {\n  case 0:\n    doSomething();\n    break;\n  case 1:\n    doSomethingElse();\n    break;\n  default:\n    error();\n    break;\n}\n</pre>\n<h3>Exceptions</h3>\n<p>If the <code>switch</code> parameter is an <code>Enum</code> and if all the constants of this enum are used in the <code>case</code> statements,\nthen no <code>default</code> clause is expected.</p>\n<p>Example:</p>\n<pre>\npublic enum Day {\n    SUNDAY, MONDAY\n}\n...\nswitch(day) {\n  case SUNDAY:\n    doSomething();\n    break;\n  case MONDAY:\n    doSomethingElse();\n    break;\n}\n</pre>",
    "howToFix": "",
    "moreInfo": "<ul>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/478\">CWE-478 - Missing Default Case in Switch Statement</a> </li>\n  <li> <a href=\"https://wiki.sei.cmu.edu/confluence/x/RtYxBQ\">CERT, MSC01-C.</a> - Strive for logical completeness </li>\n</ul>",
    "status": "READY",
    "name_ko": "\"switch\" 문에는 \"default\" 절이 있어야 합니다",
    "why_ko": "<p>마지막 <code>default</code> 절에 대한 요구 사항은 방어적 프로그래밍입니다. 이 절은 적절한 조치를 취하거나 조치를 취하지 않는 이유에 대한 적절한 주석을 포함해야 합니다.</p>\n<h3>규칙을 준수하지 않는 코드 예시</h3>\n<pre>\nswitch (param) {  // default 절 누락\n  case 0:\n    doSomething();\n    break;\n  case 1:\n    doSomethingElse();\n    break;\n}\n\nswitch (param) {\n  default: // default 절은 마지막에 있어야 합니다\n    error();\n    break;\n  case 0:\n    doSomething();\n    break;\n  case 1:\n    doSomethingElse();\n    break;\n}\n</pre>\n<h3>규칙을 준수하는 해결책</h3>\n<pre>\nswitch (param) {\n  case 0:\n    doSomething();\n    break;\n  case 1:\n    doSomethingElse();\n    break;\n  default:\n    error();\n    break;\n}\n</pre>\n<h3>예외</h3>\n<p><code>switch</code> 파라미터가 <code>Enum</code>이고 이 enum의 모든 상수가 <code>case</code> 문에서 사용되는 경우 <code>default</code> 절이 필요하지 않습니다.</p>\n<p>예시:</p>\n<pre>\npublic enum Day {\n    SUNDAY, MONDAY\n}\n...\nswitch(day) {\n  case SUNDAY:\n    doSomething();\n    break;\n  case MONDAY:\n    doSomethingElse();\n    break;\n}\n</pre>",
    "howToFix_ko": "",
    "moreInfo_ko": "<ul>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/478\">CWE-478 - Switch 문에 Default Case 누락</a> </li>\n  <li> <a href=\"https://wiki.sei.cmu.edu/confluence/x/RtYxBQ\">CERT, MSC01-C.</a> - 논리적 완전성을 위해 노력하세요 </li>\n</ul>"
  }
]
